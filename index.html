<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>Hexo</title>
  








<meta name="generator" content="Hexo 6.1.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/12/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%BD%93%E4%BD%A0%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%B9%B6%E5%9B%9E%E8%BD%A6%E7%9A%84%E4%B8%80%E7%9E%AC%E9%97%B4%E5%88%B0%E9%A1%B5%E9%9D%A2%E8%83%BD%E5%A4%9F%E5%B1%95%E7%A4%BA%E5%9B%9E%E6%9D%A5%EF%BC%8C%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/12/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%BD%93%E4%BD%A0%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%B9%B6%E5%9B%9E%E8%BD%A6%E7%9A%84%E4%B8%80%E7%9E%AC%E9%97%B4%E5%88%B0%E9%A1%B5%E9%9D%A2%E8%83%BD%E5%A4%9F%E5%B1%95%E7%A4%BA%E5%9B%9E%E6%9D%A5%EF%BC%8C%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/" itemprop="url">当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-12T10:42:02+08:00">
                2022-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>（1）浏览器本身是一个客户端，当你输入URL的时候，首先浏览器会去请求DNS服务器，通过DNS获取相应的域名对应的IP<br>（2）然后通过IP地址找到IP对应的服务器后，要求建立TCP连接<br>（3）浏览器发送完HTTP Request（请求）包后，服务器接收到请求包之后才开始处理请求包<br>（4）在服务器收到请求之后，服务器调用自身服务，返回HTTP Response（响应）包<br>（5）客户端收到来自服务器的响应后开始渲染这个Response包里的主体（body），等收到全部的内容随后断开与该服务器之间的TCP连接。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/12/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%AF%B7%E4%BD%A0%E8%B0%88%E8%B0%88%E7%BD%91%E7%AB%99%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/12/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%AF%B7%E4%BD%A0%E8%B0%88%E8%B0%88%E7%BD%91%E7%AB%99%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E7%9A%84/" itemprop="url">请你谈谈网站是如何进行访问的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-12T10:38:04+08:00">
                2022-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>输入一个域名；回车 </li>
<li>检查本机的 C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个域名映射；</li>
</ol>
<ul>
<li>有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问</li>
<li>没有：去DNS服务器找，找到的话就返回，找不到就返回找不到；</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/YtJjzAHWIaFg1iL.png" alt="image-20220412104107515.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day12%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day12%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" itemprop="url">机器学习 day12支持向量机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-19T19:00:32+08:00">
                2021-07-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="01-优化目标"><a href="#01-优化目标" class="headerlink" title="01 优化目标"></a>01 优化目标</h1><p>支持向量机（SVM）在学习复杂的非线性方程时，能够提供一种更为清晰和更加强大的方式。</p>
<hr>
<ul>
<li>从逻辑回归开始，稍作改动成为支持向量机<ol>
<li>观察下逻辑回归的假设函数和sigmoid激活函数</li>
</ol>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/3Ipseamct4f2vkR.png" alt="image-20210719085622645"></p>
<ol start="2">
<li>观察逻辑回归的代价函数，当把整个假设函数的定义代入其中，得到的就是每个样本对总体函数的具体贡献。</li>
</ol>
<p><img src="https://s2.loli.net/2022/04/12/GLZeXdYTmIKk734.png" alt="image-20210719090747802"></p>
<ol start="3">
<li>为了构建支持向量机，我们从这个代价函数开始进行少量修改，我们取z&#x3D;1，画出要使用的代价函数，右边都是平的，左边画出一条和最开始的幅度相似的直线，这就是y&#x3D;1时使用的代价函数。同样的做出y&#x3D;0时使用的代价函数。</li>
</ol>
<p><img src="https://s2.loli.net/2022/04/12/Uax3Ph46FbKeWio.png" alt="image-20210719091418291"></p>
<ol start="4">
<li>有了这些定义后，就可以开始构造支持向量机了，将修改后的代价函数定义带入到原始的逻辑回归代价函数中。支持向量机的代价函数将1&#x2F;m去掉，因为1&#x2F;m是一个常数，不影响得到参数的最优值。对于SVM来说我们将用一个不同的参数来控制第一项A与第二项B的相对权重，如果把C设置的很小，那么B就比A占有更大的权重。于是就得到了支持向量机的总体优化目标</li>
</ol>
<p><img src="https://s2.loli.net/2022/04/12/NBlQkxO7pM5URfG.png" alt="image-20210719093137145"></p>
<ol start="5">
<li>最后和逻辑回归不同的是，支持向量机并不会输出概率，相对的我们得到的是通过优化这个代价函数得到参数sita，支持向量机它是进行了一个直接的预测y&#x3D;0&#x2F;y&#x3D;1,学习得到参数sita后，这就是支持向量机的假设函数的形式。</li>
</ol>
<p><img src="https://s2.loli.net/2022/04/12/oMNIXmscOkRUqa2.png" alt="image-20210719093705338"></p>
<h1 id="02-直观上对大间隔的理解"><a href="#02-直观上对大间隔的理解" class="headerlink" title="02 直观上对大间隔的理解"></a>02 直观上对大间隔的理解</h1><ul>
<li>下面是SVM代价函数，支持向量机不是恰好能正确分类就行，因此需要比0大或者小很多（也就是1或者-1）。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/T9JLXslwydIiK51.png" alt="image-20210719111620508"></p>
<ul>
<li>如果C非常的大，那么当最小化最优目标的时候，将迫切的希望找到一个值使得第一项等于0。在两种情况下，通过选择参数sita使得第一项为0。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/DTE8PYQZoBgjFuI.png" alt="image-20210719112738716"></p>
<ul>
<li>支持向量机会选择尽量把正样本和负样本以最大的间距分开的假设模型。可以看出黑色的决策边界和训练样本的最小距离要更大一些。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/TYdDJtN7loaUQRk.png" alt="image-20210719114857176"></p>
<ul>
<li>下面的大间距分类器是在常数C被设的非常大情况下得出的，平常情况下会得到黑色线，但是如果在一侧加入异常样本，那么就可能会是粉色的线。如果C不是很大，那么就算是加入异常点也会是黑色线。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/1q6BsPaR8jJDdFK.png" alt="image-20210719115638874"></p>
<h1 id="03-大间隔分类器的数学原理"><a href="#03-大间隔分类器的数学原理" class="headerlink" title="03 大间隔分类器的数学原理"></a>03 大间隔分类器的数学原理</h1><ul>
<li>向量内积</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/NPmo8gTcIjZz5Dq.png" alt="image-20210719142359266"></p>
<ul>
<li>支持向量机的优化目标函数，当n&#x3D;2时我们只有两个特征量（也就是只有两个参数sita）。因此对于优化目标函数来说支持向量机做的是最小化参数向量sita的范数的平方。（为了简便都令sita0&#x3D;0）</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/3nhT7pxuqWOQU9K.png" alt="image-20210719143412269"></p>
<ul>
<li>将sita转置x(i)替换后的结果写入我们的优化目标函数。令sita0&#x3D;0意味着决策边界必须通过原点(0,0)。下图是支持向量机选择不同的决策边界的情况。（向量sita一定是垂直于决策边界的），支持向量机通过让间距变大，使得p(i)变大，以至于输出一个较小的sita的范数。（为了简便都令sita0&#x3D;0，即使不为0，效果也不变。支持向量机仍然会找出正样本和负样本之间大间距分隔）</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/9Vgymtj2XDk57RM.png" alt="image-20210719144720585"></p>
<h1 id="04-核函数1"><a href="#04-核函数1" class="headerlink" title="04 核函数1"></a>04 核函数1</h1><p>改造支持向量机算法来构造复杂的非线性分类器。</p>
<hr>
<ul>
<li>希望拟合一个非线性的判别边界来区分正负实例。一种方法是构造一个复杂多项式特征的集合，在这里我们用f1、f2、f3来表示这些我们将要计算的新的特征变量。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/rEMfaqSuY6Byb27.png" alt="image-20210719152526892"></p>
<ul>
<li>构造新特征f1、f2、f3的方法：首先手动选取三个点（标记），接着将新特征定义为一种相似度的度量即度量训练样本x与标记的相似度（用下面公式表达）。相似度函数就是一个核函数（这里是高斯核函数）。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/aZiVgxU3YSKwDQ6.png" alt="image-20210719153543903"></p>
<ul>
<li>对于这个核函数取两种情况：一种是x与标记点很近，一种是x与标记点很远。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/FuLZPYd3IG8fKvb.png" alt="image-20210719154231707"></p>
<ul>
<li>下面是核函数参数大小不同时的表现：</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/bkwHtXYBC2F8O9v.png" alt="image-20210719154554749"></p>
<ul>
<li>选择不同的点，来预测y值是1还是0。可以看出离l_1和l_2近的点预测y值为1（带入下面的预测函数中如果&gt;&#x3D;0说明y&#x3D;1;&lt;0说明y&#x3D;0)。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/F3rRDNLfm8jG6uO.png" alt="image-20210719155211342"></p>
<h1 id="05-核函数2"><a href="#05-核函数2" class="headerlink" title="05 核函数2"></a>05 核函数2</h1><ul>
<li>特征函数基本上是在描述每一个样本距离样本集中其他样本的距离，下面是这个过程的大纲。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/MkU8vP4ZXdlRwLA.png" alt="image-20210719162350445"></p>
<ul>
<li>当已知参数sita时，怎样做出预测的过程。因为标记点的个数等于训练点的个数（m），所以参数向量sita为m+1维</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/QqoTxY43Owd69lG.png" alt="image-20210719162903100"></p>
<ul>
<li>但是怎样得到参数sita？通过解决最小化的问题，你就得到了支持向量机的参数sita。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/kZnRmsbX39PUjr8.png" alt="image-20210719163242149"></p>
<ul>
<li>在使用支持向量机时，怎么选择支持向量机中的参数C？–C相当于正则化参数的倒数，根据需求选择C。高斯核函数中的参数？–当高斯核函数中的参数相对较大时，图像将会倾向于变得相对平滑，可能会带来较高的偏差和较低的方差；当高斯核函数中的参数相对较小时，图像弧度将会相对大，可能会带来低偏差和较高的方差。（图像跟第四节倒数第二个相配套）</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/FcWe16nKsXDSBNL.png" alt="image-20210719165010377"></p>
<h1 id="06-使用SVM"><a href="#06-使用SVM" class="headerlink" title="06 使用SVM"></a>06 使用SVM</h1><p>高度优化好的软件库：liblinear、libsvm</p>
<hr>
<ul>
<li>我们虽然不用自己写SVM优化库，但是还是有几件事需要我们做：<ol>
<li>参数C的选择</li>
<li>选择内核参数或者想要使用的相似函数</li>
</ol>
</li>
<li>对于内核函数其中第一个选择是不需要任何内核参数，没有内核参数的理念又叫线性核函数。为什么想要做这件事呢？如果有大量的特征n，而训练集m很小，也许就想拟合一条线性的判定边界，而不去拟合一条复杂的非线性函数。因此选择线性核函数可能很合适。</li>
<li>对于内核函数其中第二个选择是可以构造个高斯内核函数。n很少，m很多，使用高斯内核函数可能很合适。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/MAlIy3htDBQXU9K.png" alt="image-20210719174347974"></p>
<ul>
<li>如果选择要用高斯核函数，接下来要做的事：<ol>
<li>根据使用的支持向量机软件包可能需要实现一个核函数或者相似函数。因此如果使用Octave来实现支持向量机的话，那么就需要提供一个函数来计算核函数的特征值，它将自动的生成所有特征变量。因此对应一个i需要计算f_i。</li>
<li>如果有大小很不一样的特征变量，要在使用高斯核函数之前，将这些特征变量的大小按比例归一化。下面以计算x与l之间的范数为例，如果第一特征房子面积特别大，第二特征房间个数在1到5之间，那么间距可能都是由特征一所决定，所以需要归一化。</li>
</ol>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/ZgJfVrAkoN8ydMj.png" alt="image-20210719181257748"></p>
<ul>
<li>默塞尔定理是确保所有的SVM包能够用大类的优化方法并可以快速得到参数sita。其他核函数也都满足默塞尔定理，如下所示：多项式核函数（一个是自己添加的值可以是0、1、3…，还有一个是指数可以修改）。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/bZODYqz8uGaKV6M.png" alt="image-20210719182131812"></p>
<ul>
<li>在多类分类中，输出在多个类别中恰当的判定边界。如果有k个类别用以将每个类别从其他的类别中区分开来。例如第一个参数sita_1,y&#x3D;1作为正类别，其他作为负类别得到的，以此类推。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/rzhnPdB4ALvCbTJ.png" alt="image-20210719182818814"></p>
<ul>
<li>逻辑回归开始构造了SVM，然后更改下代价函数。如果n相对于m足够大，那么我通常使用逻辑回归或者线性核函数；如果n很小，m适中，通常使用高斯核函数的SVM比较好；当n很小m很大，建议手动地创建拥有更多的特征变量，然后用逻辑回归或者不带核函数的支持向量机。这种情况不适用神经网络，因为运行会很慢，而且SVM不用去考虑局部最优的问题。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/5fqeZRoLpdKa3MG.png" alt="image-20210719184201937"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day11%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day11%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url">机器学习 day11机器学习系统设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-18T16:07:04+08:00">
                2021-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="01-确定执行的优先级"><a href="#01-确定执行的优先级" class="headerlink" title="01 确定执行的优先级"></a>01 确定执行的优先级</h1><p><strong>在实际工作过程中，我们应该优先处理哪些事情</strong></p>
<hr>
<ul>
<li>以邮件筛选为例，选择邮件的特征向量的方法。通常我们会挑选出在训练集中出现频率最多的n个单词，将其作为特征向量。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/whUE9WXlB5JIKoH.png" alt="image-20210718101424936"></p>
<ul>
<li>如何在有限时间里让垃圾邮件分类器具有高精准度和低错误率。<ol>
<li>用更复杂的特征变量来描述邮件（可以在邮件标题中获取复杂的特征，来捕捉这封邮件的来源，以此判断是否为垃圾邮件）。</li>
<li>关注邮件的正文，并构建更复杂的特征。</li>
<li>来检测单词是否故意出现拼写的错误</li>
</ol>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/OP7Uoilka1Wpw3f.png" alt="image-20210718102227370"></p>
<h1 id="02-误差分析"><a href="#02-误差分析" class="headerlink" title="02 误差分析"></a>02 误差分析</h1><p><strong>误差分析就是一种手动地去检查算法所出现的失误的过程，走向最有成效的道路。</strong></p>
<hr>
<ul>
<li>通过手动检查分类错误的邮件，来看哪一类分类错误的多，哪一个出现错的情况最多，就着重去构造这类特征，加以训练。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/riLVvqXx5WbdRcG.png" alt="image-20210718105039718"></p>
<ul>
<li>交叉验证错误率：单一规则的数值评价指标。</li>
<li>如果只是手动地去检查看看这些例子表现得好不好，会让你很难去决定到底应不应该做出某种决定；但是通过交叉验证错误率就可以直观的看误差率是变大还是变小了，他能告诉你你的想法是提高了还是降低。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/PWcCid5fRBQKles.png" alt="image-20210718105942150"></p>
<ul>
<li>一旦有了一个初始的算法实现，我们就能使用一个强有力的工具，来帮助决定下一步应该做什么：<ol>
<li>看看他所造成的错误：通过误差分析来看看它出现了什么失误，然后以此决定之后的优化方法。</li>
<li>如果已经有了一个简单粗暴算法实现，又有一个数值评价指标，这些能帮助来试验新的想法，能够快速观察是否能够提高算法的表现，决定应该包含什么，应该舍弃什么。</li>
</ol>
</li>
</ul>
<h1 id="03-不对称性分类的误差评估"><a href="#03-不对称性分类的误差评估" class="headerlink" title="03 不对称性分类的误差评估"></a>03 不对称性分类的误差评估</h1><p><strong>当有倾斜类问题时，使用准确率与召回率来评价学习算法要比用分类误差或者分类准确率好得多。</strong></p>
<hr>
<ul>
<li>偏斜类：一个类中的样本数与另一个类中的数据相比多很多（比如，没有肿瘤的比有肿瘤的要多得多）。所以说恒把y&#x3D;0算出来的误差将会很小，因为有肿瘤的人很少。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/dR4uG2Wm1EhJXBe.png" alt="image-20210718114348142"></p>
<ul>
<li>所以我们想要一个不同的评估度量值：查准率和召回率。其中查准率是指对于所有我们的预测，患有癌症的病人，有多大比率的病人是真正患有癌症的。召回率是指假设如果测试集或者验证集中的病人确实得了癌症，有多大比率正确预测他们得了癌症。也就是如果所有病人都得了癌症，有多少人我们能够正确告诉他们你需要治疗。查准率和召回率越高越好。算法预测值与实际值分别是：1&#x2F;1（真阳性）、0&#x2F;0（真阴性）、1&#x2F;0（假阳性）、0&#x2F;1（假阴性）。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/TpCek2mhfIvynQM.png" alt="image-20210718115945590"></p>
<h1 id="04-精确度和召回率的权衡"><a href="#04-精确度和召回率的权衡" class="headerlink" title="04 精确度和召回率的权衡"></a>04 精确度和召回率的权衡</h1><ul>
<li>在逻辑回归中逻辑输出在0到1之间，其中0.5是个分界值，但是我们想在十分确定得情况下告诉病人真实信息，因此分界值为0.7，甚至0.9（是一个高查准率的模型，但是召回率会变低）。现在我们将分界值设置到较低（有30%几率得病），会得到高召回率，较低得查准率。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/n9yg4AfsozJUDPF.png" alt="image-20210718130210092"></p>
<ul>
<li>有没有办法自动选取临界值？或者说有不同的算法，我们如何比较不同的查准率和召回率？或者临界值不同，我们怎样决定哪个更好？–如果使用平均值来计算是不可行的，因为如果假设y &#x3D; 1和y &#x3D; 0这两种极端的情况（要么很高召回率、很低查准率，要么很低召回率、很高查准率），他们俩不是好的模型。再此我们使用F值的公式，因为它同时结合召回率及查准率。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/Kz8UO7MJXgkdWwE.png" alt="image-20210718131645694"></p>
<ul>
<li>自动选择临界值来决定你希望预测y&#x3D;1还是y&#x3D;0合理的方法：试一试不同的临界值，在检验集进行测试，看哪个临界值可以在检验集得到最高的F。这就是为分类器自动选择临界值的合理方法。</li>
</ul>
<h1 id="05-机器学习数据"><a href="#05-机器学习数据" class="headerlink" title="05 机器学习数据"></a>05 机器学习数据</h1><p>在一定条件下，得到大量的数据并在某种类型的学习算法中进行训练，可以是一种有效的方法来获取具有良好性能的学习算法。这种情况一般出现在这些条件对于你的问题都成立，并且可以得到大量数据。</p>
<hr>
<ul>
<li>并不是拥有最好算法的人能成功，而是拥有最多数据的人能成功。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/uS4V3gvif5htDUw.png" alt="image-20210718165155794"></p>
<ul>
<li>如果让一个英语好的选词填空，它可以通过特征x让我们能够准确的预测y，相反的，我们让一个房地产专家预测一个房价，而只告诉它房子的面积，其他特征不告诉，他会很难预测。因此如果这个假设正确可以看出大量数据是很有意义的。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/KcPJmMX43WlviOQ.png" alt="image-20210718165625270"></p>
<ul>
<li>得到一个低偏差（一个强大的具有很多参数的学习算法，可以很好的拟合复杂的函数）和低方差（如果训练集远大于参数的数量，就不大可能会过拟合）的学习算法（特征值足够并且训练集很庞大）</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/Ff4AyO7norVXbZ8.png" alt="image-20210718155309138"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day10%E5%BA%94%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BB%BA%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day10%E5%BA%94%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BB%BA%E8%AE%AE/" itemprop="url">机器学习 day10应用机器学习的建议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-17T16:50:51+08:00">
                2021-07-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="01-决定下一步做什么"><a href="#01-决定下一步做什么" class="headerlink" title="01 决定下一步做什么"></a>01 决定下一步做什么</h1><ul>
<li>开发一个机器学习系统，或者想试着改进一个机器学习系统的性能，应如何决定选择哪条路。不要随意选择。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/E8UKqkcsF4DwYQg.png" alt="image-20210717090316450"></p>
<ul>
<li>机器学习诊断法能够提前发现某些方法是无效的。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/7PuZe48UzAXIwKE.png" alt="image-20210717091230627"></p>
<h1 id="02-评估假设"><a href="#02-评估假设" class="headerlink" title="02 评估假设"></a>02 评估假设</h1><ul>
<li>将所有数据分为训练集和测试集，最经典的分割方法就是按照7:3的比例。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/wcyUo2LWQIaDORX.png" alt="image-20210717092357298"></p>
<ul>
<li>线性回归算法和平方误差标准学习和测试学习算法，从训练集学习获得参数，在将参数带入测试集得到测试误差。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/9bM7Wy3sVIJovkg.png" alt="image-20210717093055160"></p>
<ul>
<li>训练和测试逻辑回归的步骤及用错误分类（0&#x2F;1分类错误）来定义测试误差。0&#x2F;1表示了你预测的分类是正确或错误的情况。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/pM1STDOHqL8vdC6.png" alt="image-20210717094932197"></p>
<h1 id="03-模型选择和训练、验证、测试集"><a href="#03-模型选择和训练、验证、测试集" class="headerlink" title="03 模型选择和训练、验证、测试集"></a>03 模型选择和训练、验证、测试集</h1><ul>
<li><p>模型选择问题（想要确定对于一个数据集最合适的多项式次数，怎样选用正确的特征来构造学习算法或者假如你需要选择学习算法中的正则化参数）</p>
</li>
<li><p>模型选择问题：用不同的模型拟合数据集得到参数，接着对所有这些模型求出测试集误差，然后根据哪个模型有最小的测试误差来选择使用哪个模型。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/iJKVqg6z7rC1alw.png" alt="image-20210717101313299"></p>
<ul>
<li>为了解决模型选择出现的问题，我们通常会采用如下的方法来评估一个假设。我们把数据分为三个部分，分别是训练集、验证集、测试集。分配比例分别是6:2:2。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/DzKQFJIYtSABjXi.png" alt="image-20210717101755845"></p>
<ul>
<li>定义训练误差、交叉验证误差和测试误差</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/F5gjQva7l3YdAC2.png" alt="image-20210717101907114"></p>
<ul>
<li>用验证集选择模型而不是原来的测试集。省下来的测试集可以用它来衡量或者估算算法选择出的模型的泛化误差了。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/Q8aNiowjqX2Kkvr.png" alt="image-20210717102205298"></p>
<h1 id="04-诊断偏差与方差"><a href="#04-诊断偏差与方差" class="headerlink" title="04 诊断偏差与方差"></a>04 诊断偏差与方差</h1><p>如果一个算法表现得不理想，要么是偏差比较大，要么是方差比较大。换句话说要么欠拟合要么过拟合。</p>
<hr>
<ul>
<li>训练误差随着我们增大多项式的次数而减小；随着我们增大多项式的次数，我们对训练集拟合的也就越好。对于验证误差来说，如果d为1，会有较大误差；如果d为中等次数大小，能够更好的拟合；当d为4时，也就可能过拟合。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/MXY57ja1QkqcipG.png" alt="image-20210717150330017"></p>
<ul>
<li>对于验证误差来说，左边这一端对应的就是高偏差问题；右边这一端对应的就是高方差问题。如果训练误差很小，并且验证误差远大于训练误差说明出现过拟合问题（高方差）。如果是高偏差，则训练误差和验证误差都很大。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/qN4m3rS8vMpeHhV.png" alt="image-20210717151634922"></p>
<h1 id="05-正则化和偏差、方差"><a href="#05-正则化和偏差、方差" class="headerlink" title="05  正则化和偏差、方差"></a>05  正则化和偏差、方差</h1><ul>
<li>第一个图是高偏差，欠拟合；中间正合适；最后一个图是高方差，过拟合。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/MzDL7tfs2x54VFN.png" alt="image-20210717152942873"></p>
<ul>
<li>我们对训练、验证、测试误差的定义都是平均的误差平方和，或者是不使用正则化项时，训练集、验证集和测试集的平均的误差平方和的一半。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/YbpK6oSCeFuqyd3.png" alt="image-20210717153353767"></p>
<ul>
<li>自动选择正则化参数的方法：首先选取一系列想要试用的步长，通常来说步长设为2倍速增长，直到一个比较大的值。这样就选取了12个对应的正则化参数。然后对这12个模型分别最小化代价函数，得到完全不同的参数向量。可以把这些模型用不同的正则化参数来进行拟合，然后我们可以用验证集来评价这些参数sita在验证集上的平均的误差平方和，最终选择误差最小的模型。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/k9cRs7TyKVeqQhY.png" alt="image-20210717154334848"></p>
<ul>
<li>当我们改变正则化参数时，我们的假设在训练集和验证集上的表现（对应本节第一个图）</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/wQzJtrRe1nTx8HN.png" alt="image-20210717155246720"></p>
<h1 id="06-学习曲线"><a href="#06-学习曲线" class="headerlink" title="06 学习曲线"></a>06 学习曲线</h1><p>学习曲线可以判断某一学习算法是否处于偏差或者方差问题，还是二者都有。</p>
<hr>
<ul>
<li>当训练集个数很少的时候，能够十分完美的拟合数据，训练集误差基本为0，但是随着训练集越来越多，训练集误差也就会越来越大，逐渐趋于水平。而验证集误差，随着训练集的个数增加而减小，最终趋于水平。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/j9pld8HXBykbq43.png" alt="image-20210717161801051"></p>
<ul>
<li>在高偏差的情况下，训练集误差和验证集误差最终将十分接近，再增加训练集数量将毫无意义。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/ugxCqdUEYX9ao8Z.png" alt="image-20210717162345529"></p>
<ul>
<li>在高方差的情况下，总体来说随着训练集数量的增多，训练集误差将会增加，但是增加的很小。而验证集误差一直都比较高，虽然会有所下降，但是不多。所以增加训练集数量还是很有用的。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/ukSIAg4K1t3EC97.png" alt="image-20210717162807597"></p>
<h1 id="07-决定接下来做什么"><a href="#07-决定接下来做什么" class="headerlink" title="07 决定接下来做什么"></a>07 决定接下来做什么</h1><ul>
<li>接下来回到第一节的第一个图，1和2和6对应着高方差的情况，3和4和5对应高偏差的情况（个人理解：高方差就是在多项式的形式下出现的，高偏差就是在项数少的情况下出现的）。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/57xIsYr3QlATJKw.png" alt="image-20210717163411387"></p>
<ul>
<li>小型神经网络计算量少，大型神经网络比较容易出现过拟合问题（但是可以用正则化来进行解决），相对来说大型神经网络性能更好。</li>
<li>还有就是选择隐含层层数的问题，可以将数据分为训练集、验证集还有测试集。用训练集分别训练一层、两层、三层的隐含层，最终用验证集来测试，选出合适的层数。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/HacLPpBhEyiqXjA.png" alt="image-20210717164334688"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" itemprop="url">机器学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-16T17:21:56+08:00">
                2021-07-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>监督学习算法：线性回归、逻辑回归、神经网络、支持向量机（在这些问题中会有带标签的数据和样本）</li>
<li>无监督学习：K-均值聚类算法、主成分分析法（进行降维）、异常检测算法（对算法进行评估）</li>
<li>特定的应用和话题：推荐系统、大规模机器学习系统（包括并行和映射-化简算法）</li>
<li>其他的应用：滑动窗口分类器（计算机视觉问题）</li>
<li>从各个不同的方面给出了如何构建机器学习系统的建议：偏差和方差（尝试了是什么使得机器学习算法工作或者是不工作）、正则化（解决一些方差问题）、学习算法的评估方法：召回率和F1分数这样的评价指标和实践方面的评测方法：训练集-交叉验证集-测试集（当你开发一个机器学习系统时如何合理分配你的时间）、诊断方法：学习曲线和误差分析及上限分析（如何调试算法确保学习算法能够正常工作）。所有这些工具都能帮助你决定下一步该做什么以及怎么分配时间。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/12/HoW8udwt2DY54Vc.png" alt="image-20210726170215337"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day09%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day09%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/" itemprop="url">机器学习 day09神经网络参数的反向传播算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-16T16:51:50+08:00">
                2021-07-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="01-代价函数"><a href="#01-代价函数" class="headerlink" title="01 代价函数"></a>01 代价函数</h1><ul>
<li>有m组训练样本，L代表神经网络结构的总层数，S_l代表第L层的单元数也就是神经元的数量（不包括第L层的偏差单元）。其中二元分类与多类别分类问题如下：</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/drDmMvuKHpgcTfO.png" alt="image-20210716093702674"></p>
<ul>
<li>应用于神经网络的代价函数：h(x)是一个k维向量，h(x)_i代表第i个输出；k的求和符号应用于y_k和h_K,是因为我们主要是将第k个输出单元的值和y_k的值的大小作比较；y_k的值就是这些向量中其应属于哪个类的量。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/yUiOtvjaTzdRsB8.png" alt="image-20210716094105142"></p>
<h1 id="02-反向传播算法"><a href="#02-反向传播算法" class="headerlink" title="02 反向传播算法"></a>02 反向传播算法</h1><p>反向传播算法是计算代价函数关于所有参数的导数或者偏导数的一种有效方法。</p>
<hr>
<ul>
<li>使用前向传播方法来计算的顺序，计算一下在给定输入的时候，假设函数是否会真的输出结果。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/Td4UHDJEwQntFfO.png" alt="image-20210716095924991"></p>
<ul>
<li>反向传播算法中，下图上方下标j上标（l)代表了第l层的第j个结点的误差，下图上方下标j上标（l)实际上就是假设的输出值和训练集y值之间的差。反向传播算法类似于把输出层的误差反向传播给了第三层，然后再传播给第二层，注意没有第一层（第一层可以直观的观察到，没有误差）。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/lrv49uMLYxS2HaG.png" alt="image-20210716101131864"></p>
<ul>
<li><p>如何实现反向传播算法来计算这些参数的偏导数：</p>
<ol>
<li>首先将每一个i和j对应的三角形（三角形是上图上方下标j上标（l)的大写）置0</li>
<li>接下来遍历整个训练集，将输入层的激活函数设定他为第i个训练样本的输入值</li>
<li>接下来用正向传播来计算第二层的激活值，然后第三层，最后到最后一层</li>
<li>使用输出值来计算这个输出值对应的误差项（假设输出-目标输出）</li>
<li>再通过反向传播算法计算前几层的误差项，一直到第二层</li>
<li>最后通过三角形来累计我们再前面写好的偏导数项</li>
</ol>
</li>
<li><p>跳出循环后，通过下面的式子计算D(j等于0和j不等于0的情况)，计算出来的D正好就是关于每个参数的偏导数，然后可以用梯度下降法或者一些其他的高级优化算法。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/wiYsK8pBjWkSqIm.png" alt="image-20210716102950652"></p>
<h1 id="03-理解反向传播"><a href="#03-理解反向传播" class="headerlink" title="03 理解反向传播"></a>03 理解反向传播</h1><ul>
<li>理解前向传播</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/wBRkMNZcHlrs5bm.png" alt="image-20210716110750217"></p>
<ul>
<li>代价函数应用在只有一个输出单元的情况</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/SApIlocEOPWDBmZ.png" alt="image-20210716111945042"></p>
<ul>
<li>理解反向传播：代价函数是一个关于标签y和神经网络中h(x)的输出值的函数，只要稍微将z(l)j改一下，就会影响神经网络的h(x)，最终改变代价函数的值。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/QOt85NoFZVADRTq.png" alt="image-20210716142240315"></p>
<h1 id="04-使用注意：展开参数"><a href="#04-使用注意：展开参数" class="headerlink" title="04 使用注意：展开参数"></a>04 使用注意：展开参数</h1><p>把参数从矩阵展开向量，以便在高级最优化步骤中的使用需要</p>
<hr>
<ul>
<li>高级最优化算法都假定theta和initialTheta初始值都是参数向量，也许是n或者n+1维，同时假定这个代价函数的第二个返回值(梯度值)也是n维或者n+1维向量。但是现在在神经网络，参数不再是向量而是矩阵，三个参数在Octave表达如下；梯度矩阵在Octave表达也如下：</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/xrcGHU56CONBPS2.png" alt="image-20210716144733723"></p>
<ul>
<li>取出矩阵，并将其展开成向量传入theta中，并得到梯度返回值。</li>
<li>thetaVec就是将这些矩阵全部展开成为一个很长的向量；DVec同理。reshape将相应元素组合起来成相应矩阵。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/UrhzsmlZnwb1LTq.png" alt="image-20210716145958657"></p>
<ul>
<li>上面步骤通过Octave实现如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;Theta1 = ones(10,11)</span><br><span class="line">Theta1 =</span><br><span class="line"></span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line"></span><br><span class="line">&lt;&lt;Theta2 = 2*ones(10,11)</span><br><span class="line">Theta2 =</span><br><span class="line"></span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line"></span><br><span class="line">&lt;&lt;Theta3 = 3*ones(1,11)</span><br><span class="line">Theta3 =</span><br><span class="line"></span><br><span class="line">   3   3   3   3   3   3   3   3   3   3   3</span><br><span class="line"></span><br><span class="line">&lt;&lt;thetaVec = [ Theta1(:);Theta2(:);Theta3(:)];</span><br><span class="line">&lt;&lt;size(thetaVec)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   231     1</span><br><span class="line"></span><br><span class="line">&lt;&lt;reshape(thetaVec(1:110),10,11)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line">   1   1   1   1   1   1   1   1   1   1   1</span><br><span class="line"></span><br><span class="line">&lt;&lt;reshape(thetaVec(111:220),10,11)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line">   2   2   2   2   2   2   2   2   2   2   2</span><br><span class="line"></span><br><span class="line">&lt;&lt;reshape(thetaVec(221:231),1,11)</span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">   3   3   3   3   3   3   3   3   3   3   3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>将这一方法应用于我们的学习算法</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/mX7EGcZ4NAYDbpr.png" alt="image-20210716151702593"></p>
<h1 id="05-梯度检测"><a href="#05-梯度检测" class="headerlink" title="05 梯度检测"></a>05 梯度检测</h1><p>因为反向传播使用时会出现一些bug，而梯度检测可以很好的解决这些问题，确保前向传播及反向传播都百分百正确。</p>
<hr>
<ul>
<li>求出该点导数的近似值（参数是实数的情况）</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/hYr2qFMTQK7dXlC.png" alt="image-20210716154015251"></p>
<ul>
<li>当参数维向量参数的时候</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/YdlaJmtzhKokDX2.png" alt="image-20210716154300648"></p>
<ul>
<li>在Octave中为了估算导数所要实现的</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/yBRY7UkvMq9tD4p.png" alt="image-20210716155456513"></p>
<ul>
<li>总结下如何实现数值上的梯度检验：（注意反向传播算法比梯度检测效率高，检测完一定要关闭梯度检测）</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/OxNDAUQcR3PaXS9.png" alt="image-20210716160140272"></p>
<h1 id="06-随机初始化"><a href="#06-随机初始化" class="headerlink" title="06 随机初始化"></a>06 随机初始化</h1><ul>
<li>在神经网络中将所有参数初始为0，没有任何意义，所有输入都是一样，也就意味这最后输出就输出一个特征，阻挡了神经网络学习任何有趣的东西，我们称之为高度冗余。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/JvQ9PKniBYzl5sS.png" alt="image-20210716160754828"></p>
<ul>
<li>因此就应该使用随机初始化方法。值得注意的是这里的EPSILON与梯度检测中的完全没有关系。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/91QM7VimcrYGOoK.png" alt="image-20210716161237859"></p>
<ul>
<li>为了训练神经网络首先将权重随机初始化为一个接近0范围在-EPSILON到EPSILON之间，然后进行反向传播，在进行梯度检测，最后梯度下降算法或其他高级优化算法来最小化代价函数（关于参数sita的函数）。</li>
</ul>
<h1 id="07-组合到一起"><a href="#07-组合到一起" class="headerlink" title="07 组合到一起"></a>07 组合到一起</h1><ul>
<li>训练神经网络做的第一件事就是选择一种合适的网络架构（神经元之间的连接模式），注意输出时是输出一个向量y。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/4nmfAiVh37d5PIw.png" alt="image-20210716162121409"></p>
<ul>
<li>训练神经网络所需要的步骤</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/NsLGvWHeQfqYx6o.png" alt="image-20210716162700558"></p>
<p><img src="https://s2.loli.net/2022/04/11/MFnKj9VoyYLdRgp.png" alt="image-20210716162914526"></p>
<ul>
<li>反向传播算法是为了算出梯度下降算法的下降方向</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day08%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day08%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/" itemprop="url">机器学习 day08神经网络学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-15T15:36:43+08:00">
                2021-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="01-非线性假设"><a href="#01-非线性假设" class="headerlink" title="01 非线性假设"></a>01 非线性假设</h1><p>为什么已经有线性回归和逻辑回归算法了，还要学习神经网络？</p>
<hr>
<ul>
<li>因为有特别多的特征，许多机器学习都需要学习复杂的非线性假设。如果使用逻辑回归算法，由于项数过多，可以能会导致过拟合问题，此外也存在运算量过大的问题。如果项数只包括二次项的的子集，这样将二次项的数量减少到100个，但是最有可能拟合出右下角椭圆而拟合不出左上角复杂的分界线。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/oHfA6aimQk5Iv7K.png" alt="image-20210715093040511"></p>
<ul>
<li>下图车子例子所示：如果是一张50 * 50 像素的图像， 则会有 50 * 50 &#x3D; 2500个像素单位（如果是彩色，每个像素又有0-255的RGB取值。即有 2500 * 3 &#x3D; 7500），特征数量则有约 n^2 &#x2F; 2 约 3000000 个特征数量。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/6XZmKx9uRQotvLB.png" alt="image-20210715094554044"></p>
<h1 id="02-神经元与大脑"><a href="#02-神经元与大脑" class="headerlink" title="02 神经元与大脑"></a>02 神经元与大脑</h1><p>神经网络能够很好的解决不同的机器学习问题</p>
<hr>
<ul>
<li>神经网络的起源及发展</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/mkqulo8N93TdEy1.png" alt="image-20210715095046937"></p>
<ul>
<li>神经元是一个计算单元，它从输入通道接受一定数量的信息，并做一些计算，然后将结果通过它的轴突传送到其他节点，或者大脑中其他神经元。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/YNiI5uHeGzsdPpD.png" alt="image-20210715100443785"></p>
<h1 id="03-模型展示"><a href="#03-模型展示" class="headerlink" title="03 模型展示"></a>03 模型展示</h1><ul>
<li>神经网络模拟了大脑中的神经元或者神经网络。</li>
<li>在神经网络里我们将使用一个很简单的模型来模拟神经元工作，我们将神经元模拟成一个逻辑单元。黄色代表类似于神经元细胞体的东西，经过“输入”-&gt;“计算”-&gt;“输出”三个步骤，因为X0（偏置单元或偏置神经元）总是1，会根据实际情况判断时候加上X0。</li>
<li>在神经网络中激活函数是指非线性函数g(z)。单个神经元图如下：</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/1p9kYcSsigJufE4.png" alt="image-20210715101642575"></p>
<ul>
<li>在神经网络中第一层叫做输入层，因为我们在这一层输入特征；第二层叫做隐藏层（任何一个非输入层和非输出层），隐藏层的值在训练中是看不到的；最后一层叫输出层，因为在这一层输出假设的最终计算结果；</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/VSUkzXxdt5Er93h.png" alt="image-20210715102240972"></p>
<ul>
<li>ai(j)代表第j层第i个神经元或者单元的激活项，激活项是由一个具体神经元计算并输出的值。参数(j)就是权重矩阵，它控制从某一层到另外一层的映射。计算三个隐藏单位的值及输出如下：</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/KI7j3hGLogYsaAW.png" alt="image-20210715103155055"></p>
<hr>
<p>如何高效进行计算，并展示一个向量化的实现方法。</p>
<ul>
<li>前向传播方法</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/8yE2vJIneOW3gw6.png" alt="image-20210715110649533"></p>
<ul>
<li>下面这个神经网络所作的事情就像是逻辑回归，它不是以原本的X1、X2、X3作为特征，而是用a1、a2、a3作为新的特征</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/Of9WeTsqmvd4t8b.png" alt="image-20210715111837645"></p>
<h1 id="04-例子与直觉理解"><a href="#04-例子与直觉理解" class="headerlink" title="04 例子与直觉理解"></a>04 例子与直觉理解</h1><p>神经网络计算复杂非线性函数的输入</p>
<hr>
<ul>
<li>X1 AND X2运算</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/REgi75IYVh4Ja8o.png" alt="image-20210715145727991"></p>
<ul>
<li>X1 OR X2运算</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/Wgwldop31hJ2HPB.png" alt="image-20210715145844787"></p>
<ul>
<li>NOT X1</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/F12QOElktd9MC3y.png" alt="image-20210715150729226"></p>
<ul>
<li>X1 XNOR X2</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/4XZPKFuJYDk7c6x.png" alt="image-20210715151335935"></p>
<h1 id="05-多元分类"><a href="#05-多元分类" class="headerlink" title="05 多元分类"></a>05 多元分类</h1><ul>
<li>要是在神经网络中实现多类别分类，采用的方法本质是一对多法的拓展（其中Xi代表图像，Yi代表那些向量）</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/gGriKdL4Ux5fNqO.png" alt="image-20210715152619233"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day07%E6%AD%A3%E5%88%99%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day07%E6%AD%A3%E5%88%99%E5%8C%96/" itemprop="url">机器学习 day07正则化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-14T17:52:30+08:00">
                2021-07-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="01-过拟合问题"><a href="#01-过拟合问题" class="headerlink" title="01 过拟合问题"></a>01 过拟合问题</h1><p>正则化可以减少过度拟合问题</p>
<hr>
<h2 id="1-1-线性回归过拟合问题"><a href="#1-1-线性回归过拟合问题" class="headerlink" title="1.1  线性回归过拟合问题"></a>1.1  线性回归过拟合问题</h2><ul>
<li>欠拟合 | 刚好合适 | 过拟合</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/EsDjTwnZuyLcpIl.png" alt="image-20210714155814071"></p>
<ul>
<li>过度拟合问题将会在变量过多的时候出现，这时训练出的假设能够很好的拟合训练集（所以代价函数实际上可能非常接近于0。或者恰好等于0），但是可能会得到图三这样的曲线，去拟合训练集，以至于它无法泛化到新的样本中。</li>
<li>泛化是指一个假设模型应用到新样本的能力</li>
</ul>
<h2 id="1-2-逻辑回归过拟合问题"><a href="#1-2-逻辑回归过拟合问题" class="headerlink" title="1.2  逻辑回归过拟合问题"></a>1.2  逻辑回归过拟合问题</h2><ul>
<li>欠拟合 | 刚好合适 | 过拟合</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/wZy6uRBcSt4UG3H.png" alt="image-20210714161027764"></p>
<ul>
<li>如果我们有过多的特征变量而只有少量的训练集就会出现过拟合问题。</li>
<li>有两种方法解决过拟合问题：<ol>
<li>尽量减少特征变量的数量（模型选择算法会自动选择哪些变量保留，哪些舍弃）</li>
<li>正则化：减少量级或者参数的大小</li>
</ol>
</li>
</ul>
<h1 id="02-代价函数"><a href="#02-代价函数" class="headerlink" title="02 代价函数"></a>02 代价函数</h1><ul>
<li>正则化将多阶函数变成二阶函数（将参数尽可能减小），这些参数越小，我们得到的图像也就越圆滑越简单。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/nXrluhDtHQqPUSj.png" alt="image-20210714163230494"></p>
<ul>
<li>一般来说我们只对参数1以及1之后的进行正则化</li>
<li>在对代价函数进行修改，添加正则化项的目的是为了缩小参数的值。</li>
<li>正则化参数是为了控制两个不同目标之间的取舍</li>
<li>正则化参数如果过大，那么参数都会接近于0，这样就相当于把假设函数的全部项都忽略了，最终变成了欠拟合。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/y8h2zRlHEsOJTuN.png" alt="image-20210714164501298"></p>
<h1 id="03-线性回归的正则化"><a href="#03-线性回归的正则化" class="headerlink" title="03 线性回归的正则化"></a>03 线性回归的正则化</h1><ul>
<li>线性回归正则化的梯度下降法</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/4rzdJiZTx1DektE.png" alt="image-20210714171428902"></p>
<ul>
<li>线性回归正则化的正规方程法</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/hZnGId8afzLHUFM.png" alt="image-20210714171932298"></p>
<ul>
<li>m&lt;&#x3D;n，说明矩阵是不可逆的，但是当正则参数&gt;0，算出来的矩阵一定是可逆的。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/iC2gLWSwYJMOIsq.png" alt="image-20210714172415327"></p>
<h1 id="04-Logistic-回归的正则化"><a href="#04-Logistic-回归的正则化" class="headerlink" title="04 Logistic 回归的正则化"></a>04 Logistic 回归的正则化</h1><ul>
<li>Logistic 回归添加正则化项</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/kjU1qLs2xHWQdvI.png" alt="image-20210714173430686"></p>
<ul>
<li>Logistic 回归的正则化的梯度下降法</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/8Y1MsQ5BjbIyfLN.png" alt="image-20210714173512465"></p>
<ul>
<li>如何在更高级的算法中使用正则化：定义一个costFunction函数，以theta作为输入。在fminunc函数中括号里写上@cosFunction。</li>
<li>fminunc的意思是函数在无约束条件下的最小值，fminunc函数会将costFunction函数最小化，</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/BIha7gCxFqULvtl.png" alt="image-20210714174441860"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day06Logistic%E5%9B%9E%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day06Logistic%E5%9B%9E%E5%BD%92/" itemprop="url">机器学习 day06Logistic回归</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-13T11:01:22+08:00">
                2021-07-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="01-分类"><a href="#01-分类" class="headerlink" title="01 分类"></a>01 分类</h1><ul>
<li>针对于离散值来进行分类：y &#x3D; {0，1}</li>
<li>0表示负类，没有什么东西</li>
<li>1表示正类，有什么东西</li>
<li>不建议将线性回归函数应用于分类情况中</li>
<li>使用线性回归在分类问题，如果一个值远离其他值，将会使线性回归算法不够准确。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/RqnGi6KzPfo2X5T.png" alt="image-20210713082503584"></p>
<ul>
<li>Logistic回归算法的预测值一直介于0和1之间，并不会像线性回归算法大于1或者小于0</li>
</ul>
<h1 id="02-假设陈述"><a href="#02-假设陈述" class="headerlink" title="02 假设陈述"></a>02 假设陈述</h1><ul>
<li>假设陈述：当有一个分类问题的时候，我们要使用哪个方程来表示我们的假设。</li>
<li>Logistic函数的形式如下：对线性回归方程稍作修改。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/GCvIyDoEY1aulRn.png" alt="image-20210713083013942"></p>
<ul>
<li>输出某个数字，我们会把这个数字当作对一个输入x，y&#x3D;1的概率估计</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/TAnJoPx1lNC73aQ.png" alt="image-20210713084628846"></p>
<h1 id="03-决策界限"><a href="#03-决策界限" class="headerlink" title="03 决策界限"></a>03 决策界限</h1><ul>
<li>决策界限可以帮助我们理解Logistic回归的假设函数在计算什么。</li>
<li>可以从图看出什么时候预测y &#x3D; 1;什么时候预测y &#x3D; 0;</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/KsVxteGR8r2IoCi.png" alt="image-20210713085359080"></p>
<ul>
<li>决策边界将一个平面划分为两个区域，其中一片区域假设函数预测y &#x3D; 1；另一片区域假设函数预测y &#x3D; 0。只要我们确定好了参数，我们就将完全确定决策边界。例如下图所示：可以得出直线 X1 + X2 &#x3D; 3就是决策边界。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/sDhGwpMH7qF2mYk.png" alt="image-20210713090135443"></p>
<ul>
<li>例题：我们怎么才能使用Logistic回归来拟合这些数据呢？多项式回归及线性回归可以在特征中添加额外的高阶多项式，Logistic回归也可以使用。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/KLC4XkJDfPEidlS.png" alt="image-20210713091128749"></p>
<ul>
<li>决策边界不是训练集的属性，而是假设本身及其参数的属性，只要给定了参数向量就可以确定决策边界</li>
</ul>
<h1 id="04-代价函数"><a href="#04-代价函数" class="headerlink" title="04 代价函数"></a>04 代价函数</h1><p>如何拟合Logistic回归模型的参数。当代价函数为0时，可以得出与预测值想拟合。</p>
<hr>
<ul>
<li>如果将代价函数带入到Logistic回归中可以得到左侧图像非凸函数，可是我们想要得到右侧这样得凸函数。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/R2N7T9yY8hx14ZV.png" alt="image-20210713092337843"></p>
<ul>
<li>因此我们需要重新找到个代价函数可以用在Logistic回归中，保证找到全局最小值。下面使y &#x3D; 1情况下。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/QLXGwblSNVCojxh.png" alt="image-20210713092943599"></p>
<ul>
<li>下面使y &#x3D; 0情况下</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/AnTIWwHNlXe69jp.png" alt="image-20210713093247097"></p>
<h1 id="05-简化代价函数与梯度下降"><a href="#05-简化代价函数与梯度下降" class="headerlink" title="05 简化代价函数与梯度下降"></a>05 简化代价函数与梯度下降</h1><ul>
<li>简化后得代价函数</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/XsWJ7klD4zaVdMo.png" alt="image-20210713100941704"></p>
<ul>
<li>式子是在统计学中得极大似然法得来得，他是统计学中为不同模型快速寻找参数得方法。同时他是凸的。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/tmqXsBJkypg26AC.png" alt="image-20210713101334737"></p>
<ul>
<li>如何最小化代价函数：使用梯度下降算法。虽然Logistic回归中梯度下降算法与线性回归中的梯度下降算法长的一样，但是由于假设的定义发生了变化，所以实际上是两种截然不同的。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/PnR9QeXTygbhZFN.png" alt="image-20210713101818109"></p>
<h1 id="06-高级优化"><a href="#06-高级优化" class="headerlink" title="06 高级优化"></a>06 高级优化</h1><ul>
<li>一些高级算法的优缺点</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/rinMvR4XsPwdQT2.png" alt="image-20210713103002190"></p>
<ul>
<li>自动求使代价函数最小的参数，使用代码将其实现</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/q49vFIKoNLnskRd.png" alt="image-20210713103524833"></p>
<ul>
<li>写一个函数，他能返回代价函数值以及梯度值</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/H4btBK8lwaCdULZ.png" alt="image-20210713104143672"></p>
<h1 id="07-多元分类：一对多"><a href="#07-多元分类：一对多" class="headerlink" title="07 多元分类：一对多"></a>07 多元分类：一对多</h1><p>使用逻辑回归来解决多类别分类问题</p>
<hr>
<ul>
<li>训练一个逻辑回归分类器，预测i类别y &#x3D; i的概率。在三个分类器中输入x，在其中选择h(x)最大的那个类别。也就是选择出三个里面可信度最高，效果最好的的哪个分类器。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/xNB32Ly6ak85SGe.png" alt="image-20210713104911669"></p>
<ul>
<li>无论i是多少，我们都能得到一个最高的概率值，我们预测y就是那个值。</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/11/3gImPjeKAvlHw5B.png" alt="image-20210713105522497"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
