[{"title":"java day01 Typora","url":"/2021/07/06/java%20day01%20Typora/","content":"Typora的使用熟练使用Markdown语法\n标题的使用一级标题为**#**\n二级标题为**##**\n三级标题为**###**\n字体的使用粗体 hello-&gt;左右两个*\n斜体hello-&gt;左右一个*\n斜体加粗hello-&gt;左右三个*\n删除线hello-&gt;左右两个~\n引用的使用\n引用别人文章时使用，左侧一个&gt;\n\n分割线\n\n左侧三个-\n左侧三个*\n\n\n图片\n本地图片\n\n\n\n网络图片\n\n\n通用方法：**!+[名字]+()**\n超链接CSDN\n方法：**[名称]+(链接)**\n列表\n前面使用的都是有序列表\n方法：数字+.+空格\n\n无须列表方法：**-+空格**\n\nA\nB\n\n\n\n表格\n\n\n名字\n性别\n年龄\n\n\n\n小昊\n女\n20\n\n\n格式如下所示：\n名字|性别|年龄\n–|–|–\n小昊|女|20\n代码public\n\n方法如下：\n英文下的&#96;&#96;&#96;(tab上面的按键)+想要写的语言\n被忽略的windows快捷键\nalt+F4：关闭所在页面\nshift+delete：永久删除\nwindows+tab：切换程序\n\n","tags":["java基础"]},{"title":"java day01 基础","url":"/2021/07/07/java%20day01%20%E5%9F%BA%E7%A1%80/","content":"01 注释单行注释：\n// 单行注释可以注释一行文字\n\n多行注释：\n/*多行注释可以注释一段文字*/\n\n文档注释：\n/***配合JavaDoc使用*/\n\n02 标识符与关键字关键字：class,public等Java硬性要求的代码。\n标识符：类名，变量名，方法名都是标识符。\n标识符的注意事项：\n\n所有标识符都应该以字母，$，或者下划线(_)开始\nString name = &quot;xiaofang&quot;;String $name = &quot;xiaofang&quot;;String _name = &quot;xiaofang&quot;;\n\n首字母之后可以是字母，$，或者下划线(_)或者数字\nString A$ = &quot;xiaofang&quot;;String A_ = &quot;xiaofang&quot;;String A1 = &quot;xiaofang&quot;;\n\n\n\n不能使用关键字作为变量名或方法名\n\n标识符不建议使用中文\n\n标识符是大小写敏感的\n\n\n03 数据类型Java是强类型语言，要求所有变量都必须定义后才能使用。\n\n基本数据类型如下表所示：\n\n\n\n整数类型\n浮点类型\n字符类型\n布尔类型\n\n\n\nbyte占1字节\nfloat占4字节\nchar占2字节\ntrue占1位\n\n\nshort占2字节\ndouble占8字节\n\nfalse占1位\n\n\nint占4字节\n\n\n\n\n\nlong占8字节\n\n\n\n\n\n//整数byte num = 10;short num1 = 15;int num2 = 20;long num3 = 30L;//long类型要在数字后加上L//浮点数float num5 = 10.1f;//float类型要在数字后加上fdouble num6 = 10.33333;//字符char name = &#x27;f&#x27;;//注意String不是关键字//布尔boolean flag = true;boolean flag1 = false;\n\n字节与位的关系：1 Byte&#x3D;8 bit\n\n数据类型面试拓展\n\n整型拓展：\n\nint i = 10;//输出10int i2 = 010;//八进制0开头 输出8int i3 = 0x10;//十六进制0x开头（范围：0~9 A~F） 输出16\n\n\n浮点数拓展：\n由于浮点数有舍入误差，接近但不等于的特点，最好不适用浮点数进行比较，可以使用BigDecimal提供的方法进行比较。\n\n字符拓展：\n所有字符的本质还是数字\nchar s1 = &#x27;a&#x27;;char s2 = &#x27;小&#x27;;System.out.println(s1);//输出 aSystem.out.println((int)s1);//强制转换 输出 97System.out.println(s2);//输出 小System.out.println((int)s2);//强制转换 输出 23567\n\n布尔拓展：\nboolean flag =true;if(flag)&#123;&#125; == if(flag==true)&#123;&#125;//二者是等价的\n\n04 类型转换\n强制类型转换：一般是高容量转换到低容量的转换。格式：**(类型)变量名**\n\nint i = 12;byte b = (byte)i;System.out.println(i);//输出12System.out.println(b);//输出12\n\n\n自动类型转化：低容量到高容量直接转换。\n低 -------------------------------------&gt;高 byte,short,char-&gt;int-&gt;long-&gt;float-&gt;double\n\nint i = 12;double b = i;System.out.println(i);//输出12System.out.println(b);//输出12.0\n\n注意点\n\n布尔类型不能进行转换\n转换的时候可能出现内存溢出，或者精度问题\n\n\n\n//溢出问题int money = 10_0000_0000;//数字之间可以用下划线分割int year = 20;int total = money*year;//计算时溢出 输出为-1474836480long total1 = money*year;//默认为int类型，转换之前就出了问题。所以输出依旧是-1474836480long total2 = money*((long)year);//输出20000000000\n\n//精度问题System.out.println((int)23.7);//输出23System.out.println((int)-20.4f);//输出-20\n\n","tags":["java基础"]},{"title":"java day02 基础","url":"/2021/07/08/java%20day02%20%E5%9F%BA%E7%A1%80/","content":"01 变量、作用域、常量1.1 变量\n变量的格式： 数据类型  变量名 &#x3D; 值\n注意事项：\n数据类型可以是基本类型，还可以是引用类型\n变量名必须是合法的标识符\n变量声明必须以;结尾\n\n\n\nchar x = &#x27;A&#x27;;//基本数据类型int a = 1;//基本数据类型String name = &quot;xiaofang&quot;;//引用类型\n\n1.2 变量作用域public class Hello &#123;    static double salary = 1000;//类变量在类中不在方法中，由static修饰符修饰    String name;//实例变量从属于对象，整型变量默认值为0；布尔变量默认值为false;基本数据类型外默认值都为null。    public static void main(String[] args) &#123;        //定义在方法中为局部变量        int i =10;        System.out.println(i);//输出10        //使用实例变量如下所示：        Hello hello = new Hello();//变量类型 变量名 = new 变量类型        System.out.println(hello.name);//输出null        //类变量        System.out.println(salary);//输出1000.0    &#125;&#125;\n\n1.3 常量\n常量初始化后，值不能再改变\n初始化格式：final 常量名 &#x3D; 值；\n常量名都用大写字母\n\n\n命名规则\n类成员变量：首字母小写+驼峰原则：除了第一个单词外，后面单词首字母大写。xiaoFang\n局部变量：首字母小写+驼峰原则\n常量：大写字母+下划线：XIAO_FANG\n类名：首字母大写+驼峰原则\n方法名：小写+驼峰原则\n\n02 运算符2.1 二元运算符int a = 10;int b = 20;int c = 21;System.out.println(a+b);//输出30System.out.println(a-b);//输出-10System.out.println(a*b);//输出200System.out.println(a/b);//由于int类型，需要舍弃小数点，所以输出0System.out.println(a/(double)b);//输出0.5System.out.println(c%a);//输出1(取余)\n\n2.2 类型转换long a = 101010120121L;int b = 20;short c = 10;byte d = 8;//如果有一个数是long类型，那么最后输出也是long类型System.out.println(a+b+c+d);//输出101010120159//下面自动转为int类型System.out.println(b+c+d);//输出38System.out.println(c+d);//输出18\n\n2.3 关系运算符//关系运算符输出结果是布尔类型int a = 2;int b = 3;System.out.println(a&gt;b);//输出falseSystem.out.println(a&lt;b);//输出trueSystem.out.println(a==b);//输出falseSystem.out.println(a!=b);//输出true\n\n2.4 一元运算符int a = 10;int b = a++;//先赋值再自增int c = ++a;//先自增再赋值System.out.println(a);//输出12System.out.println(b);//输出10System.out.println(c);//输出12\n\n2.5 Math类double pow =Math.pow(3,2);//幂运算System.out.println(pow);//输出9.0\n\n2.6 逻辑运算符boolean a = true;boolean b = false;//逻辑与，两个变量都为真，结果才为真，否则为假System.out.println(&quot;a &amp;&amp; b:&quot;+(a &amp;&amp; b));//输出a &amp;&amp; b:false//逻辑或，两个变量只要有一个为真，结果就为真System.out.println(&quot;a || b:&quot;+(a || b));//输出a || b:true//逻辑否，真变假，假变真System.out.println(&quot;!(a &amp;&amp; b):&quot;+!(a &amp;&amp; b));//输出!(a &amp;&amp; b):true//短路原则int c = 5;boolean d = (c&lt;4)&amp;&amp;(c++&lt;4);//与运算，当第一个为假时，结果就以确定，不再进行下面操作。System.out.println(d);//输出falseSystem.out.println(c);//输出5\n\n2.7 位运算符A = 0011 1100;B = 0000 1101;A&amp;B = 0000 1100;//位与运算，同1才为1，否则为0A|B = 0011 1101;//位或运算，有一就为1，否则为0A^B = 0011 0001;//位异或运算，相同为0，不同为1~A = 1100 0011;//0变1，1变02&gt;&gt;1// 右移/2输出12&lt;&lt;1//左移*2输出4\n\n2.8 字符串连接符a = 10;int b = 20;System.out.println(&quot;&quot;+a+b);//输出1020，String类型在前面+用于连接System.out.println(a+b+&quot;&quot;);//输出30，String类型在后面正常输出\n\n2.9 三元运算符//x ? y : z//如果x==true,则结果为y，否则为zint x =62;String type = x&gt;60 ? &quot;及格&quot; : &quot;不及格&quot;;System.out.println(type);//输出及格\n\n","tags":["java基础"]},{"title":"java day03 基础","url":"/2021/07/09/java%20day03%20%E5%9F%BA%E7%A1%80/","content":"01 包机制\n包就是相当于一个文件夹\n包语句的语法格式：\n\n//package pkg1.pkg2；package com.fang;\n\n\n一般利用公司域名倒置作为包名\n使用某一个包的成员，需要用”import”导入，格式：\n\n//import package1.package1.classname；import com.fang.demo；\n\n02 JavaDoc生成文档/** * @author Fang //@author 用于标记作者 * @version 1.0 //@version 用于标记当前版本，默认为1.0 * @since 1.8 //@since 一般用于标记文件创建时项目当时对应的版本，跟版本号，也可以跟是一个时间，表示文件当前创建的时间 */public class Hello &#123;    String name;    /**     * @param name //@param用于标记参数     * @return //@return 用于返回值     * @throws Exception //@throws 用于抛出异常     */    public String test(String name)throws Exception&#123;        return name;    &#125;&#125;\n\n\n使用cmd生成文档\n\njavadoc -encoding UTF-8 -charset UTF-8 Hello.java\n\n\n使用IDEA生成文档\n\n在IDEA找到工具里的生成JavaDoc文档，配置其他命令行参数-encoding UTF-8 -charset UTF-8防止乱码。\n","tags":["java基础"]},{"title":"java day03 流程控制","url":"/2021/07/09/java%20day03%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","content":"01 Scanner对象\n基本语法：\n\nScanner s = new Scanner(System.in);\n\n\n通过Scanner类的next()和nextLine()方法获取输入字符串，在读取之前一般采用hasNext()与hasNextLine()判断是否还有输入数据。\n\n//创建一个扫描对象，用于接收数据Scanner scanner = new Scanner(System.in);System.out.println(&quot;请输入数据&quot;);//判断用户有没有输入字符if(scanner.hasNext())&#123;//使用next接收String str = scanner.next();//输入xiao fangSystem.out.println(&quot;输出内容为&quot;+str);//输出 输出内容为xiao&#125;scanner.close();//使用完一定要给关闭掉，节省资源\n\n//创建一个扫描对象，用于接收数据Scanner scanner = new Scanner(System.in);System.out.println(&quot;请输入数据&quot;);//判断用户有没有输入字符if(scanner.hasNextLine())&#123;//使用nextLine接收String str = scanner.nextLine();//输入xiao fangSystem.out.println(&quot;输出内容为&quot;+str);//输出 输出内容为xiao fang&#125;scanner.close();//使用完一定要给关闭掉，节省资源\n\n\nnext()与nextLine()的区别\nnext()以有效字符之后的空格作为分隔符胡总和结束符，对于之前遇到的空格，next()会将其去掉；nextLine()以Enter作为结束符。\nnext()不能获得带有空格的字符；nextLine()能获得带有空格的字符。\n\n\n\n02 Scanner进阶使用我们可以输入多个数字，并求其总数及平均值，每输入一个数字用回车确认，通过输入非数字结束输入并输出结果。\npublic class Hello &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        double sum = 0;        int count = 0;        while(scanner.hasNextDouble())&#123;            double x = scanner.nextDouble();            count++;            sum +=x;            System.out.println(&quot;输入第&quot;+count+&quot;个数据,总和为&quot;+sum);        &#125;        System.out.println(&quot;总和为&quot;+sum);        System.out.println(&quot;平均数为&quot;+sum/count);        scanner.close();    &#125;&#125;\n\n","tags":["java基础"]},{"title":"java day04 流程控制","url":"/2021/07/10/java%20day04%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","content":"01 顺序结构\nJava的最基本的结构就是顺序结构\n它是任何一个算法都离不开的一种基本算法结构\n\n02 if选择结构2.1 if单选择结构public class Hello &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入&quot;);        String str = scanner.nextLine();        //判断字符串是否相等        if(str.equals(&quot;hello&quot;))&#123;            System.out.println(str);        &#125;        System.out.println(&quot;end&quot;);        scanner.close();    &#125;&#125;\n\n2.2 if双选择结构//考试分数大于60就是及格，小于60就是不及格public class Hello &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入&quot;);        int num = scanner.nextInt();        if(num&gt;60)&#123;            System.out.println(&quot;及格&quot;);        &#125;else &#123;            System.out.println(&quot;不及格&quot;);        &#125;        scanner.close();    &#125;&#125;\n\n2.3 多选择结构public class Hello &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入&quot;);        int num = scanner.nextInt();        if(num&lt;=100 &amp;&amp; num&gt;=90)&#123;            System.out.println(&quot;A&quot;);        &#125;else if(num&lt;90 &amp;&amp; num&gt;=80)&#123;            System.out.println(&quot;B&quot;);        &#125;else if(num&lt;80 &amp;&amp; num&gt;=70)&#123;            System.out.println(&quot;C&quot;);        &#125;else if(num&lt;70 &amp;&amp; num&gt;=60)&#123;            System.out.println(&quot;D&quot;);        &#125;else&#123;            System.out.println(&quot;成绩不对&quot;);        &#125;        scanner.close();    &#125;&#125;\n\n03 switch多选择结构public class Hello &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入&quot;);        String str = scanner.nextLine();        switch (str)&#123;//JDK7之后就可以用字符串            case &quot;fang&quot;:                System.out.println(&quot;fang&quot;);                break;            case &quot;xiao&quot;:                System.out.println(&quot;xiao&quot;);                break;            default:                System.out.println(&quot;wu&quot;);        &#125;        scanner.close();    &#125;&#125;\n\n\ncase穿透：如果没有break，则会按顺序执行，直到遇到break或者程序结束\n\n","tags":["java基础"]},{"title":"java day05 流程控制","url":"/2021/07/11/java%20day05%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","content":"01 while循环\n只要布尔表达式为true，循环就会一直执行下去。\n我们大多数的情况需要让循环停止下来，需要一个让表达式失效的方式来结束循环。\n先判断在执行\n正常业务应该尽量避免死循环。\n如果不满足条件，则不能进入循环。\n\n//1+2.....+100int i = 0;int sum = 0;while(i&lt;100)&#123;    i++;    sum+=i;&#125;\n\n02 do…..while循环\ndo…..while循环至少执行一次\n先执行后判断\n\n//1+2.....+100int i = 0;int sum = 0;do&#123;    i++;    sum+=i;&#125;while (i&lt;100);\n\n\nwhile与do while区别\n\nint i = 0;while (i&lt;0)&#123;    System.out.println(i);//不输出&#125;System.out.println(&quot;..........................&quot;);do&#123;    System.out.println(i);//输出0&#125;while (i&lt;0);\n\n03 For循环\nfor循环语句时支持迭代的一种通用结构，最有效、最灵活的循环结构。\nfor循环执行的次数是在执行前就确定的。\nfor循环也有死循环，格式如下：\n\nfor ( ; ; )&#123; &#125;\n\n\n计算0到100之间的奇数和偶数的和\n\npublic class Hello &#123;    public static void main(String[] args) &#123;        int oddSum = 0;        int evenSum = 0;        for (int i = 0; i &lt;= 100; i++) &#123;            if(i%2==0)&#123;                evenSum+=i;            &#125;else&#123;                oddSum+=i;            &#125;        &#125;        System.out.println(&quot;偶数和&quot;+evenSum);        System.out.println(&quot;奇数和&quot;+oddSum);    &#125;&#125;\n\n\n循环输出1-1000之间能被5整除的数，并且每行输出3个\n\npublic class Hello &#123;    public static void main(String[] args) &#123;        for (int i = 0; i &lt;= 1000; i++) &#123;            if(i%5==0)&#123;                System.out.print(i+&quot;\\t&quot;);//\\t加空格            &#125;            if(i%(5*3)==0)&#123;                System.out.println();//输出完自动换行                //System.out.print(&quot;\\n&quot;);输出完不会换行            &#125;        &#125;    &#125;&#125;\n\n\n打印九九乘法表\n\npublic class Hello &#123;    public static void main(String[] args) &#123;        for (int i = 1; i &lt;= 9; i++) &#123;            for(int j = 1; j&lt;=i;j++)&#123;                System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+(i*j)+&quot;\\t&quot;);            &#125;            System.out.println();        &#125;    &#125;&#125;\n\n04 增强for循环\n主要用来遍历数组与集合\n格式：for(声明语句 ：表达式){ }\n声明语句：是声明局部变量，该变量类型必须和数组元素的类型匹配。\n表达式：是要访问的数组名，或者是返回值是数组的方法。\n\n\n\npublic class Hello &#123;    public static void main(String[] args) &#123;        int[] number = &#123;10, 20, 30, 40&#125;;        for (int x : number)&#123;            System.out.println(x);        &#125;    &#125;&#125;\n\n05 break与continue\nbreak用于强制退出循环，不再执行循环中剩余语句。\ncontinue用于终止某次循环结构，进行下次循环\n\npublic class Hello &#123;    public static void main(String[] args) &#123;       int i = 1;       while (i&lt;100)&#123;           i++;           if(i%10==0)&#123;               System.out.println();               continue;//1               //break;2           &#125;           System.out.print(i+&quot; &quot;);       &#125;    &#125;&#125;1./*1 2 3 4 5 6 7 8 9               2.   1 2 3 4 5 6 7 8 9 11 12 13 14 15 16 17 18 19 21 22 23 24 25 26 27 28 29 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46 47 48 49 51 52 53 54 55 56 57 58 59 61 62 63 64 65 66 67 68 69 71 72 73 74 75 76 77 78 79 81 82 83 84 85 86 87 88 89 91 92 93 94 95 96 97 98 99 */\n\n\n打印三角形\n\npublic class Hello &#123;    public static void main(String[] args) &#123;        for (int i = 1; i &lt;= 5; i++) &#123;            for (int j = 5; j &gt;= i; j--) &#123;                System.out.print(&quot; &quot;);            &#125;            for (int j = 1; j &lt;= i; j++)&#123;                System.out.print(&quot;*&quot;);            &#125;            for (int j = 1; j &lt; i; j++)&#123;                System.out.print(&quot;*&quot;);            &#125;            System.out.println();        &#125;    &#125;&#125;","tags":["java基础"]},{"title":"java day06 方法","url":"/2021/07/12/java%20day06%20%E6%96%B9%E6%B3%95/","content":"01 方法定义和调用1.1 方法定义//类.对象.方法System.out.println();\n\n\nJava一定是值传递\nJava方法是语句的集合，他们在一起执行一个功能。\n方法包括在类或对象中。\n方法在程序中被创建，在其他地方被引用。\n一个方法只完成一个功能。\n\n//修饰符+返回值类型+方法名（参数类型+参数名）public static int max(int num1,int num2)&#123;    return 0;&#125;\n\n//比较大小public class Hello &#123;    public static void main(String[] args) &#123;        int max =max(3,2);        System.out.println(max);    &#125;    public static int max(int num1,int num2)&#123;        int result = 0;        if(num1 == num2)&#123;            System.out.println(&quot;等价&quot;);        &#125;else if(num1&gt;num2)&#123;            result = num1;        &#125;else&#123;            result = num2;        &#125;        return result;    &#125;&#125;\n\n1.2 方法调用\n调用方法：对象名.方法名（实参列表）\n当方法返回一个值时，方法调用通常被当作一个值。例如\n\nint max =max(3,2);\n\n\n当方法返回值是void，方法调用一定是一条语句。\n\nSystem.out.println(&quot;hello&quot;);\n\n02 方法的重载\n重载就是在一个类中，有相同的函数名称，但形式参数不同的函数。\n方法重载的规则：\n方法名称必须相同。\n参数列表必须不同（个数不同、类型不同、参数排列顺序不同）。\n返回类型可以相同也可以不同。\n仅仅返回类型不同，不是方法的重载。\n\n\n\npublic static int max(int num1,int num2)public static int max(double num1,double num2)","tags":["java基础"]},{"title":"java day07 数组","url":"/2021/07/13/java%20day07%20%E6%95%B0%E7%BB%84/","content":"01 数组的定义\n数组是相同数据类型的有序集合\n按照一定的先后次序排列组合而成\n每一个数据称作一个数组元素，每个数组元素都可以通过一个下标来进行访问\n\n02 数组的声明及创建\n数组的元素是通过索引访问的，数组索引从0开始\n获得数组的长度：arrays.length\n声明数组：\n\nint[] arrays;//首选int arrays[];//不是首选\n\n\n创建一个数组：\n\narrays = new int[10];\n\n\n声明+创建数组：\n\nint[] arrays = new int[10];","tags":["java基础"]},{"title":"java day07 方法","url":"/2021/07/13/java%20day07%20%E6%96%B9%E6%B3%95/","content":"01 可变参数\n在方法声明时，在（ ）中指定参数类型后加…\n一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。\n\npublic class Hello &#123;    public static void main(String[] args) &#123;       max(1, 2, 3, 4, 5);       max(0.45, 0.55, 0.12);    &#125;    public static void max(double ...i)&#123;//i为可变参数        if(i.length == 0)&#123;            System.out.println(&quot;No Print&quot;);        &#125;        double result = i[0];        for(int number = 0;number&lt;i.length;number++)&#123;            if(result&lt;i[number])&#123;                result = i[number];            &#125;        &#125;        System.out.println(&quot;The Max is&quot;+result);    &#125;&#125;\n\n02 递归\n递归就是：自己调用自己\n递归结构包括：\n递归头：什么时候不调用自身方法。\n递归体：什么时候需要调用自身方法。\n\n\n\npublic class Hello &#123;    public static void main(String[] args) &#123;        System.out.println(f(4));    &#125;    public static int f(int i)&#123;      if(i == 1)&#123;          return 1;      &#125;else&#123;          return i*f(i-1);      &#125;    &#125;&#125;\n\n\n递归的形式：\n\n\n","tags":["java基础"]},{"title":"java day08 数组","url":"/2021/07/15/java%20day08%20%E6%95%B0%E7%BB%84/","content":"01 三种初始化及内存分析\n内存分析\n堆是用来存放new的对象和数组；可以被所有线程共享，不会存放别的对象引用\n栈是用来存放基本变量类型（包含具体数值）；或者存放引用对象变量\n方法区包括了所有的class和static变量\n\n\n\n\n\n三种初始化\n\n静态初始化\n\nint[] arrays = &#123;1,2,3,4,5,6,7&#125;;Man[] man = &#123;new Man(),new Man()&#125;;//在此之前先创建个Man类，进行引用\n\n\n动态初始化\n\nint[] a = new int[2];a[0] = 1;a[1] = 2;\n\n\n默认初始化：数组分配空间后，int类型默认为0\n\n\n\n02 下标越界\n数组的四个基本特点\n\n其长度是确定的，数组一旦被创建，它的大小就是不可以改变的。\n其元素必须是相同类型的。\n数组中的元素可以是任何数据类型，包括基本类型和引用类型。\n数组对象本身是在堆中的,数组元素相当于对象的成员变量。\n\n\n下标的合法区间：[0,length-1]\n\n\n","tags":["java基础"]},{"title":"java day09 数组","url":"/2021/07/16/java%20day09%20%E6%95%B0%E7%BB%84/","content":"01 数组的使用\n配合for循环使用\n\npublic class Hello &#123;    public static void main(String[] args) &#123;      int[] a = &#123;1,2,3,4,5&#125;;      //打印全部的数组元素        for(int i = 0;i&lt;a.length;i++)&#123;            System.out.println(a[i]);        &#125;        System.out.println(&quot;============&quot;);        //计算所有数组的和        int sum = 0;        for(int i = 0;i&lt;a.length;i++)&#123;            sum+=a[i];        &#125;        System.out.println(&quot;总和&quot;+sum);        System.out.println(&quot;============&quot;);        //查找最大的数        int max = a[0];        for(int i = 0;i&lt;a.length;i++)&#123;           if(a[i]&gt;max)&#123;               max = a[i];           &#125;        &#125;        System.out.println(&quot;最大数&quot;+max);    &#125;&#125;\n\n\nFor-Each循环\n\npublic class Hello &#123;    public static void main(String[] args) &#123;      int[] a = &#123;1,2,3,4,5&#125;;        for (int i : a) &#123;//i就是数组元素，a就代表数组            System.out.println(i);        &#125;    &#125;&#125;\n\n\n数组作方法入参\n\n////打印全部的数组元素public class Hello &#123;    public static void main(String[] args) &#123;      int[] a = &#123;1,2,3,4,5&#125;;      printArray(a);    &#125;    public static  void printArray(int[] a)&#123;        for (int i = 0;i&lt;a.length;i++)&#123;            System.out.println(a[i]);        &#125;    &#125;&#125;\n\n\n数组作返回值\n\n//反转数组public class Hello &#123;    public static void main(String[] args) &#123;      int[] a = &#123;1,2,3,4,5&#125;;      int[] reverse = reverse(a);      printArray(reverse);    &#125;    public  static int[] reverse(int[] a)&#123;        int[] b = new int[a.length];        for(int i = 0,j = b.length-1;i&lt;b.length;i++,j--)&#123;            b[j] = a[i];        &#125;        return b;    &#125;    public static  void printArray(int[] a)&#123;        for (int i = 0;i&lt;a.length;i++)&#123;            System.out.println(a[i]);        &#125;    &#125;&#125;\n\n02 二维数组int a[][] = new int[2][5];int[][] b = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;\n\n03 Arrays类\n数组的工具类java.util.Arrays\nArrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而不用适用对象来调用。\n\nint[] a =&#123;1,2,3,55645,121,11&#125;;//数组进行排序   Arrays.sort(a);//数组进行填充   Arrays.fill(a,2,4,0);//从2到4之间进行填充//打印数组元素   System.out.println(Arrays.toString(a));","tags":["java基础"]},{"title":"java day11 稀疏数组","url":"/2021/07/18/java%20day11%20%E6%95%B0%E7%BB%84/","content":"稀疏数组public class Hello &#123;    public static void main(String[] args) &#123;        //1.创建一个二维数组11*11        int[][] array1 = new int[11][11];        array1[1][2] = 1;        array1[2][3] = 2;        //2.输出原始数组        System.out.println(&quot;输出原始数组&quot;);        for (int[] ints : array1) &#123;//ints 相当于array1的每一行            for (int anInt : ints) &#123;//anInt相当于每一个元素                System.out.print(anInt+&quot;\\t&quot;);            &#125;            System.out.println();        &#125;        //3.获取有效数值        int sum = 0;        for (int i = 0; i &lt; 11; i++) &#123;            for (int j = 0; j &lt; 11; j++) &#123;                if(array1[i][j]!=0)&#123;                    sum++;                &#125;            &#125;        &#125;        System.out.println(&quot;有效个数&quot;+sum);        //4.创建一个稀疏矩阵数组        int[][] array2 = new int[sum+1][3];        array2[0][0] = 11;        array2[0][1] = 11;        array2[0][2] = 2;        //5.遍历二位数组，有非零值，存放在稀疏矩阵中        int cout = 0;        for(int i =0;i&lt;array1.length;i++)&#123;            for(int j =0;j&lt;array1[i].length;j++)&#123;                if(array1[i][j]!=0)&#123;                    cout++;                    array2[cout][0] = i;                    array2[cout][1] = j;                    array2[cout][2] = array1[i][j];                &#125;            &#125;        &#125;        //6.输出稀疏数组        System.out.println(&quot;稀疏数组：&quot;);        for (int i = 0;i&lt; array2.length;i++)&#123;            System.out.println(array2[i][0]+&quot;\\t&quot;                    +array2[i][1]+&quot;\\t&quot;                    +array2[i][2]+&quot;\\t&quot; );        &#125;        //7.读取稀疏矩阵        int[][] array3 = new int[array2[0][0]][array2[0][1]];        //8.给其他元素还原        for(int i = 1;i&lt; array2.length;i++)&#123;            array3[array2[i][0]][array2[i][1]] = array2[i][2];        &#125;        //9.打印        System.out.println(&quot;还原数组：&quot;);        for (int[] ints : array3) &#123;//ints 相当于array1的每一行            for (int anInt : ints) &#123;//anInt相当于每一个元素                System.out.print(anInt+&quot;\\t&quot;);            &#125;            System.out.println();        &#125;&#125;    &#125;\n\n输出原始数组0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t2\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t有效个数2稀疏数组：11\t11\t2\t1\t2\t1\t2\t3\t2\t还原数组：0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t2\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n\n","tags":["java基础"]},{"title":"java day12 面向对象","url":"/2021/07/20/java%20day12%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"01 什么是面向对象\n属性+方法&#x3D;类 \n面向过程思想\n步骤清晰简单，第一步做什么，第二部做什么….\n面向过程适合处理一些较为简单的问题\n\n\n面向对象思想\n物以类聚，分类的思维模式\n面向对象适合处理复杂的问题\n\n\n对于描述复杂的事务，为了从宏观上把握，从整体上合理分析，我们需要使用面向对象的思想来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思想。\n面向对象编程的本质：以类的方式组织代码，以对象的组织（封装）数据。\n三大特性：封装、继承、多态\n\n02 回顾方法\n当一个类调用静态方法时，调用形式：类名+方法名\n\npublic class Student &#123;    public static void say() &#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;public class Hello &#123;    public static void main(String[] args) &#123;        Student.say();&#125;    &#125;\n\n\n当调用非静态方法时，调用形式：将这个类实例化\n\npublic class Student &#123;    public  void say() &#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;public class Hello &#123;    public static void main(String[] args) &#123;        Student student = new Student();        student.say();&#125;    &#125;\n\n\nstatic是和类一起加载的，而不含static的是在类实例化之后才存在，所以下面代码是错误的\n\npublic  static void a()&#123;        b();&#125;public void b()&#123;&#125;\n\n\n一个类中只有一个public class,但是有很多class。\n\n03 类和对象的关系\n使用new关键字创建对象，除了分配内存空间，还会初始化，以及对类中构造器的使用。\n一个项目应该只存在一个main方法\n\npublic class Student &#123;    //属性:字段    String name;    int age;    //方法    public  void study() &#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;        //类：抽象的，实例化        //类实例化后会返回一个自己的对象        //student对象就是一个Student类的具体实例。        Student xm = new Student();        Student xh = new Student();        xm.name = &quot;xiaoming&quot;;        xm.age = 3;        System.out.println(xm.name);//xiaoming        System.out.println(xm.age);//3        System.out.println(xh.name);//默认值null        System.out.println(xh.age);//默认值0        xh.study();//hello    &#125;&#125;\n\n04 构造器详解\n一个类即使什么都不写，也会构造一个方法。\n\n构造器：\n\n特点：必须和类的名字相同；必须没有返回类型，也不能写void。\n作用：new本质就是调用构造方法；初始化对象的值。\n注意点：定义有参构造之后，如果想使用无参构造，必须显示的定义一个无参构造。\n\n\n调用无参构造函数\n\n\n\npublic class Student &#123;    String name;    public Student()&#123;        this.name = &quot;xiaofang&quot;;    &#125;    public Student(String name)&#123;        this.name = name;//this.name代表对象本身的name,name是传递下来的name。    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;     Student student = new Student();        System.out.println(student.name);//xiaofang    &#125;&#125;\n\n\n调用有参构造函数\n\npublic class Student &#123;    String name;    public Student()&#123;        this.name = &quot;xiaofang&quot;;    &#125;    public Student(String name)&#123;        this.name = name;//this.name代表对象本身的name,name是传递下来的name。    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;     Student student = new Student(&quot;xiaoxu&quot;);        System.out.println(student.name);//xiaoxu    &#125;&#125;","tags":["java基础"]},{"title":"java day10 冒泡排序","url":"/2021/07/17/java%20day10%20%E6%95%B0%E7%BB%84/","content":"01 冒泡排序冒泡排序：两层循环，外层冒泡轮数，里层依次比较。\npublic class Hello &#123;    public static void main(String[] args) &#123;        int[] a = &#123;1, 2, 3, 8, 11, 1, 55, 12&#125;;        int[] array = sort(a);        System.out.println(Arrays.toString(array));    &#125;    public static int[] sort(int[] array) &#123;        int temp = 0;        for (int i = 0; i &lt; array.length - 1; i++) &#123;            boolean flag = false;            for (int j = 0; j &lt; array.length - 1; j++) &#123;                if (array[j + 1] &lt; array[j]) &#123;                    temp = array[j + 1];                    array[j + 1] = array[j];                    array[j] = temp;                    flag = true;                &#125;            &#125;                if (flag == false) &#123;                    break;                &#125;        &#125;        return array;    &#125;&#125;\n\n","tags":["java基础"]},{"title":"java day13 面向对象三大特征1","url":"/2021/07/21/java%20day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A71/","content":"01 封装\n我们程序设计追求高内聚低耦合。\n高内聚：类的内部数据操作细节自己完成，不允许外部干涉。\n低耦合：仅暴露少量的方法给外部使用。\n\n\n封装的意义：\n提高程序的安全性，保护数据\n隐藏代码的实现细节\n统一接口\n系统可维护增加了\n\n\n属性私有，get&#x2F;set\n信息隐藏：禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问。\n\npublic class Student &#123;    //属性私有    private String name;//姓名    private int id;//学号    private char sex;//性别    //get 获得这个数据    public String getName()&#123;        return this.name;    &#125;    //set 给这个数据设置值    public void setName(String name)&#123;        this.name = name;    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;        Student student = new Student();        student.setName(&quot;小方&quot;);        System.out.println(student.getName());    &#125;&#125;\n\n02 继承\n继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。\nextends的意思是”扩展”。子类是父类的扩展。\nJAVA只有单继承，没有多继承。一个爸爸可以有多个儿子，一个儿子只能有一个爸爸。\n继承是类与类之间的一种关系\n\npublic class Person &#123;    public void say()&#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;public class Student extends Person &#123;&#125;public class Application &#123;    public static void main(String[] args) &#123;        Student student = new Student();        student.say();//hello    &#125;&#125;\n\n\n私有的东西无法被继承。\n在Java中，所有的类，都默认直接或者间接继承object\n\n03 Super\nsuper注意点：\n\nsuper调用父类的构造方法，必须在构造方法的第一个\nsuper必须只能出现在子类的方法或者构造方法中。\nsuper和this不能同时调用构造方法。\n\n\nsuper VS this\n\n代表的对象不同：this（本身调用这个对象），super（代表父类对象的引用）。\n前提：this（没有继承也可以使用），super（只有在继承条件下才可以使用）。\n构造方法：this():本类的构造，super():父类的构造\n\npublic class Person &#123;    public Person()&#123;        System.out.println(&quot;Person无参&quot;);    &#125;    protected String name = &quot;xiaofang&quot;;    public void print()&#123;        System.out.println(&quot;Person&quot;);    &#125;&#125;public class Student extends Person &#123;    //隐藏代码：调用父类的无参构造    public Student()&#123;        super();        System.out.println(&quot;Student无参&quot;);    &#125;    private String name = &quot;xiaoxu&quot;;    public void print()&#123;        System.out.println(&quot;student&quot;);    &#125;    public  void test(String name)&#123;        System.out.println(name);//方        System.out.println(this.name);//xiaoxu        System.out.println(super.name);//xiaofang    &#125;    public  void test1()&#123;        print();//student        this.print();//student        super.print();//Person    &#125;&#125;public class Application &#123;    public Application() &#123;    &#125;    public static void main(String[] args) &#123;        Student student = new Student();//先调用父类Person无参，在调用子类Student无参        student.test(&quot;方&quot;);        student.test1();    &#125;&#125;\n\n","tags":["java基础"]},{"title":"java day13 面向对象三大特征2","url":"/2021/07/28/java%20day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A72/","content":"01 方法重写\n重写：需要有继承关系，子类重写父类的方法！\n\n方法名必须相同\n参数列表必须相同\n修饰符：范围可以扩大但是不能缩小（public&gt;Protected&gt;Default&gt;private）\n抛出的异常：范围可以缩小但是不能扩大\n快捷键：Alt+Insert(override)\n\n\n为什么需要重写：因为父类的功能，子类不一定需要，或者不一定满足\n\n静态的方法和非静态方法差别很大：\n\n静态方法：方法的调用只和左边定义的数据类型有关\n\npublic class Person &#123;    public static void print()&#123;        System.out.println(&quot;Person&quot;);    &#125;&#125;public class Student extends Person &#123;    public static void print()&#123;        System.out.println(&quot;Student&quot;);    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;        Student student = new Student();        student.print();//Student        //父类的引用指向了子类        Person person = new Student();        person.print();//Person    &#125;&#125;\n\n\n非静态方法：重写\n\n\n\npublic class Person &#123;    public void print()&#123;        System.out.println(&quot;Person&quot;);    &#125;&#125;public class Student extends Person &#123;    public void print()&#123;        System.out.println(&quot;Student&quot;);    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;        Student student = new Student();        student.print();//Student        //父类的引用指向了子类        Person person = new Student();        person.print();//Student    &#125;&#125;\n\n02 多态多态就是同一方法可以根据发送对象的不同而采用多种不同的行为方式。\n\n\n多态注意事项：\n\n多态时方法的多态，属性没有多态\n存在条件：继承关系，方法需要重写，父亲引用指向子类对象\n\n\n不能重写的方法：\n\nstatic方法属于类不属于实例\nfinal常量\nprivate方法\n\n\n\npublic class Person &#123;    public void print()&#123;        System.out.println(&quot;Person&quot;);    &#125;&#125;public class Student extends Person &#123;    public void print()&#123;        System.out.println(&quot;Student&quot;);    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;        //一个对象的实际类型是确定的--&gt;new Student(); new Person()        //可以指向的引用类型就不确定了：父类的引用指向子类        //Student能调用的方法都是自己的或者继承父类的        Student student = new Student();        student.print();//Student        //Person父类型可以指向子类，但是不能调用子类独有的方法        Person person = new Student();        person.print();//Student    &#125;&#125;\n\n","tags":["java基础"]},{"title":"java day14 面向对象","url":"/2021/07/29/java%20day14%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"01 instanceof和类型转换\ninstanceof的格式是System.out.println(x instanceof y);如果x和y是同一类型或者能类型转换（兄弟之间不能类型转换，父子之间可以类型转换）则编译通过，否则不通过。编译通过后会把x和y比较，如果x是y本类或者子类的对象，结果就是true，反之就是flase。\n\npublic class Application &#123;    public static void main(String[] args) &#123;        //Object &gt; String        //Object &gt; Person &gt; Teacher        //Object &gt; Person &gt; Student        Object object = new Student();        System.out.println(object instanceof Object);//true        System.out.println(object instanceof Person);//true        System.out.println(object instanceof Teacher);//false        System.out.println(object instanceof Student);//true        System.out.println(object instanceof String);//false        System.out.println(&quot;=========================&quot;);        Person person = new Student();        System.out.println(person instanceof Object);//true        System.out.println(person instanceof Person);//true        System.out.println(person instanceof Teacher);//false        System.out.println(person instanceof Student);//true        //System.out.println(person instanceof String);编译不通过        System.out.println(&quot;=========================&quot;);        Student student = new Student();        System.out.println(student instanceof Object);//true        System.out.println(student instanceof Person);//true        //System.out.println(student instanceof Teacher);编译不通过        System.out.println(student instanceof Student);//true        //System.out.println(student instanceof String);编译不通过        System.out.println(&quot;=========================&quot;);    &#125;&#125;\n\n\n类型转换：\n把子类转换成父类，向上转型\n把父类转换成子类，向下转型：强制转换\n\n\n\npublic class Student extends Person &#123;    public void go()&#123;        System.out.println(&quot;Student&quot;);    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;        //高转低        Person obj = new Student();        //方法一        Student student = (Student) obj;        student.go();//Student        //方法二        ((Student) obj).go();//Student        //低转高可能丢失一些自己本来的方法        Student student = new Student();        Person person = student;       //person.go();报错！    &#125;&#125;\n\n02 static关键字详解\n对于代码块来说：\n\npublic class Person &#123;    &#123;        System.out.println(&quot;匿名代码块&quot;);    &#125;    static &#123;        System.out.println(&quot;静态代码块&quot;);//只执行一次    &#125;    public Person()&#123;        System.out.println(&quot;构造方法&quot;);    &#125;    public static void main(String[] args) &#123;        Person p1 = new Person();        System.out.println(&quot;==========&quot;);        Person p2 = new Person();    &#125;&#125;                                /*静态代码块                                匿名代码块                                构造方法                                ==========                                匿名代码块                                构造方法*/\n\n\n非静态方法和静态方法可以调用静态方法，而静态方法不能调用非静态方法。\n静态导入包：\n\n//静态导入包import static java.lang.Math.random;public class Person &#123;    public static void main(String[] args) &#123;        System.out.println(random());//这就可以直接使用random()，而不用Math.random()    &#125;&#125;\n\n\n调用非静态方法必须new一个对象进行调用，而调用静态方法可以直接用类调用，比如Student.run()。\n在方法中调用变量：调用非静态变量不能直接用类调用，要创建一个对象进行调用，而调用静态变量既可以用类进行调用，也可以用对象进行调用。\n\n03 抽象类\nabstract修饰符，如果修饰方法就是抽象方法，如果修饰类就是抽象类。\n抽象类中可以没有抽象方法，但是只要有抽象方法，必须声明抽象类。\n抽象类不能用new实例化。\n抽象方法只有方法的声明而没有具体实现，实现是让子类来完成的。\n子类继承抽象类，就必须实现抽象类中没有实现的抽象方法，否则子类也要声明为抽象类。\n\npublic abstract class Application &#123;   public abstract void run();   public void go()&#123;       System.out.println(&quot;有普通方法也是可以的&quot;);   &#125;&#125;\n\n04 接口\n接口的本质是契约，是对对象的抽象\n用interface定义接口\n接口的作用：\n约束\n定义一些方法，让不同的人实现（10个人可以实现一个接口）\n接口中的所有定义的方法其实都是抽象的 public abstract\n接口中的所有定义的变量其实都是静态常量 public static final\n接口也不能被实例化（没有构造方法）\nimplements可以实现多个接口，就是相当于多继承\n实现接口，必须要做重写接口中方法\n\n\n\npublic interface Person &#123;    void add(String name);    void delete(String name);    void update(String name);    void query(String name);&#125;public interface Teacher  &#123;    void run();&#125;//Ait+insert直接生成的重写方法public class Student implements Person,Teacher &#123;    @Override    public void add(String name) &#123;    &#125;    @Override    public void delete(String name) &#123;    &#125;    @Override    public void update(String name) &#123;    &#125;    @Override    public void query(String name) &#123;    &#125;    @Override    public void run() &#123;    &#125;&#125;\n\n","tags":["java基础"]},{"title":"java day15 异常","url":"/2021/07/30/java%20day15%E5%BC%82%E5%B8%B8/","content":"01 Error和Exception\n异常是指程序运行时出现的不期而至的各种状况，如：文件找不到、网络连接失败、非法参数。\n三种类型的异常：\n检查性异常：是用户错误或问题引起的异常，这时程序员无法遇见的。比如打开一个不存在的文件。\n运行时异常：是可能被程序员避免的异常。\n错误：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如堆栈溢出，在编译时也检测不到。\n\n\nJava把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。\n这些异常通常分为两大类：错误Error和异常Exception\n在Exception分支中有一个重要的子类RuntimeException（运行时异常）：\nArrayIndexOutOfBoundsException（数组下标越界）\nNullPointerException（空指针异常）\nArithmeticException（算数异常）\nMissingResourceException（丢失资源）\nClassNotFoundException（找不到类）\n\n\n\n02 捕获和抛出异常\n异常处理五个关键字：try、catch、finally、throw、throws\n\n//方法一public abstract class Application &#123;    public static void main(String[] args) &#123;        int a = 1;        int b = 0;        //假设要捕获多个异常：从小到大        try&#123;//try监控区域            System.out.println(a/b);        &#125;catch(Error e)&#123;            System.out.println(&quot;Error&quot;);        &#125;catch(Exception e)&#123;            System.out.println(&quot;Exception&quot;);        &#125;catch (Throwable t)&#123;            System.out.println(&quot;Throwable&quot;);        &#125;finally &#123;//处理善后工作            System.out.println(&quot;finally&quot;);        &#125;    &#125;&#125;//打印出Exception和finally//方法二public abstract class Application &#123;    public static void main(String[] args) &#123;        int a = 1;        int b = 0;        //通过Ctrl+Alt+t快捷键来完成        try &#123;            System.out.println(a/b);        &#125; catch (Exception e) &#123;            e.printStackTrace();//打印错误的栈信息        &#125; finally &#123;        &#125;    &#125;&#125;//打印出ava.lang.ArithmeticException: / by zero//方法三public  class Application &#123;    public static void main(String[] args) &#123;        new Application().test(1,0);    &#125;    public void test(int a, int b)&#123;        if(b==0)&#123;            throw new ArithmeticException();//主动抛出异常        &#125;    &#125;&#125;//打印出Exception in thread &quot;main&quot; java.lang.ArithmeticException//方法四public  class Application &#123;    public static void main(String[] args) &#123;        try &#123;            new Application().test(1,0);        &#125; catch (ArithmeticException e) &#123;            e.printStackTrace();        &#125;    &#125;    //假设方法处理不了这个异常。那么就将其向上抛出，在方法上抛出。    public void test(int a, int b)throws ArithmeticException&#123;        if(b==0)&#123;            throw new ArithmeticException();//主动抛出异常        &#125;    &#125;&#125;//输出java.lang.ArithmeticException\n\n03 自定义异常\n自定义异常类，大体可以分为以下几个步骤：\n创建自定义异常类\n在方法中通过throw关键字抛出异常对象\n如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作\n在出现异常方法的调用者中捕获并处理异常\n\n\n\npublic class MyException extends Exception&#123;    //传递数字&gt;10    private  int detail;    public MyException(int a) &#123;        this.detail = a;    &#125;    //toString:异常的打印信息    @Override    public String toString() &#123;        return &quot;MyException&#123;&quot; + &quot;detail=&quot; + detail + &#x27;&#125;&#x27;;    &#125;&#125;public  class Application &#123;    public static void main(String[] args) &#123;        try &#123;            new Application().test(11);        &#125; catch (MyException e) &#123;            System.out.println(&quot;MyException=&gt;&quot;+e);        &#125;    &#125;    //假设方法处理不了这个异常。那么就将其向上抛出，在方法上抛出。    public void test(int a)throws MyException&#123;        System.out.println(&quot;传递的参数为：&quot;+a);        if(a&gt;10)&#123;            throw new MyException(a);//主动抛出异常        &#125;        System.out.println(&quot;OK&quot;);    &#125;&#125;\n\n\n在实际应用中的经验：\n处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理\n在多重catch块后面，可以加一个catch(Exception)来处理可能会被遗漏的异常\n对于不确定的代码，也可以加上try-catch，处理潜在的异常（当在IDEA中出现红色波浪线可以Alt+Enter）\n尽量去处理异常，不要只是简单的调用printStackTrace()去打印输出\n尽量添加finally语句块去释放占用资源\n\n\n\n","tags":["java基础"]}]