[{"title":"1编程作业：线性回归","url":"/2021/08/06/1%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","content":"原任务是在Octave&#x2F;MATLAB实现，本次编程作业全部以python完成。\n\n01 简单的练习总结下题目：输出一个5*5的单位矩阵\n\n\n在此我们用np.eye(N,M&#x3D;None, k&#x3D;0, dtype&#x3D;&lt;type ‘float’&gt;)，首先N代表的是输出方阵的维度，第二个参数不用设置默认M&#x3D;N，主要看第三个参数，默认是对角线为1，其余全为0；如果k为正数，则对角线往上第k个全为1，其余全为0；如果k为负数，则对角线往下第k个全为1，其余全为0。\n\nimport numpy as npA = np.eye(5)print(A)&quot;&quot;&quot;[[1. 0. 0. 0. 0.] [0. 1. 0. 0. 0.] [0. 0. 1. 0. 0.] [0. 0. 0. 1. 0.] [0. 0. 0. 0. 1.]]&quot;&quot;&quot;\n\n02 单变量线性回归根据这座城市的人口数量及该城市小吃店的利润，来预测开小吃店的利润。\n\n2.1 绘制数据\n读入数据：在此我们引入pandas库，该库可以帮助我们从诸如 csv 类型的文件导入数据，并且可以用它快速的对数据进行转换和过滤的操作。\n\nimport pandas as pdpath = &quot;machine-learning-ex1\\machine-learning-ex1\\ex1\\ex1data1.txt&quot;data = pd.read_csv(path,header=None,names=[&#x27;Population&#x27;,&#x27;Profit&#x27;])#header决定要不要原始的表头，name给出自定义的表头。print(data.head())#从头查询数据&quot;&quot;&quot;   population   profit0      6.1101  17.59201      5.5277   9.13022      8.5186  13.66203      7.0032  11.85404      5.8598   6.8233&quot;&quot;&quot;\n\n\n数据可视化：在此我们引入matplotlib.pyplot库，使用plot函数画图。\n\nimport matplotlib.pyplot as pltdata.plot(kind=&#x27;scatter&#x27;, x=&#x27;Population&#x27;, y=&#x27;Profit&#x27;, figsize=(12,8))#生成图形，kind‘指定所画图的类型，figsize 指定图片大小。plt.show()#显示图形\n\n\n2.2 梯度下降这部分需要使用梯度下降将线性回归参数 θ 拟合到数据集上。\n2.21 公式\n代价函数\n\n\n\n假设函数\n\n\n\n参数更新\n\n\n\n随着梯度下降不断地更新参数，参数也就越接近使代价函数最小的最优值\n\n2.22 实现\n我们要为我们之前读取的数据添加一列x，用来更新θ_0。\n\ndata.insert(0, &#x27;Ones&#x27;, 1) #相当于在第0列，添加一个表头名为Ones，并且该列均为1print(data.head())&quot;&quot;&quot;   Ones  Population   Profit0     1      6.1101  17.59201     1      5.5277   9.13022     1      8.5186  13.66203     1      7.0032  11.85404     1      5.8598   6.8233&quot;&quot;&quot;\n\n\n分割X和y。使用pandas的iloc来进行选择训练集X和目标y\n\n# 分割X和ylists = data.shape[1]#输出列数X = data.iloc[:,:-1]#X是第一列到最后一列，但不包括最后一列，因为 python的范围/切片不包括终点y = data.iloc[:,lists-1:lists]#最后一列#y = data.iloc[:,-1]#也是最后一列print(X.head())&quot;&quot;&quot;   Ones  Population0     1      6.11011     1      5.52772     1      8.51863     1      7.00324     1      5.8598&quot;&quot;&quot;print(y.head())&quot;&quot;&quot;    Profit0  17.59201   9.13022  13.66203  11.85404   6.8233&quot;&quot;&quot;\n\n\n我们还要将θ初始化为0，并将θ、X、y全部转化为矩阵\n\nX = np.matrix(X.values)y = np.matrix(y.values)theta = np.matrix(np.array([0,0]))print(X.shape)#(97, 2)print(y.shape)#(97, 1)print(theta.shape)#(1, 2)\n\n2.23 计算J(θ)\n计算代价函数来检测代价函数的收敛性。根据上面的公式我们写出代价函数。\n\ndef computeCost(X, y, theta):    inner = np.power((X * theta.T)-y,2)#数组元素求n次方    return np.sum(inner) / (2 * len(X))print(computeCost(X, y, theta)) #32.072733877455676\n\n2.24 梯度下降代价函数J(θ)的参数是由向量θ表示，假设你已经实现了梯度下降，如果计算正确，J(θ)的值不应该增加，而应该减小然后在算法结束时收敛到一个稳定值。\ndef gradientDescent(X, y, theta, alpha, iters):    temp = np.matrix(np.zeros(theta.shape))#创建0矩阵[[0. 0.]]    parameters = int(theta.ravel().shape[1]) #ravel()将多维数组转换为一维数组,.shape[1]是看列数为多少-2    cost = np.zeros(iters)#初始化代价函数数组    for i in range(iters):        error = (X * theta.T) - y        for j in range(parameters):            term = np.multiply(error, X[:, j])            temp[0, j] = theta[0, j] - ((alpha / len(X)) * np.sum(term))#更新参数        theta = temp        cost[i] = computeCost(X, y, theta)    return theta, costalpha = 0.01iters = 1500g, cost = gradientDescent(X, y, theta, alpha, iters)print(g)#[[-3.63029144  1.16636235]]predict1 = [1,3.5]*g.Tprint(predict1)#[[0.45197679]]predict2 = [1,7]*g.Tprint(predict2)#[[4.53424501]]\n\n2.3 调试\npython可视化：原始数据以及拟合的直线\n\n# 在指定的间隔内返回均匀间隔的数字：从data.Population的最小值到最大的范围内，等间距的返回100个样本x = np.linspace(data.Population.min(), data.Population.max(), 100)f = g[0, 0] + (g[0, 1] * x)#参数为最优值的直线fig, ax = plt.subplots(figsize=(12,8))#创建一个12*8的图即多维窗口ax.plot(x, f, &#x27;r&#x27;, label=&#x27;Prediction&#x27;) #定义x, y, 颜色，图例上显示的东西ax.scatter(data.Population, data.Profit, label=&#x27;Traning Data&#x27;)ax.legend(loc=2)#指定图例的位置ax.set_xlabel(&#x27;Population&#x27;)ax.set_ylabel(&#x27;Profit&#x27;)ax.set_title(&#x27;Predicted Profit vs. Population Size&#x27;)plt.show()\n\n\n03 多变量线性回归根据ex1data2.txt里的数据建立模型，预测房屋的价格，其中第一列是房屋大小，第二列是卧室数量，第三列是房屋售价\n\n\n第一步依旧是读入数据：\n\npath = &#x27;machine-learning-ex1\\machine-learning-ex1\\ex1\\ex1data2.txt&#x27;data2 = pd.read_csv(path,header = None,names=[&#x27;Size&#x27;, &#x27;Bedrooms&#x27;, &#x27;Price&#x27;])print(data2.head())&#x27;&#x27;&#x27; Size  Bedrooms   Price0  2104         3  3999001  1600         3  3299002  2400         3  3690003  1416         2  2320004  3000         4  539900&#x27;&#x27;&#x27;\n\n3.1 特征归一化特征缩放的目的只是为了运行更快。使特征值比较接近，使图像变得比较圆。以至于梯度下降的速度更快，收敛所需要的迭代次数更少，收敛更快。\n\n\nmean()函数功能：求取均值，std()函数是用来求标准差的（std &#x3D; sqrt(mean(abs(x - x.mean())**2))）。\n\ndata2 = (data2 - data2.mean()) / data2.std()print(data2.head())&#x27;&#x27;&#x27;      Size  Bedrooms     Price0  0.130010 -0.223675  0.4757471 -0.504190 -0.223675 -0.0840742  0.502476 -0.223675  0.2286263 -0.735723 -1.537767 -0.8670254  1.257476  1.090417  1.595389&#x27;&#x27;&#x27;\n\n3.2 梯度下降data2.insert(0, &#x27;Ones&#x27;, 1)cols = data2.shape[1]X2 = data2.iloc[:,0:cols-1]y2 = data2.iloc[:,cols-1:cols]X2 = np.matrix(X2.values)y2 = np.matrix(y2.values)theta2 = np.matrix(np.array([0,0,0]))g2, cost2 = gradientDescent(X2, y2, theta2, alpha, iters)print(g2)&#x27;&#x27;&#x27;[[-1.10898288e-16  8.84042349e-01 -5.24551809e-02]]&#x27;&#x27;&#x27;\n\n3.3 正规方程训练集特征矩阵为 X（包含了x_0&#x3D;1）训练集结果为向量 y，则利用正规方程解出向量:其中np.linalg.inv()：矩阵求逆。\n\ndef normalEqn(X, y):    theta = ((np.linalg.inv(X.T.dot(X))).dot(X.T)).dot(y)    # theta = np.linalg.inv(X.T@X)@X.T@y    return thetatheta2=normalEqn(X2, y2)print(theta2)&#x27;&#x27;&#x27;[[-7.11223170e-17] [ 8.84765988e-01] [-5.31788197e-02]] &#x27;&#x27;&#x27;\n\n04 代码总结import matplotlib.pyplot as pltimport numpy as npimport pandas as pdpath = &quot;machine-learning-ex1\\machine-learning-ex1\\ex1\\ex1data1.txt&quot;data = pd.read_csv(path,header=None,names=[&#x27;Population&#x27;,&#x27;Profit&#x27;])#header决定要不要原始的表头，name给出自定义的表头。#data.plot(kind=&#x27;scatter&#x27;, x=&#x27;Population&#x27;, y=&#x27;Profit&#x27;, figsize=(12,8))#生成图形，kind‘指定所画图的类型，figsize 指定图片大小。# plt.show()#显示图形#==============================================================================data.insert(0, &#x27;Ones&#x27;, 1) #相当于在第0列，添加一个表头名为Ones，并且该列均为1# 分割X和ylists = data.shape[1]#输出列数X = data.iloc[:,:-1]#X是第一列到最后一列，但不包括最后一列，因为 python的范围/切片不包括终点y = data.iloc[:,lists-1:lists]#最后一列#y = data.iloc[:,-1]#也是最后一列X = np.matrix(X.values)y = np.matrix(y.values)theta = np.matrix(np.array([0,0]))def computeCost(X, y, theta):    inner = np.power((X * theta.T)-y,2)#数组元素求n次方    return np.sum(inner) / (2 * len(X))# print(computeCost(X, y, theta)) #32.072733877455676#梯度下降算法如下：def gradientDescent(X, y, theta, alpha, iters):    temp = np.matrix(np.zeros(theta.shape))#创建0矩阵[[0. 0.]]    parameters = int(theta.ravel().shape[1]) #ravel()将多维数组转换为一维数组,.shape[1]是看列数为多少    cost = np.zeros(iters)    for i in range(iters):        error = (X * theta.T) - y        for j in range(parameters):            term = np.multiply(error, X[:, j])            temp[0, j] = theta[0, j] - ((alpha / len(X)) * np.sum(term))        theta = temp        cost[i] = computeCost(X, y, theta)    return theta, costalpha = 0.01iters = 1500g, cost = gradientDescent(X, y, theta, alpha, iters)#print(g)#[[-3.63029144  1.16636235]]predict1 = [1,3.5]*g.T#print(predict1)#[[0.45197679]]predict2 = [1,7]*g.T#print(predict2)#[[4.53424501]]# 在指定的间隔内返回均匀间隔的数字：从data.Population的最小值到最大的范围内，等间距的返回100个样本x = np.linspace(data.Population.min(), data.Population.max(), 100)f = g[0, 0] + (g[0, 1] * x)#参数为最优值的直线fig, ax = plt.subplots(figsize=(12,8))#创建一个12*8的图即多维窗口ax.plot(x, f, &#x27;r&#x27;, label=&#x27;Prediction&#x27;) #定义x, y, 颜色，图例上显示的东西ax.scatter(data.Population, data.Profit, label=&#x27;Traning Data&#x27;)ax.legend(loc=2)#指定图例的位置ax.set_xlabel(&#x27;Population&#x27;)ax.set_ylabel(&#x27;Profit&#x27;)ax.set_title(&#x27;Predicted Profit vs. Population Size&#x27;)#plt.show()#===========================================================================path = &#x27;machine-learning-ex1\\machine-learning-ex1\\ex1\\ex1data2.txt&#x27;data2 = pd.read_csv(path,header = None,names=[&#x27;Size&#x27;, &#x27;Bedrooms&#x27;, &#x27;Price&#x27;])data2 = (data2 - data2.mean()) / data2.std()data2.insert(0, &#x27;Ones&#x27;, 1)cols = data2.shape[1]X2 = data2.iloc[:,0:cols-1]y2 = data2.iloc[:,cols-1:cols]X2 = np.matrix(X2.values)y2 = np.matrix(y2.values)theta2 = np.matrix(np.array([0,0,0]))g2, cost2 = gradientDescent(X2, y2, theta2, alpha, iters)print(g2)def normalEqn(X, y):    theta = ((np.linalg.inv(X.T.dot(X))).dot(X.T)).dot(y)    # theta = np.linalg.inv(X.T@X)@X.T@y    return thetatheta2=normalEqn(X2, y2)print(theta2)\n","tags":["机器学习"]},{"title":"Ajax","url":"/2022/05/16/Ajax/","content":"1.简介\nAjax &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。\n\nAjax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。\n\nAjax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。\n\n在 2005 年，Google 通过其 Google Suggest 使 Ajax 变得流行起来。Google Suggest能够自动帮你完成搜索单词。\n\nGoogle Suggest 使用 Ajax 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。\n\n就和国内百度的搜索框一样!\n\n传统的网页(即不用Ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。\n\n使用Ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。\n\n使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。\n\n\n2.伪造Ajax我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签\n1、新建一个module ：sspringmvc-06-ajax ， 导入web支持！\n2、编写一个 ajax-frame.html 使用 iframe 测试，感受下效果\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;方&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;  window.onload = function f() &#123;      var myDate = new Date();      document.getElementById(&#x27;currentTime&#x27;).innerText = myDate.getTime();  &#125;;  function LoadPage()&#123;      var targetUrl = document.getElementById(&quot;url&quot;).value;      console.log(targetUrl);      document.getElementById(&quot;iframePosition&quot;).src = targetUrl;  &#125;&lt;/script&gt;&lt;div&gt;  &lt;p&gt;请输入要加载的地址：&lt;span id = &quot;currentTime&quot;&gt;&lt;/span&gt;&lt;/p&gt;  &lt;p&gt;    &lt;input id=&quot;url&quot; type=&quot;text&quot; value=&quot;https://www.baidu.com&quot;/&gt;    &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;LoadPage()&quot;&gt;  &lt;/p&gt;&lt;/div&gt;&lt;div&gt;  &lt;h3&gt;加载页面位置：&lt;/h3&gt;  &lt;iframe id=&quot;iframePosition&quot; style=&quot;width: 100%;height: 500px;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n利用AJAX可以做：\n\n注册时，输入用户名自动检测用户是否已经存在。\n登陆时，提示用户名密码错误\n删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。\n….等等\n\n3.jQuery.ajax\n纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！\nAjax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。\njQuery 提供多个与 Ajax有关的方法。\n通过 jQuery Ajax方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。\njQuery 不是生产者，而是大自然搬运工。\njQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！\n\njQuery.ajax(...)      部分参数：            url：请求地址            type：请求方式，GET、POST（1.9.0之后用method）        headers：请求头            data：要发送的数据    contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;)          async：是否异步        timeout：设置请求超时时间（毫秒）      beforeSend：发送请求前执行的函数(全局)        complete：完成之后执行的回调函数(全局)        success：成功之后执行的回调函数(全局)          error：失败之后执行的回调函数(全局)        accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型        dataType：将服务器端返回的数据转换成指定类型          &quot;xml&quot;: 将服务器端返回的内容转换成xml格式          &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式          &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。        &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式          &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象        &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数\n\n简单的测试使用最原始的HttpServletResponse处理 , .最简单 , 最通用\n1、配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;      xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/mvc       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;   &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;   &lt;context:component-scan base-package=&quot;com.fang.controller&quot;/&gt;   &lt;mvc:default-servlet-handler /&gt;   &lt;mvc:annotation-driven /&gt;   &lt;!-- 视图解析器 --&gt;   &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;         id=&quot;internalResourceViewResolver&quot;&gt;       &lt;!-- 前缀 --&gt;       &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;       &lt;!-- 后缀 --&gt;       &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;   &lt;/bean&gt;&lt;/beans&gt;\n\n2、编写一个AjaxController\n@Controllerpublic class AjaxController &#123;   @RequestMapping(&quot;/a1&quot;)   public void ajax1(String name , HttpServletResponse response) throws IOException &#123;       if (&quot;admin&quot;.equals(name))&#123;           response.getWriter().print(&quot;true&quot;);      &#125;else&#123;           response.getWriter().print(&quot;false&quot;);      &#125;  &#125;&#125;\n\n3、导入jquery ， 可以使用在线的CDN ， 也可以下载导入\n&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;\n\n4、编写index.jsp测试\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt;   &lt;title&gt;$Title$&lt;/title&gt;  &lt;%--&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;--%&gt;   &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;   &lt;script&gt;       function a1()&#123;           $.post(&#123;               url:&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;,               data:&#123;&#x27;name&#x27;:$(&quot;#txtName&quot;).val()&#125;,               success:function (data,status) &#123;                   alert(data);                   alert(status);              &#125;          &#125;);      &#125;   &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;%--onblur：失去焦点触发事件--%&gt;用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; onblur=&quot;a1()&quot;/&gt; &lt;/body&gt;&lt;/html&gt;\n\n5、启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！\nSpringmvc实现实体类user\n@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123;   private String name;   private int age;   private String sex;&#125;\n\n我们来获取一个集合对象，展示到前端页面\n@RequestMapping(&quot;/a2&quot;)public List&lt;User&gt; ajax2()&#123;   List&lt;User&gt; list = new ArrayList&lt;User&gt;();   list.add(new User(&quot;秦疆1号&quot;,3,&quot;男&quot;));   list.add(new User(&quot;秦疆2号&quot;,3,&quot;男&quot;));   list.add(new User(&quot;秦疆3号&quot;,3,&quot;男&quot;));   return list; //由于@RestController注解，将list转成json格式返回&#125;\n\n前端页面\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;   &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;获取数据&quot;/&gt;&lt;table width=&quot;80%&quot; align=&quot;center&quot;&gt;   &lt;tr&gt;       &lt;td&gt;姓名&lt;/td&gt;       &lt;td&gt;年龄&lt;/td&gt;       &lt;td&gt;性别&lt;/td&gt;   &lt;/tr&gt;   &lt;tbody id=&quot;content&quot;&gt;   &lt;/tbody&gt;&lt;/table&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;   $(function () &#123;       $(&quot;#btn&quot;).click(function () &#123;           $.post(&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;,function (data) &#123;               console.log(data)               var html=&quot;&quot;;               for (var i = 0; i &lt;data.length ; i++) &#123;                   html+= &quot;&lt;tr&gt;&quot; +                       &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;/td&gt;&quot; +                       &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;/td&gt;&quot; +                       &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;/td&gt;&quot; +                       &quot;&lt;/tr&gt;&quot;              &#125;               $(&quot;#content&quot;).html(html);          &#125;);      &#125;)  &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n注册提示效果我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化\n我们写一个Controller\n@RequestMapping(&quot;/a3&quot;)public String ajax3(String name,String pwd)&#123;   String msg = &quot;&quot;;   //模拟数据库中存在数据   if (name!=null)&#123;       if (&quot;admin&quot;.equals(name))&#123;           msg = &quot;OK&quot;;      &#125;else &#123;           msg = &quot;用户名输入错误&quot;;      &#125;  &#125;   if (pwd!=null)&#123;       if (&quot;123456&quot;.equals(pwd))&#123;           msg = &quot;OK&quot;;      &#125;else &#123;           msg = &quot;密码输入有误&quot;;      &#125;  &#125;   return msg; //由于@RestController注解，将msg转成json格式返回&#125;\n\n前端页面 login.jsp\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;   &lt;title&gt;ajax&lt;/title&gt;   &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;   &lt;script&gt;       function a1()&#123;           $.post(&#123;               url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,               data:&#123;&#x27;name&#x27;:$(&quot;#name&quot;).val()&#125;,               success:function (data) &#123;                   if (data.toString()==&#x27;OK&#x27;)&#123;                       $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);                  &#125;else &#123;                       $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);                  &#125;                   $(&quot;#userInfo&quot;).html(data);              &#125;          &#125;);      &#125;       function a2()&#123;           $.post(&#123;               url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,               data:&#123;&#x27;pwd&#x27;:$(&quot;#pwd&quot;).val()&#125;,               success:function (data) &#123;                   if (data.toString()==&#x27;OK&#x27;)&#123;                       $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);                  &#125;else &#123;                       $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);                  &#125;                   $(&quot;#pwdInfo&quot;).html(data);              &#125;          &#125;);      &#125;   &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;  用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot; onblur=&quot;a1()&quot;/&gt;   &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  密码:&lt;input type=&quot;text&quot; id=&quot;pwd&quot; onblur=&quot;a2()&quot;/&gt;   &lt;span id=&quot;pwdInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\nAjax 总结：使用jQuery需要导入JQuery，使用Vue就导入Vue，两个都用，自己原生态实现\n\n三步曲：\n1.编写对应处理的Controller,返回消息或者字符串汇总json格式的数据\n2.编写ajax请求\n\nurl: Controller 请求\ndata： 键值对\nsuccess: 回调函数\n\n3.给Ajax绑定事件，点击click，失去焦点onblur,键盘弹起keyUp\n","tags":["Ajaxj"]},{"title":"Anylogic之SpringBoot整合Ecahrts动态图表","url":"/2022/06/04/Anylogic%E4%B9%8BSpringBoot%E6%95%B4%E5%90%88Ecahrts%E5%8A%A8%E6%80%81%E5%9B%BE%E8%A1%A8/","content":"1、数据库建立SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for echarts-- ----------------------------DROP TABLE IF EXISTS `echarts`;CREATE TABLE `echarts`  (  `id` bigint(20) NOT NULL AUTO_INCREMENT,  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,  `count` int(11) NULL DEFAULT NULL,  `date` datetime NULL DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of echarts-- ----------------------------INSERT INTO `echarts` VALUES (1, &#x27;搜索引擎&#x27;, 158, &#x27;2021-05-10 16:38:55&#x27;);INSERT INTO `echarts` VALUES (2, &#x27;直接访问&#x27;, 289, &#x27;2021-05-11 16:38:55&#x27;);INSERT INTO `echarts` VALUES (3, &#x27;邮件营销&#x27;, 384, &#x27;2021-05-12 16:38:55&#x27;);INSERT INTO `echarts` VALUES (4, &#x27;联盟广告&#x27;, 520, &#x27;2021-05-13 16:38:55&#x27;);INSERT INTO `echarts` VALUES (5, &#x27;视频广告&#x27;, 674, &#x27;2021-05-14 16:38:55&#x27;);SET FOREIGN_KEY_CHECKS = 1;\n\n2、后端设计1.引入依赖pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.example&lt;/groupId&gt;    &lt;artifactId&gt;echarts&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;    &lt;/parent&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;mybatis-plus.version&gt;3.2.0&lt;/mybatis-plus.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!--添加Springmvc依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- mybatis-plus --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;            &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;            &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 数据连接池 druid--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.2.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mysql--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;            &lt;version&gt;5.5.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;fork&gt;true&lt;/fork&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;    &lt;repositories&gt;        &lt;repository&gt;            &lt;id&gt;public&lt;/id&gt;            &lt;name&gt;aliyun nexus&lt;/name&gt;            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;            &lt;releases&gt;                &lt;enabled&gt;true&lt;/enabled&gt;            &lt;/releases&gt;        &lt;/repository&gt;    &lt;/repositories&gt;    &lt;pluginRepositories&gt;        &lt;pluginRepository&gt;            &lt;id&gt;public&lt;/id&gt;            &lt;name&gt;aliyun nexus&lt;/name&gt;            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;            &lt;releases&gt;                &lt;enabled&gt;true&lt;/enabled&gt;            &lt;/releases&gt;            &lt;snapshots&gt;                &lt;enabled&gt;false&lt;/enabled&gt;            &lt;/snapshots&gt;        &lt;/pluginRepository&gt;    &lt;/pluginRepositories&gt;&lt;/project&gt;\n\n2、创建配置文件application.ymlserver:  port: 1234spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    username: root    password: 123456    url: jdbc:mysql://localhost:3306/echarts?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=GMT%2b8    type: com.alibaba.druid.pool.DruidDataSourcelogging:  level:    com:      example:        debug\n\n3、创建启动项App.javapackage com.example;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@MapperScan(&quot;com/example/mapper&quot;)@SpringBootApplicationpublic class App &#123;    public static void main(String[] args) &#123;        SpringApplication.run(App.class,args);        System.out.println(&quot;页面的访问地址：http://localhost:1234/&quot;);    &#125;&#125;\n\n4、创建一个实体类Echarts.javapackage com.example.entity;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import com.fasterxml.jackson.annotation.JsonFormat;import lombok.Data;import java.util.Date;@Data@TableName(&quot;echarts&quot;)public class Echarts &#123;    @TableId(value = &quot;id&quot;, type = IdType.AUTO)    private Long id;    private String name;    private Integer count;    @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;, timezone = &quot;GMT+8&quot;)    private Date date;&#125;\n\n5、创建一个接口EchartsMapper.javapackage com.example.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.example.entity.Echarts;public interface EchartsMapper extends BaseMapper&lt;Echarts&gt; &#123;&#125;\n\n6、写一个控制类EchartsController.javapackage com.example.controller;import com.baomidou.mybatisplus.core.toolkit.Wrappers;import com.example.mapper.EchartsMapper;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@RestController@RequestMapping(&quot;/echarts&quot;)public class EchartsController &#123;    @Resource    private EchartsMapper echartsMapper;    @GetMapping    public Object echarts() &#123;        // 查询数据库 echarts表的所有数据        return echartsMapper.selectList(Wrappers.lambdaQuery());    &#125;&#125;\n\n3、前端&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot;          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;pie&quot; style=&quot;width: 1000px; height: 800px&quot;&gt;&lt;/div&gt;    &lt;div style=&quot;height: 50px&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;line&quot; style=&quot;width: 1000px; height: 800px&quot;&gt;&lt;/div&gt;    &lt;div style=&quot;height: 50px&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;bar&quot; style=&quot;width: 1000px; height: 800px&quot;&gt;&lt;/div&gt;\t&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/echarts/5.1.0/echarts.min.js&quot;&gt;&lt;/script&gt;\t&lt;script&gt;       const option = &#123;           title: &#123;               text: &#x27;饼图示例&#x27;,               subtext: &#x27;纯属虚构&#x27;,               left: &#x27;left&#x27;           &#125;,            legend: &#123;                top: &#x27;top&#x27;            &#125;,           tooltip: &#123;               trigger: &#x27;item&#x27;           &#125;,            toolbox: &#123;                show: true,                feature: &#123;                    mark: &#123;show: true&#125;,                    dataView: &#123;show: true, readOnly: false&#125;,                    restore: &#123;show: true&#125;,                    saveAsImage: &#123;show: true&#125;                &#125;            &#125;,            series: [                &#123;                    name: &#x27;面积模式&#x27;,                    type: &#x27;pie&#x27;,                    radius: [50, 250],                    center: [&#x27;50%&#x27;, &#x27;50%&#x27;],                    roseType: &#x27;area&#x27;,                    itemStyle: &#123;                        borderRadius: 8                    &#125;,                    data: [                    ]                &#125;            ]        &#125;;       lineOption = &#123;           title: &#123;               text: &#x27;折线图堆叠&#x27;           &#125;,           legend: &#123;               top: &#x27;top&#x27;           &#125;,           tooltip: &#123;               trigger: &#x27;axis&#x27;           &#125;,           xAxis: &#123;               type: &#x27;category&#x27;,               data: []           &#125;,           yAxis: &#123;               type: &#x27;value&#x27;           &#125;,           series: [&#123;               name: &#x27;11&#x27;,               data: [],               type: &#x27;line&#x27;           &#125;,               &#123;                   name: &#x27;22&#x27;,                   data: [111,222,333,444,0],                   type: &#x27;line&#x27;               &#125;           ]       &#125;;       barOption = &#123;           title: &#123;               text: &#x27;柱状图&#x27;           &#125;,           legend: &#123;               top: &#x27;top&#x27;           &#125;,           tooltip: &#123;               trigger: &#x27;axis&#x27;           &#125;,           xAxis: &#123;               type: &#x27;category&#x27;,               data: []           &#125;,           yAxis: &#123;               type: &#x27;value&#x27;           &#125;,           series: [&#123;               name: &#x27;11&#x27;,               data: [],               type: &#x27;bar&#x27;           &#125;,               &#123;                   name: &#x27;22&#x27;,                   data: [111,222,333,444,0],                   type: &#x27;bar&#x27;               &#125;           ]       &#125;;       var chartDom = document.getElementById(&#x27;pie&#x27;);       var myChart = echarts.init(chartDom);       var lineDom = document.getElementById(&#x27;line&#x27;);       var lineChart = echarts.init(lineDom);       var barDom = document.getElementById(&#x27;bar&#x27;);       var barChart = echarts.init(barDom);       fetch(&quot;/echarts&quot;).then(response=&gt;response.json()).then(res=&gt;&#123;           // 折线图           const date = res.map(v =&gt; v.date);           console.log(date)           lineOption.xAxis.data = date           const count = res.map(v =&gt; v.count);           console.log(count)           lineOption.series[0].data = count           lineChart.setOption(lineOption)           // 柱状图           console.log(date)           barOption.xAxis.data = date           console.log(count)           barOption.series[0].data = count           barChart.setOption(barOption)           // 饼图           res.forEach(item =&gt; &#123;               option.series[0].data.push(&#123;name: item.name, value: item.count&#125;)           &#125;)           console.log(option)           myChart.setOption(option);       &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n","tags":["Anylogic"]},{"title":"Anylogic之UDP实现数据可视化","url":"/2022/06/09/Anylogic%E4%B9%8BUDP%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","content":"1、创建Servlet\n配置java8和tomcat8.5，记得要引入tomcat的servlet-api库\n\n因为我们要做六个表所以创建六个Servlet，具体如下：\n\n\n1.SelectBarServletpackage servlet;import java.io.IOException;import java.io.PrintWriter;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import net.sf.json.JSONObject;/** * Servlet implementation class SelectBarServlet */public class SelectBarServlet extends HttpServlet &#123;   private static final long serialVersionUID = 1L;           /**     * @see HttpServlet#HttpServlet()     */    public SelectBarServlet() &#123;        super();        // TODO Auto-generated constructor stub    &#125;   /**    * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)    */    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;      // TODO Auto-generated method stub      doPost(request, response);   &#125;   /**    * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)    */    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;      JSONObject json =new JSONObject();//JSON格式的数据结构      //json.put(&quot;result&quot;,&quot; success&quot;);      String str = Receive();      System.out.println(str);      //从其它对象转化成JSON对象      json = JSONObject.fromObject(str);      response.setCharacterEncoding(&quot;utf-8&quot;);      response.setContentType(&quot;application/json;charset=utf-8&quot;);      PrintWriter out = null;      out = response.getWriter();      //out.write(json.toString());       System.out.println(json);      out.println(json);        out.flush();        out.close();         &#125;      public static String Receive() &#123;      //它的唯一作用就是接收和发送数据报      DatagramSocket ds = null;      try &#123;         ds = new DatagramSocket(1235);//创建一个DatagramSocket能够在UDP端口1235接收广播。      &#125; catch (SocketException e) &#123;         // TODO Auto-generated catch block         e.printStackTrace();      &#125;      while(true) &#123;         // 创建包对象         byte[] bys = new byte[1024];         //这类表示一个数据报包,接收数据包长度 length DatagramPacket构建。         DatagramPacket dp = new DatagramPacket(bys, bys.length);         // 接收数据         try &#123;            ds.receive(dp);         &#125; catch (IOException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();         &#125;         // 解析数据         InetAddress address = dp.getAddress();// 获取发送端的IP对象         byte[] data = dp.getData();// 获取接收到的数据         int length = dp.getLength();// 获取具体收到数据的长度                           String str = new String(data);                        System.out.println(str);         ds.close();           return str;      // 释放资源                  &#125;   &#125;&#125;\n\n2.SelectBar1Servletpackage servlet;import java.io.IOException;import java.io.PrintWriter;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import net.sf.json.JSONObject;/** * Servlet implementation class SelectBar1Servlet */public class SelectBar1Servlet extends HttpServlet &#123;   private static final long serialVersionUID = 1L;           /**     * @see HttpServlet#HttpServlet()     */    public SelectBar1Servlet() &#123;        super();        // TODO Auto-generated constructor stub    &#125;   /**    * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)    */   protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;      // TODO Auto-generated method stub      doPost(request, response);   &#125;   /**    * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)    */   protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;      JSONObject json =new JSONObject();      //json.put(&quot;result&quot;,&quot; success&quot;);      String str = Receive();      System.out.println(str);      json = JSONObject.fromObject(str);      response.setCharacterEncoding(&quot;utf-8&quot;);      response.setContentType(&quot;application/json;charset=utf-8&quot;);      PrintWriter out = null;      out = response.getWriter();      //out.write(json.toString());       System.out.println(json);      out.println(json);        out.flush();        out.close();         &#125;   public static String Receive() &#123;      DatagramSocket ds = null;      try &#123;         ds = new DatagramSocket(1456);      &#125; catch (SocketException e) &#123;         // TODO Auto-generated catch block         e.printStackTrace();      &#125;      while(true) &#123;         // 创建包对象         byte[] bys = new byte[1024];         DatagramPacket dp = new DatagramPacket(bys, bys.length);         // 接收数据         try &#123;            ds.receive(dp);         &#125; catch (IOException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();         &#125;         // 解析数据         InetAddress address = dp.getAddress();// 获取发送端的IP对象         byte[] data = dp.getData();// 获取接收到的数据         int length = dp.getLength();// 获取具体收到数据的长度                           String str = new String(data);                        System.out.println(str);         ds.close();           return str;      // 释放资源                  &#125;   &#125;&#125;\n\n3.SelectLineServletpackage servlet;import java.io.IOException;import java.io.PrintWriter;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import net.sf.json.JSONObject;/** * Servlet implementation class SelectLineServlet */public class SelectLineServlet extends HttpServlet &#123;   private static final long serialVersionUID = 1L;           /**     * @see HttpServlet#HttpServlet()     */    public SelectLineServlet() &#123;        super();        // TODO Auto-generated constructor stub    &#125;   /**    * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)    */   protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;      // TODO Auto-generated method stub      doPost(request, response);   &#125;   /**    * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)    */   protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;      // TODO Auto-generated method stub      JSONObject json =new JSONObject();      //json.put(&quot;result&quot;,&quot; success&quot;);      String str = Receive();      System.out.println(str);      json = JSONObject.fromObject(str);      response.setCharacterEncoding(&quot;utf-8&quot;);      response.setContentType(&quot;application/json;charset=utf-8&quot;);      PrintWriter out = null;      out = response.getWriter();      //out.write(json.toString());       System.out.println(json);      out.println(json);        out.flush();        out.close();   &#125;   public static String Receive() &#123;      DatagramSocket ds = null;      try &#123;         ds = new DatagramSocket(1237);      &#125; catch (SocketException e) &#123;         // TODO Auto-generated catch block         e.printStackTrace();      &#125;      while(true) &#123;         // 创建包对象         byte[] bys = new byte[1024];         DatagramPacket dp = new DatagramPacket(bys, bys.length);         // 接收数据         try &#123;            ds.receive(dp);         &#125; catch (IOException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();         &#125;         // 解析数据         InetAddress address = dp.getAddress();// 获取发送端的IP对象         byte[] data = dp.getData();// 获取接收到的数据         int length = dp.getLength();// 获取具体收到数据的长度                           String str = new String(data);                        System.out.println(str);         ds.close();           return str;      // 释放资源                  &#125;   &#125;&#125;\n\n4.SelectLine1Servletpackage servlet;import java.io.IOException;import java.io.PrintWriter;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import net.sf.json.JSONObject;/** * Servlet implementation class SelectLine2Servlet */public class SelectLine1Servlet extends HttpServlet &#123;   private static final long serialVersionUID = 1L;           /**     * @see HttpServlet#HttpServlet()     */    public SelectLine1Servlet() &#123;        super();        // TODO Auto-generated constructor stub    &#125;   /**    * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)    */   protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;      // TODO Auto-generated method stub      doPost(request, response);   &#125;   /**    * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)    */   protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;      // TODO Auto-generated method stub      JSONObject json =new JSONObject();      //json.put(&quot;result&quot;,&quot; success&quot;);      String str = Receive();      System.out.println(str);      json = JSONObject.fromObject(str);      response.setCharacterEncoding(&quot;utf-8&quot;);      response.setContentType(&quot;application/json;charset=utf-8&quot;);      PrintWriter out = null;      out = response.getWriter();      //out.write(json.toString());       System.out.println(json);      out.println(json);        out.flush();        out.close();   &#125;   public static String Receive() &#123;      DatagramSocket ds = null;      try &#123;         ds = new DatagramSocket(1239);      &#125; catch (SocketException e) &#123;         // TODO Auto-generated catch block         e.printStackTrace();      &#125;      while(true) &#123;         // 创建包对象         byte[] bys = new byte[1024];         DatagramPacket dp = new DatagramPacket(bys, bys.length);         // 接收数据         try &#123;            ds.receive(dp);         &#125; catch (IOException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();         &#125;         // 解析数据         InetAddress address = dp.getAddress();// 获取发送端的IP对象         byte[] data = dp.getData();// 获取接收到的数据         int length = dp.getLength();// 获取具体收到数据的长度                           String str = new String(data);                        System.out.println(str);         ds.close();           return str;      // 释放资源                  &#125;   &#125;&#125;\n\n5.SelectPieServletpackage servlet;import java.io.IOException;import java.io.PrintWriter;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import net.sf.json.JSONObject;/** * Servlet implementation class SelectPieServlet */public class SelectPieServlet extends HttpServlet &#123;   private static final long serialVersionUID = 1L;           /**     * @see HttpServlet#HttpServlet()     */    public SelectPieServlet() &#123;        super();        // TODO Auto-generated constructor stub    &#125;   /**    * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)    */   protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;      // TODO Auto-generated method stub      doPost(request, response);   &#125;   /**    * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)    */   protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;      JSONObject json =new JSONObject();      //json.put(&quot;result&quot;,&quot; success&quot;);      String str = Receive();      System.out.println(str);      json = JSONObject.fromObject(str);      response.setCharacterEncoding(&quot;utf-8&quot;);      response.setContentType(&quot;application/json;charset=utf-8&quot;);      PrintWriter out = null;      out = response.getWriter();      //out.write(json.toString());       System.out.println(json);      out.println(json);        out.flush();        out.close();   &#125;   public static String Receive() &#123;      DatagramSocket ds = null;      try &#123;         ds = new DatagramSocket(1236);      &#125; catch (SocketException e) &#123;         // TODO Auto-generated catch block         e.printStackTrace();      &#125;      while(true) &#123;         // 创建包对象         byte[] bys = new byte[1024];         DatagramPacket dp = new DatagramPacket(bys, bys.length);         // 接收数据         try &#123;            ds.receive(dp);         &#125; catch (IOException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();         &#125;         // 解析数据         InetAddress address = dp.getAddress();// 获取发送端的IP对象         byte[] data = dp.getData();// 获取接收到的数据         int length = dp.getLength();// 获取具体收到数据的长度                           String str = new String(data);                        System.out.println(str);         ds.close();           return str;      // 释放资源                  &#125;   &#125;&#125;\n\n6.SelectPie1Servletpackage servlet;import java.io.IOException;import java.io.PrintWriter;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import net.sf.json.JSONObject;/** * Servlet implementation class SelectPie1Servlet */public class SelectPie1Servlet extends HttpServlet &#123;   private static final long serialVersionUID = 1L;           /**     * @see HttpServlet#HttpServlet()     */    public SelectPie1Servlet() &#123;        super();        // TODO Auto-generated constructor stub    &#125;   /**    * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)    */   protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;      // TODO Auto-generated method stub      doPost(request, response);   &#125;   /**    * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)    */   protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;      // TODO Auto-generated method stub      JSONObject json =new JSONObject();      //json.put(&quot;result&quot;,&quot; success&quot;);      String str = Receive();      System.out.println(str);      json = JSONObject.fromObject(str);      response.setCharacterEncoding(&quot;utf-8&quot;);      response.setContentType(&quot;application/json;charset=utf-8&quot;);      PrintWriter out = null;      out = response.getWriter();      //out.write(json.toString());       System.out.println(json);      out.println(json);        out.flush();        out.close();   &#125;   public static String Receive() &#123;      DatagramSocket ds = null;      try &#123;         ds = new DatagramSocket(1238);      &#125; catch (SocketException e) &#123;         // TODO Auto-generated catch block         e.printStackTrace();      &#125;      while(true) &#123;         // 创建包对象         byte[] bys = new byte[1024];         DatagramPacket dp = new DatagramPacket(bys, bys.length);         // 接收数据         try &#123;            ds.receive(dp);         &#125; catch (IOException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();         &#125;         // 解析数据         InetAddress address = dp.getAddress();// 获取发送端的IP对象         byte[] data = dp.getData();// 获取接收到的数据         int length = dp.getLength();// 获取具体收到数据的长度                           String str = new String(data);                        System.out.println(str);         ds.close();           return str;      // 释放资源                  &#125;   &#125;&#125;\n\n2、前端&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge，chrome=1&quot;&gt;    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.css&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/index.css&quot;/&gt;    &lt;script src=&quot;assets/js/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;assets/js/echarts.min.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;assets/js/map/shanghai.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    &lt;!--头部--&gt;    &lt;div class=&quot;header&quot;&gt;        上海项目使用        &lt;a href=&quot;javascript:;&quot; class=&quot;a-access&quot;&gt;        &lt;/a&gt;    &lt;/div&gt;    &lt;!--主体--&gt;    &lt;div class=&quot;main clearfix&quot;&gt;        &lt;div class=&quot;main-left&quot;&gt;            &lt;div class=&quot;border-container&quot;&gt;                &lt;div class=&quot;name-title&quot;&gt;                    ===                &lt;/div&gt;                &lt;div id=&quot;graduateyear&quot;&gt;&lt;/div&gt;                &lt;ul class=&quot;three-pie clearfix&quot;&gt;                    &lt;div id=&quot;sexrate&quot;&gt;&lt;/div&gt;                    &lt;span class=&quot;top-left border-span&quot;&gt;&lt;/span&gt;                    &lt;span class=&quot;top-right border-span&quot;&gt;&lt;/span&gt;                    &lt;span class=&quot;bottom-left border-span&quot;&gt;&lt;/span&gt;                    &lt;span class=&quot;bottom-right border-span&quot;&gt;&lt;/span&gt;                &lt;/ul&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;main-middle&quot;&gt;            &lt;div class=&quot;border-container&quot;&gt;                &lt;ul class=&quot;teacher-pie clearfix&quot;&gt;                    &lt;li&gt;                        &lt;div class=&quot;name-title&quot;&gt;                            =======                        &lt;/div&gt;                        &lt;div id=&quot;courserate&quot;&gt;&lt;/div&gt;                    &lt;/li&gt;                    &lt;li&gt;                        &lt;div class=&quot;name-title&quot;&gt;                            =======                        &lt;/div&gt;                        &lt;div id=&quot;professionrate&quot;&gt;&lt;/div&gt;                    &lt;/li&gt;                &lt;/ul&gt;                &lt;div class=&quot;name-title&quot;&gt;                    ===                &lt;/div&gt;                &lt;div id=&quot;mapadd&quot;&gt;                &lt;/div&gt;                &lt;span class=&quot;top-left border-span&quot;&gt;&lt;/span&gt;                &lt;span class=&quot;top-right border-span&quot;&gt;&lt;/span&gt;                &lt;span class=&quot;bottom-left border-span&quot;&gt;&lt;/span&gt;                &lt;span class=&quot;bottom-right border-span&quot;&gt;&lt;/span&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;main-right&quot;&gt;            &lt;div class=&quot;border-container&quot;&gt;                &lt;div class=&quot;name-title&quot;&gt;                    ===                &lt;/div&gt;                &lt;div id=&quot;juniorservice&quot;&gt;&lt;/div&gt;                &lt;span class=&quot;top-left border-span&quot;&gt;&lt;/span&gt;                &lt;span class=&quot;top-right border-span&quot;&gt;&lt;/span&gt;                &lt;span class=&quot;bottom-left border-span&quot;&gt;&lt;/span&gt;                &lt;span class=&quot;bottom-right border-span&quot;&gt;&lt;/span&gt;            &lt;/div&gt;            &lt;div class=&quot;border-container&quot;&gt;                &lt;div class=&quot;name-title&quot;&gt;                    ===                &lt;/div&gt;                &lt;div id=&quot;edubalance&quot;&gt;&lt;/div&gt;                &lt;span class=&quot;top-left border-span&quot;&gt;&lt;/span&gt;                &lt;span class=&quot;top-right border-span&quot;&gt;&lt;/span&gt;                &lt;span class=&quot;bottom-left border-span&quot;&gt;&lt;/span&gt;                &lt;span class=&quot;bottom-right border-span&quot;&gt;&lt;/span&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var myLine = echarts.init(document.getElementById(&#x27;graduateyear&#x27;));    myLine.setOption(&#123;        color:[&#x27;#7de494&#x27;,&#x27;#7fd7b1&#x27;, &#x27;#5578cf&#x27;, &#x27;#5ebbeb&#x27;, &#x27;#d16ad8&#x27;,&#x27;#f8e19a&#x27;,  &#x27;#00b7ee&#x27;, &#x27;#81dabe&#x27;,&#x27;#5fc5ce&#x27;],        backgroundColor: &#x27;rgba(1,202,217,.2)&#x27;,        grid: &#123;            left:30,            right:40,            top:30,            bottom:20,            containLabel: true        &#125;,        toolbox: &#123;            feature: &#123;                saveAsImage: &#123;&#125;            &#125;        &#125;,        xAxis: &#123;            type: &#x27;category&#x27;,            boundaryGap: false,            axisLine:&#123;                lineStyle:&#123;                    color:&#x27;rgba(255,255,255,.2)&#x27;                &#125;            &#125;,            splitLine:&#123;                lineStyle:&#123;                    color:&#x27;rgba(255,255,255,.1)&#x27;                &#125;            &#125;,            axisLabel:&#123;                color:&quot;rgba(255,255,255,.7)&quot;            &#125;,            data: [&#x27;手术室&#x27;,&#x27;x光室&#x27;,&#x27;抗休克室&#x27;,&#x27;化验室&#x27;]        &#125;,        yAxis: &#123;            type: &#x27;value&#x27;,            axisLine:&#123;                lineStyle:&#123;                    color:&#x27;rgba(255,255,255,.2)&#x27;                &#125;            &#125;,            splitLine:&#123;                lineStyle:&#123;                    color:&#x27;rgba(255,255,255,.1)&#x27;                &#125;            &#125;,            axisLabel:&#123;                color:&quot;rgba(255,255,255,.7)&quot;            &#125;,        &#125;,        series: [            &#123;                name:&#x27;2014年&#x27;,                type:&#x27;line&#x27;,                stack: &#x27;总量&#x27;,                areaStyle: &#123;normal: &#123;&#125;&#125;,                data:[14,58,26,78]            &#125;        ]    &#125;);&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var myPie1 = echarts.init(document.getElementById(&#x27;sexrate&#x27;));    myPie1.setOption(&#123;        color:[&#x27;#00b7ee&#x27;,&#x27;#f8e19a&#x27;, &#x27;#f19ec2&#x27;, &#x27;#5ebbeb&#x27;, &#x27;#d16ad8&#x27;,&#x27;#f8e19a&#x27;,  &#x27;#00b7ee&#x27;, &#x27;#81dabe&#x27;,&#x27;#5fc5ce&#x27;],        backgroundColor: &#x27;rgba(1,202,217,.2)&#x27;,        grid: &#123;            left:20,            right:20,            top:0,            bottom:20        &#125;,        legend: &#123;            top:10,            textStyle:&#123;                fontSize: 10,                color:&#x27;rgba(255,255,255,.7)&#x27;            &#125;,            data:[]        &#125;,        series : [            &#123;                name: &#x27;访问来源&#x27;,                type: &#x27;pie&#x27;,                radius : &#x27;55%&#x27;,                center: [&#x27;50%&#x27;, &#x27;55%&#x27;],                data:&#123;&#125;,                itemStyle: &#123;                    emphasis: &#123;                        shadowBlur: 10,                        shadowOffsetX: 0,                        shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27;                    &#125;                &#125;            &#125;        ]    &#125;);    window.setInterval(function () &#123;        //\tmyPie.showLoading(); //数据加载完之前先显示一段简单的loading动画        // var namep=[];        //var arrp = [];        $.ajax(&#123;            type : &quot;post&quot;,            async : true, //异步请求（同步请求将会锁住浏览器，用户其他操作必须等待请求完成才可以执行）            url : &quot;/WeiQin/SelectPieServlet&quot;, //请求发送到Controller处，路径我上面写好了的，直接拼的，你自己按照你的写            data : &#123;&#125;,            dataType : &quot;json&quot;, //返回数据形式为json            success : function(result) &#123;                //请求成功时执行该函数内容，result即为服务器返回的json对象                console.log(result);                myPie1.hideLoading(); //隐藏加载动画                myPie1.setOption(&#123; //加载数据图表                    color:[&#x27;#00b7ee&#x27;,&#x27;#f8e19a&#x27;, &#x27;#f19ec2&#x27;, &#x27;#5ebbeb&#x27;, &#x27;#d16ad8&#x27;,&#x27;#f8e19a&#x27;,  &#x27;#00b7ee&#x27;, &#x27;#81dabe&#x27;,&#x27;#5fc5ce&#x27;],                    backgroundColor: &#x27;rgba(1,202,217,.2)&#x27;,                    grid: &#123;                        left:20,                        right:20,                        top:0,                        bottom:20                    &#125;,                    legend: &#123;                        top:10,                        textStyle:&#123;                            fontSize: 10,                            color:&#x27;rgba(255,255,255,.7)&#x27;                        &#125;,                        data:[&#x27;手术室&#x27;,&#x27;x光室&#x27;,&#x27;抗休克室&#x27;,&#x27;化验室&#x27;]                    &#125;,                    series : [                        &#123;                            name: &#x27;访问来源&#x27;,                            type: &#x27;pie&#x27;,                            radius : &#x27;55%&#x27;,                            center: [&#x27;50%&#x27;, &#x27;55%&#x27;],                            data:[                                &#123;value:result.手术室, name:&#x27;手术室&#x27;&#125;,                                &#123;value:result.x光室, name:&#x27;x光室&#x27;&#125;,                                &#123;value:result.抗休克室, name:&#x27;抗休克室&#x27;&#125;,                                &#123;value:result.化验室, name:&#x27;化验室&#x27;&#125;                            ],                            itemStyle: &#123;                                emphasis: &#123;                                    shadowBlur: 10,                                    shadowOffsetX: 0,                                    shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27;                                &#125;                            &#125;                        &#125;                    ]                &#125;);            &#125;,            error : function(errorMsg) &#123;                //请求失败时执行该函数                //alert(&quot;图表请求数据失败!&quot;);                myPie1.hideLoading();            &#125;        &#125;)    &#125;,5000);&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var myBar1 = echarts.init(document.getElementById(&#x27;courserate&#x27;));    myBar1.setOption(&#123;        color: [&#x27;#3398DB&#x27;],        tooltip: &#123;            trigger: &#x27;axis&#x27;,            axisPointer: &#123;            // 坐标轴指示器，坐标轴触发有效                type: &#x27;shadow&#x27;        // 默认为直线，可选为：&#x27;line&#x27; | &#x27;shadow&#x27;            &#125;        &#125;,        grid: &#123;            left: &#x27;3%&#x27;,            right: &#x27;4%&#x27;,            bottom: &#x27;3%&#x27;,            containLabel: true        &#125;,        xAxis: [            &#123;                type: &#x27;category&#x27;,                data: [],                axisTick: &#123;                    alignWithLabel: true                &#125;            &#125;        ],        yAxis:[            &#123;                axisLine:&#123;                    lineStyle:&#123;                        color:&#x27;rgba(255,255,255)&#x27;                    &#125;                &#125;,                splitLine:&#123;                    lineStyle:&#123;                        color:&#x27;rgba(255,255,255,0.1)&#x27;                    &#125;                &#125;,                type : &#x27;value&#x27;            &#125;        ],        series: [            &#123;                name: &#x27;直接访问&#x27;,                type: &#x27;bar&#x27;,                barWidth: &#x27;60%&#x27;,                data: []            &#125;        ]    &#125;);    window.setInterval(function () &#123;        //myLine.showLoading(); //数据加载完之前先显示一段简单的loading动画        //var namel = []; //类别数组（实际用来盛放X轴坐标值）        //var numl = []; //销量数组（实际用来盛放Y坐标值）        $.ajax(&#123;            type : &quot;post&quot;,            async : true, //异步请求（同步请求将会锁住浏览器，用户其他操作必须等待请求完成才可以执行）            url : &quot;/WeiQin/SelectBarServlet&quot;, //请求发送到Controller处，路径我上面写好了的，直接拼的，你自己按照你的写            data : &#123;&#125;,            dataType : &quot;json&quot;, //返回数据形式为json            success : function(result) &#123;                console.log(result);                //请求成功时执行该函数内容，result即为服务器返回的json对象                myBar1.hideLoading(); //隐藏加载动画                myBar1.setOption(&#123; //加载数据图表                    color: [&#x27;#3398DB&#x27;],                    tooltip: &#123;                        trigger: &#x27;axis&#x27;,                        axisPointer: &#123;            // 坐标轴指示器，坐标轴触发有效                            type: &#x27;shadow&#x27;        // 默认为直线，可选为：&#x27;line&#x27; | &#x27;shadow&#x27;                        &#125;                    &#125;,                    grid: &#123;                        left: &#x27;3%&#x27;,                        right: &#x27;4%&#x27;,                        bottom: &#x27;3%&#x27;,                        containLabel: true                    &#125;,                    xAxis: [                        &#123;                            type: &#x27;category&#x27;,                            data: [&#x27;v轻伤计数器&#x27;,&#x27;v中伤计数器&#x27;,&#x27;v重伤计数器&#x27;],                            axisTick: &#123;                                alignWithLabel: true                            &#125;                        &#125;                    ],                    yAxis:[                        &#123;                            axisLine:&#123;                                lineStyle:&#123;                                    color:&#x27;rgba(255,255,255)&#x27;                                &#125;                            &#125;,                            splitLine:&#123;                                lineStyle:&#123;                                    color:&#x27;rgba(255,255,255,0.1)&#x27;                                &#125;                            &#125;,                            type : &#x27;value&#x27;                        &#125;                    ],                    series: [                        &#123;                            name: &#x27;直接访问&#x27;,                            type: &#x27;bar&#x27;,                            barWidth: &#x27;60%&#x27;,                            data:[result.v轻伤计数器,result.v中伤计数器,result.v重伤计数器]                        &#125;                    ]                &#125;);            &#125;,            error : function(errorMsg) &#123;                //请求失败时执行该函数                //alert(&quot;图表请求数据失败!&quot;);                myBar1.hideLoading();            &#125;        &#125;)    &#125;,5000);&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var myLine1 = echarts.init(document.getElementById(&#x27;juniorservice&#x27;));    var date1 = [];    var data1 = [0];    var now1 = 0;    function addData(shift) &#123;        $.ajax(&#123;            type : &quot;post&quot;,            async : true, //异步请求（同步请求将会锁住浏览器，用户其他操作必须等待请求完成才可以执行）            url : &quot;/WeiQin/SelectLine1Servlet&quot;, //请求发送到Controller处，路径我上面写好了的，直接拼的，你自己按照你的写            data : &#123;&#125;,            dataType : &quot;json&quot;, //返回数据形式为json            success : function(result) &#123;                //请求成功时执行该函数内容，result即为服务器返回的json对象                console.log(result);                date1.push(now1);                now1=now1+1;                data1.push(result.v轻伤计数器);            &#125;,            error : function(errorMsg) &#123;            &#125;        &#125;)    &#125;    for (var i = 1; i &lt; 100; i++) &#123;        addData();    &#125;    setInterval(function () &#123;        addData(true);        myLine1.setOption(&#123;            color:[&#x27;#7de494&#x27;,&#x27;#7fd7b1&#x27;, &#x27;#5578cf&#x27;, &#x27;#5ebbeb&#x27;, &#x27;#d16ad8&#x27;,&#x27;#f8e19a&#x27;,  &#x27;#00b7ee&#x27;, &#x27;#81dabe&#x27;,&#x27;#5fc5ce&#x27;],            backgroundColor: &#x27;rgba(1,202,217,.2)&#x27;,            grid: &#123;                left:30,                right:40,                top:30,                bottom:20,                containLabel: true            &#125;,            toolbox: &#123;                feature: &#123;                    saveAsImage: &#123;&#125;                &#125;            &#125;,            xAxis: &#123;                type: &#x27;category&#x27;,                boundaryGap: false,                axisLine:&#123;                    lineStyle:&#123;                        color:&#x27;rgba(255,255,255,.2)&#x27;                    &#125;                &#125;,                splitLine:&#123;                    lineStyle:&#123;                        color:&#x27;rgba(255,255,255,.1)&#x27;                    &#125;                &#125;,                axisLabel:&#123;                    color:&quot;rgba(255,255,255,.7)&quot;                &#125;,                data: date1            &#125;,            yAxis: &#123;                type: &#x27;value&#x27;,                axisLine:&#123;                    lineStyle:&#123;                        color:&#x27;rgba(255,255,255,.2)&#x27;                    &#125;                &#125;,                splitLine:&#123;                    lineStyle:&#123;                        color:&#x27;rgba(255,255,255,.1)&#x27;                    &#125;                &#125;,                axisLabel:&#123;                    color:&quot;rgba(255,255,255,.7)&quot;                &#125;,            &#125;,            series: [                &#123;                    name:&#x27;2014年&#x27;,                    type:&#x27;line&#x27;,                    stack: &#x27;总量&#x27;,                    areaStyle: &#123;normal: &#123;&#125;&#125;,                    data:data1                &#125;            ]        &#125;);    &#125;, 5000);&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var myLine = echarts.init(document.getElementById(&#x27;professionrate&#x27;));    myLine.setOption(&#123;        color:[&#x27;#7de494&#x27;,&#x27;#7fd7b1&#x27;, &#x27;#5578cf&#x27;, &#x27;#5ebbeb&#x27;, &#x27;#d16ad8&#x27;,&#x27;#f8e19a&#x27;,  &#x27;#00b7ee&#x27;, &#x27;#81dabe&#x27;,&#x27;#5fc5ce&#x27;],        backgroundColor: &#x27;rgba(1,202,217,.2)&#x27;,        grid: &#123;            left:30,            right:40,            top:30,            bottom:20,            containLabel: true        &#125;,        toolbox: &#123;            feature: &#123;                saveAsImage: &#123;&#125;            &#125;        &#125;,        xAxis: &#123;            type: &#x27;category&#x27;,            boundaryGap: false,            axisLine:&#123;                lineStyle:&#123;                    color:&#x27;rgba(255,255,255,.2)&#x27;                &#125;            &#125;,            splitLine:&#123;                lineStyle:&#123;                    color:&#x27;rgba(255,255,255,.1)&#x27;                &#125;            &#125;,            axisLabel:&#123;                color:&quot;rgba(255,255,255,.7)&quot;            &#125;,            data: [&#x27;手术室&#x27;,&#x27;x光室&#x27;,&#x27;抗休克室&#x27;,&#x27;化验室&#x27;]        &#125;,        yAxis: &#123;            type: &#x27;value&#x27;,            axisLine:&#123;                lineStyle:&#123;                    color:&#x27;rgba(255,255,255,.2)&#x27;                &#125;            &#125;,            splitLine:&#123;                lineStyle:&#123;                    color:&#x27;rgba(255,255,255,.1)&#x27;                &#125;            &#125;,            axisLabel:&#123;                color:&quot;rgba(255,255,255,.7)&quot;            &#125;,        &#125;,        series: [            &#123;                name:&#x27;2014年&#x27;,                type:&#x27;line&#x27;,                stack: &#x27;总量&#x27;,                areaStyle: &#123;normal: &#123;&#125;&#125;,                data:[14,58,26,78]            &#125;        ]    &#125;);&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var myLine = echarts.init(document.getElementById(&#x27;edubalance&#x27;));    var date = [];    var data = [0];    var now = 0;    function addData1(shift) &#123;        $.ajax(&#123;            type : &quot;post&quot;,            async : true, //异步请求（同步请求将会锁住浏览器，用户其他操作必须等待请求完成才可以执行）            url : &quot;/WeiQin/SelectLineServlet&quot;, //请求发送到Controller处，路径我上面写好了的，直接拼的，你自己按照你的写            data : &#123;&#125;,            dataType : &quot;json&quot;, //返回数据形式为json            success : function(result) &#123;                //请求成功时执行该函数内容，result即为服务器返回的json对象                console.log(result);                date.push(now);                data.push(result.手术室);                now=now+1;            &#125;,            error : function(errorMsg) &#123;            &#125;        &#125;)    &#125;    for (var i = 1; i &lt; 100; i++) &#123;        addData1();    &#125;    setInterval(function () &#123;        addData1(true);        myLine.setOption(&#123;            color:[&#x27;#7de494&#x27;,&#x27;#7fd7b1&#x27;, &#x27;#5578cf&#x27;, &#x27;#5ebbeb&#x27;, &#x27;#d16ad8&#x27;,&#x27;#f8e19a&#x27;,  &#x27;#00b7ee&#x27;, &#x27;#81dabe&#x27;,&#x27;#5fc5ce&#x27;],            backgroundColor: &#x27;rgba(1,202,217,.2)&#x27;,            grid: &#123;                left:30,                right:40,                top:30,                bottom:20,                containLabel: true            &#125;,            toolbox: &#123;                feature: &#123;                    saveAsImage: &#123;&#125;                &#125;            &#125;,            xAxis: &#123;                type: &#x27;category&#x27;,                boundaryGap: false,                axisLine:&#123;                    lineStyle:&#123;                        color:&#x27;rgba(255,255,255,.2)&#x27;                    &#125;                &#125;,                splitLine:&#123;                    lineStyle:&#123;                        color:&#x27;rgba(255,255,255,.1)&#x27;                    &#125;                &#125;,                axisLabel:&#123;                    color:&quot;rgba(255,255,255,.7)&quot;                &#125;,                data: date            &#125;,            yAxis: &#123;                type: &#x27;value&#x27;,                axisLine:&#123;                    lineStyle:&#123;                        color:&#x27;rgba(255,255,255,.2)&#x27;                    &#125;                &#125;,                splitLine:&#123;                    lineStyle:&#123;                        color:&#x27;rgba(255,255,255,.1)&#x27;                    &#125;                &#125;,                axisLabel:&#123;                    color:&quot;rgba(255,255,255,.7)&quot;                &#125;,            &#125;,            series: [                &#123;                    name:&#x27;2014年&#x27;,                    type:&#x27;line&#x27;,                    stack: &#x27;总量&#x27;,                    areaStyle: &#123;normal: &#123;&#125;&#125;,                    data:data                &#125;            ]        &#125;);    &#125;, 5000);&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    /* 热力图*/    /* 地图 需要哪个省市的地图直接引用js 将下面的name以及mapType修改为对应省市名称*/    /* 地图 需要哪个省市的地图直接引用js 将下面的name以及mapType修改为对应省市名称*/    var maps = echarts.init(document.getElementById(&#x27;mapadd&#x27;));    option = &#123;        tooltip : &#123;            trigger: &#x27;item&#x27;,            formatter: &#x27;&#123;b&#125;&#x27;        &#125;,        series : [&#123;            name: &#x27;上海&#x27;,            type: &#x27;map&#x27;,            mapType: &#x27;上海&#x27;,            roam: false,            top:&#x27;8%&#x27;,            zoom:1.2,            x:&#x27;25%&#x27;,            selectedMode : &#x27;single&#x27;,//multiple多选            itemStyle:&#123;                normal:&#123;                    label:&#123;                        show:true,                        textStyle: &#123;                            color: &quot;#231816&quot;                        &#125;                    &#125;,                    areaStyle:&#123;color:&#x27;#B1D0EC&#x27;&#125;,                    color:&#x27;#B1D0EC&#x27;,                    borderColor:&#x27;#dadfde&#x27;//区块的边框颜色                &#125;,                emphasis:&#123;//鼠标hover样式                    label:&#123;                        show:true,                        textStyle:&#123;                            color:&#x27;#fa4f04&#x27;                        &#125;                    &#125;,                    areaStyle:&#123;color:&#x27;red&#x27;&#125;                &#125;            &#125;,            data:[                &#123;name:&#x27;宝山区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#f69009&#x27;,                            borderColor: &#x27;#edce00&#x27;                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;嘉定区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#ce05c4&#x27;,                            borderColor: &#x27;#0abcee&#x27;                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;虹口区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#92d050&#x27;,                            borderColor: &#x27;#1ca9f2&#x27;                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;黄浦区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#88ddf5&#x27;,                            borderColor: &#x27;#88ddf5&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;静安区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#13d5ff&#x27;,                            borderColor: &#x27;#45b5ef&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;浦东新区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#13d5ff&#x27;,                            borderColor: &#x27;#45b5ef&#x27;                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;普陀区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#45b5ef&#x27;,                            borderColor: &#x27;#45b5ef&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;徐汇区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#ffd811&#x27;,                            borderColor: &#x27;#45b5ef&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;闸北区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#ffa312&#x27;,                            borderColor: &#x27;#45b5ef&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;杨浦区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#92d050&#x27;,                            borderColor: &#x27;#1ca9f2&#x27;                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;长宁区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#054757&#x27;,                            borderColor: &#x27;#0cbbec&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;青浦区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;rgba(35,255,19,0.6)&#x27;,                            borderColor: &#x27;#0d1dd0&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;松江区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#f5d60c&#x27;,                            borderColor: &#x27;#160457&#x27;                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;奉贤区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#38d70a&#x27;,                            borderColor: &#x27;#010d13&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;闵行区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#d71d95&#x27;,                            borderColor: &#x27;#599abb&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;金山区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;red&#x27;,                            borderColor: &#x27;#45b5ef&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;崇明区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#0928f3&#x27;,                            borderColor: &#x27;#45b5ef&#x27;,                        &#125;                    &#125;                &#125;,            ]        &#125;]    &#125;;    setInterval(function () &#123;        maps.setOption(option);    &#125;, 5000);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n注意：还是用模板12\n\n3、Anylogic1.functionbar      //创建发送端Socket对象DatagramSocket ds = null;try &#123;\tds = new DatagramSocket();&#125; catch (SocketException e) &#123;\t// TODO Auto-generated catch block\te.printStackTrace();&#125;// byte[] bys=null; //创建数据并打包\t//String s = v中伤计数器+&quot;&quot;;//要发送的数据//for(int i=0;i&lt;1000;i++)&#123;//String s = v中伤计数器+&quot;&quot;;//要发送的数据// bys = s.getBytes(); //将数据放在字节数组中//&#125;JSONObject jo = new JSONObject();Object obj = null;try&#123;    jo.put(&quot;v轻伤计数器&quot;,v轻伤计数器);\tjo.put(&quot;v中伤计数器&quot;,v中伤计数器);\tjo.put(&quot;v重伤计数器&quot;,v重伤计数器);\t\t&#125;catch(Exception e)&#123;\te.printStackTrace();&#125;String str = jo.toString();byte[] bys=null;bys = str.getBytes(); //将数据放在字节数组中int length = bys.length;    //字节数组的长度InetAddress address = null;try &#123;\taddress = InetAddress.getByName(&quot;127.0.0.1&quot;);&#125; catch (UnknownHostException e) &#123;\t// TODO Auto-generated catch block\te.printStackTrace();&#125; //目的地址int port = 1235;  //设置端口号//System.out.println(bys);//打包\t\tDatagramPacket dp = new DatagramPacket(bys,length,address,port); \t\t//发送数据try &#123;\tds.send(dp);&#125; catch (IOException e) &#123;\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125; \t\t//释放资源ds.close();\t\t\n\n2.functionbar1   //创建发送端Socket对象DatagramSocket ds = null;try &#123;\tds = new DatagramSocket();&#125; catch (SocketException e) &#123;\t// TODO Auto-generated catch block\te.printStackTrace();&#125;// byte[] bys=null; //创建数据并打包\t//String s = v中伤计数器+&quot;&quot;;//要发送的数据//for(int i=0;i&lt;1000;i++)&#123;//String s = v中伤计数器+&quot;&quot;;//要发送的数据// bys = s.getBytes(); //将数据放在字节数组中//&#125;JSONObject jo = new JSONObject();Object obj = null;try&#123;    jo.put(&quot;v轻伤计数器&quot;,v轻伤计数器);\tjo.put(&quot;v中伤计数器&quot;,v中伤计数器);\tjo.put(&quot;v重伤计数器&quot;,v重伤计数器);\t\t&#125;catch(Exception e)&#123;\te.printStackTrace();&#125;String str = jo.toString();byte[] bys=null;bys = str.getBytes(); //将数据放在字节数组中int length = bys.length;    //字节数组的长度InetAddress address = null;try &#123;\taddress = InetAddress.getByName(&quot;127.0.0.1&quot;);&#125; catch (UnknownHostException e) &#123;\t// TODO Auto-generated catch block\te.printStackTrace();&#125; //目的地址int port = 1456;  //设置端口号//System.out.println(bys);//打包\t\tDatagramPacket dp = new DatagramPacket(bys,length,address,port); \t\t//发送数据try &#123;\tds.send(dp);&#125; catch (IOException e) &#123;\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125; \t\t//释放资源ds.close();\n\n3.functionline     //创建发送端Socket对象DatagramSocket ds = null;try &#123;\tds = new DatagramSocket();&#125; catch (SocketException e) &#123;\t// TODO Auto-generated catch block\te.printStackTrace();&#125;// byte[] bys=null; //创建数据并打包\t//String s = v中伤计数器+&quot;&quot;;//要发送的数据//for(int i=0;i&lt;1000;i++)&#123;//String s = v中伤计数器+&quot;&quot;;//要发送的数据// bys = s.getBytes(); //将数据放在字节数组中//&#125;JSONObject jo = new JSONObject();Object obj = null;try&#123; \tjo.put(&quot;手术室&quot;,a医院.a诊室.col伤员从病房去向各诊室计数.get(0)-1);\tjo.put(&quot;x光室&quot;,a医院.a诊室.col伤员从病房去向各诊室计数.get(1)-1);\tjo.put(&quot;抗休克室&quot;,a医院.a诊室.col伤员从病房去向各诊室计数.get(2)-1);\tjo.put(&quot;化验室&quot;,a医院.a诊室.col伤员从病房去向各诊室计数.get(3)-1);\t&#125;catch(Exception e)&#123;\te.printStackTrace();&#125;String str = jo.toString();byte[] bys=null;bys = str.getBytes(); //将数据放在字节数组中int length = bys.length;    //字节数组的长度InetAddress address = null;try &#123;\taddress = InetAddress.getByName(&quot;127.0.0.1&quot;);&#125; catch (UnknownHostException e) &#123;\t// TODO Auto-generated catch block\te.printStackTrace();&#125; //目的地址int port = 1237;  //设置端口号//System.out.println(bys);//打包\t\tDatagramPacket dp = new DatagramPacket(bys,length,address,port); \t\t//发送数据try &#123;\tds.send(dp);&#125; catch (IOException e) &#123;\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125; \t\t//释放资源ds.close();\n\n4.functionline1     //创建发送端Socket对象DatagramSocket ds = null;try &#123;\tds = new DatagramSocket();&#125; catch (SocketException e) &#123;\t// TODO Auto-generated catch block\te.printStackTrace();&#125;// byte[] bys=null; //创建数据并打包\t//String s = v中伤计数器+&quot;&quot;;//要发送的数据//for(int i=0;i&lt;1000;i++)&#123;//String s = v中伤计数器+&quot;&quot;;//要发送的数据// bys = s.getBytes(); //将数据放在字节数组中//&#125;JSONObject jo = new JSONObject();Object obj = null;try&#123; \t jo.put(&quot;v轻伤计数器&quot;,v轻伤计数器);\tjo.put(&quot;v中伤计数器&quot;,v中伤计数器);\tjo.put(&quot;v重伤计数器&quot;,v重伤计数器);\t&#125;catch(Exception e)&#123;\te.printStackTrace();&#125;String str = jo.toString();byte[] bys=null;bys = str.getBytes(); //将数据放在字节数组中int length = bys.length;    //字节数组的长度InetAddress address = null;try &#123;\taddress = InetAddress.getByName(&quot;127.0.0.1&quot;);&#125; catch (UnknownHostException e) &#123;\t// TODO Auto-generated catch block\te.printStackTrace();&#125; //目的地址int port = 1239;  //设置端口号//System.out.println(bys);//打包\t\tDatagramPacket dp = new DatagramPacket(bys,length,address,port); \t\t//发送数据try &#123;\tds.send(dp);&#125; catch (IOException e) &#123;\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125; \t\t//释放资源ds.close();\t\t\n\n5.functionpie     //创建发送端Socket对象DatagramSocket ds = null;try &#123;\tds = new DatagramSocket();&#125; catch (SocketException e) &#123;\t// TODO Auto-generated catch block\te.printStackTrace();&#125;// byte[] bys=null; //创建数据并打包\t//String s = v中伤计数器+&quot;&quot;;//要发送的数据//for(int i=0;i&lt;1000;i++)&#123;//String s = v中伤计数器+&quot;&quot;;//要发送的数据// bys = s.getBytes(); //将数据放在字节数组中//&#125;JSONObject jo = new JSONObject();Object obj = null;try&#123; \tjo.put(&quot;手术室&quot;,a医院.a诊室.col伤员从病房去向各诊室计数.get(0)-1);\tjo.put(&quot;x光室&quot;,a医院.a诊室.col伤员从病房去向各诊室计数.get(1)-1);\tjo.put(&quot;抗休克室&quot;,a医院.a诊室.col伤员从病房去向各诊室计数.get(2)-1);\tjo.put(&quot;化验室&quot;,a医院.a诊室.col伤员从病房去向各诊室计数.get(3)-1);\t&#125;catch(Exception e)&#123;\te.printStackTrace();&#125;String str = jo.toString();byte[] bys=null;bys = str.getBytes(); //将数据放在字节数组中int length = bys.length;    //字节数组的长度InetAddress address = null;try &#123;\taddress = InetAddress.getByName(&quot;127.0.0.1&quot;);&#125; catch (UnknownHostException e) &#123;\t// TODO Auto-generated catch block\te.printStackTrace();&#125; //目的地址int port = 1236;  //设置端口号//System.out.println(bys);//打包\t\tDatagramPacket dp = new DatagramPacket(bys,length,address,port); \t\t//发送数据try &#123;\tds.send(dp);&#125; catch (IOException e) &#123;\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125; \t\t//释放资源ds.close();\n\n6.functionpie1     //创建发送端Socket对象DatagramSocket ds = null;try &#123;\tds = new DatagramSocket();&#125; catch (SocketException e) &#123;\t// TODO Auto-generated catch block\te.printStackTrace();&#125;// byte[] bys=null; //创建数据并打包\t//String s = v中伤计数器+&quot;&quot;;//要发送的数据//for(int i=0;i&lt;1000;i++)&#123;//String s = v中伤计数器+&quot;&quot;;//要发送的数据// bys = s.getBytes(); //将数据放在字节数组中//&#125;JSONObject jo = new JSONObject();Object obj = null;try&#123; \tjo.put(&quot;手术室&quot;,a医院.a诊室.col伤员从x光室去向各诊室计数.get(0)-1);\tjo.put(&quot;x光室&quot;,a医院.a诊室.col伤员从化验室去向各诊室计数.get(1)-1);\tjo.put(&quot;抗休克室&quot;,a医院.a诊室.col伤员从化验室去向各诊室计数.get(2)-1);\tjo.put(&quot;病房&quot;,a医院.a诊室.col伤员从化验室去向各诊室计数.get(4)-1);\t&#125;catch(Exception e)&#123;\te.printStackTrace();&#125;String str = jo.toString();byte[] bys=null;bys = str.getBytes(); //将数据放在字节数组中int length = bys.length;    //字节数组的长度InetAddress address = null;try &#123;\taddress = InetAddress.getByName(&quot;127.0.0.1&quot;);&#125; catch (UnknownHostException e) &#123;\t// TODO Auto-generated catch block\te.printStackTrace();&#125; //目的地址int port = 1238;  //设置端口号//System.out.println(bys);//打包\t\tDatagramPacket dp = new DatagramPacket(bys,length,address,port); \t\t//发送数据try &#123;\tds.send(dp);&#125; catch (IOException e) &#123;\t// TODO Auto-generated catch block\t\t\te.printStackTrace();\t\t&#125; \t\t//释放资源ds.close();\n\n7.连接数据库java.sql.Statement stmt = null;java.sql.Connection conn = null;try &#123;            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\t\t\tString url = &quot;jdbc:mysql://127.0.0.1:3306/weiqin?useUnicode=true&amp;characterEncoding=utf-8&quot;;\t\t\tconn = DriverManager.getConnection(url, &quot;root&quot;, &quot;password&quot;);\t\t   // System.out.println(conn.isClosed());测试数据库是否连接成功\t\t\tstmt = conn.createStatement();\t\t\t//System.out.println(&quot;sql: &quot;+sql);输出sql语句\t\t\treturn stmt.executeQuery(sql);\t\t&#125; catch (SQLException e) &#123;\t\t\te.printStackTrace();\t\t&#125;catch (ClassNotFoundException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\treturn null;\n\n","tags":["Anylogic"]},{"title":"Anylogic之基于百度地图做热力图","url":"/2022/04/25/Anylogic%E4%B9%8B%E5%9F%BA%E4%BA%8E%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%81%9A%E7%83%AD%E5%8A%9B%E5%9B%BE/","content":"第一步：我们先把先把准备好的数据转化成固定格式\n\n通过以下代码进行转化（使用的是pycharm）\nimport csvimport requestsimport jsondef gain_location(adress):    api_url =&quot;http://api.map.baidu.com/geocoding/v3/?address=&#123;adress&#125;&amp;output=json&amp;ak=你自己的密钥&amp;callback=showLocation&quot;.format(adress=adress)    r = requests.get(api_url)    r = r.text    r = r.strip(&#x27;showLocation&amp;&amp;showLocation(&#x27;)    r = r.strip(&#x27;)&#x27;)    jsonData = json.loads(r)  # 将json字符串转换为字典类型转为字典格式类型    return jsonDatawith open(r&#x27;附件2 北京地铁各站点进站客流分时汇总表.csv&#x27;,encoding = &#x27;gb18030&#x27;) as csvfile: #打开csv    reader = csv.reader(csvfile)    for line in reader: #读取csv里的数据        if reader.line_num == 1:            continue        if gain_location(line[0]).get(&#x27;result&#x27;, False):            try:                lng = gain_location(line[0])[&#x27;result&#x27;][&#x27;location&#x27;][&#x27;lng&#x27;]  # 经度                lat = gain_location(line[0])[&#x27;result&#x27;][&#x27;location&#x27;][&#x27;lat&#x27;]  # 纬度                count = line[1]  # 地名计数                str_temp = &#x27;&#123;&quot;lat&quot;:&#x27; + str(lat) + &#x27;,&quot;lng&quot;:&#x27; + str(lng) + &#x27;,&quot;count&quot;:&#x27; + str(count) + &#x27;&#125;,&#x27;  # 将经度，纬度，计数变成格式                print(str_temp)            except:                print(line[0])  # 打印出出问题的地名\n\n使用上面代码转化csv图片得到的数据是\n\n然后我们将百度地图的热力图示例复制过来稍作修该\n\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, user-scalable=no&quot; /&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;//api.map.baidu.com/api?v=2.0&amp;ak=你自己的密钥&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;//api.map.baidu.com/library/Heatmap/2.0/src/Heatmap_min.js&quot;&gt;&lt;/script&gt;    &lt;title&gt;热力图功能示例&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;      ul,li&#123;list-style: none;margin:0;padding:0;float:left;&#125;      html&#123;height:100%&#125;      body&#123;height:100%;margin:0px;padding:0px;font-family:&quot;微软雅黑&quot;;&#125;      #container&#123;height:500px;width:100%;&#125;      #r-result&#123;width:100%;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;   &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;   &lt;div id=&quot;r-result&quot;&gt;      &lt;input type=&quot;button&quot;  onclick=&quot;openHeatmap();&quot; value=&quot;显示热力图&quot;/&gt;&lt;input type=&quot;button&quot;  onclick=&quot;closeHeatmap();&quot; value=&quot;关闭热力图&quot;/&gt;   &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var map = new BMap.Map(&quot;container&quot;);          // 创建地图实例    var point = new BMap.Point(116.438927, 39.923508);//中心点坐标    map.centerAndZoom(point, 15);             // 初始化地图，设置中心点坐标和地图级别    map.enableScrollWheelZoom(); // 允许滚轮缩放//这个就是上面我们输出出来的数据    var points =[    &#123;&quot;lat&quot;:39.914537522974534,&quot;lng&quot;:116.50836872513715,&quot;count&quot;:37794&#125;,   &#123;&quot;lat&quot;:39.914537522974534,&quot;lng&quot;:116.50836872513715,&quot;count&quot;:35550&#125;,   &#123;&quot;lat&quot;:39.91645575947582,&quot;lng&quot;:116.46703499370652,&quot;count&quot;:46435&#125;,   &#123;&quot;lat&quot;:22.828572041904824,&quot;lng&quot;:120.23700834379214,&quot;count&quot;:33390&#125;,   &#123;&quot;lat&quot;:39.920195646104496,&quot;lng&quot;:116.4342834036266,&quot;count&quot;:31753&#125;,   &#123;&quot;lat&quot;:39.92315809391276,&quot;lng&quot;:116.42394965636201,&quot;count&quot;:14195&#125;,   &#123;&quot;lat&quot;:39.92223158631893,&quot;lng&quot;:116.4186675301328,&quot;count&quot;:33208&#125;,   &#123;&quot;lat&quot;:31.34224126103566,&quot;lng&quot;:121.2789357477942,&quot;count&quot;:33006&#125;,   &#123;&quot;lat&quot;:39.08308716818319,&quot;lng&quot;:117.2690831157461,&quot;count&quot;:35867&#125;,];    if(!isSupportCanvas())&#123;       alert(&#x27;热力图目前只支持有canvas支持的浏览器,您所使用的浏览器不能使用热力图功能~&#x27;)    &#125;   //详细的参数,可以查看heatmap.js的文档 https://github.com/pa7/heatmap.js/blob/master/README.md   //参数说明如下:   /* visible 热力图是否显示,默认为true     * opacity 热力的透明度,1-100     * radius 势力图的每个点的半径大小     * gradient  &#123;JSON&#125; 热力图的渐变区间 . gradient如下所示     * &#123;         .2:&#x27;rgb(0, 255, 255)&#x27;,         .5:&#x27;rgb(0, 110, 255)&#x27;,         .8:&#x27;rgb(100, 0, 255)&#x27;      &#125;      其中 key 表示插值的位置, 0~1.          value 为颜色值.     */   heatmapOverlay = new BMapLib.HeatmapOverlay(&#123;&quot;radius&quot;:40&#125;);//热力图半径   map.addOverlay(heatmapOverlay);   heatmapOverlay.setDataSet(&#123;data:points,max:40000&#125;);   //是否显示热力图    function openHeatmap()&#123;        heatmapOverlay.show();    &#125;   function closeHeatmap()&#123;        heatmapOverlay.hide();    &#125;   closeHeatmap();    function setGradient()&#123;       /*格式如下所示:      &#123;         0:&#x27;rgb(102, 255, 0)&#x27;,         .5:&#x27;rgb(255, 170, 0)&#x27;,         1:&#x27;rgb(255, 0, 0)&#x27;      &#125;*/       var gradient = &#123;&#125;;       var colors = document.querySelectorAll(&quot;input[type=&#x27;color&#x27;]&quot;);       colors = [].slice.call(colors,0);       colors.forEach(function(ele)&#123;         gradient[ele.getAttribute(&quot;data-key&quot;)] = ele.value;       &#125;);        heatmapOverlay.setOptions(&#123;&quot;gradient&quot;:gradient&#125;);    &#125;   //判断浏览区是否支持canvas    function isSupportCanvas()&#123;        var elem = document.createElement(&#x27;canvas&#x27;);        return !!(elem.getContext &amp;&amp; elem.getContext(&#x27;2d&#x27;));    &#125;&lt;/script&gt;\n","tags":["Anylogic"]},{"title":"Anylogic之百度地图从后台获取实时坐标点以实现车辆实时跟踪","url":"/2022/06/05/Anylogic%E4%B9%8B%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E4%BB%8E%E5%90%8E%E5%8F%B0%E8%8E%B7%E5%8F%96%E5%AE%9E%E6%97%B6%E5%9D%90%E6%A0%87%E7%82%B9%E4%BB%A5%E5%AE%9E%E7%8E%B0%E8%BD%A6%E8%BE%86%E5%AE%9E%E6%97%B6%E8%B7%9F%E8%B8%AA/","content":"​\t\t要想实现车辆实时跟踪，就必须实时获取车辆的坐标点，然后展示在百度地图上。而实现实时获取车辆坐标点的功能，有两个方案：方案①定义一个函数getCars()，此函数的功能是通过ajax访问后台接口，从而返回车辆的实时位置信息。然后利用setInterval() 方法，每隔2000毫秒（根据业务需求确定）就调用一次获取车辆实时位置信息的函数； 方案②：定义一个获取车辆实时位置信息的函数getCars()，并在此函数中使用setTimeout() 方法在2000毫秒后重新调用上面的函数getCars()。\n  方案确定好后，怎样具体实现跟踪功能呢，且跟踪时需要将车辆在跟踪期间走过的路径绘制出来。\n  首先，在实现跟踪之前，应该先把所有车辆当前的位置信息定位在百度地图上，且每个车辆对应百度地图中的一个marker，然后给每个车辆的marker添加一个鼠标滑过打开信息窗口的功能。被打开的信息窗口中有一个“跟踪”按钮，当用户点击“跟踪”按钮时，就每隔2000毫秒调用已经定义好的获取车辆实时位置信息的函数getCars()。在getCars()函数中，首先通过ajax调用后台接口，以从后台获取到车辆的实时位置信息；然后将此实时位置信息push到一个全局数组trackMap中，此数组存放被跟踪车辆所走过的轨迹坐标点；随后，利用Polyline将trackMap中最新的两个坐标点用线段连接起来，再利用addOverlay将此线段添加到百度地图中，以作为被跟踪车辆所走过的历史轨迹路线；最后，利用marker的setPosition()方法，将代表被跟踪车辆的marker移动到最新的位置trackMap[trackMap.length - 1]处，即可。至此，就实现了车辆的实时跟踪。\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, user-scalable=no&quot; /&gt;  &lt;style type=&quot;text/css&quot;&gt;      html&#123;height:100%&#125;      body&#123;height:100%;margin:0px;padding:0px&#125;      #allmap&#123;height:100%&#125;  &lt;/style&gt;  &lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=自己的&quot;&gt;  &lt;/script&gt;  &lt;title&gt;单个标注点沿直线的轨迹运动&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    // 百度地图API功能    var map=new BMap.Map(&quot;allmap&quot;);//创建地图实例    map.centerAndZoom(new BMap.Point(116.297611,40.047363), 15);    map.enableScrollWheelZoom(true);    $.ajax(&#123;        async:false,        cache:true,        url: &quot;/baidu&quot;,        type: &#x27;GET&#x27;,        success: function(result)&#123;            if(result != undefined &amp;&amp; result.length &gt;0)&#123;                 lon = [], lat = [];                for (var i = 0; i &lt; result.length; i++) &#123;                    lon[i] = result[i].lontitude;                    lat[i] = result[i].latitude;                    var myIcon=new BMap.Icon(&quot;http://lbsyun.baidu.com/jsdemo/img/Mario.png&quot;, new BMap.Size(32, 70), &#123;                        offset: new BMap.Size(0, -5),                        //相当于CSS精灵                        imageOffset: new BMap.Size(0, 0)                        //图片的偏移量。为了是图片底部中心对准坐标点。                    &#125;);                     steelMarker = new BMap.Marker(new BMap.Point(lon[i],lat[i]), &#123;icon:myIcon&#125;);//                     steelContent = &#x27;&lt;div&gt;&lt;p style=&quot;margin:0;line-height:1.5;font-size:13px;text-indent:2em&quot;&gt;&lt;br/&gt;经度：&#x27;+lon[i]+&#x27;&lt;br/&gt;纬度：&#x27;+lat[i]+                        &#x27;&lt;br/&gt;&lt;button type=&quot;button&quot; onclick=&quot;getCars()&quot;&gt;点击我！&lt;/button&gt;&lt;/p&gt;&lt;/div&gt;&#x27;;                     steelOpts = &#123;                        width : 260,     //信息窗口宽度                        height: 200,     //信息窗口高度                        title : &quot;&lt;b&gt;车辆信息&lt;/b&gt;&quot; , //信息窗口标题                        enableMessage:true //设置允许信息窗发送短息                    &#125;;                    map.addOverlay(steelMarker); //将标注添加到地图中                    //添加鼠标双击时打开自定义信息窗口事件                    steelMarker.addEventListener(&quot;mouseover&quot;,function () &#123;                        this.openInfoWindow(new BMap.InfoWindow(steelContent, steelOpts));                      &#125;                    );                &#125;            &#125;        &#125;,        error:function(e)&#123;            //alert(&quot;获取信息失败&quot;);        &#125;    &#125;);    var trackMap = [];    function getCars()&#123;        $.ajax(&#123;            async:false,            cache:true,            url: &quot;/baidu&quot;,            type: &#x27;GET&#x27;,            dataType:&#x27;text&#x27;,            success: function(result)&#123;                result = eval(&#x27;(&#x27;+ result +&#x27;)&#x27;);                for (var i = 0; i &lt; result.length; i++) &#123;                    /*** 实时获取经纬度信息 ***/                    sitsLongitude = result[i].lontitude;                    sitsLatitude = result[i].latitude;                    console.info(sitsLongitude);                    trackMap.push(new BMap.Point(sitsLongitude, sitsLatitude));//push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。                    carContent = &#x27;&lt;div&gt;&lt;br/&gt;经度： &#x27; + sitsLongitude + &#x27;&lt;br/&gt;纬度： &#x27; + sitsLatitude + &#x27;&lt;p style=&quot;color:green; margin-left:65%;&quot;&gt;正在跟踪中&lt;/p&gt;&lt;/div&gt;&#x27;;                    //addOverlay(overlay: Overlay) : 将覆盖物添加到地图中，一个覆盖物实例只能向地图中添加一次                    //Polyline(points: Array&lt;Point&gt;, opts: PolylineOptions) : 创建折线覆盖物对象                    //PolylineOptions: 此类表示Polyline构造函数的可选参数。                    if (trackMap.length &gt; 2) &#123;                        map.addOverlay(new BMap.Polyline([trackMap[trackMap.length-2], trackMap[trackMap.length-1]], &#123;                            strokeColor: &quot;blue&quot;,                            strokeWeight: 3,                            strokeOpacity: 1,                        &#125;));                    &#125;                    addEventListener(carContent, steelMarker);                    steelMarker.setPosition(trackMap[trackMap.length - 1]);//setPosition:设置标注的地理坐标                &#125;            &#125;,            error:function(e)&#123;                alert(&quot;获取物资信息失败&quot;);            &#125;        &#125;);        setTimeout(function()&#123; //setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。setTimeout() 只执行 code 一次。如果要多次调用，请使用 setInterval() 或者让 code 自身再次调用 setTimeout()。            getCars();        &#125;, 2000);    &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n需要注意的是：\n​    1.  在使用setPosition()方法设置被跟踪车辆的最新位置时，应在跟踪之前，就将代表车辆的marker添加至地图中，不然setPosition()不会起作用的。具体将车辆marker添加到地图中的操作，即是跟踪之前的定位操作。\n​    2. 为marker添加鼠标滑过事件addMouseoverHandler()，也参考定位的那篇文章。只是在跟踪时，需要将最新的经纬度信息重新获取后再展示即可。\n","tags":["Anylogic"]},{"title":"Anylogic之echarts实现数据可视化","url":"/2022/06/07/Anylogic%E4%B9%8Becharts%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","content":"1、CSS样式@charset &quot;utf-8&quot;;/*通用样式ͨ*/body,ul,li,p,h1,h2,h3,h4,h5,h6,dl,dt,dd &#123;    margin:0;    padding:0;&#125;ul, li&#123;    list-style: none;&#125;a:link,a:visited,a:active &#123;    text-decoration: none;&#125;body&#123;    background: #040f3c;&#125;.header&#123;    height: 80px;    position: relative;    padding-top: 13px;    font-size: 36px;    color: #00ffff;    text-align: center;    background: url(../bg.png) top center no-repeat;&#125;.header a.a-access&#123;  position: absolute;    right: 3%;    top: -18%;&#125;.main&#123;    padding: 0 30px 30px;&#125;.main-left&#123;    float: left;    width: 28%;    padding: 0 10px;&#125;.main-right&#123;    float: left;    width: 28%;    padding: 0 10px;&#125;.main-middle&#123;    float: left;    width: 44%;    padding: 0 10px;&#125;.border-container &#123;    position: relative;    margin-top: 15px;    padding: 10px;    border: 1px solid #54dcf2;&#125;.border-container span.border-span &#123;    display: block;    position: absolute;    width:35px;    height: 35px;&#125;.border-container span.top-left &#123;    top: -4px;    left:-4px;    border-top: 3px solid #54dcf2;    border-left: 3px solid #54dcf2;&#125;.border-container span.top-right &#123;    top:-4px;    right:-4px;    border-top: 3px solid #54dcf2;    border-right: 3px solid #54dcf2;&#125;.border-container span.bottom-left &#123;    bottom: -4px;    left: -4px;    border-bottom: 3px solid #54dcf2;    border-left: 3px solid #54dcf2;&#125;.border-container span.bottom-right &#123;    bottom: -4px;    right: -4px;    border-bottom: 3px solid #54dcf2;    border-right: 3px solid #54dcf2;&#125;.name-title&#123;    font-size:20px ;    color: #00ffff;&#125;#radar&#123;    height: 275px;&#125;#dormitorydetail&#123;    height: 135px;&#125;#graduateyear&#123;    height: 192px;&#125;.three-pie&#123;    border-top: 1px solid #2c768a;    margin: -10px;    margin-top: 10px;&#125;.teacher-pie&#123;    border-bottom: 1px solid #2c768a;    margin: -10px;    margin-bottom: 0;&#125;.three-pie li,.teacher-pie li&#123;    float: left;    width: 50%;    border-right: 1px solid #2c768a;&#125;.teacher-pie li .name-title&#123;    padding-left:10px ;    padding-top:10px ;&#125;.three-pie li:last-child,.teacher-pie li:last-child&#123;    border-right: none;&#125;#sexrate,#nationarate,#householdrate&#123;    height: 266px;&#125;.number-show&#123;    position: absolute;    top: 20%;    right: 5%;&#125;.number-show span.span-name&#123;    font-size:14px ;    color:#fffd51 ;&#125;.number-show span.span-number-show&#123;    font-size:18px ;    color:#54b5b5 ;    font-style: italic;&#125;.number-show li&#123;    line-height: 25px;&#125;#teacherrate,#courserate,#professionrate&#123;    height: 200px;&#125;#agelist&#123;    height: 130px;&#125;#changedetail&#123;    height: 229px;&#125;.table-kingdargen&#123;    margin-top: 6px;    text-align: center;    margin-bottom: 0;&#125;.table-kingdargen&gt;thead&gt;tr&gt;th&#123;    border-bottom: 1px solid #0f4075;    padding: 2px 8px;    text-align: center;    color: #419aff;    font-size: 12px;    font-weight: normal;    border-top: 1px solid #0f4075!important;&#125;.table-kingdargen tbody tr td&#123;    padding: 1px 8px;    font-size: 12px;    border: none;    color: #fff;&#125;.table-kingdargen tbody tr:nth-child(2n)&#123;    background: #1d2a42;&#125;.table-kingdargen tbody tr:hover&#123;    background: #1d2a42;&#125;.table-kingdargen tbody tr td:nth-child(2)&#123;    color: #e9aa00;&#125;.table-kingdargen tbody tr td:nth-child(3)&#123;    color: #53bf18;&#125;.table-kingdargen tbody tr td:nth-child(4)&#123;    color: #f9504a;&#125;.table-kingdargen tbody tr td:nth-child(5)&#123;    color: #12f0e9;&#125;#juniorservice&#123;    height: 190px;&#125;#edubalance&#123;    height: 203px;&#125;@import url(&quot;https://fonts.googleapis.com/css?family=Raleway&quot;);* &#123;  box-sizing: border-box;&#125;.copyright &#123;  position: absolute;  bottom: 0;&#125;.copyright a &#123;  text-decoration: none;  color: #16a085;&#125;.copyright a:hover &#123;  text-decoration: underline;&#125;.button &#123;  position: relative;  padding: 0.5em 1.5em;  border: none;  background-color: transparent;  cursor: pointer;  outline: none;  font-size: 18px;  margin: 1em 0.8em;&#125;.button.type1 &#123;  color: #00ffff;&#125;.button.type1.type1::after, .button.type1.type1::before &#123;  content: &quot;&quot;;  display: block;  position: absolute;  width: 20%;  height: 20%;  border: 2px solid;  transition: all 0.6s ease;  border-radius: 2px;&#125;.button.type1.type1::after &#123;  bottom: 0;  right: 0;  border-top-color: transparent;  border-left-color: transparent;  border-bottom-color: #566473;  border-right-color: #566473;&#125;.button.type1.type1::before &#123;  top: 0;  left: 0;  border-bottom-color: transparent;  border-right-color: transparent;  border-top-color: #566473;  border-left-color: #566473;&#125;.button.type1.type1:hover:after, .button.type1.type1:hover:before &#123;  width: 100%;  height: 100%;&#125;\n\n2、自定义js使用Echarts$(function get()&#123;    /* 左上*/    var graduateyear = echarts.init(document.getElementById(&#x27;graduateyear&#x27;));    lineOption = &#123;        title: &#123;            text: &#x27;折线图&#x27;,            textStyle:&#123;                color:&quot;#fff&quot;            &#125;,        &#125;,        legend: &#123;            top: &#x27;top&#x27;,            data: [&#x27;销售&#x27;],            textStyle:&#123;                color:&#x27;#00ffff&#x27;            &#125;        &#125;,        color:[&quot;#72b332&quot;,&#x27;#35a9e0&#x27;],        tooltip: &#123;            trigger: &#x27;axis&#x27;        &#125;,        xAxis: &#123;            type: &#x27;category&#x27;,            data: [],            axisLabel : &#123;                textStyle: &#123;                    color: &#x27;#ffffff&#x27;                &#125;            &#125;,            splitLine:&#123;                show:true,                lineStyle:&#123;                    color: &#x27;#c2f602&#x27;                &#125;            &#125;,        &#125;,        yAxis: [&#123;            type: &#x27;value&#x27;,            axisLabel : &#123;                textStyle: &#123;                    color: &#x27;#ffffff&#x27;                &#125;            &#125;        &#125;],        series: [&#123;            name: &#x27;销售&#x27;,            data: [],            type: &#x27;line&#x27;,        &#125;        ]    &#125;;    /*左下*/    var sexrate = echarts.init(document.getElementById(&#x27;sexrate&#x27;));    bar1Option = &#123;        title: &#123;            text: &#x27;柱状图&#x27;,            textStyle:&#123;                color:&quot;#fff&quot;            &#125;,        &#125;,        legend: &#123;            top: &#x27;top&#x27;,            data: [&#x27;11&#x27;,&#x27;22&#x27;],            textStyle:&#123;                color:&#x27;#00ffff&#x27;            &#125;        &#125;,        tooltip: &#123;            trigger: &#x27;axis&#x27;        &#125;,        xAxis: &#123;            type: &#x27;category&#x27;,            data: [],            axisLabel : &#123;                textStyle: &#123;                    color: &#x27;#ffffff&#x27;                &#125;            &#125;,        &#125;,        yAxis: &#123;            type: &#x27;value&#x27;,            axisLabel : &#123;                textStyle: &#123;                    color: &#x27;#ffffff&#x27;                &#125;            &#125;,        &#125;,        series: [&#123;            name: &#x27;11&#x27;,            data: [],            type: &#x27;bar&#x27;        &#125;,            &#123;                name: &#x27;22&#x27;,                data: [111,222,333,444,0],                type: &#x27;bar&#x27;            &#125;        ]    &#125;;       /* 中上*/    var courserate = echarts.init(document.getElementById(&#x27;courserate&#x27;));    pie1Option = &#123;        title: &#123;            text: &#x27;饼图示例&#x27;,            left: &#x27;left&#x27;        &#125;,        legend: &#123;            orient: &#x27;vertical&#x27;,            right: &#x27;0&#x27;,            y: &#x27;middle&#x27;,            textStyle: &#123;                color: &quot;#fff&quot;            &#125;        &#125;,        tooltip: &#123;            trigger: &#x27;item&#x27;        &#125;,        series: [            &#123;                name: &#x27;面积模式&#x27;,                type: &#x27;pie&#x27;,                radius : &#x27;45%&#x27;,                center: [&#x27;50%&#x27;, &#x27;50%&#x27;],                roseType: &#x27;area&#x27;,                itemStyle: &#123;                    borderRadius: 8                &#125;,                data: [                ]            &#125;        ]    &#125;;    /* 中上*/    var professionrate = echarts.init(document.getElementById(&#x27;professionrate&#x27;));    pie2Option = &#123;        title: &#123;            text: &#x27;饼图示例&#x27;,            left: &#x27;left&#x27;        &#125;,        legend: &#123;            orient: &#x27;vertical&#x27;,            right: &#x27;0&#x27;,            y: &#x27;middle&#x27;,            textStyle: &#123;                color: &quot;#fff&quot;            &#125;        &#125;,        tooltip: &#123;            trigger: &#x27;item&#x27;        &#125;,        series: [            &#123;                name: &#x27;面积模式&#x27;,                type: &#x27;pie&#x27;,                radius : &#x27;45%&#x27;,                center: [&#x27;50%&#x27;, &#x27;50%&#x27;],                roseType: &#x27;area&#x27;,                itemStyle: &#123;                    borderRadius: 8                &#125;,                data: [                ]            &#125;        ]    &#125;;     /* 热力图*/    /* 地图 需要哪个省市的地图直接引用js 将下面的name以及mapType修改为对应省市名称*/    /* 地图 需要哪个省市的地图直接引用js 将下面的name以及mapType修改为对应省市名称*/    var maps = echarts.init(document.getElementById(&#x27;mapadd&#x27;));    option = &#123;        tooltip : &#123;            trigger: &#x27;item&#x27;,            formatter: &#x27;&#123;b&#125;&#x27;        &#125;,        series : [&#123;            name: &#x27;上海&#x27;,            type: &#x27;map&#x27;,            mapType: &#x27;上海&#x27;,            roam: false,            top:&#x27;8%&#x27;,            zoom:1.2,            x:&#x27;25%&#x27;,            selectedMode : &#x27;single&#x27;,//multiple多选            itemStyle:&#123;                normal:&#123;                    label:&#123;                        show:true,                        textStyle: &#123;                            color: &quot;#231816&quot;                        &#125;                    &#125;,                    areaStyle:&#123;color:&#x27;#B1D0EC&#x27;&#125;,                    color:&#x27;#B1D0EC&#x27;,                    borderColor:&#x27;#dadfde&#x27;//区块的边框颜色                &#125;,                emphasis:&#123;//鼠标hover样式                    label:&#123;                        show:true,                        textStyle:&#123;                            color:&#x27;#fa4f04&#x27;                        &#125;                    &#125;,                    areaStyle:&#123;color:&#x27;red&#x27;&#125;                &#125;            &#125;,            data:[                &#123;name:&#x27;宝山区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#f69009&#x27;,                            borderColor: &#x27;#edce00&#x27;                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;嘉定区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#ce05c4&#x27;,                            borderColor: &#x27;#0abcee&#x27;                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;虹口区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#92d050&#x27;,                            borderColor: &#x27;#1ca9f2&#x27;                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;黄浦区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#88ddf5&#x27;,                            borderColor: &#x27;#88ddf5&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;静安区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#13d5ff&#x27;,                            borderColor: &#x27;#45b5ef&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;浦东新区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#13d5ff&#x27;,                            borderColor: &#x27;#45b5ef&#x27;                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;普陀区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#45b5ef&#x27;,                            borderColor: &#x27;#45b5ef&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;徐汇区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#ffd811&#x27;,                            borderColor: &#x27;#45b5ef&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;闸北区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#ffa312&#x27;,                            borderColor: &#x27;#45b5ef&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;杨浦区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#92d050&#x27;,                            borderColor: &#x27;#1ca9f2&#x27;                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;长宁区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#054757&#x27;,                            borderColor: &#x27;#0cbbec&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;青浦区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;rgba(35,255,19,0.6)&#x27;,                            borderColor: &#x27;#0d1dd0&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;松江区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#f5d60c&#x27;,                            borderColor: &#x27;#160457&#x27;                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;奉贤区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#38d70a&#x27;,                            borderColor: &#x27;#010d13&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;闵行区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#d71d95&#x27;,                            borderColor: &#x27;#599abb&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;金山区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;red&#x27;,                            borderColor: &#x27;#45b5ef&#x27;,                        &#125;                    &#125;                &#125;,                &#123;name:&#x27;崇明区&#x27;,                    itemStyle: &#123;                        normal: &#123;                            areaColor: &#x27;#0928f3&#x27;,                            borderColor: &#x27;#45b5ef&#x27;,                        &#125;                    &#125;                &#125;,            ]        &#125;]    &#125;;    maps.setOption(option);    /*右上*/    var juniorservice = echarts.init(document.getElementById(&#x27;juniorservice&#x27;));    scatterOption = &#123;        title: &#123;            text: &#x27;散点图堆叠&#x27;,            textStyle:&#123;                color:&quot;#fff&quot;            &#125;,        &#125;,        // 区域缩放控制器        dataZoom: &#123;            orient: &#x27;horizontal&#x27;,      // 布局方式，默认为水平布局，可选为：                                       // &#x27;horizontal&#x27; ¦ &#x27;vertical&#x27;            // x: &#123;number&#125;,            // 水平安放位置，默认为根据grid参数适配，可选为：            // &#123;number&#125;（x坐标，单位px）            // y: &#123;number&#125;,            // 垂直安放位置，默认为根据grid参数适配，可选为：            // &#123;number&#125;（y坐标，单位px）            // width: &#123;number&#125;,        // 指定宽度，横向布局时默认为根据grid参数适配            // height: &#123;number&#125;,       // 指定高度，纵向布局时默认为根据grid参数适配            backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,       // 背景颜色            dataBackgroundColor: &#x27;#eee&#x27;,            // 数据背景颜色            fillerColor: &#x27;rgba(144,197,237,0.2)&#x27;,   // 填充颜色        &#125;,        xAxis: &#123;            type: &#x27;category&#x27;,            data: [],            axisLabel: &#123;                textStyle: &#123;                    color: &#x27;#ffffff&#x27;                &#125;            &#125;        &#125;,        yAxis: &#123;            type: &#x27;value&#x27;,            axisLabel : &#123;                textStyle: &#123;                    color: &#x27;#ffffff&#x27;                &#125;            &#125;        &#125;,        tooltip: &#123;            trigger: &#x27;axis&#x27;        &#125;,        series: [            &#123;                symbolSize: 5,                data: [                ],                type: &#x27;scatter&#x27;            &#125;        ]    &#125;;/*右下*/    var edubalance = echarts.init(document.getElementById(&#x27;edubalance&#x27;));    barOption = &#123;        title: &#123;            text: &#x27;柱状图&#x27;,            textStyle:&#123;                color:&quot;#fff&quot;            &#125;,        &#125;,        legend: &#123;            top: &#x27;top&#x27;,            data: [&#x27;11&#x27;,&#x27;22&#x27;],            textStyle:&#123;                color:&#x27;#00ffff&#x27;            &#125;        &#125;,        tooltip: &#123;            trigger: &#x27;axis&#x27;        &#125;,        xAxis: &#123;            type: &#x27;category&#x27;,            data: [],            axisLabel : &#123;                textStyle: &#123;                    color: &#x27;#ffffff&#x27;                &#125;            &#125;,        &#125;,        yAxis: &#123;            type: &#x27;value&#x27;,            axisLabel : &#123;                textStyle: &#123;                    color: &#x27;#ffffff&#x27;                &#125;            &#125;,        &#125;,        series: [&#123;            name: &#x27;11&#x27;,            data: [],            type: &#x27;bar&#x27;        &#125;,            &#123;                name: &#x27;22&#x27;,                data: [111,222,333,444,0],                type: &#x27;bar&#x27;            &#125;        ]    &#125;;    fetch(&quot;/echarts&quot;).then(response =&gt; response.json()).then(res =&gt; &#123;        // 折线图        const date = res.map(v =&gt; v.date);        lineOption.xAxis.data = date        const count = res.map(v =&gt; v.count);        lineOption.series[0].data = count        graduateyear.setOption(lineOption)        // 中上        res.forEach(item =&gt; &#123;            pie1Option.series[0].data.push(&#123;name: item.name, value: item.count&#125;)        &#125;)        courserate.setOption(pie1Option);        // 中上        res.forEach(item =&gt; &#123;            pie2Option.series[0].data.push(&#123;name: item.name, value: item.count&#125;)        &#125;)        professionrate.setOption(pie2Option);        //右下        barOption.xAxis.data = date        barOption.series[0].data = count        edubalance.setOption(barOption)        //右上        scatterOption.xAxis.data = date        scatterOption.series[0].data = count        juniorservice.setOption(scatterOption);        //左下        bar1Option.xAxis.data = date        bar1Option.series[0].data = count        sexrate.setOption(bar1Option)    &#125;)    setTimeout(&quot;get()&quot;, 100)&#125;)\n\n3、上海地图的js!function(B,A)&#123;&quot;function&quot;==typeof define&amp;&amp;define.amd?define([&quot;exports&quot;,&quot;echarts&quot;],A):&quot;object&quot;==typeof exports&amp;&amp;&quot;string&quot;!=typeof exports.nodeName?A(exports,require(&quot;echarts&quot;)):A(&#123;&#125;,B.echarts)&#125;(this,function(B,A)&#123;var D=function(B)&#123;&quot;undefined&quot;!=typeof console&amp;&amp;console&amp;&amp;console.error&amp;&amp;console.error(B)&#125;;A?A.registerMap?A.registerMap(&quot;上海&quot;,&#123;type:&quot;FeatureCollection&quot;,features:[&#123;id:&quot;310101&quot;,type:&quot;Feature&quot;,geometry:&#123;type:&quot;Polygon&quot;,coordinates:[&quot;@@AHV@BDCPEPLENFHCJHFBNCAGBGXWFIBGCGMUKKCCcGCDGBALCPIAAPGR&quot;],encodeOffsets:[[124373,31970]]&#125;,properties:&#123;cp:[121.490317,31.222771],name:&quot;黄浦区&quot;,childNum:1&#125;&#125;,&#123;id:&quot;310104&quot;,type:&quot;Feature&quot;,geometry:&#123;type:&quot;Polygon&quot;,coordinates:[&quot;@@CEAMMAA@C@AFA@@BC@ABC@@BD@@BH@@BB@EHDDCBECADGEEAEBFNET]CMRELQjOEGRFBAHDBAHH@@B@BDA`H@F@BC@AB@FD@DD@@@CH@DDAFDD^LEPF@DFTDPHHQBOJBDOBKHADCOGCEAE@EFOBMAEUW@GBEHILMBE@KGM&quot;],encodeOffsets:[[124381,31859]]&#125;,properties:&#123;cp:[121.43752,31.179973],name:&quot;徐汇区&quot;,childNum:1&#125;&#125;,&#123;id:&quot;310105&quot;,type:&quot;Feature&quot;,geometry:&#123;type:&quot;Polygon&quot;,coordinates:[&quot;@@@AACE@FO]KCCBECCG@@D@@CCmBSAcKG@EBAEGC@DC@QE@CA@@BEBMTNFAFDBA`D@BDA@AA@FFBBLD@@@IBDBABDB@@DBADB@CHA@@DC@C@@@BBABFDH@AHD@ACDA@FD@BCA@@CJCNWJ@BCHAFEF@XCV@DFH@VFBBCFD@HEFFFBB@@IDAJFBABIFK&quot;],encodeOffsets:[[124354,31964]]&#125;,properties:&#123;cp:[121.4222,31.218123],name:&quot;长宁区&quot;,childNum:1&#125;&#125;,&#123;id:&quot;310106&quot;,type:&quot;Feature&quot;,geometry:&#123;type:&quot;Polygon&quot;,coordinates:[&quot;@@AB@PCJBNG@ABBDBB@DNBAJJ@@FB@@H@@@DF@ENB@BDD@BAT@BENDFDPB@AF@A]G@BOCKCEBA@G@KBEDCLMVQ@EACDECABCDKECGDMEKFFODOACU@BGOGUCELAJABIECBBNFHJBTLHB@BADDD@FB@@DC@BHOVUJCFIG&quot;],encodeOffsets:[[124340,32022]]&#125;,properties:&#123;cp:[121.448224,31.229003],name:&quot;静安区&quot;,childNum:1&#125;&#125;,&#123;id:&quot;310107&quot;,type:&quot;Feature&quot;,geometry:&#123;type:&quot;Polygon&quot;,coordinates:[&quot;@@DB@DHBBCDBB@A@DF@@DFDDHGBDDALZCB@@EBA@ACQ@@DGBEFBB@FD@J@BFMBCCCDID@AODAEIDBDEBABBB@DC@AF@@AFGACBADBB@@NFADD@@BB@B@BAB@@@BBDA@HBB@AJ@@AD@@BB@AFHBDCJFHBGQAAJA@ALCBBF@@AB@@BD@@@JABDABD@@BHBBBNACEJA@ADAAA@B@ADAAAJBIQB@FCBBD@AGJ@@EJA@EHADDAB@BFANNDEVIPUAGD@@CA@@ECCBC@AGASKIAEGACA@EAEEA@EFC@DEAAUEG@CEU@WDE@EFGBADI@MV&quot;],encodeOffsets:[[124267,31987]]&#125;,properties:&#123;cp:[121.392499,31.241701],name:&quot;普陀区&quot;,childNum:1&#125;&#125;,&#123;id:&quot;310109&quot;,type:&quot;Feature&quot;,geometry:&#123;type:&quot;Polygon&quot;,coordinates:[&quot;@@@OHWVFBABIKK@MJCJGBKV[C@@I[AOEODCACCCLADDBCFBD@FURQT@J@F@HABDFDLAPH@BTVCLBBE&quot;],encodeOffsets:[[124402,32064]]&#125;,properties:&#123;cp:[121.491832,31.26097],name:&quot;虹口区&quot;,childNum:1&#125;&#125;,&#123;id:&quot;310110&quot;,type:&quot;Feature&quot;,geometry:&#123;type:&quot;Polygon&quot;,coordinates:[&quot;@@@JD@U\\\\ALIHID@NLLAJABUEGX@PVA@ZDDADGFX`ZKDHFAFHpSNGDCDGDM@cBGL[BKAGEGMOcY[GWA&quot;],encodeOffsets:[[124433,31997]]&#125;,properties:&#123;cp:[121.522797,31.270755],name:&quot;杨浦区&quot;,childNum:1&#125;&#125;,&#123;id:&quot;310112&quot;,type:&quot;Feature&quot;,geometry:&#123;type:&quot;Polygon&quot;,coordinates:[&quot;@@@EBAD@@A@E_GCB@A@AG@BGCABGEAHQPFRiFKNQ^DFSEMFAFBHFBCFDDACCFGA@@AG@@AC@@AD@BAD@@AB@BED@B@F@B@FBBNDFLCDBCBFB@DFG@CBBABDB@CDBAFCB@DABD@B@DB@BD@@B@BB@B@@FJ@DKLFB@DMDBBABBCFDB@@HB@BBABBDCBGNBDAB@@BPDBAF@@AB@@AB@@CDB@BF@DGB@@CD@FDADF@BADDDCBBDCAAC@BCFEAAB@FECABC@ADBBEB@@EGCABAB@@CAA@CAIABAAA@@ECDGD@BCBBD@BBHBFALABAFBD@@CGA@BC@BCEAA@A@@AEA@@AAA@G@DCG@CCBAAA@ADBDAEAC@ACE@BCC@BG@ACBBAEAAA@B@CECDEAEBAB@BDB@DBD@BBD@FDBGBBFCAABCBDBCEC@UBACA@AAA@ABB@CCCE@AA@ADCD@@BF@@FB@@BDB@CDB@ED@DFB@ABB@HDAADCBE@CCACC@CACIABA@@@BD@@AD@DICABCECFA@AMEO@@CC@ABA@@ABA@GCACBADCDA@@BAAAB@BICADE@@BEAABC@GHC@E@@FD@@BA@CFC@@BC@AASEKG@ACAIZBFGDYCIAKGKAU@OCGAKIMIMCOEeCWOBQHI@C@CBB\\\\HBPTBHJHABECM@ADBB@J@F@D@B@FBDAD@NBBBN@T@DBBADFCFDDGTDJFAFNB@DB@EFFBADD@@DFDDCDBADERCDAB@DELGAADMCEPHB@AB@@BHF@@GNQV@DEJCDC@ADD@@BCFABADA@@FCB@DCD@DABA@EJEF@BEJCLGJABCHAB@BABCFCB@BED@BA@@BABADGFAAA@@CAAKGCAKAUTC@CDDBADIHDFCF@@CDBDCHDBAHGDBDCDABCAABAFKACBDDABBF@@@BHBBDDBC@BDFFFBBDD@@AH@HB@EFC@ABC@FFCFBB@LCFBBAEGFEDABGJMJCL@XGNFH@PDBB@FHDBAAA@@D@D@@CB@DGA@BCCA@@CABACAJA@@C@AKEA@EBBB@ACC@B_CABEMENSFA@AB@@DRFD@@CHDBFFAH@dLTBjA&quot;],encodeOffsets:[[124327,31940]]&#125;,properties:&#123;cp:[121.375972,31.111658],name:&quot;闵行区&quot;,childNum:1&#125;&#125;,&#123;id:&quot;310113&quot;,type:&quot;Feature&quot;,geometry:&#123;type:&quot;Polygon&quot;,coordinates:[&quot;@@@JE@@BOAECMCAFS@ABC@ACA@FME@@C@@@GA@@EI@BIMA@CCA@CBAH@AMDI@OBACEEB@ABACCGB@FIB@FI@BHC@AAEDA@JRIABBCB@B@ABBCB@BIBDFMBAAGA@AC@BAACIB@@C@@AA@@BE@AAKD@BIBBBHRC@ICCCCDGABEA@@AC@@BI@@BAA@GCBAAA@ABBBCDAAEJFDB@P\\\\J@@FB@@DGA@FD@@DAAADCF@@ABBBCDDB@DF@CLCAEFEB@DG@@HD@DB@BB@@FHD@BADA@CFCFABDB@BED@BCDEFFBABB@ADG@GNCBFHAFA@@DCAIB@DB@@FBBEF^JBAH@AFD@A@@DA@@BFDABD@@JB@@BA@AD@DB@@FCJ@FA@C@ABAAABENDB@BCDCFG@ADDBEDDDABA@ADB@ADF@BD@BEACD@BCBJF@BABA@BBCFE@ABCLABBBAFEB@A@BCDEBADD@CBBBBAADBBD@B@BBADFADDDA@ED@ACB@FF@DFBBCB@@AC@@GF@B@AFD@@DB@@AD@@BD@\\\\PfK^I|]BAEGBE\\\\Q`W|i\\\\UdSXUBD@DFAEG\\\\UQQQY@QJONIVIEGEBCGYLW_HEBCCC@YUBAFKAUD&quot;],encodeOffsets:[[124384,32068]]&#125;,properties:&#123;cp:[121.489934,31.398896],name:&quot;宝山区&quot;,childNum:1&#125;&#125;,&#123;id:&quot;310114&quot;,type:&quot;Feature&quot;,geometry:&#123;type:&quot;Polygon&quot;,coordinates:[&quot;@@A@A@@AC@BCME@@AABCDAHBBE@@BED@@CAABAFAACJCBFPC@BJCDCDDNAAEI@C@@EAAFEHA@CR@BDB@FA@@DAKYCBACGHCCCE@@CEB@A@CAADGA@CCAADGB@DB@ADC@@ECBBDC@BGG@CCIC@EAAOCG@OEUHK@IDINAHCBEFFHABEAKDA@EAED@EAD@BED@FGAG@@BC@@AC@@DA@@CCBEA@DGAKFOB@CG@@BAA@CGCBAEA@CA@@DEA@FCFB@ABAAABAC@AAACFGEBCABCCABCCABCAB@@CC@ADGDEEC@EDCA@BA@BDA@ACEFECABC@@BB@BDC@AJIJCAADC@CGEB@@AB@BDF@JDD@DHBABD@B@@BCHE@@BC@@DCA@DC@@DDBADA@EDFBIPCFIIBCMAE@AJ@B@FAB@DAJDB@DDB@FD@@BCBBBB@@DABAB@DCBBBAHBB@FMCKB@HF@EHIACBE@BFCBBLAH@DD@@CD@D@BFNBCDGBAFTHBEBB@DB@@AJD@ANFABBBD@ABD@@ANDBDCD@BABA@ABLDCFDBF@ABC@ABDB@BFDADJDDCCDBDCDAAABBB@BC@ABA@ABC@@HA@C@@DJ@@DFB@BD@HB@AD@ABBDFA@HA@@CA@BDABOBMFAFB@ADBDAB\\\\LDAHBBADBHAPFJFAFBFFD@BJHRD@FHFNHDACCLADBH@DDFABHCB@BHJF@AJ@@FAFDB@AEFE@CBIHB@AC@@AA@DEHD@BD@ADB@BDB@AKD@@DBA@@@AD@DBBDBBDBD@@FDDBA@CDAHDBBHDADB@FA@BD@DCD@BFFCJD@DA@FBBDFADC@A@BFABEAABADKBAF@DEAAB@BA@AIEDA@ADCFB@AACE@BCA@BCB@BACCFCCABCH@DEDC@ACAFMBABBBAD@B@@EDI@EA@@CBCB@@AA@@IC@BAEC@AB@@CB@C@BEG@AB]IFEAA@EA@@CJADB@CB@BEEGDAHMH@BCA@BAEAFEDC@AFC@ACABALQGC@ECCE@@GH@@CFAFEDBDKE@@CCADCAABA@@DEBCBB@CC@@EHB@CA@@EI@GMEMICFIBBBABAAA&quot;],encodeOffsets:[[124249,32046]]&#125;,properties:&#123;cp:[121.250333,31.383524],name:&quot;嘉定区&quot;,childNum:1&#125;&#125;,&#123;id:&quot;310115&quot;,type:&quot;Feature&quot;,geometry:&#123;type:&quot;MultiPolygon&quot;,coordinates:[[&quot;@@bM²WLCļÑNI^_ÈïsJQ¶±`e`Z¡LDCsEWOWs@GBI\\\\wsYg|QNUBģFqAZHZB@@JHBAJFRA@BB@HABB@@J@HBDBLAJC@@BD@ABA@B@AD@FB@@BA@@BA@G@@FC@AB@DA@ABCAC@@DEA@DD@BDEF@FQJE@CAGJA@ABCAEDBDGHADWR_TYJI@G@SD@AA@@AA@IDGB@A@BQBmAA@CBOAGFELC@AAaDACS@C@@AIAABKA@BEBFDADDBCJC@@BC@@A@@ABJBBD@DDDDB@DAFCDBBGCA@BAA@CEC@@FCA@DCA@AA@@EE@@AC@CD@BBBF@DD@DAA@BBB@BDBAB@VFDADACADBBEDAAAHECC@AAC@CAA@ACA@ABBFCFFD@D@ABBFBABDA@BAHD@ADF@BDD@FBCBCA@BBBABDDH@CDH@B@BB@@FB@BB@B@FBADD@@AHB@DC@EAABKBEBGAAAC@AAADC@CHFD@@BBABJBDBB@DB@@BABAHD@FA@AFCA@BADDBEFA@BBEFADD@BBCDAACDCCABE@BCECC@@DA@CHE@@ACA@DA@@BA@@BE@ABOC@AA@CBMAAHCDAAAB@AGA@@CADEAAABCACNA@KECLC@E@@EA@A@@A@AC@@AAAA@A@C@BA@CDABEAAADCABAAA@DEH@CEADACAKDHN@LAFKNGJAF@D@DBFNLHLANEP@FBFJJJDdHDDLLNVDHAHEJWXAF@FJFHDtDXHhZNPFHBHALK\\\\AH@dCNCHCDMHoTUJMJIP@RRZRR&quot;],[&quot;@@PDNAvOFGBKCeEQGEI@IBMNY\\\\GJELATBJ&quot;],[&quot;@@HRHJNBX@XCRGfEFGBM@eYuGIgCIAK@KDMPIREVCXARBP&quot;]],encodeOffsets:[[[124438,32149]],[[124808,31991]],[[124870,31965]]]&#125;,properties:&#123;cp:[121.567706,31.245944],name:&quot;浦东新区&quot;,childNum:3&#125;&#125;,&#123;id:&quot;310116&quot;,type:&quot;Feature&quot;,geometry:&#123;type:&quot;MultiPolygon&quot;,coordinates:[[&quot;@@DBBAGCBD&quot;],[&quot;@@HADA@AGCKHBBF@&quot;],[&quot;@@FACAAD&quot;],[&quot;@@DB@EB@@CB@@GEQ@IEKAM@ATE@EHADF@GDCFFPD^BBED@@BD@@DPBB@@CDB@BLC@ADB@BF@@CF@@DB@BDCDA@@DCACBC@AB@HDBRTHGBCHBDB@AF@B@NACQ@@@AC@@CC@CIEE@CFCFHDBHABDN@BED@BDNA@HAF@FCBADDLD@DAAC@AB@@ANC@ANC@TDBL@DGJC^BDBDBJ@^F\\\\VHGPB@CD@BAF@DKDBBCA@BAC@FK@E@BD@@BNABCF@@AFB@AD@BADB@GA@@AF@BCFBDKB@@BDBB@BEDBBDF@@CFB@HD@@F@@@HA@BBA@BDC@BJADBBLB@AA@@ED@DIHA@BB@BDDBBCBA@@@BF@@CB@ABFBBCFB@BD@FCF@DBBAD@BAD@BABBBAHDJ@ABDDABDBHCBDJIBOFE@IDKJAFCBAJELAAEBCBKAA@GD@AIBEAIDOK@@EDEAABA@A@BB@@@B@B@AAD@@ADA@EJ@@CB@H@BLDBFA@@B@@GEB@EB@@CB@DETAAADA@GH@BHLAPA@ABBD@JU@ABBFCB@£«ugWOCOCgBDaAE`@HCBBFCBAJA@AFDFAFFD@FDFCFBBA@BBAFBDA@CDAAA@STCBWLAAABBBCBAACB@AABBBIFAPCHCFBBCB@HA@CAABGPIBO@ICCEDMGAILADACCBCA@CECEAKCADCBADAAKAEC@HEBCAEDQBACEAAB@BGCYDEJCB@BBFN@B@@JDbHRJL@D@FA@@CCB@DABBDEFACSDA@AAA@DDBLFHAB@BABCAIDADABCEKCABC@CDABBBC@@B@BA@BBcO[@MGDCC@DK_KFMGBCFGADEA@AGCA@@DAD@AFB@BCB@DGOCCLKR]JADEAMMABBCA@CB@BABCAACB@CEAB@CAAGBDFGFHFGBBDFHF@BDB@ABBFDADFF@DHD@DFFADDGDDDADDABDA@DDCDFFBDEBFFDCDBCBDDEBBDB@@@CDCDI@GB@BBFAB]DAHCDDH@DDBHB@DHABDB@@FG@CABJBl@FEFCFBB@LB@J@@GPDA@DD@AD@D@@CCA@BCA@CB@A@@AF@BGFAADDB@ARF&quot;]],encodeOffsets:[[[124321,31442]],[[124337,31429]],[[124341,31419]],[[123933,31687]]]&#125;,properties:&#123;cp:[121.330736,30.724697],name:&quot;金山区&quot;,childNum:4&#125;&#125;,&#123;id:&quot;310117&quot;,type:&quot;Feature&quot;,geometry:&#123;type:&quot;Polygon&quot;,coordinates:[&quot;@@@DLB@BFTHAFB@DABHFELFBBAH@DIHB@GB@@CB@BEDAB@LAPB@DFBADD@@BBBN@@DRB@BADALHABlH@@\\\\ABAFQPOLDBDBDCJBBJFA@FCJC@@DCAABDDBDKHB@CDBDEBCEINHDABFB@DDDD@F@@ABCAA@EB@@CH@B@BCBABD@DLBBCB@R@ADD@BAJ@BBBB@BA@@NG@AFELC@AB@@CBA@KJAAA@CAC@CLD@ABBBGJDBBDCFBBDCFDADBBDCABB@@BA@HHDBABFFDCBBDCB@BABB@AFEBBBED@FEDDBED@BALB@CD@DEHBBGDBBCB@BFB@@LC@@FJA@AJB@@B@@FB@@HH@@BJ@CJDDADDBB@B@BCJD@DB@AB@FC@@FC@@D@FDA@X\\\\ILF@CAA@ABBJ@DEXFPBI_CM@CF@NFF@BBB@BAADBLFBJABHKB@@L@BHXCAGBAF@@BB@@BCFBDDBD@BB^ENNEFEAEHCC@DBB@BB@AH@BFCD@B@ABDB@@FAF@ABXFnNHKB@BA@CDC@CDA@EB@BCBADE@AC@BCD@DCFI@CRUHM@@GE@AA@@BGAFONDBCHBFK@CBAHODICACDEC@CC@BCEAFEA@@CMABEIESCCHECEDBCAA@WAMAA@MBCAC@E@A@C@E@IAABCN@FDBAIGAGOSGAA[DAD@J@XIJ@PDDI@ODK@UD@BCAAGADSG@CAA@AABAAAA@@BECBC@IFCBC@CIG@A@AGDCABACCBAA@@@G@GCCB@AABC@ABC@ABCAE@EDC@@AEAADEABAA@@DE@@A@@ABADCAACA@@AGBCJC@@FB@@BMCBCAID@ACB@AAB@@G@@@EC@@GEA@DE@ACCAAFA@CA@AA@CLEAADE@@BB@@HCAABC@@BEA@BE@ADMB@AC@@A@FELD@ABB@ADCACLE@ABC@@DOAGH[U]EI@CACA]AIDCHK@CA@SMD@BMD@BA@@BBDCBC@CKBCDA@EBE@GMBACC@AFM@ACGBCAEGED@DFFDJD@@DD@@B@@DRMBA@E@@BCAGAADGHQSCA@GBAD@DADB@CB@DCACA@@CE@@DE@@ACA@BKD@ACA@DA@OA@CC@@AC@AF]AOCEECD@HCEGB@FSF@BBNFL@JFR@HA@@DA@@FCA&quot;],encodeOffsets:[[123933,31687]]&#125;,properties:&#123;cp:[121.223543,31.03047],name:&quot;松江区&quot;,childNum:1&#125;&#125;,&#123;id:&quot;310118&quot;,type:&quot;Feature&quot;,geometry:&#123;type:&quot;Polygon&quot;,coordinates:[&quot;@@@GCIBA@@FADHD@BCDBJIBID@ACA@@AD@BAFDFEBDB@ACB@@ADBFCD@FFHCBCD@@DA@DBBADDBADDBAADHFDEBB@BBDBABBBAA@DE@EFB@CB@@DFBABHD@DBB@AH@@DPALEHB@CFBDA@DB@@CD@AAEAEEACD@CAACGA@A@@AEBACCDALBBEBADBBADCACHCBGCADGACDC@@DECEJGBCCADCD@VSLBDBLHBB@DB@BBFCDEBA@AB@@AFC@ADADEBA@ABADGBAHIDKJOmMWEBAE@EB@@CABAA@C@ED@ABGA@@AAA@CDDFGFBFEMM]FAAC@CAACDE@AA@@AE@ABBHWDAGK@@@LAAGIBEAAKBCABA@AAE@MEE@@DDNJ`OAWECFI@AA@BBB@DKE[J@WCB@E@CD@@ED@@EBAA@@CICADA@A@CABCCCDII@@AG@@GA@@EA@@@IA@BIB@ED@@KA@AEA@ADCAAHGACFC@@DKAABC@AFCCEFC@AFAAEF@BAAABA@CDAACDEEBACAGGB@@AA@BACDAABCECCDAADGAACAHIAABAC@@EDEB@HBBBLIB@DA@@BAD@FKBEH@@MB@@AAAAAI@ABC@BCQ@A@ADKA@CACABADA@G@@DA@@FBBAD@BE@C@CC@CEABAGCJMDFFAACDCA@LGACCCBADB@CD@DI@EEBAIIACDCACAPKROBEBA@[G@AkGBBKBC@AQA@CM@AA@AC@BCEA@COAKBA@CBAFA@@DA@@HGACJG@ABEAFKGEBA@CEAGBEUKA@CQE@BCABCEBAHE@@BB@A@@DDB@ADB@DC@C@@BCCB@OC@HM@AHC@AHF@CHBF@BC@@DB@ADBB@BNB@BB@@FDB@DC@A@CRA@CFBBAFGAADDB@HA@@DB@@D@@ADBBEJDBM@ADg@ABFFABGBCNGBC@CACBAADAAEFACK[AAAJK@AC@GBEDG@ACOFOEAD@JQ@@FBdCDEL@FCD@H@JHXBPHABDEJ@BEDCACHCFAHA@@EG@QB@BBDE@@DE@AAE@@CG@ABADA@ABCAABCDBLD@DHNJDD@HDHHHJFdDPCTD\\\\JnEMPDvBJHADHBBD@BD@@EHBFCBEDB@AD@HREB@FHD@DHBBGD@H@ABDBL@@AB@@AD@@CFA@BAFFD@BBB@CB@@FHDADB@@DEAADJB@DCHEAABBB@BFBAFEFADJDABIAADFB@DAB@B@BDBABCB@BE@@DD@Kz@DD@@HD@@DC@ADA@A@AFFB@HBA@BAB@FC@@AIBDBDABD@NA@BBBBABBRA@@@dFFDDHEBBHDNFFABDBDADCB@@AB@BCFO@ABCHCD@BBC@@@FDPRF@FA@DB@@AHAACFCHA@DFAACD@BBDAAABAD@BBD@@CDALBFB&quot;],encodeOffsets:[[124062,32028]]&#125;,properties:&#123;cp:[121.113021,31.151209],name:&quot;青浦区&quot;,childNum:1&#125;&#125;,&#123;id:&quot;310120&quot;,type:&quot;Feature&quot;,geometry:&#123;type:&quot;Polygon&quot;,coordinates:[&quot;@@LBBAJB@BD@T@BDbCBBD@FKHEPBDAB@nBRA@A@BHAJCB@@BB@@BTCH@J@ZI`SXQBCHGACFCDBBAB@HIDBF@NGDA@EFEACC@@CFB@CD@DBBAB@@CBAD@@EH@B@@AB@@AA@@EBCA@B@BAC@@AD@BIAKAC@G@IA@BA@GAAB@EQBIGA@IA@GYBYrĥDEU¡_[g¤A@EDAA@BIVC@AA@BOBKBAGG@@HCBBBSBCFA@@DA@@FFA@HA@@@EBCAAKG@A@@DI@@FCB@BC@BBA@A@@@A@@A@BABBBCF@FL@CPBJAFBJC@@HBBALADBFKBIFABEDIBCL@JEFAPKJHFBFADED@JADFD@AB@BBABBBB@DBH@CTHBBBADC@@VCL@PCJTfD^JNJLJHBPDV@LBLHJBZDHCAEJYDB@BLHTFBBD@@AD@DEB@@AC@@EF@D@HGD@BAFB@AF@BCJD@ABABB@AB@DCBCDADB@HAB@BB@BAD@@DP@NF&quot;],encodeOffsets:[[124489,31743]]&#125;,properties:&#123;cp:[121.458472,30.912345],name:&quot;奉贤区&quot;,childNum:1&#125;&#125;,&#123;type:&quot;Feature&quot;,properties:&#123;name:&quot;崇明区&quot;&#125;,geometry:&#123;id:&quot;310151&quot;,type:&quot;MultiPolygon&quot;,coordinates:[[&quot;@@Æp@dG¶YIÐtuÆu¬RWWckĜyPVĆgðÕTUmU¥c&#125;SH¥|÷^oGĝ¬åµxbcAXor]d&quot;],[&quot;@@MURm@kYiD[YRwRmdS^ChQv&quot;],[&quot;@@¬QSzoMUægLShQe^sFwS_aLï&#123;d\\\\ungZeNGZ&quot;]],encodeOffsets:[[[124119,32586]],[[124716,32134]],[[124427,32249]]]&#125;&#125;],UTF8Encoding:!0&#125;):D(&quot;ECharts Map is not loaded&quot;):D(&quot;ECharts is not Loaded&quot;)&#125;);\n\n\n可以自己下载js地图\n\n4、前端显示代码&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge，chrome=1&quot;&gt;    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.css&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/index.css&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;!--头部--&gt;&lt;div class=&quot;header&quot;&gt;    上海项目使用    &lt;a href=&quot;javascript:;&quot; class=&quot;a-access&quot;&gt;    &lt;/a&gt;&lt;/div&gt;&lt;!--主体--&gt;&lt;div class=&quot;main clearfix&quot;&gt;    &lt;div class=&quot;main-left&quot;&gt;        &lt;div class=&quot;border-container&quot;&gt;            &lt;div class=&quot;name-title&quot;&gt;               ===            &lt;/div&gt;            &lt;div id=&quot;graduateyear&quot;&gt;&lt;/div&gt;            &lt;ul class=&quot;three-pie clearfix&quot;&gt;                    &lt;div id=&quot;sexrate&quot;&gt;&lt;/div&gt;                    &lt;span class=&quot;top-left border-span&quot;&gt;&lt;/span&gt;                    &lt;span class=&quot;top-right border-span&quot;&gt;&lt;/span&gt;                    &lt;span class=&quot;bottom-left border-span&quot;&gt;&lt;/span&gt;                    &lt;span class=&quot;bottom-right border-span&quot;&gt;&lt;/span&gt;            &lt;/ul&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;main-middle&quot;&gt;        &lt;div class=&quot;border-container&quot;&gt;            &lt;ul class=&quot;teacher-pie clearfix&quot;&gt;                &lt;li&gt;                    &lt;div class=&quot;name-title&quot;&gt;                        =======                    &lt;/div&gt;                    &lt;div id=&quot;courserate&quot;&gt;&lt;/div&gt;                &lt;/li&gt;                &lt;li&gt;                    &lt;div class=&quot;name-title&quot;&gt;                       =======                    &lt;/div&gt;                    &lt;div id=&quot;professionrate&quot;&gt;&lt;/div&gt;                &lt;/li&gt;            &lt;/ul&gt;            &lt;div class=&quot;name-title&quot;&gt;                ===            &lt;/div&gt;            &lt;div id=&quot;mapadd&quot;&gt;            &lt;/div&gt;            &lt;span class=&quot;top-left border-span&quot;&gt;&lt;/span&gt;            &lt;span class=&quot;top-right border-span&quot;&gt;&lt;/span&gt;            &lt;span class=&quot;bottom-left border-span&quot;&gt;&lt;/span&gt;            &lt;span class=&quot;bottom-right border-span&quot;&gt;&lt;/span&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;main-right&quot;&gt;        &lt;div class=&quot;border-container&quot;&gt;            &lt;div class=&quot;name-title&quot;&gt;             \t===            &lt;/div&gt;          &lt;div id=&quot;juniorservice&quot;&gt;&lt;/div&gt;            &lt;span class=&quot;top-left border-span&quot;&gt;&lt;/span&gt;            &lt;span class=&quot;top-right border-span&quot;&gt;&lt;/span&gt;            &lt;span class=&quot;bottom-left border-span&quot;&gt;&lt;/span&gt;            &lt;span class=&quot;bottom-right border-span&quot;&gt;&lt;/span&gt;        &lt;/div&gt;        &lt;div class=&quot;border-container&quot;&gt;            &lt;div class=&quot;name-title&quot;&gt;                ===            &lt;/div&gt;            &lt;div id=&quot;edubalance&quot;&gt;&lt;/div&gt;            &lt;span class=&quot;top-left border-span&quot;&gt;&lt;/span&gt;            &lt;span class=&quot;top-right border-span&quot;&gt;&lt;/span&gt;            &lt;span class=&quot;bottom-left border-span&quot;&gt;&lt;/span&gt;            &lt;span class=&quot;bottom-right border-span&quot;&gt;&lt;/span&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;assets/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;assets/js/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;assets/js/index.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;assets/js/map/shanghai.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; &gt;    function myrefresh()&#123;        window.location.reload();    &#125;    setTimeout(&quot;myrefresh()&quot;, 5000)&lt;/script&gt;&lt;/html&gt;\n\n5、使用数据库的步骤1.引入pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.example&lt;/groupId&gt;    &lt;artifactId&gt;echarts&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;    &lt;/parent&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;mybatis-plus.version&gt;3.2.0&lt;/mybatis-plus.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!--添加Springmvc依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- mybatis-plus --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;            &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;            &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 数据连接池 druid--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.2.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mysql--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;            &lt;version&gt;5.5.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;fork&gt;true&lt;/fork&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;    &lt;repositories&gt;        &lt;repository&gt;            &lt;id&gt;public&lt;/id&gt;            &lt;name&gt;aliyun nexus&lt;/name&gt;            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;            &lt;releases&gt;                &lt;enabled&gt;true&lt;/enabled&gt;            &lt;/releases&gt;        &lt;/repository&gt;    &lt;/repositories&gt;    &lt;pluginRepositories&gt;        &lt;pluginRepository&gt;            &lt;id&gt;public&lt;/id&gt;            &lt;name&gt;aliyun nexus&lt;/name&gt;            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;            &lt;releases&gt;                &lt;enabled&gt;true&lt;/enabled&gt;            &lt;/releases&gt;            &lt;snapshots&gt;                &lt;enabled&gt;false&lt;/enabled&gt;            &lt;/snapshots&gt;        &lt;/pluginRepository&gt;    &lt;/pluginRepositories&gt;&lt;/project&gt;\n\n2.配置信息application.ymlserver:  port: 1236spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    username: root    password: 密码    url: jdbc:mysql://localhost:3306/echarts?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=GMT%2b8    type: com.alibaba.druid.pool.DruidDataSourcelogging:  level:    com:      example:        debug\n\n3.创建实体类package com.example.entity;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import com.fasterxml.jackson.annotation.JsonFormat;import lombok.Data;import java.util.Date;@Data@TableName(&quot;echarts&quot;)public class Echarts &#123;    @TableId(value = &quot;id&quot;, type = IdType.AUTO)    private Long id;    private String name;    private Integer count;    @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;, timezone = &quot;GMT+8&quot;)    private Date date;&#125;\n\n4.设置对应的mapperpackage com.example.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.example.entity.Echarts;public interface EchartsMapper extends BaseMapper&lt;Echarts&gt; &#123;&#125;\n\n5.添加控制器package com.example.controller;import com.baomidou.mybatisplus.core.toolkit.Wrappers;import com.example.mapper.EchartsMapper;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@RestController@RequestMapping(&quot;/echarts&quot;)public class EchartsController &#123;    @Resource    private EchartsMapper echartsMapper;    @GetMapping    public Object echarts() &#123;        // 查询数据库 echarts表的所有数据        return echartsMapper.selectList(Wrappers.lambdaQuery());    &#125;&#125;\n\n6.添加启动类package com.example;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@MapperScan(&quot;com/example/mapper&quot;)@SpringBootApplicationpublic class App &#123;    public static void main(String[] args) &#123;        SpringApplication.run(App.class,args);        System.out.println(&quot;页面的访问地址：http://localhost:1236/&quot;);    &#125;&#125;\n\n6、注意整合的模板是visual-large-screen-master74套大屏模板第12套\n7、效果图\n","tags":["Anylogic"]},{"title":"Anylogic之百度地图实现动态运行轨迹实现","url":"/2022/06/15/Anylogic%E4%B9%8B%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E5%AE%9E%E7%8E%B0/","content":"​\t要求：一个基于离线百度地图(此方法在线也适用)实时展示车或者其他对象的运行轨迹，且在运行过程中需要车头方向随着角度进行变化。\n1、创建地图&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\t\t&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, user-scalable=no&quot; /&gt;\t\t&lt;style type=&quot;text/css&quot;&gt;\t\tbody, html,#allmap &#123;width: 100%;height: 100%;overflow: hidden;margin:0;font-family:&quot;微软雅黑&quot;;&#125;\t\t&lt;/style&gt;\t\t&lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=密匙&quot;&gt;\t\t\t&lt;/script&gt;\t\t&lt;title&gt;单个标注点沿直线的轨迹运动&lt;/title&gt;\t&lt;/head&gt;&lt;body&gt;\t\t&lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\t&lt;script type=&quot;text/javascript&quot;&gt;\t// 百度地图API功能\tvar map=new BMap.Map(&quot;allmap&quot;); // 创建map实例\tmap.centerAndZoom(new BMap.Point(116.36239048877775, 39.938322220559), 15);// 初始化地图,设置中心点坐标和地图级别\tmap.enableScrollWheelZoom(true);//鼠标滚轮缩放\tmap.addControl(new BMap.MapTypeControl()); //添加切换地图类型附件&lt;/script&gt;\n\n2、绘制折线路径点var PointArr = [\t\t\t&#123;&quot;lng&quot;:116.36239048877775,&quot;lat&quot;:39.938322220559&#125;,\t\t\t&#123;&quot;lng&quot;:116.36239048877775,&quot;lat&quot;:39.93793496684673&#125;,\t\t\t&#123;&quot;lng&quot;:116.36239048877775,&quot;lat&quot;:39.93760303333522&#125;,\t\t\t&#123;&quot;lng&quot;:116.36246235321855,&quot;lat&quot;:39.936883838492925&#125;,\t\t\t&#123;&quot;lng&quot;:116.36246235321855,&quot;lat&quot;:39.93627528306042&#125;,\t\t\t&#123;&quot;lng&quot;:116.36246235321855,&quot;lat&quot;:39.93577737001302&#125;,\t\t\t&#123;&quot;lng&quot;:116.36246235321855,&quot;lat&quot;:39.93527945331416&#125;,\t\t\t&#123;&quot;lng&quot;:116.36260608210014,&quot;lat&quot;:39.93472620825511&#125;,\t\t\t&#123;&quot;lng&quot;:116.36260608210014,&quot;lat&quot;:39.933785681309004&#125;,\t\t\t&#123;&quot;lng&quot;:116.36274981098174,&quot;lat&quot;:39.9334537275117&#125;,\t\t\t&#123;&quot;lng&quot;:116.36267794654094,&quot;lat&quot;:39.93295579377289&#125;,\t\t\t&#123;&quot;lng&quot;:116.36267794654094,&quot;lat&quot;:39.932402529780596&#125;,\t\t\t&#123;&quot;lng&quot;:116.36267794654094,&quot;lat&quot;:39.93184926128044&#125;,\t\t\t&#123;&quot;lng&quot;:116.36267794654094,&quot;lat&quot;:39.93063205471247&#125;,\t\t\t&#123;&quot;lng&quot;:116.36274981098174,&quot;lat&quot;:39.92902752181022&#125;,\t\t\t&#123;&quot;lng&quot;:116.36282167542254,&quot;lat&quot;:39.92841889596463&#125;,\t\t\t&#123;&quot;lng&quot;:116.36282167542254,&quot;lat&quot;:39.92781026466464&#125;,\t\t\t&#123;&quot;lng&quot;:116.36289353986334,&quot;lat&quot;:39.92703563512155&#125;,\t\t\t&#123;&quot;lng&quot;:116.36289353986334,&quot;lat&quot;:39.926260996743295&#125;,\t\t\t&#123;&quot;lng&quot;:116.36282167542254,&quot;lat&quot;:39.925541681766745&#125;,\t\t\t&#123;&quot;lng&quot;:116.36289353986334,&quot;lat&quot;:39.92449036155915&#125;,\t\t\t&#123;&quot;lng&quot;:116.36296540430413,&quot;lat&quot;:39.92410302895963&#125;,\t\t\t&#123;&quot;lng&quot;:116.36332472650813,&quot;lat&quot;:39.9228303491527&#125;,\t\t\t&#123;&quot;lng&quot;:116.36382777759371,&quot;lat&quot;:39.9228303491527&#125;,\t\t\t&#123;&quot;lng&quot;:116.36469015088329,&quot;lat&quot;:39.922775014707135&#125;,\t\t\t&#123;&quot;lng&quot;:116.36619930414005,&quot;lat&quot;:39.922719680216495&#125;,\t\t\t&#123;&quot;lng&quot;:116.36655862634404,&quot;lat&quot;:39.92288568355318&#125;,\t\t\t&#123;&quot;lng&quot;:116.36627116858085,&quot;lat&quot;:39.9242690289156&#125;,\t\t\t&#123;&quot;lng&quot;:116.36670235522564,&quot;lat&quot;:39.924324362144105&#125;,\t\t\t&#123;&quot;lng&quot;:116.36742099963362,&quot;lat&quot;:39.924324362144105&#125;,\t\t\t&#123;&quot;lng&quot;:116.3684989662456,&quot;lat&quot;:39.924324362144105&#125;,\t\t\t&#123;&quot;lng&quot;:116.36943320397597,&quot;lat&quot;:39.92437969532753&#125;,\t\t\t&#123;&quot;lng&quot;:116.37029557726555,&quot;lat&quot;:39.92437969532753&#125;,\t\t\t&#123;&quot;lng&quot;:116.37094235723274,&quot;lat&quot;:39.92437969532753&#125;,\t\t\t&#123;&quot;lng&quot;:116.37158913719992,&quot;lat&quot;:39.92449036155915&#125;,\t\t\t&#123;&quot;lng&quot;:116.3723796460487,&quot;lat&quot;:39.92443502846588&#125;,\t\t\t&#123;&quot;lng&quot;:116.37302642601588,&quot;lat&quot;:39.92449036155915&#125;,\t\t\t&#123;&quot;lng&quot;:116.37360134154227,&quot;lat&quot;:39.92460102761046&#125;,\t\t\t&#123;&quot;lng&quot;:116.37439185039105,&quot;lat&quot;:39.924545694607346&#125;,\t\t\t&#123;&quot;lng&quot;:116.37496676591743,&quot;lat&quot;:39.924545694607346&#125;,\t\t\t&#123;&quot;lng&quot;:116.37546981700302,&quot;lat&quot;:39.92460102761046&#125;,\t\t\t&#123;&quot;lng&quot;:116.37582913920701,&quot;lat&quot;:39.924656360568505&#125;,\t\t\t&#123;&quot;lng&quot;:116.37669151249659,&quot;lat&quot;:39.924656360568505&#125;,\t\t\t&#123;&quot;lng&quot;:116.37719456358218,&quot;lat&quot;:39.92471169348146&#125;,\t\t\t&#123;&quot;lng&quot;:116.37776947910857,&quot;lat&quot;:39.924767026349365&#125;,\t\t\t&#123;&quot;lng&quot;:116.37848812351655,&quot;lat&quot;:39.924822359172175&#125;,\t\t\t&#123;&quot;lng&quot;:116.37906303904293,&quot;lat&quot;:39.924767026349365&#125;,\t\t\t&#123;&quot;lng&quot;:116.37963795456932,&quot;lat&quot;:39.924822359172175&#125;,\t\t\t&#123;&quot;lng&quot;:116.38006914121411,&quot;lat&quot;:39.924767026349365&#125;,\t\t\t&#123;&quot;lng&quot;:116.38006914121411,&quot;lat&quot;:39.92443502846588&#125;,\t\t\t&#123;&quot;lng&quot;:116.38006914121411,&quot;lat&quot;:39.923992362096946&#125;,\t\t\t&#123;&quot;lng&quot;:116.3801410056549,&quot;lat&quot;:39.92332835713435&#125;,\t\t\t&#123;&quot;lng&quot;:116.3801410056549,&quot;lat&quot;:39.9229410179086&#125;,\t\t\t&#123;&quot;lng&quot;:116.3802128700957,&quot;lat&quot;:39.92227700266861&#125;,\t\t\t&#123;&quot;lng&quot;:116.3802847345365,&quot;lat&quot;:39.92155764550042&#125;,\t\t\t&#123;&quot;lng&quot;:116.3802847345365,&quot;lat&quot;:39.92089361673764&#125;,\t\t\t&#123;&quot;lng&quot;:116.3803565989773,&quot;lat&quot;:39.920229581483945&#125;,\t\t\t&#123;&quot;lng&quot;:116.3803565989773,&quot;lat&quot;:39.91962087679934&#125;,\t\t\t&#123;&quot;lng&quot;:116.3803565989773,&quot;lat&quot;:39.918956829104815&#125;,\t\t\t&#123;&quot;lng&quot;:116.3803565989773,&quot;lat&quot;:39.91829277491945&#125;,\t\t\t&#123;&quot;lng&quot;:116.3804284634181,&quot;lat&quot;:39.91762871424328&#125;,\t\t\t&#123;&quot;lng&quot;:116.3804284634181,&quot;lat&quot;:39.91696464707632&#125;,\t\t\t&#123;&quot;lng&quot;:116.3805721922997,&quot;lat&quot;:39.91524911018613&#125;,\t\t\t&#123;&quot;lng&quot;:116.3805003278589,&quot;lat&quot;:39.914806383957064&#125;,\t\t\t&#123;&quot;lng&quot;:116.3805003278589,&quot;lat&quot;:39.914363654843264&#125;,\t\t\t&#123;&quot;lng&quot;:116.3803565989773,&quot;lat&quot;:39.9136442138807&#125;,\t\t\t&#123;&quot;lng&quot;:116.38186575223406,&quot;lat&quot;:39.91331216163647&#125;,\t\t\t&#123;&quot;lng&quot;:116.38315931216843,&quot;lat&quot;:39.913422845898175&#125;,\t\t\t&#123;&quot;lng&quot;:116.3844528721028,&quot;lat&quot;:39.913422845898175&#125;,\t\t\t&#123;&quot;lng&quot;:116.38553083871477,&quot;lat&quot;:39.91331216163647&#125;,\t\t\t&#123;&quot;lng&quot;:116.38739931417552,&quot;lat&quot;:39.913422845898175&#125;,\t\t\t&#123;&quot;lng&quot;:116.3885491452283,&quot;lat&quot;:39.913367503789864&#125;,\t\t\t&#123;&quot;lng&quot;:116.38977084072187,&quot;lat&quot;:39.91358887195269&#125;,\t\t\t&#123;&quot;lng&quot;:116.39092067177464,&quot;lat&quot;:39.91353352997958&#125;,\t\t\t&#123;&quot;lng&quot;:116.39199863838661,&quot;lat&quot;:39.9136442138807&#125;,\t\t\t&#123;&quot;lng&quot;:116.39415457161057,&quot;lat&quot;:39.9136442138807&#125;,\t\t\t&#123;&quot;lng&quot;:116.39551999598574,&quot;lat&quot;:39.91381023939432&#125;,\t\t\t&#123;&quot;lng&quot;:116.3967416914793,&quot;lat&quot;:39.913754897601514&#125;,\t\t\t&#123;&quot;lng&quot;:116.39774779365048,&quot;lat&quot;:39.913865581142055&#125;,\t\t\t&#123;&quot;lng&quot;:116.39810711585447,&quot;lat&quot;:39.913920922844696&#125;,\t\t\t&#123;&quot;lng&quot;:116.39817898029527,&quot;lat&quot;:39.91469570194906&#125;,\t\t\t&#123;&quot;lng&quot;:116.39817898029527,&quot;lat&quot;:39.915304450761944&#125;,\t\t\t&#123;&quot;lng&quot;:116.39810711585447,&quot;lat&quot;:39.91624523365416&#125;,\t\t\t&#123;&quot;lng&quot;:116.39810711585447,&quot;lat&quot;:39.91707532538824&#125;,\t\t\t&#123;&quot;lng&quot;:116.39796338697288,&quot;lat&quot;:39.91773939147339&#125;,\t\t\t&#123;&quot;lng&quot;:116.39803525141367,&quot;lat&quot;:39.9184587890743&#125;,\t\t\t&#123;&quot;lng&quot;:116.39796338697288,&quot;lat&quot;:39.91912284163695&#125;,\t\t\t&#123;&quot;lng&quot;:116.39789152253208,&quot;lat&quot;:39.92045092728972&#125;,\t\t\t&#123;&quot;lng&quot;:116.39774779365048,&quot;lat&quot;:39.9212256319304&#125;,\t\t\t&#123;&quot;lng&quot;:116.39774779365048,&quot;lat&quot;:39.92200032773621&#125;,\t\t\t&#123;&quot;lng&quot;:116.39774779365048,&quot;lat&quot;:39.922719680216495&#125;,\t\t\t&#123;&quot;lng&quot;:116.39767592920968,&quot;lat&quot;:39.923605026657604&#125;,\t\t\t&#123;&quot;lng&quot;:116.39753220032809,&quot;lat&quot;:39.92460102761046&#125;,\t\t\t&#123;&quot;lng&quot;:116.39753220032809,&quot;lat&quot;:39.925541681766745&#125;,\t\t\t&#123;&quot;lng&quot;:116.39746033588729,&quot;lat&quot;:39.92637165990969&#125;,\t\t\t&#123;&quot;lng&quot;:116.39746033588729,&quot;lat&quot;:39.928474225812344&#125;,\t\t\t&#123;&quot;lng&quot;:116.39896948914405,&quot;lat&quot;:39.92958081330031&#125;,\t\t\t&#123;&quot;lng&quot;:116.39997559131523,&quot;lat&quot;:39.92958081330031&#125;,\t\t\t&#123;&quot;lng&quot;:116.40148474457199,&quot;lat&quot;:39.92974679986831&#125;,\t\t\t&#123;&quot;lng&quot;:116.40292203338795,&quot;lat&quot;:39.92980212863415&#125;,\t\t\t&#123;&quot;lng&quot;:116.40443118664471,&quot;lat&quot;:39.92980212863415&#125;,\t\t\t&#123;&quot;lng&quot;:116.40579661101988,&quot;lat&quot;:39.92980212863415&#125;,\t\t\t&#123;&quot;lng&quot;:116.40716203539505,&quot;lat&quot;:39.92991278603061&#125;,\t\t\t&#123;&quot;lng&quot;:116.40852745977021,&quot;lat&quot;:39.92985745735493&#125;,\t\t\t&#123;&quot;lng&quot;:116.4088867819742,&quot;lat&quot;:39.92991278603061&#125;,\t\t\t&#123;&quot;lng&quot;:116.4090305108558,&quot;lat&quot;:39.929470155362914&#125;,\t\t\t&#123;&quot;lng&quot;:116.4091023752966,&quot;lat&quot;:39.928861533484174&#125;,\t\t\t&#123;&quot;lng&quot;:116.4091023752966,&quot;lat&quot;:39.92786559500822&#125;,\t\t\t&#123;&quot;lng&quot;:116.4092461041782,&quot;lat&quot;:39.92637165990969&#125;,\t\t\t&#123;&quot;lng&quot;:116.40946169750059,&quot;lat&quot;:39.92388169505393&#125;,\t\t\t&#123;&quot;lng&quot;:116.40953356194139,&quot;lat&quot;:39.92244300708714&#125;,\t\t\t&#123;&quot;lng&quot;:116.40938983305979,&quot;lat&quot;:39.92161298093767&#125;,\t\t\t&#123;&quot;lng&quot;:116.40938983305979,&quot;lat&quot;:39.92039559090589&#125;,\t\t\t&#123;&quot;lng&quot;:116.40938983305979,&quot;lat&quot;:39.919178179057525&#125;,\t\t\t&#123;&quot;lng&quot;:116.40960542638219,&quot;lat&quot;:39.91685396858412&#125;,\t\t\t&#123;&quot;lng&quot;:116.40960542638219,&quot;lat&quot;:39.91574717374566&#125;,\t\t\t&#123;&quot;lng&quot;:116.40960542638219,&quot;lat&quot;:39.914751042975595&#125;,\t\t\t&#123;&quot;lng&quot;:116.40974915526378,&quot;lat&quot;:39.91419763068185&#125;,\t\t\t&#123;&quot;lng&quot;:116.40802440868462,&quot;lat&quot;:39.91414228920457&#125;,\t\t\t&#123;&quot;lng&quot;:116.40665898430946,&quot;lat&quot;:39.91419763068185&#125;,\t\t\t&#123;&quot;lng&quot;:116.40594033990148,&quot;lat&quot;:39.91408694768221&#125;,\t\t\t&#123;&quot;lng&quot;:116.40594033990148,&quot;lat&quot;:39.91309079257217&#125;,\t\t\t&#123;&quot;lng&quot;:116.40579661101988,&quot;lat&quot;:39.9118179064571&#125;,\t\t\t&#123;&quot;lng&quot;:116.40608406878307,&quot;lat&quot;:39.91087706226448&#125;,\t\t\t&#123;&quot;lng&quot;:116.40615593322387,&quot;lat&quot;:39.91010223961911&#125;,\t\t\t&#123;&quot;lng&quot;:116.40629966210547,&quot;lat&quot;:39.909272062695706&#125;,\t\t\t&#123;&quot;lng&quot;:116.40608406878307,&quot;lat&quot;:39.90871860577934&#125;,\t\t\t&#123;&quot;lng&quot;:116.40615593322387,&quot;lat&quot;:39.90766702522079&#125;,\t\t\t&#123;&quot;lng&quot;:116.40601220434228,&quot;lat&quot;:39.90689216597646&#125;,\t\t\t&#123;&quot;lng&quot;:116.4050061021711,&quot;lat&quot;:39.90667077599834&#125;,\t\t\t&#123;&quot;lng&quot;:116.40320949115115,&quot;lat&quot;:39.90667077599834&#125;,\t\t\t&#123;&quot;lng&quot;:116.40134101569039,&quot;lat&quot;:39.90661542839114&#125;,\t\t\t&#123;&quot;lng&quot;:116.39904135358485,&quot;lat&quot;:39.90683681854954&#125;,\t\t\t&#123;&quot;lng&quot;:116.39746033588729,&quot;lat&quot;:39.90667077599834&#125;]\n\n3、设置小车图标var myIcon=new BMap.Icon(&quot;http://lbsyun.baidu.com/jsdemo/img/Mario.png&quot;, new BMap.Size(32, 70), &#123; \t\t\toffset: new BMap.Size(0, -5),   \t\t//相当于CSS精灵\t\t\timageOffset: new BMap.Size(0, 0)\t\t//图片的偏移量。为了是图片底部中心对准坐标点。\t\t&#125;);\tvar carMk;//先将终点坐标展示的mark对象定义       //小车行驶图标       var drivingPoint = myIcon;       //终点图标       var terminalPoint = myIcon;\n\n4、展示实时画线的效果我们将数组300毫秒取出一个，这里时间间隔可以根据自己需求设定。然后将取出值存储到新的数组里，通过数组拿出前后两个值进行画线。\nvar i = 0;       var interval = setInterval(function () &#123;           if (i &gt;= PointArr.length) &#123;               clearInterval(interval);               return;           &#125;           drawLine(map,PointArr[i],PointArr[i+1]);//画线调用           i = i + 1;       &#125;, 300);\n\n5、绘制运动路径调用方法：function drawLine(map,PointArr,PointArrNext) &#123;         if(PointArrNext!=undefined) &#123;             var polyline = new BMap.Polyline(                 [                     new BMap.Point(PointArr.lng, PointArr.lat),                     new BMap.Point(PointArrNext.lng, PointArrNext.lat)                 ],                 &#123;                     strokeColor: &quot;red&quot;,                     strokeWeight: 7,                     strokeOpacity: 1                 &#125;);   //创建折线             map.addOverlay(polyline);//将折线添加到地图上             addMarkerEnd(new BMap.Point(PointArrNext.lng, PointArrNext.lat), &#x27;小车行驶&#x27;, map, PointArrNext, new BMap.Point(PointArr.lng, PointArr.lat));//添加图标         &#125;else &#123;             addMarkerEnd(new BMap.Point(PointArr.lng, PointArr.lat), &#x27;终点&#x27;, map);//添加终点图标         &#125;     &#125;\n\n6、模拟出运动效果交互没关，在画下一次图标时候先将前一个图标清除掉，重新绘制新位置的图标；\nfunction addMarkerEnd(point, name,mapInit,trackUnit,prePoint) &#123;          if(name==&quot;小车行驶&quot;)&#123;              if(carMk)&#123;//先判断第一次进来的时候这个值有没有定义，有的话就清除掉上一次的。然后在进行画图标。第一次进来时候没有定义也就不走这块，直接进行画图标                  mapInit.removeOverlay(carMk);              &#125;              carMk = new BMap.Marker(point,&#123;icon:drivingPoint&#125;);  // 创建标注              getCarAngle(point,prePoint);// js求解两点之间的角度              carMk.setRotation(getCarAngle(point,prePoint)-90);// 旋转的角度              mapInit.addOverlay(carMk);               // 将标注添加到地图中\t\t//carMk.setAnimation(BMAP_ANIMATION_BOUNCE); //跳动的动画          &#125;else &#123;              mapInit.removeOverlay(carMk);              // carMk = new BMap.Marker(point,&#123;icon:terminalPoint&#125;);  // 创建标注              // mapInit.addOverlay(carMk);          &#125;      &#125;\n\n7、获得角度的函数比如汽车运动时，图标肯定是有朝向的，比如车头永远朝前面，所以我们需要对角度方向进行调整，所以我们就根据点的经纬度调整方向，代码如下：\nfunction getCarAngle(n,next)&#123;          var ret          var w1 = n.lat/180 * Math.PI          var j1 = n.lng/180 * Math.PI          var w2 = next.lat/180 * Math.PI          var j2 = next.lng/180 * Math.PI          ret = 4 * Math.pow(Math.sin((w1 - w2) / 2), 2) - Math.pow(Math.sin((j1 - j2) / 2) * (Math.cos(w1) - Math.cos(w2)), 2);          ret = Math.sqrt(ret);          // var temp = Math.sin(Math.abs(j1 - j2) / 2) * (Math.cos(w1) + Math.cos(w2));          var temp = Math.sin((j1 - j2) / 2) * (Math.cos(w1) + Math.cos(w2));          console.log(temp)          ret = ret/temp;          ret = Math.atan(ret) / Math.PI * 180 ;          ret += 90;          // 这里用如此臃肿的if..else是为了判定追踪单个点的具体情况,从而调整ret的值          if(j1-j2 &lt; 0)&#123;              if(w1-w2 &lt; 0)&#123;                  ret;              &#125;else&#123;                  ret = -ret+180;              &#125;          &#125;else&#123;              if(w1-w2 &lt; 0)&#123;                  ret = 180+ret;              &#125;else&#123;                  ret = -ret;              &#125;          &#125;          return ret ;      &#125;\n\n8、删除折线覆盖物在这个基础上添加一个功能，当小车到达终点时，将绘制的折线全部删除。在百度地图中所有的覆盖物都是通过map.addOverlay存储的，也就是存在同一个地方，正好轨迹覆盖物是折线，那就找到所有的折线覆盖物删除即可。\nfunction addMarkerEnd(point, name,mapInit,trackUnit,prePoint,p) &#123;          if(name==&quot;小车行驶&quot;)&#123;              if(carMk)&#123;//先判断第一次进来的时候这个值有没有定义，有的话就清除掉上一次的。然后在进行画图标。第一次进来时候没有定义也就不走这块，直接进行画图标                  mapInit.removeOverlay(carMk);              &#125;              carMk = new BMap.Marker(point,&#123;icon:drivingPoint&#125;);  // 创建标注              getCarAngle(point,prePoint);// js求解两点之间的角度              carMk.setRotation(getCarAngle(point,prePoint)-90);// 旋转的角度              mapInit.addOverlay(carMk);               // 将标注添加到地图中\t\t//carMk.setAnimation(BMAP_ANIMATION_BOUNCE); //跳动的动画          &#125;else &#123;              mapInit.removeOverlay(carMk);              var allOverlay = map.getOverlays();////返回地图上的所有覆盖物                  for (var i = 0; i &lt; allOverlay.length; i++)&#123;                      if(allOverlay[i].toString().indexOf(&quot;Polyline&quot;) &gt; 0)                       &#123;//删除折线                          map.removeOverlay(allOverlay[i]);                      &#125;                  &#125;              // carMk = new BMap.Marker(point,&#123;icon:terminalPoint&#125;);  // 创建标注              // mapInit.addOverlay(carMk);          &#125;      &#125;\n\n","tags":["Anylogic"]},{"title":"Anylogic之百度地图导航","url":"/2022/04/14/Anylogic%E4%B9%8B%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%AF%BC%E8%88%AA/","content":"&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\t\t&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, user-scalable=no&quot; /&gt;\t\t&lt;style type=&quot;text/css&quot;&gt;\t\tbody, html,#allmap &#123;width: 100%;height: 100%;overflow: hidden;margin:0;font-family:&quot;微软雅黑&quot;;&#125;\t\t&lt;/style&gt;\t\t&lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=GjxdF4HBRYNY0piKp6K7I4U7lOI7Lyor&quot;&gt;\t\t\t&lt;/script&gt;\t\t&lt;title&gt;单个标注点沿直线的轨迹运动&lt;/title&gt;\t&lt;/head&gt;&lt;body&gt;\t\t&lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt;\t// 百度地图API功能\tvar map=new BMap.Map(&quot;allmap&quot;);\tvar startPoint=&#123;lon:116.297611,lat:40.047363&#125;;\tmap.centerAndZoom(new BMap.Point(startPoint.lon, startPoint.lat), 15);\tmap.enableScrollWheelZoom(true);\tvar myIcon=new BMap.Icon(&quot;http://lbsyun.baidu.com/jsdemo/img/Mario.png&quot;, new BMap.Size(32, 70), &#123; \toffset: new BMap.Size(0, -5),   \t//相当于CSS精灵\t\timageOffset: new BMap.Size(0, 0)\t//图片的偏移量。为了是图片底部中心对准坐标点。\t&#125;);\tvar carMk=new BMap.Marker(new BMap.Point(startPoint.lon, startPoint.lat),&#123;icon:myIcon&#125;);\tmap.addOverlay(carMk);\tfunction renderLastPoint(point)&#123;\t\t\t// 实例化一个驾车导航用来生成路线\t\t\tvar driving=new BMap.DrivingRoute(map);\t\t\tvar sp=new BMap.Point(startPoint.lon, startPoint.lat);\t\t\tvar ep=new BMap.Point(point.lon, point.lat);\t\t\tdriving.search(sp, ep);\t\t\t//设置新的开始点\t\t\tstartPoint=point;\t\t\tdriving.setSearchCompleteCallback(function(res)&#123;\t\t\t\t\tconsole.info(res);\t\t\t\t\tif(driving.getStatus()==BMAP_STATUS_SUCCESS)&#123;\t\t\t\t//获取两点之间的实际点组            \t\t\tvar plan=res.getPlan(0);            \t\t\tvar arrPois=[];            \t\t\tfor(var j=0;j&lt;plan.getNumRoutes();j++)&#123;                \t\t\t\tvar route=plan.getRoute(j);                \t\t\t\tarrPois=arrPois.concat(route.getPath());         \t\t\t&#125;\t\t\t\t\t\t//把实际点加到地图上           \t\t\t//根据点组的长度画线和画点\t\t\t\t\t\tdrawMap(arrPois);\t\t\t\t\t&#125;\t\t\t&#125;);\t&#125;\tvar t30=10*1000;\tfunction drawMap(pointArr)&#123;\t\t\tif(pointArr.length==0)&#123;\t\t\t\t\treturn;\t\t\t&#125;\t\t\tvar t=t30;//30秒\t\t//计算每次执行的时间\t\t\tvar at=t/pointArr.length;\t\t\tvar i=0;\t\t\tvar f=function()&#123;\t\t\t\t\tif((i+1)&gt;(pointArr.length-1))&#123;\t\t\t\t\t\t\treturn;\t\t\t\t\t&#125;\t\t\t\t\tvar sp=pointArr[i];\t\t\t\t\tvar ep=pointArr[i+1];\t\t\t\t\t//地图画线\t\t\t\t\tvar polyline=new BMap.Polyline([sp,ep],&#123;strokeColor:&quot;blue&quot;, strokeWeight:2, strokeOpacity:0.5&#125;);\t\t\t//创建折线\t\t\t\t\tmap.addOverlay(polyline);\t\t\t\t\t//移动点\t\t\t\t\tcarMk.setPosition(ep);\t\t\t\t\tvar bound=map.getBounds();//地图可视区域\t\t\t\t\tif(bound.containsPoint(ep)==false)&#123;\t\t\t\t\t\t\tmap.panTo(ep);\t\t\t\t\t&#125;\t\t\t\t\ti++;\t\t\t\t\tsetTimeout(function()&#123;\t\t\t\t\t\t\tf();\t\t\t\t\t&#125;,\t\t\tat);\t\t&#125;;\t\t\tf();\t&#125;\t//模拟业务\tvar _task=setInterval(function()&#123;\t\t\tvar lastPoint=&#123;lon:116.307223,lat:40.056379&#125;;\t\t//终点\t\t\tif(lastPoint.lon==startPoint.lon&amp;&amp;lastPoint.lat==startPoint.lat)&#123;\t\t\t\t\t//相同点，则不需要画图\t\t\t\t\treturn;\t\t\t&#125;\t\t\trenderLastPoint(lastPoint);\t&#125;,1000);&lt;/script&gt;\n\n","tags":["Anylogic"]},{"title":"Anylogic之路书实现一边走一边画","url":"/2022/06/15/Anylogic%E4%B9%8B%E8%B7%AF%E4%B9%A6%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%BE%B9%E8%B5%B0%E4%B8%80%E8%BE%B9%E7%94%BB/","content":"&lt;html &gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;title&gt;轨迹回放(路书)&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        body, html&#123;width: 100%;height: 100%;margin:0;font-family:&quot;微软雅黑&quot;;&#125;        #map_canvas&#123;width:100%;height:500px;&#125;        #result &#123;width:100%&#125;    &lt;/style&gt;&lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;\t\t\t  integrity=&quot;sha256-Qw82+bXyGq6MydymqBxNPYTaUXXq7c8v3CwiYwLLNXU=&quot;\t\t\t  crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=GjxdF4HBRYNY0piKp6K7I4U7lOI7Lyor&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/library/LuShu/1.2/src/LuShu_min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;map_canvas&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;    &lt;button id=&quot;run&quot;&gt;开始&lt;/button&gt;    &lt;button id=&quot;stop&quot;&gt;停止&lt;/button&gt;    &lt;button id=&quot;pause&quot;&gt;暂停&lt;/button&gt;    &lt;button id=&quot;hide&quot;&gt;隐藏信息窗口&lt;/button&gt;    &lt;button id=&quot;show&quot;&gt;展示信息窗口&lt;/button&gt;    &lt;script&gt;    var marker;    var map = new BMap.Map(&#x27;map_canvas&#x27;);    map.enableScrollWheelZoom();    map.centerAndZoom();    var lushu;    // 实例化一个驾车导航用来生成路线  //  var drv = new BMap.DrivingRoute(&#x27;北京&#x27;, &#123;   //     onSearchComplete: function(res) &#123;    //        if (drv.getStatus() == BMAP_STATUS_SUCCESS) &#123;              //  var plan = res.getPlan(0);               // var arrPois =[];//                for(var j=0;j&lt;plan.getNumRoutes();j++)&#123;                 //   var route = plan.getRoute(j);                 //   arrPois= arrPois.concat(route.getPath());               // &#125;      var arrPois=[new BMap.Point(116.403984,39.914004),new BMap.Point(116.402116,39.913938),new BMap.Point(116.402116,39.913938),new BMap.Point(116.402046,39.913928),new BMap.Point(116.401856,39.913927),          new BMap.Point(116.401547,39.913926),new BMap.Point(116.401008,39.913923),new BMap.Point(116.400599,39.913921),new BMap.Point(116.39999,39.913908),new BMap.Point(116.399471,39.913875),          new BMap.Point(116.399042,39.913852),new BMap.Point(116.398035,39.913835),new BMap.Point(116.395593,39.913683),new BMap.Point(116.395383,39.913681),new BMap.Point(116.395114,39.913658),          new BMap.Point(116.394666,39.913664),new BMap.Point(116.390265,39.91349),new BMap.Point(116.38925,39.913456),new BMap.Point(116.388931,39.913461),new BMap.Point(116.388643,39.913457),          new BMap.Point(116.388335,39.913463),new BMap.Point(116.386455,39.913424),new BMap.Point(116.386166,39.913429),new BMap.Point(116.385898,39.913425),new BMap.Point(116.384327,39.913399),          new BMap.Point(116.384168,39.913396),new BMap.Point(116.38384,39.913391),new BMap.Point(116.383472,39.913395),new BMap.Point(116.383323,39.913402),new BMap.Point(116.382796,39.913403),          new BMap.Point(116.382747,39.913402),new BMap.Point(116.38227,39.913394),new BMap.Point(116.381594,39.913372),new BMap.Point(116.381465,39.91337),new BMap.Point(116.381445,39.913369),          new BMap.Point(116.381197,39.913365),new BMap.Point(116.380779,39.913348),new BMap.Point(116.38066,39.913346),new BMap.Point(116.380491,39.913343),new BMap.Point(116.380488,39.913341),          new BMap.Point(116.38014,39.913344),new BMap.Point(116.379435,39.913342),new BMap.Point(116.378848,39.913331),new BMap.Point(116.378103,39.913307),new BMap.Point(116.376722,39.913282),new BMap.Point(116.374238,39.913227),          new BMap.Point(116.373105,39.913226),new BMap.Point(116.37221,39.91321),new BMap.Point(116.370004,39.913171),new BMap.Point(116.369865,39.913169),new BMap.Point(116.369706,39.913166),new BMap.Point(116.369616,39.913175),          new BMap.Point(116.366474,39.913103),new BMap.Point(116.366276,39.913109),new BMap.Point(116.365997,39.913105),new BMap.Point(116.365898,39.913104),new BMap.Point(116.365639,39.91312),new BMap.Point(116.364605,39.913094),          new BMap.Point(116.364127,39.913087),new BMap.Point(116.364126,39.913086),new BMap.Point(116.363917,39.913193),new BMap.Point(116.363827,39.913262),new BMap.Point(116.363797,39.913311),new BMap.Point(116.363767,39.913391),          new BMap.Point(116.363767,39.913541),new BMap.Point(116.363757,39.913771),new BMap.Point(116.363757,39.913821),new BMap.Point(116.363737,39.91432),new BMap.Point(116.363687,39.914809),new BMap.Point(116.363647,39.915039),          new BMap.Point(116.363617,39.915198),new BMap.Point(116.363567,39.915377),new BMap.Point(116.363527,39.915527),new BMap.Point(116.363487,39.915676),new BMap.Point(116.363438,39.915905),new BMap.Point(116.363436,39.915905),          new BMap.Point(116.363327,39.916154),new BMap.Point(116.363327,39.916154),new BMap.Point(116.363356,39.916444),new BMap.Point(116.363376,39.916694),new BMap.Point(116.363504,39.917936),new BMap.Point(116.363404,39.918974),          new BMap.Point(116.363384,39.919494),new BMap.Point(116.363374,39.919673),new BMap.Point(116.363374,39.919723),new BMap.Point(116.363374,39.919763),new BMap.Point(116.363374,39.919813),new BMap.Point(116.363364,39.920293),          new BMap.Point(116.363364,39.920393),new BMap.Point(116.363273,39.922131),new BMap.Point(116.363263,39.922441),new BMap.Point(116.363192,39.92405),new BMap.Point(116.363183,39.92422),new BMap.Point(116.363183,39.9243),          new BMap.Point(116.363173,39.92446),new BMap.Point(116.363122,39.925599),new BMap.Point(116.363112,39.925818),new BMap.Point(116.363072,39.926798),new BMap.Point(116.363052,39.927057),new BMap.Point(116.363042,39.927277),          new BMap.Point(116.363002,39.928407),new BMap.Point(116.362952,39.929326),new BMap.Point(116.362952,39.929466),new BMap.Point(116.362942,39.929486),new BMap.Point(116.362842,39.931454),new BMap.Point(116.362822,39.931694),          new BMap.Point(116.362822,39.931834),new BMap.Point(116.362802,39.932393),new BMap.Point(116.362772,39.933293),new BMap.Point(116.362763,39.933313),new BMap.Point(116.362683,39.934892),new BMap.Point(116.362603,39.936531),          new BMap.Point(116.362544,39.93769),new BMap.Point(116.362524,39.93804),new BMap.Point(116.362514,39.938159),new BMap.Point(116.362514,39.938209),new BMap.Point(116.362514,39.938259),new BMap.Point(116.362504,39.938509),          new BMap.Point(116.362465,39.939329),new BMap.Point(116.362405,39.940878),new BMap.Point(116.362376,39.941888),new BMap.Point(116.362366,39.942108),new BMap.Point(116.362366,39.942138),new BMap.Point(116.362356,39.942398),          new BMap.Point(116.362337,39.942597),new BMap.Point(116.362307,39.943287),new BMap.Point(116.362277,39.943637),new BMap.Point(116.362218,39.944746),new BMap.Point(116.362219,39.946046),new BMap.Point(116.362219,39.946196),          new BMap.Point(116.362219,39.946226),new BMap.Point(116.362209,39.946276),new BMap.Point(116.362209,39.946326),new BMap.Point(116.362199,39.946436),new BMap.Point(116.36218,39.946876),new BMap.Point(116.36213,39.947595),          new BMap.Point(116.36227,39.948167),new BMap.Point(116.36235,39.948339),new BMap.Point(116.362509,39.948611),new BMap.Point(116.362738,39.948914),new BMap.Point(116.362928,39.949197),new BMap.Point(116.363167,39.94943),          new BMap.Point(116.363416,39.949604),new BMap.Point(116.363913,39.949851),new BMap.Point(116.36469,39.950052),new BMap.Point(116.365595,39.950366),new BMap.Point(116.365794,39.950429),new BMap.Point(116.366093,39.950524),          new BMap.Point(116.366242,39.950556),new BMap.Point(116.367266,39.950863),new BMap.Point(116.368162,39.951127),new BMap.Point(116.371174,39.952029),new BMap.Point(116.371324,39.952072),new BMap.Point(116.372029,39.952315),          new BMap.Point(116.372417,39.952482),new BMap.Point(116.37365,39.953024),new BMap.Point(116.374435,39.953378),new BMap.Point(116.374833,39.953536),new BMap.Point(116.374962,39.953598),new BMap.Point(116.375588,39.95386),          new BMap.Point(116.375585,39.95386),new BMap.Point(116.375903,39.953895),new BMap.Point(116.376171,39.95396),new BMap.Point(116.376399,39.954035),new BMap.Point(116.376648,39.954099),new BMap.Point(116.376727,39.954131),          new BMap.Point(116.377026,39.954216),new BMap.Point(116.377085,39.954237),new BMap.Point(116.377354,39.954312),new BMap.Point(116.377642,39.954358),new BMap.Point(116.377821,39.954391),new BMap.Point(116.378198,39.954458),          new BMap.Point(116.378377,39.954491),new BMap.Point(116.378536,39.954504),new BMap.Point(116.378586,39.954505),new BMap.Point(116.378715,39.954517),new BMap.Point(116.378924,39.954531),new BMap.Point(116.379311,39.954558),          new BMap.Point(116.379848,39.954598),new BMap.Point(116.379898,39.954599),new BMap.Point(116.380037,39.954611),new BMap.Point(116.380723,39.954664),new BMap.Point(116.381458,39.954697),new BMap.Point(116.381736,39.954712),          new BMap.Point(116.382432,39.954744),new BMap.Point(116.38273,39.954759),new BMap.Point(116.38279,39.95476),new BMap.Point(116.383098,39.954795),new BMap.Point(116.383456,39.954882),new BMap.Point(116.383536,39.954903),          new BMap.Point(116.383576,39.954914),new BMap.Point(116.383655,39.954935),new BMap.Point(116.383695,39.954946),new BMap.Point(116.383795,39.954987),new BMap.Point(116.383854,39.955019),new BMap.Point(116.383884,39.955029),          new BMap.Point(116.383954,39.95507),new BMap.Point(116.384013,39.955121),new BMap.Point(116.384063,39.955162),new BMap.Point(116.384093,39.955183),new BMap.Point(116.384153,39.955244),new BMap.Point(116.384212,39.955315),          new BMap.Point(116.384242,39.955345),new BMap.Point(116.384382,39.955518),new BMap.Point(116.384441,39.955609),new BMap.Point(116.384501,39.95568),new BMap.Point(116.384581,39.955811),new BMap.Point(116.38468,39.955953),          new BMap.Point(116.384849,39.956206),new BMap.Point(116.384919,39.956317),new BMap.Point(116.385059,39.956529),new BMap.Point(116.385079,39.95657),new BMap.Point(116.385347,39.956974),new BMap.Point(116.385527,39.957267),          new BMap.Point(116.385576,39.957358),new BMap.Point(116.385626,39.957459),new BMap.Point(116.385676,39.95757),new BMap.Point(116.385716,39.95768),new BMap.Point(116.385776,39.957841),new BMap.Point(116.385806,39.958002),          new BMap.Point(116.385836,39.958162),new BMap.Point(116.385846,39.958293),new BMap.Point(116.385846,39.958473),new BMap.Point(116.385856,39.958623),new BMap.Point(116.385856,39.958623),new BMap.Point(116.385897,39.960014),          new BMap.Point(116.385898,39.960984),new BMap.Point(116.385908,39.961295),new BMap.Point(116.385929,39.961865),new BMap.Point(116.385909,39.962295),new BMap.Point(116.38588,39.963275),new BMap.Point(116.385831,39.963644),          new BMap.Point(116.385782,39.964123),new BMap.Point(116.385782,39.964143),new BMap.Point(116.385842,39.964715),new BMap.Point(116.385903,39.965356),new BMap.Point(116.385983,39.966067),new BMap.Point(116.386043,39.966538),          new BMap.Point(116.386053,39.966629),new BMap.Point(116.386133,39.96726),new BMap.Point(116.386414,39.969935),new BMap.Point(116.386474,39.970407),new BMap.Point(116.386685,39.9718),new BMap.Point(116.386805,39.972673),          new BMap.Point(116.386935,39.973505),new BMap.Point(116.386985,39.973796),new BMap.Point(116.386984,39.973796),new BMap.Point(116.387035,39.974166),new BMap.Point(116.387055,39.974317),new BMap.Point(116.387075,39.974427),          new BMap.Point(116.387095,39.974608),new BMap.Point(116.387175,39.975129),new BMap.Point(116.387185,39.975199),new BMap.Point(116.387195,39.975309),new BMap.Point(116.387285,39.975931),new BMap.Point(116.387385,39.976803),          new BMap.Point(116.387626,39.978957),new BMap.Point(116.387646,39.979127),new BMap.Point(116.387656,39.979228),new BMap.Point(116.387736,39.979829),new BMap.Point(116.387866,39.981111),new BMap.Point(116.387926,39.981592),          new BMap.Point(116.388026,39.982294),new BMap.Point(116.388016,39.982684),new BMap.Point(116.388007,39.982864),new BMap.Point(116.387997,39.982953),new BMap.Point(116.387997,39.983003),new BMap.Point(116.387997,39.983054),          new BMap.Point(116.387987,39.983333),new BMap.Point(116.387918,39.983782),new BMap.Point(116.387819,39.984381),new BMap.Point(116.3877,39.984779),new BMap.Point(116.386975,39.987338),new BMap.Point(116.386806,39.987906),          new BMap.Point(116.386776,39.988015),new BMap.Point(116.386727,39.988195),new BMap.Point(116.386518,39.988971),new BMap.Point(116.386379,39.989529),new BMap.Point(116.386221,39.990087),new BMap.Point(116.386012,39.990823),          new BMap.Point(116.385943,39.991072),new BMap.Point(116.385724,39.991819),new BMap.Point(116.385376,39.992993),new BMap.Point(116.385347,39.993123),new BMap.Point(116.385237,39.993471),new BMap.Point(116.385208,39.993591),          new BMap.Point(116.385168,39.99374),new BMap.Point(116.385128,39.993889),new BMap.Point(116.385109,39.993939),new BMap.Point(116.385079,39.994048),new BMap.Point(116.384622,39.995631),new BMap.Point(116.384552,39.99591),          new BMap.Point(116.384254,39.996995),new BMap.Point(116.384244,39.997034),new BMap.Point(116.383936,39.997829),new BMap.Point(116.383906,39.997919),new BMap.Point(116.383687,39.998425),new BMap.Point(116.383469,39.998841),          new BMap.Point(116.38327,39.999118),new BMap.Point(116.382982,39.999513),new BMap.Point(116.382534,40.000135),new BMap.Point(116.382455,40.000253),new BMap.Point(116.382157,40.000658),new BMap.Point(116.382067,40.000777),          new BMap.Point(116.381491,40.001506),new BMap.Point(116.381023,40.002088),new BMap.Point(116.380516,40.002739),new BMap.Point(116.380188,40.003163),new BMap.Point(116.379612,40.003902),new BMap.Point(116.379234,40.004385),          new BMap.Point(116.378578,40.005213),new BMap.Point(116.377942,40.006032),new BMap.Point(116.377524,40.006564),new BMap.Point(116.376937,40.007333),new BMap.Point(116.376848,40.007431),new BMap.Point(116.376789,40.00752),new BMap.Point(116.376749,40.007559),new BMap.Point(116.376739,40.007589),new BMap.Point(116.376431,40.007983),new BMap.Point(116.376043,40.008486),new BMap.Point(116.374452,40.010616),new BMap.Point(116.373895,40.011406),new BMap.Point(116.373606,40.011791),new BMap.Point(116.372303,40.013577),new BMap.Point(116.371706,40.014386),new BMap.Point(116.371617,40.014514),new BMap.Point(116.37106,40.015244),new BMap.Point(116.37097,40.015373),new BMap.Point(116.370542,40.015935),new BMap.Point(116.369577,40.017208),new BMap.Point(116.369259,40.017652),new BMap.Point(116.368711,40.018443),new BMap.Point(116.368303,40.018946),new BMap.Point(116.367557,40.019883),new BMap.Point(116.36687,40.020752),new BMap.Point(116.366183,40.02162),new BMap.Point(116.364589,40.023695),new BMap.Point(116.363912,40.024585),new BMap.Point(116.363334,40.025317),new BMap.Point(116.362975,40.025762),new BMap.Point(116.362816,40.025959),new BMap.Point(116.362228,40.026711),new BMap.Point(116.361869,40.027156),new BMap.Point(116.36164,40.027463),new BMap.Point(116.361421,40.02776),new BMap.Point(116.361401,40.02779),new BMap.Point(116.361311,40.027899),new BMap.Point(116.361304,40.027899),new BMap.Point(116.361274,40.027948),new BMap.Point(116.361175,40.028107),new BMap.Point(116.361085,40.028236),new BMap.Point(116.360995,40.028385),new BMap.Point(116.360945,40.028474),new BMap.Point(116.360916,40.028524),new BMap.Point(116.360806,40.028712),new BMap.Point(116.360706,40.028881),new BMap.Point(116.360677,40.028941),new BMap.Point(116.360667,40.028961),new BMap.Point(116.360637,40.02903),new BMap.Point(116.360597,40.02912),new BMap.Point(116.360557,40.029199),new BMap.Point(116.360547,40.029219),new BMap.Point(116.360538,40.029259),new BMap.Point(116.360518,40.029299),new BMap.Point(116.360508,40.029338),new BMap.Point(116.360508,40.029388),new BMap.Point(116.360508,40.029438),new BMap.Point(116.360508,40.029488),new BMap.Point(116.360518,40.029539),new BMap.Point(116.360528,40.029589),new BMap.Point(116.360547,40.029639),new BMap.Point(116.360577,40.029679),new BMap.Point(116.360607,40.02972),new BMap.Point(116.360647,40.02976),new BMap.Point(116.360687,40.029791),new BMap.Point(116.360726,40.029821),new BMap.Point(116.360766,40.029841),new BMap.Point(116.360806,40.029862),new BMap.Point(116.360846,40.029872),new BMap.Point(116.360896,40.029883),new BMap.Point(116.360945,40.029894),new BMap.Point(116.360995,40.029904),new BMap.Point(116.361055,40.029905),new BMap.Point(116.361115,40.029906),new BMap.Point(116.361174,40.029907),new BMap.Point(116.361234,40.029887),new BMap.Point(116.361294,40.029878),new BMap.Point(116.361354,40.029859),new BMap.Point(116.361393,40.02984),new BMap.Point(116.361453,40.029811),new BMap.Point(116.361493,40.029781),new BMap.Point(116.361533,40.029742),new BMap.Point(116.361573,40.029692),new BMap.Point(116.361603,40.029643),new BMap.Point(116.361633,40.029593),new BMap.Point(116.361643,40.029544),new BMap.Point(116.361643,40.029504),new BMap.Point(116.361643,40.029464),new BMap.Point(116.361633,40.029424),new BMap.Point(116.361623,40.029374),new BMap.Point(116.361603,40.029323),new BMap.Point(116.361574,40.029273),new BMap.Point(116.361544,40.029233),new BMap.Point(116.361504,40.029202),new BMap.Point(116.361474,40.029172),new BMap.Point(116.361425,40.029141),new BMap.Point(116.361385,40.029101),new BMap.Point(116.361325,40.02906),new BMap.Point(116.361266,40.02904),new BMap.Point(116.361226,40.029009),new BMap.Point(116.361186,40.028989),new BMap.Point(116.361147,40.028968),new BMap.Point(116.361107,40.028948),new BMap.Point(116.361104,40.028946),new BMap.Point(116.360765,40.028942),new BMap.Point(116.360676,40.028941),new BMap.Point(116.360477,40.028939),new BMap.Point(116.360228,40.028936),new BMap.Point(116.359521,40.028937),new BMap.Point(116.359292,40.028945),new BMap.Point(116.358943,40.028951),new BMap.Point(116.358515,40.028946),new BMap.Point(116.358495,40.028946),new BMap.Point(116.357638,40.028947),new BMap.Point(116.357499,40.028946),new BMap.Point(116.357011,40.028931),new BMap.Point(116.356801,40.028929),new BMap.Point(116.356792,40.028929),new BMap.Point(116.356632,40.028928),new BMap.Point(116.355356,40.028937),new BMap.Point(116.355037,40.028934),new BMap.Point(116.354628,40.028941),new BMap.Point(116.354219,40.028938),new BMap.Point(116.353571,40.028934),new BMap.Point(116.353062,40.028941),new BMap.Point(116.352872,40.02894),new BMap.Point(116.351874,40.028934),new BMap.Point(116.350277,40.028937),new BMap.Point(116.347059,40.028961),new BMap.Point(116.346519,40.028971),new BMap.Point(116.343748,40.028925),new BMap.Point(116.343718,40.028925),new BMap.Point(116.343608,40.028925),new BMap.Point(116.342968,40.028888),new BMap.Point(116.341516,40.028704),new BMap.Point(116.340915,40.028537),new BMap.Point(116.340184,40.028331),new BMap.Point(116.337588,40.02754),new BMap.Point(116.337585,40.027539),new BMap.Point(116.337244,40.027532),new BMap.Point(116.336974,40.027464),new BMap.Point(116.336522,40.027388),new BMap.Point(116.336201,40.027321),new BMap.Point(116.33576,40.027336),new BMap.Point(116.335309,40.02738),new BMap.Point(116.334907,40.027494),new BMap.Point(116.334445,40.027659),new BMap.Point(116.334405,40.027679),new BMap.Point(116.333823,40.027946),new BMap.Point(116.333311,40.028252),new BMap.Point(116.332839,40.028617),new BMap.Point(116.331713,40.029801),new BMap.Point(116.331711,40.0298),new BMap.Point(116.330726,40.031463),new BMap.Point(116.330585,40.031744),new BMap.Point(116.330071,40.032911),new BMap.Point(116.330021,40.033112),new BMap.Point(116.329437,40.035059),new BMap.Point(116.329245,40.035672),new BMap.Point(116.329165,40.035913),new BMap.Point(116.329084,40.036174),new BMap.Point(116.328984,40.036465),new BMap.Point(116.328943,40.036576),new BMap.Point(116.328802,40.037018),new BMap.Point(116.328209,40.038366),new BMap.Point(116.327716,40.039103),new BMap.Point(116.32685,40.040136),new BMap.Point(116.326659,40.040299),new BMap.Point(116.325231,40.041552),new BMap.Point(116.323168,40.043356),new BMap.Point(116.323047,40.043468),new BMap.Point(116.323017,40.043489),new BMap.Point(116.322937,40.04357),new BMap.Point(116.322806,40.043682),new BMap.Point(116.322756,40.043733),new BMap.Point(116.322715,40.043764),new BMap.Point(116.322243,40.044202),new BMap.Point(116.322233,40.044222),new BMap.Point(116.321719,40.044821),new BMap.Point(116.321578,40.044983),new BMap.Point(116.320773,40.046077),new BMap.Point(116.320451,40.046673),new BMap.Point(116.319867,40.047743),new BMap.Point(116.319122,40.049116),new BMap.Point(116.31878,40.049552),new BMap.Point(116.317048,40.051744),new BMap.Point(116.316032,40.053022),new BMap.Point(116.315639,40.053519),new BMap.Point(116.313536,40.056347),new BMap.Point(116.313365,40.05658),new BMap.Point(116.313265,40.056712),new BMap.Point(116.313215,40.056783),new BMap.Point(116.313064,40.056985),new BMap.Point(116.31242,40.058037),new BMap.Point(116.311555,40.059442),new BMap.Point(116.311535,40.059473),new BMap.Point(116.311123,40.06015),new BMap.Point(116.311118,40.06015),new BMap.Point(116.311119,40.06048),new BMap.Point(116.310968,40.060772),new BMap.Point(116.310385,40.061943),new BMap.Point(116.310334,40.062044),new BMap.Point(116.310103,40.062488),new BMap.Point(116.310063,40.062568),new BMap.Point(116.310033,40.062629),new BMap.Point(116.309309,40.064021),new BMap.Point(116.308897,40.064488),new BMap.Point(116.308555,40.064634),new BMap.Point(116.308375,40.064707),new BMap.Point(116.308244,40.064759),new BMap.Point(116.307963,40.064834),new BMap.Point(116.30756,40.064791),new BMap.Point(116.306866,40.064622),new BMap.Point(116.304856,40.064163),new BMap.Point(116.303499,40.063863),new BMap.Point(116.302966,40.06374),new BMap.Point(116.302856,40.063682),new BMap.Point(116.302854,40.063681),new BMap.Point(116.302995,40.063199),new BMap.Point(116.303979,40.060475),new BMap.Point(116.303989,40.060395),new BMap.Point(116.304079,40.060064),new BMap.Point(116.30432,40.05918),new BMap.Point(116.304501,40.058558),new BMap.Point(116.304521,40.058518),new BMap.Point(116.304662,40.058015),new BMap.Point(116.304933,40.057151),new BMap.Point(116.305194,40.056358),new BMap.Point(116.305235,40.056207),new BMap.Point(116.305325,40.055946),new BMap.Point(116.305566,40.055212),new BMap.Point(116.305647,40.054951),new BMap.Point(116.305747,40.05494),new BMap.Point(116.305717,40.05502),new BMap.Point(116.305717,40.055019),new BMap.Point(116.305647,40.05523),new BMap.Point(116.305416,40.055964),new BMap.Point(116.305295,40.056375),new BMap.Point(116.305034,40.057169),new BMap.Point(116.304773,40.058033),new BMap.Point(116.304772,40.058033),new BMap.Point(116.306491,40.058347),new BMap.Point(116.306492,40.058347),new BMap.Point(116.306914,40.05729),new BMap.Point(116.306954,40.05717),new BMap.Point(116.306954,40.05717),new BMap.Point(116.306974,40.057169)];      var attrs = [];    for(var i = arrPois.length - 1; i &gt;= 0; i--)&#123;        attrs[i] = &#123;            title:&quot;title&quot; + Math.random(),            content: &quot;content&quot; + Math.random(),            id:&quot;ss&quot;+Math.random()        &#125;;    &#125;    console.log(arrPois.length);            //    map.addOverlay(new BMap.Polyline(arrPois, &#123;strokeColor: &#x27;#111&#x27;&#125;)); //不画线                map.setViewport(arrPois);                   marker=new BMap.Marker(arrPois[0],&#123;                      icon  : new BMap.Icon(&#x27;http://developer.baidu.com/map/jsdemo/img/car.png&#x27;, new BMap.Size(52,26),&#123;anchor : new BMap.Size(27, 13)&#125;)                   &#125;);      var label = new BMap.Label(&quot;粤A30780&quot;,&#123;offset:new BMap.Size(0,-30)&#125;);      label.setStyle(&#123;border:&quot;1px solid rgb(204, 204, 204)&quot;,color: &quot;rgb(0, 0, 0)&quot;,borderRadius:&quot;10px&quot;,padding:&quot;5px&quot;,background:&quot;rgb(255, 255, 255)&quot;,&#125;);                marker.setLabel(label);                       map.addOverlay(marker);map.addEventListener(&#x27;dragging&#x27;,function(type,target,pixel,point)&#123;//x:731,y:420  left:622 top:264  offset_x 109 offset_y:156&#125;);var infoWindow = null;var hideInfoFlag = false;    /**     * 显示弹窗信息     * @param pixel 像素坐标     * @param pointAttr 属性     */    function showInfoWindow(pixel, pointAttr)&#123;    if(infoWindow &amp;&amp; jQuery(&quot;.BMap_pop&quot;).length &gt; 0 &amp;&amp; !hideInfoFlag)&#123;        map.closeInfoWindow();        jQuery(&quot;.BMap_pop&quot;).css(&#x27;display&#x27;,&quot;inline-block&quot;);        hideInfoFlag = true;    &#125;    jQuery(&quot;.BMap_pop&quot;).css(&quot;left&quot;,pixel.x - 109).css(&quot;top&quot;,pixel.y - 156);    jQuery(&quot;.BMap_bubble_title&quot;).text(pointAttr.title);    jQuery(&quot;.BMap_bubble_content&quot;).html(&quot;&lt;div&gt;id:&quot;+pointAttr.id+&quot;&lt;/div&gt;&lt;div&gt;id:&quot;+pointAttr.content+&quot;&lt;/div&gt;&quot;);    &#125;var curIndex = 0;     BMapLib.LuShu.prototype._move=function(initPos,targetPos,effect) &#123;            var pointsArr=[initPos,targetPos];  //点数组            var me = this,            //当前的帧数            currentCount = 0,            //步长，米/秒            timer = 10,            step = this._opts.speed / (1000 / timer),            //初始坐标            init_pos = this._projection.lngLatToPoint(initPos),            //获取结束点的(x,y)坐标            target_pos = this._projection.lngLatToPoint(targetPos),            //总的步长            count = Math.round(me._getDistance(init_pos, target_pos) / step);             //显示折线 syj201607191107            this._map.addOverlay(new BMap.Polyline(pointsArr, &#123;                 strokeColor : &quot;#111&quot;,                 strokeWeight : 5,                 strokeOpacity : 0.5             &#125;)); // 画线         ++curIndex;         var pointAttr = attrs[curIndex];            //如果小于1直接移动到下一点            if (count &lt; 1) &#123;                me._moveNext(++me.i);                return;            &#125;            me._intervalFlag = setInterval(function() &#123;            //两点之间当前帧数大于总帧数的时候，则说明已经完成移动                if (currentCount &gt;= count) &#123;                    clearInterval(me._intervalFlag);                    //移动的点已经超过总的长度                    if(me.i &gt; me._path.length)&#123;                        return;                    &#125;                    //运行下一个点                    me._moveNext(++me.i);                &#125;else &#123;                        currentCount++;                        var x = effect(init_pos.x, target_pos.x, currentCount, count),                            y = effect(init_pos.y, target_pos.y, currentCount, count),                            pos = me._projection.pointToLngLat(new BMap.Pixel(x, y));                        //设置marker                        if(currentCount == 1)&#123;                            var proPos = null;                            if(me.i - 1 &gt;= 0)&#123;                                proPos = me._path[me.i - 1];                            &#125;                            if(me._opts.enableRotation == true)&#123;                                 me.setRotation(proPos,initPos,targetPos);                            &#125;                            if(me._opts.autoView)&#123;                                if(!me._map.getBounds().containsPoint(pos))&#123;                                    me._map.setCenter(pos);                                &#125;                              &#125;                        &#125;                        //正在移动                        me._marker.setPosition(pos);                        //设置自定义overlay的位置                        me._setInfoWin(pos);                    var opts = &#123;                      width:200,                      height: 100,                      title:&quot;title&quot;,                      message:&quot;message&quot;                    &#125;;                    infoWindow = map.getInfoWindow();                    if(!infoWindow)&#123;                        infoWindow = new BMap.InfoWindow(&quot;test&lt;br&gt;dierhang&quot;,opts);                        map.openInfoWindow(infoWindow, pos);                    &#125;                    var pixel = map.pointToOverlayPixel(pos);                    showInfoWindow(pixel, pointAttr);                    infoWindow.getPosition().lat = pos.lat;                    infoWindow.getPosition().lng = pos.lng;                    infoWindow.getPosition().pixel = pixel;                    //infoWindow.setTitle(pointAttr.title);                    //infoWindow.setContent(pointAttr.content);                    //console.log(infoWindow.getPosition());//infoWindow.restore();//infoWindow.redraw();//infoWindow.setPosition(pos);                    &#125;            &#125;,timer);        &#125;;                lushu = new BMapLib.LuShu(map,arrPois,&#123;                defaultContent:&quot;粤A30780&quot;,//&quot;从天安门到百度大厦&quot;                autoView:true,//是否开启自动视野调整，如果开启那么路书在运动过程中会根据视野自动调整                icon  : new BMap.Icon(&#x27;http://developer.baidu.com/map/jsdemo/img/car.png&#x27;, new BMap.Size(52,26),&#123;anchor : new BMap.Size(27, 13)&#125;),                speed: 4500,                enableRotation:true,//是否设置marker随着道路的走向进行旋转                   landmarkPois:[                   &#123;lng:116.306954,lat:40.05718,html:&#x27;加油站&#x27;,pauseTime:2&#125;                  ]                                    &#125;);                marker.addEventListener(&quot;click&quot;,function()&#123;        marker.enableMassClear();   //设置后可以隐藏改点的覆盖物        marker.hide();        lushu.start();        //map.clearOverlays();  //清除所有覆盖物      &#125;);            //&#125;//        &#125;  //  &#125;);    //drv.search(&#x27;天安门&#x27;, &#x27;百度大厦&#x27;);     // lushu.start();     // lushu.pause();    //绑定事件    $(&quot;run&quot;).onclick = function()&#123;      marker.enableMassClear(); //设置后可以隐藏改点的覆盖物      marker.hide();      lushu.start();     // map.clearOverlays();    //清除所有覆盖物    &#125;    $(&quot;stop&quot;).onclick = function()&#123;        lushu.stop();    &#125;    $(&quot;pause&quot;).onclick = function()&#123;        lushu.pause();    &#125;    $(&quot;hide&quot;).onclick = function()&#123;        lushu.hideInfoWindow();    &#125;    $(&quot;show&quot;).onclick = function()&#123;        lushu.showInfoWindow();    &#125;    function $(element)&#123;        return document.getElementById(element);    &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n","tags":["Anylogic"]},{"title":"JavaWeb之Cookie、Session","url":"/2022/04/20/JavaWeb%E4%B9%8BCookie%E3%80%81Session/","content":"会话会话：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话；\n有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话；\n一个网站，怎么证明你来过？\n\n服务端给客户端一个 信件，客户端下次访问服务端带上信件就可以了； cookie \n服务器登记你来过了，下次你来的时候我来匹配你； seesion\n\n保存会话的两种技术cookie\n\n客户端技术 （响应，请求）\n\nsession\n\n服务器技术，利用这个技术，可以保存用户的会话信息。 我们可以把信息或者数据放在Session 中！\n\n常见现象：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！\nCookie\n\n从请求中拿到cookie信息 \n\n服务器响应给客户端cookie\n\n\n@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    req.setCharacterEncoding(&quot;utf-8&quot;);    resp.setCharacterEncoding(&quot;utf-8&quot;);    Cookie[] cookies = req.getCookies();//获得Cookie    PrintWriter out = resp.getWriter();    if (cookies != null)&#123;        out.print(&quot;你上次访问的时间是：&quot;);        for (int i = 0; i &lt; cookies.length; i++) &#123;          Cookie  cookie = cookies[i];          if (cookie.getName().equals(&quot;lastLoginTime&quot;))&#123;              long lastLoginTime = Long.parseLong(cookie.getValue()); //获得cookie中的vlaue              Date date = new Date(lastLoginTime);              out.print(date.toLocaleString());          &#125;        &#125;    &#125;else&#123;        out.print(&quot;你第一次访问&quot;);    &#125;    Cookie cookie = new Cookie(&quot;lastLoginTime&quot;, System.currentTimeMillis() + &quot;&quot;);//新建一个cookie    cookie.setMaxAge(24*60*60);//设置cookie的有效期    resp.addCookie(cookie);//响应给客户端一个cookie&#125;\n\ncookie：一般会保存在本地的 用户目录下 appdata；\n一个网站cookie是否存在上限？\n\n一个Cookie只能保存一个信息；\n一个web站点可以给浏览器发送多个cookie，最多存放20个cookie；\nCookie大小有限制4kb； \n300个cookie浏览器上限\n\n删除Cookie：\n\n不设置有效期，关闭浏览器，自动失效；\n设置有效期时间为 0 ；\n\n编码解码：\nURLEncoder.encode(&quot;秦疆&quot;,&quot;utf-8&quot;)URLDecoder.decode(cookie.getValue(),&quot;UTF-8&quot;)\n\nSession\n什么是Session：\n\n服务器会给每一个用户（浏览器）创建一个Seesion对象；\n一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在；\n用户登录之后，整个网站它都可以访问！–&gt; 保存用户的信息；保存购物车的信息…..\n\n使用场景： \n\n保存一个登录用户的信息； 购物车信息； \n在整个网站中经常会使用的数据，我们将它保存在Session中；\n\n新建session\nimport javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;public class session extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //解决乱码问题        req.setCharacterEncoding(&quot;utf-8&quot;);        resp.setCharacterEncoding(&quot;utf-8&quot;);        resp.setContentType(&quot;text/html;charset=utf-8&quot;);        //得到session        HttpSession session = req.getSession();        //给session中存东西        session.setAttribute(&quot;name&quot;,new Person(&quot;秦疆&quot;,1));        //获取session的ID        String sessionId = session.getId();        //判断session是否是新建的        if(session.isNew())&#123;            resp.getWriter().write(&quot;session创建成功,ID:&quot;+sessionId);        &#125;else &#123;            resp.getWriter().write(&quot;session以及在服务器中存在了,ID:&quot;+sessionId);        &#125;    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req, resp);    &#125;&#125;\n\n得到Session内容：\nHttpSession session = req.getSession();Person person = (Person) session.getAttribute(&quot;name&quot;);System.out.println(person.toString());HttpSession session = req.getSession();session.removeAttribute(&quot;name&quot;);\n\n手动注销Session:\nsession.invalidate();\n\n会话自动过期：web.xml配置\n&lt;!--设置Session默认的失效时间--&gt;&lt;session-config&gt;&lt;!--15分钟后Session自动失效，以分钟为单位--&gt;&lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/session-config&gt;\n\nSession和cookie的区别\nCookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个）\nSession把用户的数据写到用户独占Session中，服务器端保存 （保存重要的信息，减少服务器资源的浪费） \nSession对象由服务创建；\n\n","tags":["JavaWeb"]},{"title":"JavaWeb之Filter实现权限拦截","url":"/2022/04/29/JavaWeb%E4%B9%8BFilter%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E6%8B%A6%E6%88%AA/","content":"\n用户登录之后才能进入主页！用户注销后就不能进入主页了！\n\n\n用户登录之后，向Sesison中放入用户的数据 \n进入主页的时候要判断用户是否已经登录；要求：在过滤器中实现！\n\n\n首先我们创建一个登录页面Login.jsp\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;登录&lt;/h4&gt;&lt;form action=&quot;/servlet/login&quot; method=&quot;post&quot;&gt;//action必须和web.xml中设置的地址一样    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n然后我们创建一个constant.java设置常量\n\npublic class constant &#123;    public static String USER_SESSION = &quot;USER_SESSION&quot;;&#125;\n\n\n增加一个error.jsp登录失败页面\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;error&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;注销吧&lt;/h4&gt;&lt;a href=&quot;/Login.jsp&quot;&gt;返回登录页面&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n增加一个登录成功的页面success.jsp\n\n&lt;html&gt;&lt;head&gt;    &lt;title&gt;登录成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;登录成功&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;/servlet/logout&quot;&gt;注销&lt;/a&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n然后我们对登录用户名进行判断，创建login.java\n\nimport util.Constast;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class login extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        String user = req.getParameter(&quot;username&quot;);        if (user.equals(&quot;admin&quot;))&#123;            req.getSession().setAttribute(Constast.USER_SESSION,req.getSession().getId());            resp.sendRedirect(&quot;/sys/success.jsp&quot;);        &#125;else&#123;            resp.sendRedirect(&quot;/error.jsp&quot;);        &#125;    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req, resp);    &#125;&#125;\n\n\n接下来在web.xml中增加映射\n\n&lt;servlet&gt;  &lt;servlet-name&gt;login&lt;/servlet-name&gt;  &lt;servlet-class&gt;login&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;  &lt;servlet-name&gt;login&lt;/servlet-name&gt;  &lt;url-pattern&gt;/servlet/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n\n增加注销的操作logout.java\n\nimport util.Constast;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class logout extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        Object user_session = req.getSession().getAttribute(Constast.USER_SESSION);        if (user_session != null)&#123;            req.getSession().removeAttribute(Constast.USER_SESSION);            resp.sendRedirect(&quot;/Login.jsp&quot;);        &#125;    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req, resp);    &#125;&#125;\n\n\nweb.xml中增加映射\n\n&lt;servlet&gt;  &lt;servlet-name&gt;logout&lt;/servlet-name&gt;  &lt;servlet-class&gt;logout&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;  &lt;servlet-name&gt;logout&lt;/servlet-name&gt;  &lt;url-pattern&gt;/servlet/logout&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n\n增加一个权限拦截，注销过的用户不能直接进入登录成功的界面Fileter.java\n\nimport util.Constast;import javax.servlet.*;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class Fileter implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        HttpServletRequest request = (HttpServletRequest) servletRequest;        HttpServletResponse response = (HttpServletResponse) servletResponse;        if (request.getSession().getAttribute(Constast.USER_SESSION)==null)&#123;            response.sendRedirect(&quot;/error.jsp&quot;);        &#125;        filterChain.doFilter(request,response);//重中之重    &#125;    @Override    public void destroy() &#123;    &#125;&#125;\n\n\n在web.xml中加入映射\n\n&lt;filter&gt;  &lt;filter-name&gt;Filter&lt;/filter-name&gt;  &lt;filter-class&gt;Fileter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;  &lt;filter-name&gt;Filter&lt;/filter-name&gt;  &lt;url-pattern&gt;/sys/*&lt;/url-pattern&gt;//这个是对sys下的所有东西都加拦截&lt;/filter-mapping&gt;\n","tags":["JavaWeb"]},{"title":"JavaWeb之Filter：过滤器","url":"/2022/04/24/JavaWeb%E4%B9%8BFilter%EF%BC%9A%E8%BF%87%E6%BB%A4%E5%99%A8/","content":"Filter：过滤器 ，用来过滤网站的数据；\n\n处理中文乱码\n登录验证….\n\nFilter开发步骤：\n\n导包 （import javax.servlet.Filter;）\n\n编写过滤器\n\n实现Filter接口，重写对应的方法即可\nimport javax.servlet.*;import java.io.IOException;public class CharacterEncodingFilter implements Filter &#123;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;        System.out.println(&quot;CharacterEncodingFilter初始化&quot;);    &#125;    //Chain : 链    /*    1. 过滤中的所有代码，在过滤特定请求的时候都会执行    2. 必须要让过滤器继续同行    chain.doFilter(request,response);    */    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;        servletRequest.setCharacterEncoding(&quot;utf-8&quot;);        servletResponse.setCharacterEncoding(&quot;utf-8&quot;);        servletResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);        System.out.println(&quot;CharacterEncodingFilter执行前....&quot;);        filterChain.doFilter(servletRequest,servletResponse);; //让我们的请求继续走，如果不写，程序到这里就被拦截停止！        System.out.println(&quot;CharacterEncodingFilter执行后....&quot;);    &#125;    @Override    public void destroy() &#123;        System.out.println(&quot;CharacterEncodingFilter销毁&quot;);    &#125;&#125;\n\n在web.xml中配置 Filter：\n\n\n&lt;filter&gt;\t&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;\t&lt;filter-class&gt;com.kuang.filter.CharacterEncodingFilter&lt;/filter\u0002class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;\t&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;\t&lt;!--只要是 /servlet的任何请求，会经过这个过滤器--&gt;\t&lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;\t&lt;!--&lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;&lt;/filter-mapping&gt;\n\n","tags":["JavaWeb"]},{"title":"JavaWeb之JSP内置对象和作用域","url":"/2022/04/24/JavaWeb%E4%B9%8BJSP%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"JSP内置对象和作用域\nPageContext 存东西 \nRequest 存东西\nResponse\nSession 存东西 \nApplication 【SerlvetContext】 存东西\nconfig 【SerlvetConfig】 \nout \npage ，不用了解\nexception\n\npageContext.setAttribute(&quot;name1&quot;,&quot;1&quot;); //保存的数据只在一个页面中有效request.setAttribute(&quot;name2&quot;,&quot;2&quot;); //保存的数据只在一次请求中有效，请求转发会携带这个数据session.setAttribute(&quot;name3&quot;,&quot;3&quot;); //保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器application.setAttribute(&quot;name4&quot;,&quot;4&quot;); //保存的数据只在服务器中有效，从打开服务器到关闭服务器\n\n\nrequest：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！\n\nsession：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车；\n\napplication：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如： 聊天数据；\n\n\n接下来我们将其取出并输出，输出结果是1234\n&lt;%    //从pageContext取出，通过寻找的方式来    //从底层到高层（作用域）page-&gt;request-&gt;session-&gt;application    String name1 = (String) pageContext.findAttribute(&quot;name1&quot;);    String name2 = (String) pageContext.findAttribute(&quot;name2&quot;);    String name3 = (String) pageContext.findAttribute(&quot;name3&quot;);    String name4 = (String) pageContext.findAttribute(&quot;name4&quot;);%&gt;&lt;%--使用EL表达式输出 $&#123;&#125;--%&gt;&lt;h1&gt; $&#123;name1&#125;&lt;/h1&gt;&lt;h1&gt; $&#123;name2&#125;&lt;/h1&gt;&lt;h1&gt; $&#123;name3&#125;&lt;/h1&gt;&lt;h1&gt; $&#123;name4&#125;&lt;/h1&gt;\n\n\n我们再新建一个jsp文件将存进去的值取出，就输出3和4\n\n我们再加一个转发，输出就是1234，请求转发保存数据有效\n\n\n&lt;%    pageContext.forward(&quot;/demo1.jsp&quot;);//    request.getRequestDispatcher(&quot;/demo1.jsp&quot;).forward(request,response);%&gt;\n","tags":["JavaWeb"]},{"title":"JavaWeb之JSP原理剖析","url":"/2022/04/22/JavaWeb%E4%B9%8BJSP%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/","content":"什么是JSPJava Server Pages ： Java服务器端页面，也和Servlet一样，用于动态Web技术！\n\n最大的特点：\n\n写JSP就像在写HTML \n区别： HTML只给用户提供静态的数据 JSP页面中可以嵌入JAVA代码，为用户提供动态数据；\n\nJSP原理服务器内部工作 tomcat中有一个work目录；IDEA中使用Tomcat的会在tomcat中生产一个work目录，发现页面转变成了Java程序。\n在我电脑里面的地址：\nC:\\Program Files\\Apache Software Foundation\\Tomcat 8.5\\work\\Catalina\\localhost\\ROOT\\org\\apache\\jsp\n\n浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！ JSP最终也会被转换成为一个Java类！ JSP 本质上就是一个Servlet。接下来我们看下jsp.java的代码\n//初始化public void _jspInit() &#123;&#125;//销毁public void _jspDestroy() &#123;&#125;//JSPServicepublic void _jspService(.HttpServletRequest request,HttpServletResponseresponse)\n\n\n判断请求\n\nfinal java.lang.String _jspx_method = request.getMethod();   if (!&quot;GET&quot;.equals(_jspx_method) &amp;&amp; !&quot;POST&quot;.equals(_jspx_method) &amp;&amp; !&quot;HEAD&quot;.equals(_jspx_method) &amp;&amp; !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) &#123;     response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, &quot;JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS&quot;);     return;   &#125;\n\n\n内置一些对象\n\nfinal javax.servlet.jsp.PageContext pageContext; //页面上下文javax.servlet.http.HttpSession session = null; //sessionfinal javax.servlet.ServletContext application; //applicationContextfinal javax.servlet.ServletConfig config; //configjavax.servlet.jsp.JspWriter out = null; //outfinal java.lang.Object page = this; //page：当前HttpServletRequest request //请求HttpServletResponse response //响应\n\n\n输出页面前增加的代码\n\nresponse.setContentType(&quot;text/html; charset=UTF-8&quot;);pageContext = _jspxFactory.getPageContext(this, request, response,null, false, 8192, true);_jspx_page_context = pageContext;application = pageContext.getServletContext();config = pageContext.getServletConfig();out = pageContext.getOut();_jspx_out = out;\n\n\n以上的这些个对象我们可以在JSP页面中直接使用！\n\n在JSP页面中:\n\n只要是 JAVA代码就会原封不动的输出；\n\n如果是HTML代码，就会被转换为以下的格式，输出到前端！\n\n\nout.write(&quot;&lt;html&gt;\\r\\n&quot;);\n\n","tags":["JavaWeb"]},{"title":"JavaWeb之JSP基础语法","url":"/2022/04/23/JavaWeb%E4%B9%8BJSP%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","content":"JSP基础语法任何语言都有自己的语法，JAVA中有,。 JSP 作为java技术的一种应用，它拥有一些自己扩充的语法（了 解，知道即可！），Java所有语法都支持！\n\nJSP表达式&lt;%--JSP表达式作用：用来将程序的输出，输出到客户端&lt;%= 变量或者表达式%&gt;--%&gt;&lt;%= new java.util.Date()%&gt;\n\njsp脚本片段&lt;%--jsp脚本片段--%&gt;&lt;%int sum = 0;for (int i = 1; i &lt;=100 ; i++) &#123;sum+=i;&#125;out.println(&quot;&lt;h1&gt;Sum=&quot;+sum+&quot;&lt;/h1&gt;&quot;);%&gt;\n\nJSP声明JSP声明：会被编译到JSP生成Java的类中！其他的，就会被生成到_jspService方法中！\n&lt;%!static &#123;System.out.println(&quot;Loading Servlet!&quot;);&#125;private int globalVar = 0;public void kuang()&#123;System.out.println(&quot;进入了方法Kuang！&quot;);&#125;%&gt;\n\n**注意:**JSP的注释，不会在客户端显示，HTML就会！\nJSP指令&lt;%@page args.... %&gt;&lt;%@include file=&quot;&quot;%&gt;&lt;%--@include会将两个页面合二为一--%&gt;&lt;%@include file=&quot;common/header.jsp&quot;%&gt;&lt;h1&gt;网页主体&lt;/h1&gt;&lt;%@include file=&quot;common/footer.jsp&quot;%&gt;&lt;hr&gt;&lt;%--jSP标签jsp:include：拼接页面，本质还是三个--%&gt;&lt;jsp:include page=&quot;/common/header.jsp&quot;/&gt;&lt;h1&gt;网页主体&lt;/h1&gt;&lt;jsp:include page=&quot;/common/footer.jsp&quot;/&gt;\n\n","tags":["JavaWeb"]},{"title":"JavaWeb之JSP标签、JSTL标签、EL表达式","url":"/2022/04/24/JavaWeb%E4%B9%8BJSP%E6%A0%87%E7%AD%BE%E3%80%81JSTL%E6%A0%87%E7%AD%BE%E3%80%81EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"EL表达式\n获取数据\n执行运算 \n获取web开发的常用对象\n\nJSP标签\n建立一个设置参数的jsp\n\n&lt;jsp:forward page=&quot;jsptag1.jsp&quot;&gt;    &lt;jsp:param name=&quot;name&quot; value=&quot;xiao&quot;/&gt;    &lt;jsp:param name=&quot;age&quot; value=&quot;12&quot;/&gt;&lt;/jsp:forward&gt;\n\n\n建立一个取参数的jsp\n\n名字：&lt;%=request.getParameter(&quot;name&quot;)%&gt;年龄：&lt;%=request.getParameter(&quot;age&quot;)%&gt;\n\nJSTL表达式\nJSTL标签库的使用就是为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和 Java代码一样！\n在使用JSTL之前我们要引入jar包\n\n&lt;!-- JSTL表达式的依赖 --&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;  &lt;artifactId&gt;jstl-api&lt;/artifactId&gt;  &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- standard标签库 --&gt;&lt;dependency&gt;  &lt;groupId&gt;taglibs&lt;/groupId&gt;  &lt;artifactId&gt;standard&lt;/artifactId&gt;  &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;\n\n\n我们主要掌握的就是核心标签\n\nJSTL标签库使用步骤：\n\n引入对应的 taglib （&lt;%@ taglib prefix&#x3D;”c” uri&#x3D;”http://java.sun.com/jsp/jstl/core&quot; %&gt;）\n\n使用其中的方法 \n\n在Tomcat 也需要引入 jstl的包，否则会报错：JSTL解析错误\n\nc:if的使用\n\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;if测试&lt;/h4&gt;&lt;hr&gt;&lt;form action=&quot;jsptag1.jsp&quot; method=&quot;get&quot;&gt;    &lt;%--    EL表达式获取表单中的数据    $&#123;param.参数名&#125;    --%&gt;    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;$&#123;param.username&#125;&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt;&lt;%--判断如果提交的用户名是管理员，则登录成功--%&gt;&lt;c:if test=&quot;$&#123;param.username==&#x27;admin&#x27;&#125;&quot; var=&quot;isAdmin&quot;&gt;    &lt;c:out value=&quot;欢迎&quot;/&gt;&lt;/c:if&gt;&lt;c:out value=&quot;$&#123;isAdmin&#125;&quot;/&gt;&lt;/body&gt;&lt;/html&gt;\n\n\nc:choose c:when的使用\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;c:set var=&quot;score&quot; value=&quot;55&quot;/&gt;&lt;c:choose&gt;    &lt;c:when test=&quot;$&#123;score&gt;=90&#125;&quot;&gt;        你的成绩为优秀    &lt;/c:when&gt;    &lt;c:when test=&quot;$&#123;score&gt;=80&#125;&quot;&gt;        你的成绩为一般    &lt;/c:when&gt;    &lt;c:when test=&quot;$&#123;score&gt;=70&#125;&quot;&gt;        你的成绩为良好    &lt;/c:when&gt;    &lt;c:when test=&quot;$&#123;score&lt;=60&#125;&quot;&gt;        你的成绩为不及格    &lt;/c:when&gt;&lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt;\n\n\nc:forEach使用\n\n&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    ArrayList&lt;String&gt; people = new ArrayList&lt;&gt;();    people.add(0,&quot;0&quot;);    people.add(1,&quot;1&quot;);    people.add(2,&quot;2&quot;);    people.add(3,&quot;3&quot;);    people.add(4,&quot;4&quot;);    request.setAttribute(&quot;list&quot;,people);%&gt;&lt;c:forEach var=&quot;people&quot; items=&quot;$&#123;list&#125;&quot;&gt;    &lt;c:out value=&quot;$&#123;people&#125;&quot;/&gt;&lt;br&gt;&lt;/c:forEach&gt;&lt;hr&gt;&lt;c:forEach var=&quot;people&quot; items=&quot;$&#123;list&#125;&quot; begin=&quot;1&quot; end=&quot;3&quot; step=&quot;2&quot;&gt;    &lt;c:out value=&quot;$&#123;people&#125;&quot;/&gt;&lt;br&gt;&lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt;\n","tags":["JavaWeb"]},{"title":"JavaWeb之JavaBean","url":"/2022/04/24/JavaWeb%E4%B9%8BJavaBean/","content":"实体类JavaBean有特定的写法：\n\n必须要有一个无参构造 \n属性必须私有化\n必须有对应的get&#x2F;set方法； 一般用来和数据库的字段做映射 ORM；\n\nORM ：对象关系映射 ：\n\n表—&gt;类 \n字段–&gt;属性 \n行记录—-&gt;对象\n\n\n\n\nid\nname\nage\naddress\n\n\n\n1\nx\n12\n承德\n\n\n2\ny\n21\n天津\n\n\n3\nz\n32\n邢台\n\n\n\n对应的实体类\n\npublic class Person &#123;    private int id;    private String name ;    private int age;    private String address;    public Person(int id, String name, int age, String address) &#123;        this.id = id;        this.name = name;        this.age = age;        this.address = address;    &#125;    public Person() &#123;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getAddress() &#123;        return address;    &#125;    @Override    public String toString() &#123;        final StringBuffer sb = new StringBuffer(&quot;Person&#123;&quot;);        sb.append(&quot;id=&quot;).append(id);        sb.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, age=&quot;).append(age);        sb.append(&quot;, address=&#x27;&quot;).append(address).append(&#x27;\\&#x27;&#x27;);        sb.append(&#x27;&#125;&#x27;);        return sb.toString();    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;&#125;\n\n\n使用的时候就\n\nclass A&#123;    new Person(1,&quot;xiao&quot;,5,&quot;天津&quot;);&#125;\n\n\n使用jsp设置参数得到参数\n\n&lt;%//    Person person = new Person();//    person.setAge();//    person.setName();//    person.setId();//    person.setAddress();%&gt;&lt;jsp:useBean id=&quot;person&quot; class=&quot;Person&quot; scope=&quot;page&quot;/&gt;&lt;jsp:setProperty name=&quot;person&quot; property=&quot;id&quot; value=&quot;1&quot;/&gt;&lt;jsp:setProperty name=&quot;person&quot; property=&quot;name&quot; value=&quot;小&quot;/&gt;&lt;jsp:setProperty name=&quot;person&quot; property=&quot;age&quot; value=&quot;5&quot;/&gt;&lt;jsp:setProperty name=&quot;person&quot; property=&quot;address&quot; value=&quot;天津&quot;/&gt;&lt;%--&lt;%=person.getAddress()%&gt;--%&gt;id：&lt;jsp:getProperty name=&quot;person&quot; property=&quot;id&quot;/&gt;姓名：&lt;jsp:getProperty name=&quot;person&quot; property=&quot;name&quot;/&gt;年龄：&lt;jsp:getProperty name=&quot;person&quot; property=&quot;age&quot;/&gt;地址：&lt;jsp:getProperty name=&quot;person&quot; property=&quot;address&quot;/&gt;\n","tags":["JavaWeb"]},{"title":"JavaWeb之MVC三层架构","url":"/2022/04/24/JavaWeb%E4%B9%8BMVC%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/","content":"\nModel \n\n业务处理 ：业务逻辑（Service）\n数据持久层：CRUD （Dao）\n\nView\n\n展示数据 \n提供链接发起Servlet请求 （a，form，img…）\n\nController （Servlet）\n\n接收用户的请求 ：（req：请求参数、Session信息….） \n交给业务层处理对应的代码 \n控制视图的跳转\n\n登录---&gt;接收用户的登录请求---&gt;处理用户的请求（获取用户登录的参数，username，password）----&gt;交给业务层处理登录业务（判断用户名密码是否正确：事务）---&gt;Dao层查询用户名和密码是否正确--&gt;数据库\n\n","tags":["JavaWeb"]},{"title":"JavaWeb之Response下载文件","url":"/2022/04/18/JavaWeb%E4%B9%8BResponse%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/","content":"HttpServletResponseweb服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对 象，代表响应的一个HttpServletResponse：\n\n如果要获取客户端请求过来的参数：找HttpServletRequest \n如果要给客户端响应一些信息：找HttpServletResponse\n\n简单分类负责向浏览器发送数据的方法：\nServletOutputStream getOutputStream() throws IOException;PrintWriter getWriter() throws IOException;\n\n负责向浏览器发送响应头的方法:\nvoid setCharacterEncoding(String var1);void setContentLength(int var1);void setContentLengthLong(long var1);void setContentType(String var1);void setDateHeader(String var1, long var2);void addDateHeader(String var1, long var2);void setHeader(String var1, String var2);void addHeader(String var1, String var2);void setIntHeader(String var1, int var2);void addIntHeader(String var1, int var2);\n\n响应的状态码:\nint SC_CONTINUE = 100;int SC_SWITCHING_PROTOCOLS = 101;int SC_OK = 200;int SC_CREATED = 201;int SC_ACCEPTED = 202;int SC_NON_AUTHORITATIVE_INFORMATION = 203;int SC_NO_CONTENT = 204;int SC_RESET_CONTENT = 205;int SC_PARTIAL_CONTENT = 206;int SC_MULTIPLE_CHOICES = 300;int SC_MOVED_PERMANENTLY = 301;int SC_MOVED_TEMPORARILY = 302;int SC_FOUND = 302;int SC_SEE_OTHER = 303;int SC_NOT_MODIFIED = 304;int SC_USE_PROXY = 305;int SC_TEMPORARY_REDIRECT = 307;int SC_BAD_REQUEST = 400;int SC_UNAUTHORIZED = 401;int SC_PAYMENT_REQUIRED = 402;int SC_FORBIDDEN = 403;int SC_NOT_FOUND = 404;int SC_METHOD_NOT_ALLOWED = 405;int SC_NOT_ACCEPTABLE = 406;int SC_PROXY_AUTHENTICATION_REQUIRED = 407;int SC_REQUEST_TIMEOUT = 408;int SC_CONFLICT = 409;int SC_GONE = 410;int SC_LENGTH_REQUIRED = 411;int SC_PRECONDITION_FAILED = 412;int SC_REQUEST_ENTITY_TOO_LARGE = 413;int SC_REQUEST_URI_TOO_LONG = 414;int SC_UNSUPPORTED_MEDIA_TYPE = 415;int SC_REQUESTED_RANGE_NOT_SATISFIABLE = 416;int SC_EXPECTATION_FAILED = 417;int SC_INTERNAL_SERVER_ERROR = 500;int SC_NOT_IMPLEMENTED = 501;int SC_BAD_GATEWAY = 502;int SC_SERVICE_UNAVAILABLE = 503;int SC_GATEWAY_TIMEOUT = 504;int SC_HTTP_VERSION_NOT_SUPPORTED = 505;\n\n下载文件\n要获取下载文件的路径\n下载的文件名是啥？\n设置想办法让浏览器能够支持下载我们需要的东西 \n获取下载文件的输入流 \n创建缓冲区 \n获取OutputStream对象\n将FileOutputStream流写入到buffer缓冲区 \n使用OutputStream将缓冲区中的数据输出到客户端！\n\n@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;//1. 要获取下载文件的路径    String realPath = &quot;C:\\\\Users\\\\1\\\\Desktop\\\\fang\\\\java\\\\response\\\\target\\\\response-1.0-SNAPSHOT\\\\WEB-INF\\\\classes\\\\1.jpg&quot;;    System.out.println(&quot;下载文件的路径：&quot;+realPath);//2. 下载的文件名是啥？    String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\\\&quot;)+1);//3. 设置想办法让浏览器能够支持下载我们需要的东西    resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+ URLEncoder.encode(fileName,&quot;UTF-8&quot;));//4. 获取下载文件的输入流    FileInputStream in = new FileInputStream(realPath);//5. 创建缓冲区    int len = 0;    byte[] buffer = new byte[1024];//6. 获取OutputStream对象    ServletOutputStream out = resp.getOutputStream();//7. 将FileOutputStream流写入到buffer缓冲区,使用OutputStream将缓冲区中的数据输出到客户端！    while((len = in.read(buffer))&gt;0)&#123;        out.write(buffer,0,len);    &#125;    in.close();    out.close();&#125;\n\n\n自己配置映射\n\n","tags":["JavaWeb"]},{"title":"JavaWeb之Response重定向","url":"/2022/04/19/JavaWeb%E4%B9%8BResponse%E9%87%8D%E5%AE%9A%E5%90%91/","content":"实现重定向B一个web资源收到客户端A请求后，B他会通知A客户端去访问另外一个web资源C，这个过程叫重定向。常见场景是登录页面\n\n只需要使用一个函数就行sendRedirect\n\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;      /*      resp.setHeader(&quot;Location&quot;,&quot;/r/img&quot;);      resp.setStatus(302);      */      resp.sendRedirect(&quot;/r/img&quot;);  &#125;\n\n简单实现登录重定向\n我们先在index.jsp中设置一个表单\n\n&lt;%--这里提交的路径，需要寻找到项目的路径--%&gt;&lt;%--$&#123;pageContext.request.contextPath&#125;代表当前的项目--%&gt;  &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/login&quot; method=&quot;get&quot;&gt;      用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt;      密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt;      &lt;input type=&quot;submit&quot;&gt;  &lt;/form&gt;\n\n\n然后写请求\n\nimport javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RequestServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        String username = req.getParameter(&quot;username&quot;);        String password = req.getParameter(&quot;password&quot;);        System.out.println(username+&quot;:&quot;+password);        resp.sendRedirect(&quot;/success.jsp&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req, resp);    &#125;&#125;\n\n\n设置映射\n\n&lt;servlet&gt;  &lt;servlet-name&gt;requset&lt;/servlet-name&gt;  &lt;servlet-class&gt;RequestServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;  &lt;servlet-name&gt;requset&lt;/servlet-name&gt;  &lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n\n新建一个success.jsp用于重定向\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;  &lt;h1&gt;hello&lt;/h1&gt;  &lt;/body&gt;&lt;/html&gt;\n","tags":["JavaWeb"]},{"title":"JavaWeb之Response验证码实现","url":"/2022/04/19/JavaWeb%E4%B9%8BResponse%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0/","content":"@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    //如何让浏览器3秒自动刷新一次;    resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);    //在内存中创建一个图片    BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);    //得到图片    Graphics g = image.getGraphics();    //设置图片的背景颜色    g.setColor(Color.white);    g.fillRect(0,0,80,20);    //给图片写数据    g.setColor(Color.blue);    g.setFont(new Font(null,Font.BOLD,20));    g.drawString(makeNum(),0,20);    //告诉浏览器，这个请求用图片的方式打开    resp.setContentType(&quot;image/jpeg&quot;);    //不让浏览器缓存    resp.setDateHeader(&quot;expires&quot;,-1);    resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);    resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);    //把图片写给浏览器    ImageIO.write(image,&quot;jpg&quot;,resp.getOutputStream());&#125;private String makeNum()&#123;    Random random = new Random();    String num = random.nextInt(9999999) + &quot;&quot;;    StringBuffer sb = new StringBuffer();    for (int i = 0; i &lt; 7-num.length(); i++) &#123;        sb.append(&quot;0&quot;);    &#125;    num = sb.toString()+num;    return num;&#125;\n","tags":["JavaWeb"]},{"title":"JavaWeb之Servlet原理","url":"/2022/04/15/JavaWeb%E4%B9%8BServlet%E5%8E%9F%E7%90%86/","content":"Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会：\n","tags":["JavaWeb"]},{"title":"JavaWeb之两个简单Servlet互通","url":"/2022/04/18/JavaWeb%E4%B9%8B%E4%B8%A4%E4%B8%AA%E7%AE%80%E5%8D%95Servlet%E4%BA%92%E9%80%9A/","content":"web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的 web应用；&lt; &gt;   \n\nServletContext共享数据：\n\n\n在这个servlet中写数据\n\npackage com.fang;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class helloServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        ServletContext content = this.getServletContext();        String username = &quot;胡歌&quot;;        content.setAttribute(&quot;username&quot;,username);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req, resp);    &#125;&#125;\n\n\n在这个servlet中拿数据：\npackage com.fang;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class getServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        ServletContext context = this.getServletContext();        String username = (String) context.getAttribute(&quot;username&quot;);        resp.setContentType(&quot;text/html&quot;);        resp.setCharacterEncoding(&quot;utf-8&quot;);        resp.getWriter().print(&quot;名字&quot;+username);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req, resp);    &#125;&#125;\n\nweb.xml设置映射\n\n\n&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.fang.helloServlet&lt;/servlet-class&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;getc&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.fang.getServlet&lt;/servlet-class&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;getc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/getc&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n","tags":["JavaWeb"]},{"title":"JavaWeb之新建的第一个helloServlet程序","url":"/2022/04/15/JavaWeb%E4%B9%8B%E6%96%B0%E5%BB%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAhelloServlet%E7%A8%8B%E5%BA%8F/","content":"先写一个HelloServlet.java\n\n可以再tomcat端口中的example找实例代码\n\nimport javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class HelloServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse response) throws ServletException, IOException &#123;        //响应类型        response.setContentType(&quot;text/html&quot;);        response.setCharacterEncoding(&quot;utf-8&quot;);        //获取响应的输出流        PrintWriter out = response.getWriter();        out.println(&quot;&lt;html&gt;&quot;);        out.println(&quot;&lt;head&gt;&quot;);        out.println(&quot;&lt;title&gt;Hello World!&lt;/title&gt;&quot;);        out.println(&quot;&lt;/head&gt;&quot;);        out.println(&quot;&lt;body&gt;&quot;);        out.println(&quot;&lt;h1&gt;你好&lt;/h1&gt;&quot;);        out.println(&quot;&lt;/body&gt;&quot;);        out.println(&quot;&lt;/head&gt;&quot;);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req, resp);    &#125;&#125;\n\n然后我们还要配置web.xml，编写Servlet的映射。为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器， 所以我们需要再web服务中注册我们写的Servlet，还需给他一个浏览器能够访问的路径；\n&lt;web-app&gt;  &lt;!--  web.xml是配置我们web的核心应用--&gt;  &lt;!--  注册servlet--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt;  &lt;/servlet&gt;&lt;!--  一个servlet对应一个Mapping：映射--&gt;&lt;servlet-mapping&gt;  &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;  &lt;url-pattern&gt;/fang&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt;\n","tags":["JavaWeb"]},{"title":"JavaWeb之监听器","url":"/2022/04/25/JavaWeb%E4%B9%8B%E7%9B%91%E5%90%AC%E5%99%A8/","content":"实现一个监听器的接口，以统计网站在线人数为例\nimport javax.servlet.ServletContext;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;//统计网站在线人数 ： 统计sessionpublic class OnlineCountListener implements HttpSessionListener &#123;    //创建session监听： 看你的一举一动    //一旦创建Session就会触发一次这个事件！    @Override    public void sessionCreated(HttpSessionEvent httpSessionEvent) &#123;        ServletContext ctx = httpSessionEvent.getSession().getServletContext();        System.out.println(httpSessionEvent.getSession().getId());        Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;);        if(onlineCount == null)&#123;            onlineCount = new Integer(1);        &#125;else&#123;            int count = onlineCount.intValue();            onlineCount = new Integer(count+1);        &#125;        ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);    &#125;    //销毁session监听    //一旦销毁Session就会触发一次这个事件！    @Override    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) &#123;        ServletContext ctx = httpSessionEvent.getSession().getServletContext();        Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;);        if(onlineCount == null)&#123;            onlineCount = new Integer(0);        &#125;else&#123;            int count = onlineCount.intValue();            onlineCount = new Integer(count-1);        &#125;        ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);    &#125;    /*Session销毁：1. 手动销毁 getSession().invalidate();2. 自动销毁*/&#125;\n\n在web.xml中设置监听\n&lt;listener&gt;  &lt;listener-class&gt;OnlineCountListener&lt;/listener-class&gt;&lt;/listener&gt;\n\n\n在index.jsp中进行测试\n\n&lt;body&gt;&lt;h4&gt;当前一共&lt;span&gt;&lt;%=this.getServletConfig().getServletContext().getAttribute(&quot;OnlineCount&quot;)%&gt;个人&lt;/span&gt;&lt;/h4&gt;&lt;/body&gt;\n","tags":["JavaWeb"]},{"title":"JavaWeb之监听器GUI中的理解","url":"/2022/04/28/JavaWeb%E4%B9%8B%E7%9B%91%E5%90%AC%E5%99%A8GUI%E4%B8%AD%E7%9A%84%E7%90%86%E8%A7%A3/","content":"监听器：GUI编程中经常使用；\nimport java.awt.*;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.awt.event.WindowListener;public class TestPanel &#123;    public static void main(String[] args) &#123;        Frame frame = new Frame(&quot;你教授&quot;);        Panel panel = new Panel(null);        frame.setLayout(null);        frame.setBounds(300,300,500,500);        frame.setBackground(new Color(0,0,255));        panel.setBounds(300,300,500,500);        panel.setBackground(new Color(0,0,25));        frame.add(panel);        frame.setVisible(true);        frame.addWindowListener(new WindowListener() &#123;            @Override            public void windowOpened(WindowEvent e) &#123;                System.out.println(&quot;登上了&quot;);            &#125;            @Override            public void windowClosing(WindowEvent e) &#123;                System.out.println(&quot;关闭ing&quot;);                System.exit(0);            &#125;            @Override            public void windowClosed(WindowEvent e) &#123;                System.out.println(&quot;关闭ed&quot;);            &#125;            @Override            public void windowIconified(WindowEvent e) &#123;            &#125;            @Override            public void windowDeiconified(WindowEvent e) &#123;            &#125;            @Override            public void windowActivated(WindowEvent e) &#123;                System.out.println(&quot;激活&quot;);            &#125;            @Override            public void windowDeactivated(WindowEvent e) &#123;                System.out.println(&quot;未激活&quot;);            &#125;        &#125;);    &#125;&#125;\n","tags":["JavaWeb"]},{"title":"MySQL之JDBC复习","url":"/2022/04/29/MySQL%E4%B9%8BJDBC%E5%A4%8D%E4%B9%A0/","content":"什么是JDBC ： Java连接数据库！\n\n首先在pom.xml引入jar包\n\n      &lt;!--mysql的驱动--&gt;&lt;dependency&gt;&lt;groupId&gt;mysql&lt;/groupId&gt;&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;\n\nJDBC 固定步骤：\n\n加载驱动 \n连接数据库,代表数据库 \n向数据库发送SQL的对象Statement : CRUD\n编写SQL （根据业务，不同的SQL）\n执行SQL \n关闭连接\n\nimport java.sql.*;public class TestJdbc &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        //配置信息        //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码        String url=&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;;        String username = &quot;root&quot;;        String password = &quot;123456&quot;;        //1.加载驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //2.连接数据库,代表数据库        Connection connection = DriverManager.getConnection(url, username,                password);        //3.向数据库发送SQL的对象Statement,PreparedStatement : CRUD        Statement statement = connection.createStatement();        //4.编写SQL        String sql = &quot;select * from users&quot;;        //5.执行查询SQL，返回一个 ResultSet ： 结果集        ResultSet rs = statement.executeQuery(sql);        while (rs.next())&#123;            System.out.println(&quot;id=&quot;+rs.getObject(&quot;id&quot;));            System.out.println(&quot;name=&quot;+rs.getObject(&quot;name&quot;));            System.out.println(&quot;password=&quot;+rs.getObject(&quot;password&quot;));            System.out.println(&quot;email=&quot;+rs.getObject(&quot;email&quot;));            System.out.println(&quot;birthday=&quot;+rs.getObject(&quot;birthday&quot;));        &#125;        //6.关闭连接，释放资源（一定要做） 先开后关        rs.close();        statement.close();        connection.close();    &#125;&#125;\n\n预编译SQL\nimport java.sql.Connection;import java.sql.Date;import java.sql.DriverManager;import java.sql.PreparedStatement;public class TestJDBC2 &#123;    public static void main(String[] args) throws Exception &#123;        //配置信息        //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码        String url=&quot;jdbc:mysql://localhost:3306/jdbc? useUnicode=true&amp;characterEncoding=utf-8&quot;;        String username = &quot;root&quot;;        String password = &quot;123456&quot;;        //1.加载驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //2.连接数据库,代表数据库        Connection connection = DriverManager.getConnection(url, username, password);        //3.编写SQL        String sql = &quot;insert into users(id, name, password, email, birthday) values (?,?,?,?,?);&quot;;        //4.预编译        PreparedStatement preparedStatement = connection.prepareStatement(sql);        preparedStatement.setInt(1,2);//给第一个占位符？ 的值赋值为1；        preparedStatement.setString(2,&quot;Java&quot;);//给第二个占位符？ 的值赋值为Java        preparedStatement.setString(3,&quot;123456&quot;);//给第三个占位符？ 的值赋值为123456；        preparedStatement.setString(4,&quot;24736743@qq.com&quot;);//给第四个占位符？ 的值赋值为1；        preparedStatement.setDate(5,new Date(new java.util.Date().getTime()));//给第五个占位符？ 的值赋值为new Date(newjava.util.Date().getTime())；        //5.执行SQL        int i = preparedStatement.executeUpdate();        if (i&gt;0)&#123;            System.out.println(&quot;插入成功@&quot;);        &#125;        //6.关闭连接，释放资源（一定要做） 先开后关        preparedStatement.close();        connection.close();    &#125;&#125;\n\n事务：\nACID原则：保证数据的安全。\n开启事务事务提交 commit()事务回滚 rollback()关闭事务转账：A:1000B:1000A(900) --100--&gt; B(1100)\n\nJunit单元测试，需要引入依赖。@Test注解只有在方法上有效，只要加了这个注解的方法，就可以直接运行！\n&lt;!--单元测试--&gt;&lt;dependency&gt;&lt;groupId&gt;junit&lt;/groupId&gt;&lt;artifactId&gt;junit&lt;/artifactId&gt;&lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;\n\n\njava实现事务\n\nimport java.sql.*;public class TestJDBC2 &#123;        @Test        public void test() &#123;            //配置信息            //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码            String url = &quot;jdbc:mysql://localhost:3306/jdbc? useUnicode=true&amp;characterEncoding=utf-8&quot;;            String username = &quot;root&quot;;            String password = &quot;123456&quot;;            Connection connection = null;            //1.加载驱动            try &#123;                Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                //2.连接数据库,代表数据库                connection = DriverManager.getConnection(url, username,                        password);                //3.通知数据库开启事务,false 开启                connection.setAutoCommit(false);                String sql = &quot;update account set money = money-100 where name = &#x27;A&#x27;&quot;;                connection.prepareStatement(sql).executeUpdate();                //制造错误                //int i = 1/0;                String sql2 = &quot;update account set money = money+100 where name = &#x27;B&#x27;&quot;;                connection.prepareStatement(sql2).executeUpdate();                connection.commit();//以上两条SQL都执行成功了，就提交事务！                System.out.println(&quot;success&quot;);            &#125; catch (Exception e) &#123;                try &#123;                    //如果出现异常，就通知数据库回滚事务                    connection.rollback();                &#125; catch (SQLException e1) &#123;                    e1.printStackTrace();                &#125;                e.printStackTrace();            &#125; finally &#123;                try &#123;                    connection.close();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;&#125;\n","tags":["MySQL"]},{"title":"JavaWeb之ServletContext应用","url":"/2022/04/18/JavaWeb%E4%B9%8BServletContext%E5%BA%94%E7%94%A8/","content":"获取初始化参数\n在web.xml中设置参数\n\n&lt;context-param&gt;  &lt;param-name&gt;url&lt;/param-name&gt;  &lt;param-value&gt;jdbc:mysql://locallhost:3306/mybatis&lt;/param-value&gt;&lt;/context-param&gt;\n\n\n构建java类，用getInitParameter方法\n\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;          ServletContext context = this.getServletContext();          String url = context.getInitParameter(&quot;url&quot;);          resp.getWriter().print(url);      &#125;\n\n\nweb.xml中设置映射\n\n&lt;servlet&gt;  &lt;servlet-name&gt;dm3&lt;/servlet-name&gt;  &lt;servlet-class&gt;com.fang.ServletDemon3&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;  &lt;servlet-name&gt;dm3&lt;/servlet-name&gt;  &lt;url-pattern&gt;/dm3&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n请求转发\n构建java类，用getRequestDispatcher方法，然后也设置映射\n\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;      ServletContext context = this.getServletContext();      context.getRequestDispatcher(&quot;/dm3&quot;).forward(req,resp);    &#125;\n\n\n下面图，上面是请求转发，下面是重定向\n\n读取资源文件\n在java目录下新建properties\n\n在resources目录下新建properties \n\n发现：都被打包到了同一个路径下：classes，我们俗称这个路径为classpath: \n\n思路：需要一个文件流；\n\n我们新建文件db.properties\n\n\nusername=root12312password=zxczxczxc\n\n\n新建java类，自己设置映射吧\n\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;    InputStream is = this.getServletContext().getResourceAsStream(&quot;WEB-INF/classes/db.properties&quot;);    Properties prop = new Properties();    prop.load(is);    String username = prop.getProperty(&quot;username&quot;);    String password = prop.getProperty(&quot;password&quot;);    resp.getWriter().print(username+&quot;:&quot;+password);&#125;\n","tags":["JavaWeb"]},{"title":"MybatisPlus之乐观锁","url":"/2022/06/16/MybatisPlus%E4%B9%8B%E4%B9%90%E8%A7%82%E9%94%81/","content":"在面试过程中，我们经常会被问道乐观锁，悲观锁！这个其实非常简单！\n\n乐观锁：顾名思义十分乐观，他总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试！\n悲观锁：顾名思义十分悲观，他总是任务总是出现问题，无论干什么都会上锁！再去操作！\n\n当要更新一条记录的时候，希望这条记录没有被别人更新 乐观锁实现方式：\n乐观锁实现方式：\n\n取出记录，获取当前version\n更新时，带上这个version\n执行更新时，set version &#x3D; new version where version &#x3D; oldversion\n如果version不对，就更新失败\n\n测试一下mybatis-plus的乐观锁插件\n官方文档（必看）：https://baomidou.com/pages/0d93c0/#optimisticlockerinnerinterceptor\n有的方法会过期，具体操作以官方文档例子为主\n1、给数据库中增加version字段！\n\n2、我们实体类加对应的字段\n@Version //乐观锁Version注解private Integer version;\n\n3、注册组件\npackage com.oddfar.config;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author zhiyuan * @date 2021/4/5 17:57 */// 扫描我们的 mapper 文件夹@MapperScan(&quot;com.oddfar.mapper&quot;)@Configuration // 配置类public class MyBatisPlusConfig &#123;    // 注册乐观锁和分页插件(新版：3.4.0)    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); // 乐观锁插件        return interceptor;    &#125;&#125;\n\n4、测试一下！\n/** * 测试乐观锁 */@Testpublic void testOptimisticLocker()&#123;    // 1、查询用户信息    User user = userMapper.selectById(1L);    // 2、修改用户信息    user.setName(&quot;zhiyuan&quot;);    user.setEmail(&quot;123456@qq.com&quot;);    // 3、执行更新操作    userMapper.updateById(user);&#125;\n\n我们来模拟下\n// 测试乐观锁失败！多线程下@Testpublic void testOptimisticLocker2()&#123;    // 线程 1    User user = userMapper.selectById(1L);    user.setName(&quot;zhiyuan000000&quot;);    user.setEmail(&quot;000000000@qq.com&quot;);    // 模拟另外一个线程执行了插队操作    User user2 = userMapper.selectById(1L);    user2.setName(&quot;zhiyuan1111111&quot;);    user2.setEmail(&quot;111111111@qq.com&quot;);    userMapper.updateById(user2);    // 自旋锁来多次尝试提交！    userMapper.updateById(user); // 如果没有乐观锁就会覆盖插队线程的值！&#125;\n\n\n如果不加乐观锁，以上代码，name最后就是zhiyuan000000\n","tags":["MybatisPlus"]},{"title":"MybatisPlus之代码自动生成器","url":"/2022/06/17/MybatisPlus%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%99%A8/","content":"dao、pojo、service、controller都给我自己去编写完成！\nAutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。\n测试：\npublic class Code &#123;    public static void main(String[] args) &#123;        //需要构建一个 代码自动生成器 对象        // 代码生成器        AutoGenerator mpg = new AutoGenerator();        //配置策略        //1、全局配置        GlobalConfig gc = new GlobalConfig();        String projectPath = System.getProperty(&quot;user.dir&quot;);        gc.setOutputDir(projectPath + &quot;/src/main/java&quot;);//输出路径        gc.setAuthor(&quot;fang&quot;);//作者信息        gc.setOpen(false);//是否打开文件夹        gc.setFileOverride(false);  //是否覆盖        gc.setServiceName(&quot;%sService&quot;); //去Service的I前缀        gc.setIdType(IdType.ID_WORKER);        gc.setDateType(DateType.ONLY_DATE);//日期类型        gc.setSwagger2(true);        mpg.setGlobalConfig(gc);        //2、设置数据源        DataSourceConfig dsc = new DataSourceConfig();        dsc.setUrl(&quot;jdbc:mysql://localhost:3306/mybatis-plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&quot;);        dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);        dsc.setUsername(&quot;root&quot;);        dsc.setPassword(&quot;root&quot;);        dsc.setDbType(DbType.MYSQL);        mpg.setDataSource(dsc);        //3、包的配置        PackageConfig pc = new PackageConfig();        pc.setModuleName(&quot;blog&quot;);        pc.setParent(&quot;com.chanv&quot;);        pc.setEntity(&quot;pojo&quot;);        pc.setMapper(&quot;mapper&quot;);        pc.setService(&quot;service&quot;);        pc.setController(&quot;controller&quot;);        mpg.setPackageInfo(pc);        //4、策略配置        StrategyConfig strategy = new StrategyConfig();        strategy.setInclude(&quot;user&quot;);    //设置要映射的表名        strategy.setNaming(NamingStrategy.underline_to_camel);        strategy.setColumnNaming(NamingStrategy.underline_to_camel);        strategy.setEntityLombokModel(true);    //自动lombok        strategy.setLogicDeleteFieldName(&quot;deleted&quot;);        //自动填充配置        TableFill createTime = new TableFill(&quot;create_time&quot;, FieldFill.INSERT);        TableFill updateTime = new TableFill(&quot;update_time&quot;, FieldFill.UPDATE);        ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;();        tableFills.add(createTime);        tableFills.add(updateTime);        strategy.setTableFillList(tableFills);        //乐观锁        strategy.setVersionFieldName(&quot;version&quot;);        strategy.setRestControllerStyle(true);//驼峰命名        strategy.setControllerMappingHyphenStyle(true);     //localhost:8080/hello_id_2        mpg.setStrategy(strategy);        mpg.execute();  //执行代码构造器    &#125;&#125;\n","tags":["MybatisPlus"]},{"title":"MybatisPlus之分页查询","url":"/2022/06/17/MybatisPlus%E4%B9%8B%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/","content":"1、原始的 limit 进行分页 2、pageHelper 第三方插件 3、MP其实也内置了分页插件！\nmybais-plus分页查询方法：\n1、配置拦截器组件即可\ninterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.H2));//分页插件\n\n2、直接使用Page对象即可！\n/** * 测试分页查询 */@Testpublic void testPage() &#123;    //参数一：当前页    //参数二：页面大小    Page&lt;User&gt; page = new Page&lt;&gt;(1, 5);    userMapper.selectPage(page, null);    page.getRecords().forEach(System.out::println);    System.out.println(page.getTotal());//总数量&#125;\n","tags":["MybatisPlus"]},{"title":"MybatisPlus之删除操作","url":"/2022/06/17/MybatisPlus%E4%B9%8B%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/","content":"// 通过id单个删除@Testpublic void testDeleteById()&#123;    userMapper.deleteById(1379026108137123842L);&#125;// 通过id批量删除@Testpublic void testDeleteBatchId()&#123;   userMapper.deleteBatchIds(Arrays.asList(1379026108137123842L,1379026441420791810L));&#125;// 通过map删除@Testpublic void testDeleteMap()&#123;    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;name&quot;,&quot;zhiyuan4&quot;);    userMapper.deleteByMap(map);&#125;\n","tags":["MybatisPlus"]},{"title":"MybatisPlus之性能分析插件","url":"/2022/06/17/MybatisPlus%E4%B9%8B%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%8F%92%E4%BB%B6/","content":"作用：性能分析拦截器，用于输出每条 SQL 语句及其执行时间。MP也提供性能分析插件，如果超过这个时间就停止运行，不过新版本已去掉这功能。\n推荐使用druid\n或者使用P6Spy：\n\n该功能依赖 p6spy 组件，完美的输出打印 SQL 及执行时长 3.1.0 以上版本\n\n示例工程：\n👉 mybatis-plus-sample-crud(opens new window)\n\np6spy 依赖引入\n\nMaven：\n&lt;dependency&gt;  &lt;groupId&gt;p6spy&lt;/groupId&gt;  &lt;artifactId&gt;p6spy&lt;/artifactId&gt;  &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt;\n\nGradle：\ncompile group: &#x27;p6spy&#x27;, name: &#x27;p6spy&#x27;, version: &#x27;最新版本&#x27;\n\n\napplication.yml 配置：\n\nspring:  datasource:    driver-class-name: com.p6spy.engine.spy.P6SpyDriver    url: jdbc:p6spy:h2:mem:test    ...\n\n\nspy.properties 配置：\n\n#3.2.1以上使用modulelist=com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory#3.2.1以下使用或者不配置#modulelist=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory# 自定义日志打印logMessageFormat=com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger#日志输出到控制台appender=com.baomidou.mybatisplus.extension.p6spy.StdoutLogger# 使用日志系统记录 sql#appender=com.p6spy.engine.spy.appender.Slf4JLogger# 设置 p6spy driver 代理deregisterdrivers=true# 取消JDBC URL前缀useprefix=true# 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.excludecategories=info,debug,result,commit,resultset# 日期格式dateformat=yyyy-MM-dd HH:mm:ss# 实际驱动可多个#driverlist=org.h2.Driver# 是否开启慢SQL记录outagedetection=true# 慢SQL记录标准 2 秒outagedetectioninterval=2\n","tags":["MybatisPlus"]},{"title":"MybatisPlus之插入测试及主键生成策略","url":"/2022/06/16/MybatisPlus%E4%B9%8B%E6%8F%92%E5%85%A5%E6%B5%8B%E8%AF%95%E5%8F%8A%E4%B8%BB%E9%94%AE%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/","content":"插入操作@Testvoid addUser() &#123;    User user = new User();    user.setName(&quot;zhiyuan&quot;);    user.setAge(3);    user.setEmail(&quot;123456@qq.com&quot;);    // 帮我们自动生成id    int result = userMapper.insert(user);     System.out.println(result); // 受影响的行数    System.out.println(user); // 发现，id会自动回填&#125;\n\n数据库插入的id的默认值为：全局的唯一id\n主键生成策略\n默认 ID_WORKER 全局唯一id 分布式系统唯一id生成：https://www.cnblogs.com/haoxinyue/p/5208136.html\n\n雪花算法：snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！\n主键自增：\n实体类字段上 @TableId(type &#x3D; IdType.AUTO)\n\n数据库id字段自增！\n\n","tags":["MybatisPlus"]},{"title":"MybatisPlus之更新操作","url":"/2022/06/16/MybatisPlus%E4%B9%8B%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C/","content":"/** * 更改一个用户 */@Testvoid testUpdate() &#123;    User user = new User();    // 通过条件自动拼接动态sql    user.setId(5L);    user.setName(&quot;test&quot;);    user.setAge(5);    // 注意：updateById 但是参数是一个 对象！    int i = userMapper.updateById(user);    System.out.println(i);&#125;\n","tags":["MybatisPlus"]},{"title":"MybatisPlus之条件构造器","url":"/2022/06/17/MybatisPlus%E4%B9%8B%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8/","content":"官网文档：https://baomidou.com/pages/10c804/#alleq\nwrapper：十分重要： 我们写一些复杂的sql就可以使用它来替代！\n1、查询name不为空的用户，并且邮箱不为空的用户，年龄大于12\n@Testvoid contextLoads() &#123;    //查询name不为空的用户，并且邮箱不为空的用户，年龄大于12    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();    wrapper.isNotNull(&quot;name&quot;)            .isNotNull(&quot;email&quot;)            .ge(&quot;age&quot;, 12);    userMapper.selectList(wrapper).forEach(System.out::println); &#125;\n\n2、查询名字为zhiyuan2\n@Testvoid test2()&#123;    //查询名字为zhiyuan2    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;name&quot;, &quot;zhiyuan2&quot;);    User user = userMapper.selectOne(wrapper);    System.out.println(user);&#125;\n\n3、查询年龄在19到30岁之间的用户\n@Testvoid test3()&#123;    //查询年龄在19到30岁之间的用户    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();    wrapper.between(&quot;age&quot;, 19, 30); //区间    Integer count = userMapper.selectCount(wrapper);    System.out.println(count);&#125;\n\n4、查询name不包含t，邮箱以123开头\n\n例: notLike(&quot;name&quot;, &quot;王&quot;)—&gt;name not like &#39;%王%&#39;\n例: likeRight(&quot;name&quot;, &quot;王&quot;)—&gt;name like &#39;王%&#39;\n\n//模糊查询@Testvoid test4()&#123;    //查询name不包含t，邮箱以123开头    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();    wrapper.notLike(&quot;name&quot;, &quot;t&quot;)            .likeRight(&quot;email&quot;, &quot;123&quot;);    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper);    maps.forEach(System.out::println);&#125;\n\n5、子查询\n@Testvoid test5()&#123;    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();    //id 在子查询中查出来    wrapper.inSql(&quot;id&quot;, &quot;select id from user where id &lt; 3&quot;);    List&lt;Object&gt; objects = userMapper.selectObjs(wrapper);    objects.forEach(System.out::println);&#125;\n\n最后sql：\n\nSELECT id,name,age,email,version,deleted,create_time,update_time FROM user WHERE deleted&#x3D;0 AND (id IN (select id from user where id &lt; 3))\n\n6、通过id进行排序–降序\n@Testvoid test6()&#123;    QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();    //通过id进行排序--降序    wrapper.orderByDesc(&quot;id&quot;);    List&lt;User&gt; users = userMapper.selectList(wrapper);    users.forEach(System.out::println);&#125;\n","tags":["MybatisPlus"]},{"title":"MybatisPlus之查询操作","url":"/2022/06/17/MybatisPlus%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/","content":"// 指定id查询@Testpublic void testSelectById()&#123;    User user = userMapper.selectById(1L);    System.out.println(user);&#125;// 多个id批量查询！@Testpublic void testSelectByBatchId()&#123;    List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1L, 2L, 3L));    users.forEach(System.out::println);&#125;// 多个where条件查询之一使用map操作@Testpublic void testSelectByBatchIds()&#123;    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();    // 自定义要查询    map.put(&quot;name&quot;,&quot;zhiyuan&quot;);    map.put(&quot;age&quot;,3);    List&lt;User&gt; users = userMapper.selectByMap(map);    users.forEach(System.out::println);&#125;\n","tags":["MybatisPlus"]},{"title":"MybatisPlus之简介","url":"/2022/06/16/MybatisPlus%E4%B9%8B%E7%AE%80%E4%BB%8B/","content":"原先写crud，需要在xml配置或注解中写sql语句，用了MyBatisPlus后，对单表进行crud无需再写sql语句\n简单的增删改查还行，不支持多表操作，一般不在公司里使用，适合个人快速开发和偷懒使用\n官网：https://baomidou.com/\n简介：简化mybatis，简化开发、提高写代码效率\n\n无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑\n损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作\n强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求\n支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错\n支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题\n支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作\n支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）\n内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用\n内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询\n分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库\n内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询\n内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作\n\n","tags":["MybatisPlus"]},{"title":"MybatisPlus之快速开始","url":"/2022/06/16/MybatisPlus%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/","content":"官网地址：https://mp.baomidou.com/guide/quick-start.html\n使用第三方组件：\n\n导入对应的依赖\n研究依赖如何配置\n代码如何编写\n提高扩展技术能力！\n\n步骤：\n1、创建数据库 mybatis_plus2、创建user表并插入数据DROP TABLE IF EXISTS user;CREATE TABLE user(\tid BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;,\tname VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;姓名&#x27;,\tage INT(11) NULL DEFAULT NULL COMMENT &#x27;年龄&#x27;,\temail VARCHAR(50) NULL DEFAULT NULL COMMENT &#x27;邮箱&#x27;,\tPRIMARY KEY (id));DELETE FROM user;INSERT INTO user (id, name, age, email) VALUES(1, &#x27;Jone&#x27;, 18, &#x27;test1@baomidou.com&#x27;),(2, &#x27;Jack&#x27;, 20, &#x27;test2@baomidou.com&#x27;),(3, &#x27;Tom&#x27;, 28, &#x27;test3@baomidou.com&#x27;),(4, &#x27;Sandy&#x27;, 21, &#x27;test4@baomidou.com&#x27;),(5, &#x27;Billie&#x27;, 24, &#x27;test5@baomidou.com&#x27;);\n\n3、编写项目，初始化项目！使用SpringBoot初始化！4、导入依赖&lt;!-- 数据库驱动 --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;\n\n5、填写properties配置spring.datasource.username=rootspring.datasource.password=123456spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\n6、填写测试类，读取数据库原先我们使用mybatis：pojo-dao（连接mybatis，配置mapper.xml文件）-service-controller\n现在：\n\npojo类\n@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123;    private Long id;    private String name;    private Integer age;    private String email;&#125;\n\nmapper接口\n// 在对应的Mapper上面继承基本的类 BaseMapper@Repository // 代表持久层public interface UserMapper extends BaseMapper&lt;User&gt; &#123;    // 所有的CRUD操作都已经编写完成了    // 你不需要像以前的配置一大堆文件了！&#125;\n\nspringboot启动类\n添加注解来扫描\n@MapperScan(&quot;com.oddfar.mapper&quot;)\n\n测试类\n// 继承了BaseMapper，所有的方法都来自己父类// 我们也可以编写自己的扩展方法！@Autowiredprivate UserMapper userMapper;@Testvoid contextLoads() &#123;    // 参数是一个 Wrapper ，条件构造器，这里我们先不用，填写null    // 查询全部用户    List&lt;User&gt; users = userMapper.selectList(null);    users.forEach(System.out::println);&#125;\n\n","tags":["MybatisPlus"]},{"title":"MybatisPlus之自动填充","url":"/2022/06/16/MybatisPlus%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85/","content":"创建时间、修改时间！这些个操作一遍都是自动化完成的，我们不希望手动更新！\n阿里巴巴开发手册：所有的数据库表：gmt_create、gmt_modified几乎所有的表都要配置上！而且需 要自动化！\n方式一：数据库级别（工作中一般不允许你修改数据库）\n1、在表中新增字段 create_time, update_time\nALTER TABLE `mybatis_plus`.`user`  ADD COLUMN `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP NULL COMMENT &#x27;创建时间&#x27; AFTER `email`,  ADD COLUMN `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL COMMENT &#x27;更新时间&#x27; AFTER `create_time`;\n\n\n默认：CURRENT_TIMESTAMP\n2、再次测试插入方法，我们需要先把实体类同步！\n方式二：代码级别\n1、删除数据库的默认值、更新操作！\n\n2、实体类字段属性上需要增加注解\n// 字段添加填充内容@TableField(fill = FieldFill.INSERT)private Date createTime;@TableField(fill = FieldFill.INSERT_UPDATE)private Date updateTime;\n\n3、编写处理器来处理这个注解即可！\npackage com.oddfar.handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.util.Date;@Slf4j@Component // 一定不要忘记把处理器加到IOC容器中！public class MyMetaObjectHandler implements MetaObjectHandler &#123;    // 插入时的填充策略    @Override    public void insertFill(MetaObject metaObject) &#123;        log.info(&quot;start insert fill.....&quot;);        // setFieldValByName(String fieldName, Object fieldVal, MetaObject metaObject        this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject);        this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject);    &#125;    // 更新时的填充策略    @Override    public void updateFill(MetaObject metaObject) &#123;        log.info(&quot;start update fill.....&quot;);        this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject);    &#125;&#125;\n\n4、测试插入 ，测试更新、观察时间即可！\n","tags":["MybatisPlus"]},{"title":"MybatisPlus之逻辑删除","url":"/2022/06/17/MybatisPlus%E4%B9%8B%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4/","content":"官方文档：https://baomidou.com/pages/6b03c5/#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95\n物理删除 ：从数据库中直接移除\n逻辑删除 ：再数据库中没有被移除，而是通过一个变量来让他失效！ 比如一个系统，有管理员，操作员，用户等…… 设置数据库的时候，加个deleted字段，默认为0，代表数据存在 当用户或操作员要删除数据了，我们则把deleted赋值为1，表示数据已删除 这样管理员则可以在后台查询被删除的记录，防止数据的丢失，类似于回收站！\n方法如下：\n1、在数据表中增加一个 deleted 字段\n\n2、实体类中增加属性\n@TableLogic //逻辑删除private Integer deleted;\n\n3、配置\napplication.yml（properties也可以）\nmybatis-plus:  global-config:    db-config:      logic-delete-field: flag  # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)      logic-delete-value: 1 # 逻辑已删除值(默认为 1)      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)\n\n4、测试\n\n记录依旧在数据库，但是值确已经变化了！查询的时候会自动过滤被逻辑删除的字段\n","tags":["MybatisPlus"]},{"title":"MybatisPlus之配置日志","url":"/2022/06/16/MybatisPlus%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97/","content":"我们所有的sql现在是不可见的，我们希望知道他是怎么执行的，所以我们必须要看日志！\n# 配置日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl\n","tags":["MybatisPlus"]},{"title":"Mybatis之Log4j","url":"/2022/05/05/Mybatis%E4%B9%8BLog4j/","content":"简介：\n\nLog4j是Apache的一个开源项目 \n通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件…. \n我们也可以控制每一条日志的输出格式；  \n通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n\n使用步骤：\n\n导入log4j的包\n\n&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;\n\n\n配置文件编写，建立log4j.properties文件\n\n#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/xiao.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG\n\n\nsetting设置日志实现\n\n&lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt;\n\n\n在程序中使用Log4j进行输出！\n\n    private static final Logger LOG = Logger.getLogger(MyTest.class);@Test    public void getUserLike()&#123;    LOG.info(&quot;info：  进入getUserLike方法&quot;);    LOG.debug(&quot;debug：进入getUserLike方法&quot;);    LOG.error(&quot;error: 进入getUserLike方法&quot;);    SqlSession session = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    List&lt;User&gt; users = mapper.getUserLike(&quot;张&quot;);    for (User user : users) &#123;        System.out.println(user);    &#125;    session.close();&#125;\n\n","tags":["Mybatis"]},{"title":"Mybatis之Map和模糊查询拓展","url":"/2022/05/03/Mybatis%E4%B9%8BMap%E5%92%8C%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E6%8B%93%E5%B1%95/","content":"1.万能的Map\n在接口方法中，参数直接传递Map；\n\n//使用MapUser selectUserByNP2(Map&lt;String,Object&gt; map);\n\n\n编写sql语句的时候，需要传递参数类型，参数类型为map\n\n&lt;select id=&quot;selectUserByNP2&quot; parameterType=&quot;map&quot; resultType=&quot;com.fang.pojo.User&quot;&gt;    select * from mybatis.user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;&lt;/select&gt;\n\n\n在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！\n\n@Test    public void selectUserByNP2()&#123;    SqlSession session = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;username&quot;,&quot;张三&quot;);    map.put(&quot;pwd&quot;,&quot;abcdef&quot;);    User user = mapper.selectUserByNP2(map);    System.out.println(user);    session.close();&#125;\n\n\n总结：如果参数过多，我们可以考虑直接使用Map实现\n\n2.模糊查询模糊查询like语句该怎么写?\n\n我们先把接口写出来\n\n//模糊查询List&lt;User&gt; getUserLike(String value);\n\n\n我们在把mapper.xml写出来\n\n&lt;select id=&quot;getUserLike&quot; resultType=&quot;com.fang.pojo.User&quot;&gt;    select * from mybatis.user where name Like #&#123;value&#125;&lt;/select&gt;\n\n\n第1种：在Java代码中添加sql通配符。\n\n@Test    public void getUserLike()&#123;    SqlSession session = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    List&lt;User&gt; users = mapper.getUserLike(&quot;%张%&quot;);    for (User user : users) &#123;        System.out.println(user);    &#125;    session.close();&#125;\n\n\n第2种：在sql语句中拼接通配符，会引起sql注入（先把第一种的%去掉）\n\n&lt;select id=&quot;getUserLike&quot; resultType=&quot;com.fang.pojo.User&quot;&gt;    select * from mybatis.user where name Like &quot;%&quot;#&#123;value&#125;&quot;%&quot;&lt;/select&gt;\n","tags":["Mybatis"]},{"title":"Mybatis之MyBatis实现CRUD操作","url":"/2022/05/03/Mybatis%E4%B9%8BMyBatis%E5%AE%9E%E7%8E%B0CRUD%E6%93%8D%E4%BD%9C/","content":"1.namespace配置文件中namespace中的名称为对应Mapper接口或者Dao接口的完整包名,必须一致！\n2.select\nselect标签是mybatis中最常用的标签之一 \nselect语句有很多属性可以详细配置每一条SQL语句 \nid \n命名空间中唯一的标识符 \n接口中的方法名与映射文件中的SQL语句ID 一一对应\n\n\nparameterType \n传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】\n\n\nresultType \nSQL语句返回值类型。【完整的类名或者别名】\n\n\n\n\n\n需求：根据id查询用户\n\n在UserMapper.java中添加对应方法\n\n//根据id查询用户User selectUserById(int id);\n\n2.在UserMapper.xml中添加Select语句\n&lt;select id=&quot;selectUserById&quot; resultType=&quot;com.fang.pojo.User&quot;&gt;    select * from user where id = #&#123;id&#125;&lt;/select&gt;\n\n3.测试类中测试\n@Testpublic void testSelectUserById() &#123;    SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接    UserMapper mapper = session.getMapper(UserMapper.class);    User user = mapper.selectUserById(1);    System.out.println(user);    session.close();&#125;\n\n3.insert需求：给数据库增加一个用户\n\n在UserMapper接口中添加对应的方法\n\n//添加一个用户int addUser(User user);\n\n2.在UserMapper.xml中添加insert语句\n&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.fang.pojo.User&quot;&gt;    insert into mybatis.user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&lt;/insert&gt;\n\n3.测试\n@Testpublic void testAddUser()&#123;    SqlSession session = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    User user = new User(4, &quot;王四&quot;, &quot;zzz&quot;);    int i = mapper.addUser(user);    System.out.println(i);    session.commit();    session.close();\n\n注意点：增、删、改操作需要提交事务！\n4.update需求：修改用户的信息\n\n同理，编写接口方法\n\n//修改一个用户int updateUser(User user);\n\n\n编写对应的配置文件SQL\n\n&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.fang.pojo.User&quot;&gt;    update mybatis.user set  name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;&lt;/update&gt;\n\n3.测试\n@Testpublic void testUpdateUser()&#123;    SqlSession session = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    User user = mapper.selectUserById(1);    user.setPwd(&quot;xiaoer&quot;);    int i = mapper.updateUser(user);    System.out.println(i);    session.commit();    session.close();&#125;\n\n5.delete需求：根据id删除一个用户\n\n同理，编写接口方法\n\n//根据id删除用户int deleteUser(int id);\n\n2.编写对应的配置文件SQL\n&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;    delete from mybatis.user where id = #&#123;id&#125;&lt;/delete&gt;\n\n3.测试\n@Test    public void testdelete()&#123;    SqlSession session = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    mapper.deleteUser(1);    session.commit();    session.close();    &#125;\n","tags":["Mybatis"]},{"title":"Mybatis之MyBatis第一个程序","url":"/2022/05/02/Mybatis%E4%B9%8BMyBatis%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/","content":"第一个Mybatis程序思路流程：搭建环境–&gt;导入Mybatis—&gt;编写代码—&gt;测试\n1.我们先搭建实验数据库，我是直接在IDEA中先连接上数据库，然后输入以下代码\ncreate database `mybatis`;use `mybatis`;drop table if exists `user`;create table `user`(    `id` int(20) not null ,    `name` varchar(20) default null ,    `pwd` varchar(20) default null ,    primary key (`id`))engine=InnoDB default charset=utf8;insert into user (id, name, pwd) values (1,&#x27;x&#x27;,&#x27;123456&#x27;),(2,&#x27;y&#x27;,&#x27;abcdef&#x27;),(3,&#x27;z&#x27;,&#x27;987654&#x27;);\n\n\n导入MyBatis相关 jar 包\n\n &lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.47&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n3.编写MyBatis核心配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;你自己的密码&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;&lt;/configuration&gt;\n\n\n编写MyBatis工具类，创建utils软件包\n\npackage com.fang.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtils &#123;    private static  SqlSessionFactory sqlSessionFactory;   static&#123;        try &#123;            String resource = &quot;mybatis-config.xml&quot;;            InputStream inputStream = Resources.getResourceAsStream(resource);             sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    //获取SqlSession连接    public static SqlSession getSession()&#123;        return sqlSessionFactory.openSession();    &#125;&#125;\n\n5.在pojo软件包下创建实体类\npackage com.fang.pojo;public class User &#123;    private int id;    private String name;    private String pwd;    public User() &#123;    &#125;    public User(int id, String name, String pwd) &#123;        this.id = id;        this.name = name;        this.pwd = pwd;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getPwd() &#123;        return pwd;    &#125;    public void setPwd(String pwd) &#123;        this.pwd = pwd;    &#125;    @Override    public String toString() &#123;        final StringBuffer sb = new StringBuffer(&quot;User&#123;&quot;);        sb.append(&quot;id=&quot;).append(id);        sb.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, pwd=&#x27;&quot;).append(pwd).append(&#x27;\\&#x27;&#x27;);        sb.append(&#x27;&#125;&#x27;);        return sb.toString();    &#125;&#125;\n\n6.在mapper软件包下编写Mapper接口类\npackage com.fang.mapper;import com.fang.pojo.User;import java.util.List;public interface UserMapper &#123;    List&lt;User&gt; selectUser();&#125;\n\n\n在mapper下编写Mapper.xml配置文件\nnamespace 十分重要，不能写错\n\n\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.fang.mapper.UserMapper&quot;&gt;    &lt;select id=&quot;selectUser&quot; resultType=&quot;com.fang.pojo.User&quot;&gt;        select * from user    &lt;/select&gt;&lt;/mapper&gt;\n\n8.编写测试类\n\nJunit 包测试\n\npackage com.fang.mapper;import com.fang.pojo.User;import com.fang.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import java.util.List;public class MyTest &#123;    @Test    public void selectUser()&#123;        SqlSession session = MybatisUtils.getSession();        UserMapper mapper = session.getMapper(UserMapper.class);        List&lt;User&gt; users = mapper.selectUser();        for (User user : users) &#123;            System.out.println(user);        &#125;        session.close();    &#125;&#125;\n\n遇到问题\n遇到的第一个问题：\n\n解决方法：\n\n遇到的第二个问题\n\n\norg.apache.ibatis.binding.BindingException: Type interface com.fang.mapper.UserMapper is not known to the MapperRegistry.\n\n\n解决方法在mybatis-config.xml增加\n\n&lt;mappers&gt;    &lt;mapper resource=&quot;com/fang/mapper/UserMapper.xml&quot;/&gt;&lt;/mappers&gt;\n\n\n遇到的第三个问题：就是Maven静态资源过滤问题\n\nCould not find resource com/fang/mapper/UserMapper.xml\n\n\n解决方法，在pom.xml增加\n\n&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;\n","tags":["Mybatis"]},{"title":"Mybatis之Mybatis缓存","url":"/2022/05/07/Mybatis%E4%B9%8BMybatis%E7%BC%93%E5%AD%98/","content":"1.缓存简介\n什么是缓存 [ Cache ]？ \n存在内存中的临时数据。 \n将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库 数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。\n\n\n为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率。 \n什么样的数据能使用缓存？ 经常查询并且不经常改变的数据。\n\n2.Mybatis缓存\nMyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的 提升查询效率。 \nMyBatis系统中默认定义了两级缓存：一级缓存和二级缓存 \n默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） \n二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 \n为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二 级缓存\n\n\n\n3.一级缓存一级缓存也叫本地缓存:\n\n与数据库同一次会话期间查询到的数据会放在本地缓存中。 \n以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；\n\n测试:\n编写接口方法\n\n//根据id查询用户User queryUserById(@Param(&quot;id&quot;) int id);\n\n\n接口对应的Mapper文件\n\n&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;    select * from user where id = #&#123;id&#125;&lt;/select&gt;\n\n\n测试\n\n@Testpublic void testQueryUserById()&#123;    SqlSession session = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    User user = mapper.queryUserById(2);    System.out.println(user);    User user2 = mapper.queryUserById(2);    System.out.println(user2);    System.out.println(user==user2);    session.close();&#125;\n\n\n结果分析：通过下图可以看出SQL只查询了一次，第二次结果，没有进行数据库查询；true表明用的同一个对象\n\n\n一级缓存失效的四种情况\n一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它； \n一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请 求！\n\n\nsqlSession不同\n\n@Testpublic void testQueryUserById()&#123;    SqlSession session = MybatisUtils.getSession();    SqlSession session2 = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    UserMapper mapper2 = session2.getMapper(UserMapper.class);    User user = mapper.queryUserById(2);    System.out.println(user);    User user2 = mapper2.queryUserById(2);    System.out.println(user2);    System.out.println(user==user2);    session.close();    session2.close();&#125;\n\n观察结果：发现发送了两条SQL语句！\n结论：每个sqlSession中的缓存相互独立\n\nsqlSession相同，查询条件不同\n\n@Testpublic void testQueryUserById()&#123;    SqlSession session = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    UserMapper mapper2 = session.getMapper(UserMapper.class);    User user = mapper.queryUserById(2);    System.out.println(user);    User user2 = mapper2.queryUserById(3);    System.out.println(user2);    System.out.println(user==user2);    session.close();&#125;\n\n观察结果：发现发送了两条SQL语句！很正常的理解 \n结论：当前缓存中，不存在这个数据\n\nsqlSession相同，两次查询之间执行了增删改操作！\n\n\n增加方法\n\n//修改用户int updateUser(Map map);\n\n\n编写SQL\n\n&lt;update id=&quot;updateUser&quot; parameterType=&quot;map&quot;&gt;    update user set name = #&#123;name&#125; where id = #&#123;id&#125;&lt;/update&gt;\n\n\n测试\n\n@Testpublic void testQueryUserById()&#123;    SqlSession session = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    User user = mapper.queryUserById(2);    System.out.println(user);    HashMap map = new HashMap();    map.put(&quot;name&quot;,&quot;qwe&quot;);    map.put(&quot;id&quot;,4);    mapper.updateUser(map);    User user2 = mapper.queryUserById(2);    System.out.println(user2);    System.out.println(user==user2);    session.close();&#125;\n\n观察结果：查询在中间执行了增删改操作后，重新执行了 \n结论：因为增删改操作可能会对当前数据产生影响\n\nsqlSession相同，手动清除一级缓存\n\n@Testpublic void testQueryUserById()&#123;    SqlSession session = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    User user = mapper.queryUserById(2);    System.out.println(user);    session.clearCache();//手动清除缓存    User user2 = mapper.queryUserById(2);    System.out.println(user2);    System.out.println(user==user2);    session.close();&#125;\n\n4.二级缓存\n二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 \n基于namespace级别的缓存，一个名称空间，对应一个二级缓存； \n工作机制 \n一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； \n如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； \n新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中；\n\n\n\n使用步骤\n开启全局缓存 【mybatis-config.xml】\n\n&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;\n\n\n去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】\n\n&lt;cache/&gt;官方示例=====&gt;查看官方文档&lt;cache        eviction=&quot;FIFO&quot;        flushInterval=&quot;60000&quot;        size=&quot;512&quot;        readOnly=&quot;true&quot;/&gt;这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。\n\n\n代码测试\n\n\n所有的实体类先实现序列化接口 \n测试代码\n\n@Testpublic void testQueryUserById()&#123;    SqlSession session = MybatisUtils.getSession();    SqlSession session2 = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    UserMapper mapper2 = session2.getMapper(UserMapper.class);    User user = mapper.queryUserById(2);    System.out.println(user);    session.close();    User user2 = mapper2.queryUserById(2);    System.out.println(user2);    System.out.println(user==user2);    session2.close();&#125;\n\n结论\n只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据 \n查出的数据都会被默认先放在一级缓存中 \n只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中\n\n5.缓存原理\n6.EhCache第三方缓存实现–EhCache: 查看百度百科 \n\n官方文档 :mybatis-ehcache – MyBatis Ehcache | Reference Documentation\nEhcache是一种广泛使用的java分布式缓存，用于通用缓存； \n要在应用程序中使用Ehcache，需要引入依赖的jar包\n\n!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis\u0002ehcache --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt;\n\n\n在mapper.xml中使用对应的缓存即可\n\n&lt;mapper namespace = “org.acme.FooMapper” &gt;&lt;cache type = “org.mybatis.caches.ehcache.EhcacheCache” /&gt;&lt;/mapper&gt;\n\n\n编写ehcache.xml文件，如果在 加载时 未找到 &#x2F;ehcache.xml 资源或出现问题，则将使用默 认配置。\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;         updateCheck=&quot;false&quot;&gt;    &lt;!--    diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位    置。参数解释如下：    user.home – 用户主目录    user.dir – 用户当前工作目录    java.io.tmpdir – 默认临时文件路径    --&gt;    &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt;    &lt;defaultCache            eternal=&quot;false&quot;            maxElementsInMemory=&quot;10000&quot;            overflowToDisk=&quot;false&quot;            diskPersistent=&quot;false&quot;            timeToIdleSeconds=&quot;1800&quot;            timeToLiveSeconds=&quot;259200&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;    &lt;cache            name=&quot;cloud_user&quot;            eternal=&quot;false&quot;            maxElementsInMemory=&quot;5000&quot;            overflowToDisk=&quot;false&quot;            diskPersistent=&quot;false&quot;            timeToIdleSeconds=&quot;1800&quot;            timeToLiveSeconds=&quot;1800&quot;            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;    &lt;!--    defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策    略。只能定义一个。    --&gt;    &lt;!--    name:缓存名称。    maxElementsInMemory:缓存最大数目    maxElementsOnDisk：硬盘最大缓存个数。    eternal:对象是否永久有效，一但设置了，timeout将不起作用。    overflowToDisk:是否保存到磁盘，当系统当机时    timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当    eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。    timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建    时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存    活时间无穷大。    diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store    persists between restarts of the Virtual Machine. The default value is    false.    diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默    认是30MB。每个Cache都应该有自己的一个缓冲区。    diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。    memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将    会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先    出）或是LFU（较少使用）。    clearOnFlush：内存数量最大时是否清除。    memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、    FIFO（先进先出）、LFU（最少访问次数）。    FIFO，first in first out，这个是大家最熟的，先进先出。    LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以    来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。    LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容    量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的    元素将被清出缓存。    --&gt;&lt;/ehcache&gt;\n\n","tags":["Mybatis"]},{"title":"Mybatis之Mybatis详细的执行流程","url":"/2022/05/05/Mybatis%E4%B9%8BMybatis%E8%AF%A6%E7%BB%86%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/","content":"\n","tags":["Mybatis"]},{"title":"Mybatis之PageHelper","url":"/2022/05/05/Mybatis%E4%B9%8BPageHelper/","content":"\n官方文档：https://pagehelper.github.io/\n详细使用文档：https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/en/HowToUse.md\n","tags":["Mybatis"]},{"title":"Mybatis之ResultMap结果映射","url":"/2022/05/03/Mybatis%E4%B9%8BResultMap%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84/","content":"要解决的问题：属性名和字段名不一致\n\n1.查询为null的问题1.我们假设将数据库的字段名设置为id,name,pwd\n2.而我们Java的实体类设计\npackage com.fang.pojo;public class User &#123;    private int id;    private String name;    private String password;    public User() &#123;    &#125;    public User(int id, String name, String password) &#123;        this.id = id;        this.name = name;        this.password = password;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    @Override    public String toString() &#123;        final StringBuffer sb = new StringBuffer(&quot;User&#123;&quot;);        sb.append(&quot;id=&quot;).append(id);        sb.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, password=&#x27;&quot;).append(password).append(&#x27;\\&#x27;&#x27;);        sb.append(&#x27;&#125;&#x27;);        return sb.toString();    &#125;&#125;\n\n3.接口\n//模糊查询List&lt;User&gt; getUserLike(String value);\n\n4.mapper映射文件\n&lt;select id=&quot;getUserLike&quot; resultType=&quot;com.fang.pojo.User&quot;&gt;    select * from mybatis.user where name Like &quot;%&quot;#&#123;value&#125;&quot;%&quot;&lt;/select&gt;\n\n5.我们执行查询操作\n@Test    public void getUserLike()&#123;    SqlSession session = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    List&lt;User&gt; users = mapper.getUserLike(&quot;张&quot;);    for (User user : users) &#123;        System.out.println(user);    &#125;    session.close();&#125;\n\n结果：\n\n分析：\n\nselect * from mybatis.user where name Like “%”#{value}”%”可以看成select id,name,pwd from userwhere name Like “%”#{value}”%”\n\nmybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找 相应列名的set方法设值 , 由于找不到setPwd() , 所以password返回null ; 【自动映射】\n\n\n2.解决方案方案一：为列名指定别名 , 别名和java实体类的属性名一致 .\n&lt;select id=&quot;getUserLike&quot; resultType=&quot;com.fang.pojo.User&quot;&gt;    select id , name , pwd as password  from mybatis.user where name Like &quot;%&quot;#&#123;value&#125;&quot;%&quot;&lt;/select&gt;\n\n方案二：使用结果集映射-&gt;ResultMap 【推荐】\n&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;    &lt;!-- id为主键 --&gt;    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;    &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;    &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;    &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserLike&quot; resultMap=&quot;UserMap&quot;&gt;        select * from mybatis.user where name Like &quot;%&quot;#&#123;value&#125;&quot;%&quot;    &lt;/select&gt;\n\n3.ResultMap3.1自动映射\nresultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC \nResultSets 数据提取代码中解放出来。\n实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 resultMap 能够代替实现同等功能的长达数千行的代码。 \nResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语 句只需要描述它们的关系就行了。\n\n简单映射语句的示例了，但并没有显式指定 resultMap 。比如：\n&lt;select id=&quot;selectUserById&quot; resultType=&quot;map&quot;&gt;select id , name , pwdfrom userwhere id = #&#123;id&#125;&lt;/select&gt;\n\n上述语句只是简单地将所有的列映射到 HashMap 的键上，这由 resultType 属性指定。虽然在 大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。\nResultMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。\n3.2手动映射\n返回值类型为resultMap\n\n&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt;select id , name , pwd from user where id = #&#123;id&#125;&lt;/select&gt;\n\n\n编写resultMap，实现手动映射！\n\n&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;&lt;!-- id为主键 --&gt;&lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;&lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;&lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;&lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt;\n\n如果世界总是这么简单就好了。但是肯定不是的，数据库中，存在一对多，多对一的情况，我们之后会 使用到一些高级的结果集映射，association，collection这些\n","tags":["Mybatis"]},{"title":"Mybatis之RowBounds分页","url":"/2022/05/05/Mybatis%E4%B9%8BRowBounds%E5%88%86%E9%A1%B5/","content":"我们除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，当然此种方 式作为了解即可。我们来看下如何实现的！\n步骤： \n\nmapper接口\n\n//选择全部用户RowBounds实现分页List&lt;User&gt; getUserByRowBounds();\n\n\n对应的mapper文件\n\n&lt;select id=&quot;getUserByRowBounds&quot; resultType=&quot;com.fang.pojo.User&quot;&gt;    select * from mybatis.user&lt;/select&gt;\n\n\n测试类\n\n@Testpublic void testUserByRowBounds()&#123;    SqlSession session = MybatisUtils.getSession();    int currentPage = 2;    int pageSize = 2;    RowBounds rowBounds = new RowBounds((currentPage - 1) * pageSize, pageSize);    //通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了]    List&lt;User&gt; users = session.selectList(&quot;com.fang.mapper.UserMapper.getUserByRowBounds&quot;);    for (User user : users) &#123;        System.out.println(user);    &#125;    session.close();&#125;\n","tags":["Mybatis"]},{"title":"Mybatis之limit实现分页","url":"/2022/05/05/Mybatis%E4%B9%8Blimit%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5/","content":"思考：为什么需要分页？\n在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查 询操作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对 数据库压力就在可控范围内。\n使用Limit实现分页\n#语法SELECT * FROM table LIMIT stratIndex，pageSizeSELECT * FROM table LIMIT 5,10; // 检索记录行 6-15#为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.#如果只给定一个参数，它表示返回最大的记录行数目：SELECT * FROM table LIMIT 5; //检索前 5 个记录行#换句话说，LIMIT n 等价于 LIMIT 0,n。\n\n步骤： \n\n修改Mapper文件\n\n&lt;select id=&quot;selectUser&quot; parameterType=&quot;map&quot; resultType=&quot;user&quot;&gt;    select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;/select&gt;\n\n\nMapper接口，参数为map\n\n//查询全部用户实现分页List&lt;User&gt; selectUser(Map&lt;String,Integer&gt;map);\n\n\n在测试类中传入参数测试 \n推断：起始位置 &#x3D; （当前页面 - 1 ） * 页面大小\n\n\n\n@Testpublic void selectUser()&#123;    SqlSession session = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    int currentPage = 1; //第几页    int pageSize = 2; //每页显示几个    Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();    map.put(&quot;startIndex&quot;,(currentPage-1)*pageSize);    map.put(&quot;pageSize&quot;,pageSize);    List&lt;User&gt; users = mapper.selectUser(map);    for (User user : users) &#123;        System.out.println(user);    &#125;    session.close();&#125;\n","tags":["Mybatis"]},{"title":"Mybatis之一对多的处理","url":"/2022/05/07/Mybatis%E4%B9%8B%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%A4%84%E7%90%86/","content":"一对多的理解： \n\n一个老师拥有多个学生 \n如果对于老师这边，就是一个一对多的现象，即从一个老师下面拥有一群学生（集合）！\n\n1.实体类编写@Datapublic class Student &#123;    private int id;    private String name;    private int tid;&#125;\n\n@Data //GET,SET,ToString，有参，无参构造public class Teacher &#123;    private int id;    private String name;    //一个老师多个学生    private List&lt;Student&gt; students;&#125;\n\n2.按结果嵌套处理\nTeacherMapper接口编写方法\n\npublic interface TeacherMapper &#123;    //获取指定老师，及老师下的所有学生    public Teacher getTeacher( int id);&#125;\n\n\n编写接口对应的Mapper配置文件\n\n&lt;mapper namespace=&quot;com.fang.mapper.TeacherMapper&quot;&gt;    &lt;!--    思路:    1. 从学生表和老师表中查出学生id，学生姓名，老师姓名    2. 对查询出来的操作做结果集映射    1. 集合的话，使用collection！    JavaType和ofType都是用来指定对象类型的    JavaType是用来指定pojo中属性的类型    ofType指定的是映射到list集合属性中pojo的类型。    --&gt;    &lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt;        select s.id sid ,s.name sname ,t.name tname, t.id tid        from mybatis.student s, mybatis.teacher t        where s.tid = t.id and t.id = #&#123;id&#125;    &lt;/select&gt;    &lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt;        &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;        &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;            &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;            &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;            &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;&lt;/mapper&gt;\n\n\n将Mapper文件注册到MyBatis-config文件中\n\n&lt;!--使用class绑定接口--&gt;&lt;mappers&gt;    &lt;mapper class=&quot;com.fang.mapper.TeacherMapper&quot;/&gt;&lt;/mappers&gt;\n\n\n测试\n\n@Testpublic void testGetTeacher()&#123;    SqlSession session = MybatisUtils.getSession();    TeacherMapper mapper = session.getMapper(TeacherMapper.class);    Teacher teacher = mapper.getTeacher(1);    System.out.println(teacher);    session.close();&#125;\n\n3.按查询嵌套处理\nTeacherMapper接口编写方法\n\n//获取指定老师，及老师下的所有学生public Teacher getTeacher2( int id);\n\n\n编写接口对应的Mapper配置文件\n\n&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt;    select  * from mybatis.teacher where id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;Teacher&quot;&gt;    &lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt;    &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; column=&quot;id&quot; select=&quot;getStudentByTeacherId&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt;    select * from mybatis.student where tid = #&#123;id&#125;&lt;/select&gt;\n\n\n将Mapper文件注册到MyBatis-config文件中\n\n测试\n\n\n@Testpublic void testGetTeacher2()&#123;    SqlSession session = MybatisUtils.getSession();    TeacherMapper mapper = session.getMapper(TeacherMapper.class);    Teacher teacher = mapper.getTeacher2(1);    System.out.println(teacher.getName());    System.out.println(teacher.getStudents());    session.close();&#125;\n\n4.小结\n关联-association \n集合-collection \n所以association是用于一对一和多对一，而collection是用于一对多的关系 \nJavaType和ofType都是用来指定对象类型的 \nJavaType是用来指定pojo中属性的类型 \nofType指定的是映射到list集合属性中pojo的类型。\n\n\n\n注意说明： \n\n保证SQL的可读性，尽量通俗易懂 \n根据实际要求，尽量编写性能更高的SQL语句 \n注意属性名和字段不一致的问题 \n注意一对多和多对一 中：字段和属性对应的问题 \n尽量使用Log4j，通过日志来查看自己的错误\n\n","tags":["Mybatis"]},{"title":"Mybatis之Mybatis简介","url":"/2022/05/02/Mybatis%E4%B9%8B%E4%BB%80%E4%B9%88%E6%98%AFMybatis/","content":"1.什么是MyBatis\nMyBatis 是一款优秀的持久层框架 \nMyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程 \nMyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。 \nMyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并 且改名为MyBatis 。\n2013年11月迁移到Github .\nMybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html \nGitHub : https://github.com/mybatis/mybatis-3\n\n2.持久化持久化是将程序数据在持久状态和瞬时状态间转换的机制。 \n\n即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 \nJDBC就是一种持久化机制。文件IO也是一种持久化机制。\n在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。\n\n为什么需要持久化服务呢？那是由于内存本身的缺陷引起的 \n\n内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 \n内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。\n\n3.持久层什么是持久层？ \n\n完成持久化工作的代码块 . —-&gt; dao层 【DAO (Data Access Object) 数据访问对象】 \n大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。 \n不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许 是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专著于数据持久化逻辑的实现. 与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。 【说白了就是用来操作数据库存在的！】\n\n4.为什么需要Mybatis\nMybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 . \n传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率 .\nMyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) –&gt;对象关系映射 \n所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！技术没有高低之分，只有使用这个技术的人有高低之别 \nMyBatis的优点 \n简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个 sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 \n灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 \n解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 \n提供xml标签，支持编写动态sql。 …….\n\n\n最重要的一点，使用的人多！公司需要！\n\n","tags":["Mybatis"]},{"title":"Mybatis之使用注解开发","url":"/2022/05/05/Mybatis%E4%B9%8B%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","content":"面向接口编程\n大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 \n根本原因 : 解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好 \n在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下， 各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了； \n而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。\n\n关于接口的理解 \n\n接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。 \n\n接口的本身反映了系统设计人员对系统的抽象理解。 接口应有两类： \n\n第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； \n第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；\n\n\n一个体有可能有多个抽象面。抽象体与抽象面是有区别的。\n\n\n三个面向区别\n\n面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 . \n面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 . \n接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是 对系统整体的架构\n\n利用注解开发\nmybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java注解的的表达力和灵活性十分有限。最强大的 MyBatis映射并不能用注解来构建 \nsql 类型主要分成 : \n@select () \n@update () \n@Insert () \n@delete ()\n\n\n\n【注意】利用注解开发就不需要mapper.xml映射文件了 .\n\n我们在我们的接口中添加注解\n\n//查询全部用户@Select(&quot;select id,name,pwd password from mybatis.user&quot;)public List&lt;User&gt; getAllUser();\n\n\n在mybatis的核心配置文件中注入\n\n&lt;!--使用class绑定接口--&gt;&lt;mappers&gt;    &lt;mapper class=&quot;com.fang.mapper.UserMapper&quot;/&gt;&lt;/mappers&gt;\n\n\n测试\n\n@Testpublic void testGetAllUser()&#123;    SqlSession session = MybatisUtils.getSession();    //本质上利用了jvm的动态代理机制    UserMapper mapper = session.getMapper(UserMapper.class);    List&lt;User&gt; users = mapper.getAllUser();    for (User user : users) &#123;        System.out.println(user);    &#125;    session.close();&#125;\n\n\n利用Debug查看本质\n本质上利用了jvm的动态代理机制（举个例子就是你要结婚，婚庆公司帮你做结婚事项）\n\n\n","tags":["Mybatis"]},{"title":"Mybatis之动态SQL之Foreach","url":"/2022/05/07/Mybatis%E4%B9%8B%E5%8A%A8%E6%80%81SQL%E4%B9%8BForeach/","content":"将数据库中前三个数据的id修改为1,2,3； \n需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息\n\n编写接口\n\nList&lt;Blog&gt; queryBlogForeach(Map map);\n\n\n编写SQL语句\n\n&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select  * from mybatis.blog    &lt;where&gt;        &lt;!--        collection:指定输入对象中的集合属性        item:每次遍历生成的对象        open:开始遍历时的拼接字符串        close:结束时拼接的字符串        separator:遍历对象之间需要拼接的字符串        select * from blog where 1=1 and (id=1 or id=2 or id=3)        --&gt;        &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;            id = #&#123;id&#125;        &lt;/foreach&gt;    &lt;/where&gt;&lt;/select&gt;\n\n\n测试\n\n@Testpublic void testQueryBlogForeach()&#123;    SqlSession session = MybatisUtils.getSession();    BlogMapper mapper = session.getMapper(BlogMapper.class);    HashMap map = new HashMap();    ArrayList&lt;Integer&gt; ids = new ArrayList&lt;&gt;();    ids.add(1);    ids.add(2);    ids.add(3);    map.put(&quot;ids&quot;,ids);    List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map);    System.out.println(blogs);    session.close();&#125;\n\n小结：\n其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生 的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。\n","tags":["Mybatis"]},{"title":"Mybatis之动态SQL常用标签","url":"/2022/05/07/Mybatis%E4%B9%8B%E5%8A%A8%E6%80%81SQL%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/","content":"1.if 语句需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则 根据作者名来查询\n\n编写接口类\n\nList&lt;Blog&gt; queryBlogIf(Map map);\n\n\n编写SQL语句\n\n&lt;!--需求1：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询select * from blog where title = #&#123;title&#125; and author = #&#123;author&#125;--&gt;&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from mybatis.blog where     &lt;if test=&quot;title!=null&quot;&gt;        title = #&#123;title&#125;    &lt;/if&gt;    &lt;if test=&quot;author!=null&quot;&gt;        and author = #&#123;author&#125;    &lt;/if&gt;&lt;/select&gt;\n\n\n测试\n\n@Testpublic void testQueryBlogIf()&#123;    SqlSession session = MybatisUtils.getSession();    BlogMapper mapper = session.getMapper(BlogMapper.class);    HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();    map.put(&quot;title&quot;,&quot;Mybatis如此简单&quot;);    map.put(&quot;author&quot;,&quot;xiao&quot;);    List&lt;Blog&gt; blogs = mapper.queryBlogIf(map);    System.out.println(blogs);    session.close();&#125;\n\n这样写我们可以看到，如果 author 等于 null，那么查询语句为 select * from user where title&#x3D;#{title}, 但是如果title为空呢？那么查询语句为 select * from user where and author&#x3D;#{author}，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句！\n2.Where语句修改上面的SQL语句\n&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from mybatis.blog    &lt;where&gt;        &lt;if test=&quot;title != null&quot;&gt;            title = #&#123;title&#125;        &lt;/if&gt;        &lt;if test=&quot;author != null&quot;&gt;            and author = #&#123;author&#125;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;\n\n这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返 回的内容是以AND 或OR 开头的，则它会剔除掉。\n3.Set语句同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词， 我们怎么处理呢？\n\n编写接口方法\n\nint updateBlog(Map map);\n\n\nsql配置文件\n\n&lt;!--注意set是用的逗号隔开--&gt;&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt;    update mybatis.blog    &lt;set&gt;        &lt;if test=&quot;title != null&quot;&gt;            title = #&#123;title&#125;,        &lt;/if&gt;        &lt;if test=&quot;author != null&quot;&gt;            author = #&#123;author&#125;        &lt;/if&gt;    &lt;/set&gt;    where id = #&#123;id&#125;;&lt;/update&gt;\n\n\n测试\n\n@Testpublic void testUpdateBlog()&#123;    SqlSession session = MybatisUtils.getSession();    BlogMapper mapper = session.getMapper(BlogMapper.class);    HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();    map.put(&quot;title&quot;,&quot;动态SQL&quot;);    map.put(&quot;author&quot;,&quot;xiaoxiao&quot;);    map.put(&quot;id&quot;,&quot;13a5adc515904dc19c7581d89e593987&quot;);    mapper.updateBlog(map);    session.close();&#125;\n\n4.choose语句有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句\n\n编写接口方法\n\nList&lt;Blog&gt; queryBlogChoose(Map map);\n\n\nsql配置文件\n\n&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from mybatis.blog    &lt;where&gt;        &lt;choose&gt;            &lt;when test=&quot;title != null&quot;&gt;                title = #&#123;title&#125;            &lt;/when&gt;            &lt;when test=&quot;author != null&quot;&gt;                and author = #&#123;author&#125;            &lt;/when&gt;            &lt;otherwise&gt;                and views = #&#123;views&#125;            &lt;/otherwise&gt;        &lt;/choose&gt;    &lt;/where&gt;&lt;/select&gt;\n\n\n测试类\n\n@Testpublic void testQueryBlogChoose()&#123;    SqlSession session = MybatisUtils.getSession();    BlogMapper mapper = session.getMapper(BlogMapper.class);    HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();    map.put(&quot;views&quot;,9999);    List&lt;Blog&gt; blogs = mapper.queryBlogChoose(map);    System.out.println(blogs);    session.close();&#125;\n\n5.SQL片段有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽 取出来，然后使用时直接调用。\n提取SQL片段：\n&lt;sql id=&quot;if-title-author&quot;&gt;    &lt;if test=&quot;title != null&quot;&gt;        title = #&#123;title&#125;,    &lt;/if&gt;    &lt;if test=&quot;author != null&quot;&gt;        author = #&#123;author&#125;    &lt;/if&gt;&lt;/sql&gt;\n\n引用SQL片段：\n&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt;    select * from mybatis.blog    &lt;where&gt;        &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace        --&gt;        &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt;        &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt;    &lt;/where&gt;&lt;/select&gt;\n\n注意：\n①、最好基于单表来定义 sql 片段，提高片段的可重用性 \n②、在 sql 片段中不要包括 where\n","tags":["Mybatis"]},{"title":"Mybatis之动态SQL环境搭建","url":"/2022/05/07/Mybatis%E4%B9%8B%E5%8A%A8%E6%80%81SQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"介绍什么是动态SQL：动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句。\n官网描述：MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。-------------------------------- if- choose (when, otherwise)- trim (where, set)- foreach-------------------------------\n\n我们之前写的 SQL 语句都比较简单，如果有比较复杂的业务，我们需要写复杂的 SQL 语句，往往需 要拼接，而拼接 SQL ，稍微不注意，由于引号，空格等缺失可能都会导致错误。 \n那么怎么去解决这个问题呢？这就要使用 mybatis 动态SQL，通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同 时，也大大提高了开发人员的效率。\n搭建环境新建一个数据库表：blog\nCREATE TABLE `blog` (                        `id` varchar(50) NOT NULL COMMENT &#x27;博客id&#x27;,                        `title` varchar(100) NOT NULL COMMENT &#x27;博客标题&#x27;,                        `author` varchar(30) NOT NULL COMMENT &#x27;博客作者&#x27;,                        `create_time` datetime NOT NULL COMMENT &#x27;创建时间&#x27;,                        `views` int(30) NOT NULL COMMENT &#x27;浏览量&#x27;) ENGINE=InnoDB DEFAULT CHARSET=utf8\n\n\n创建IDutil工具类\n\npublic class IDUtil &#123;    public static String genId()&#123;        return UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);    &#125;&#125;\n\n\n实体类编写\n\n@Datapublic class Blog &#123;    private String id;    private String title;    private String author;    private Date createTime;    private int views;&#125;\n\n3.编写Mapper接口及xml文件\npublic interface BlogMapper &#123;    //新增一个博客    int addBlog(Blog blog);&#125;\n\n\n对应的xml方法\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.fang.mapper.BlogMapper&quot;&gt;    &lt;insert id=&quot;addBlog&quot; parameterType=&quot;blog&quot;&gt;        insert into mybatis.blog (id, title, author, create_time, views)        values (#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;);    &lt;/insert&gt;&lt;/mapper&gt;\n\n\nmybatis核心配置文件，下划线驼峰自动转换\n\n&lt;settings&gt;    &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt;&lt;!--使用class绑定接口--&gt;&lt;mappers&gt;    &lt;mapper class=&quot;com.fang.mapper.BlogMapper&quot;/&gt;&lt;/mappers&gt;\n\n\n初始化博客方法\n\n@Testpublic void addInitBlog()&#123;    SqlSession session = MybatisUtils.getSession();    BlogMapper mapper = session.getMapper(BlogMapper.class);    Blog blog = new Blog();    blog.setId(IDUtil.genId());    blog.setTitle(&quot;Mybatis如此简单&quot;);    blog.setAuthor(&quot;xiao&quot;);    blog.setCreateTime(new Date());    blog.setViews(9999);    mapper.addBlog(blog);    blog.setId(IDUtil.genId());    blog.setTitle(&quot;Java如此简单&quot;);    mapper.addBlog(blog);    blog.setId(IDUtil.genId());    blog.setTitle(&quot;Spring如此简单&quot;);    mapper.addBlog(blog);    blog.setId(IDUtil.genId());    blog.setTitle(&quot;微服务如此简单&quot;);    mapper.addBlog(blog);    session.close();&#125;\n","tags":["Mybatis"]},{"title":"Mybatis之日志工厂","url":"/2022/05/04/Mybatis%E4%B9%8B%E6%97%A5%E5%BF%97%E5%B7%A5%E5%8E%82/","content":"思考：我们在测试SQL的时候，要是能够在控制台输出 SQL 的话，是不是就能够有更快的排错效率？如果一个 数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用 Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具。Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具： \n\nSLF4J \nApache Commons Logging \nLog4j 2 \nLog4j \nJDK logging\n\n具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序 查找）。 如果一个都未找到，日志功能就会被禁用。\n标准日志实现 指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。在mybatis-config中设置\n&lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt;\n","tags":["Mybatis"]},{"title":"Mybatis之多对一的处理","url":"/2022/05/05/Mybatis%E4%B9%8B%E5%A4%9A%E5%AF%B9%E4%B8%80%E7%9A%84%E5%A4%84%E7%90%86/","content":"多对一的理解： \n\n多个学生对应一个老师 \n如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！\n\n1.数据库设计CREATE TABLE `teacher` (                           `id` INT(10) NOT NULL,                           `name` VARCHAR(30) DEFAULT NULL,                           PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8;INSERT INTO teacher(`id`, `name`) VALUES (1, &#x27;秦老师&#x27;);CREATE TABLE `student` (                           `id` INT(10) NOT NULL,                           `name` VARCHAR(30) DEFAULT NULL,                           `tid` INT(10) DEFAULT NULL,                           PRIMARY KEY (`id`),                           KEY `fktid` (`tid`),                           CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8;INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;1&#x27;, &#x27;小明&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;2&#x27;, &#x27;小红&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;3&#x27;, &#x27;小张&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;4&#x27;, &#x27;小李&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;5&#x27;, &#x27;小王&#x27;, &#x27;1&#x27;);\n\n\n2.搭建测试环境【Lombok的使用】 \n\nIDEA安装Lombok插件\n引入Maven依赖\n\n&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.16.10&lt;/version&gt;&lt;/dependency&gt;\n\n\n在代码中增加注解\n\n@Data //GET,SET,ToString，有参，无参构造public class Teacher &#123;    private int id;    private String name;&#125;\n\n@Datapublic class Student &#123;    private int id;    private String name;    //多个学生可以是同一个老师，即多对一    private Teacher teacher;&#125;\n\n\n编写实体类对应的Mapper接口 【两个】 \n无论有没有需求，都应该写上，以备后来之需！\n\n\n\npublic interface TeacherMapper &#123;&#125;\n\npublic interface StudentMapper &#123;&#125;\n\n\n编写Mapper接口对应的 mapper.xml配置文件 【两个】 \n无论有没有需求，都应该写上，以备后来之需！\n\n\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.fang.mapper.TeacherMapper&quot;&gt;   &lt;/mapper&gt;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.fang.mapper.StudentMapper&quot;&gt;&lt;/mapper&gt;\n\n3.按查询嵌套处理\n给StudentMapper接口增加方法\n\n//获取所有学生及对应老师的信息public List&lt;Student&gt; getStudents();\n\n\n编写对应的Mapper文件\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.fang.mapper.StudentMapper&quot;&gt;    &lt;!--    需求：获取所有学生及对应老师的信息    思路：    1. 获取所有学生的信息    2. 根据获取的学生信息的老师ID-&gt;获取该老师的信息    3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般    使用关联查询？    1. 做一个结果集映射：StudentTeacher    2. StudentTeacher结果集的类型为 Student    3. 学生中老师的属性为teacher，对应数据库中为tid。    多个 [1,...）学生关联一个老师=&gt; 一对一，一对多    4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查    询    --&gt;    &lt;select id=&quot;getStudents&quot; resultMap=&quot;StudentTeacher&quot;&gt;        select * from mybatis.student    &lt;/select&gt;    &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;        &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;        &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;    &lt;/resultMap&gt;    &lt;!--    这里传递过来的id，只有一个属性的时候，下面可以写任何值    association中column多参数配置：    column=&quot;&#123;key=value,key=value&#125;&quot;    其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的    字段名。    --&gt;    &lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt;        select * from mybatis.teacher where id = #&#123;id&#125;    &lt;/select&gt;&lt;/mapper&gt;\n\n\n测试\n\n@Testpublic void testGetStudents()&#123;    SqlSession session = MybatisUtils.getSession();    StudentMapper mapper = session.getMapper(StudentMapper.class);    List&lt;Student&gt; students = mapper.getStudents();    for (Student student : students)&#123;        System.out.println(                &quot;学生名:&quot;+ student.getName()                        +&quot;\\t老师:&quot;+student.getTeacher().getName());    &#125;&#125;\n\n4.按结果嵌套处理\n接口方法编写\n\npublic List&lt;Student&gt; getStudents2();\n\n\n编写对应的mapper文件\n\n  &lt;!--按查询结果嵌套处理思路：1. 直接查询出结果，进行结果集的映射--&gt;    &lt;select id=&quot;getStudents2&quot; resultMap=&quot;StudentTeacher2&quot; &gt;        select s.id sid, s.name sname , t.name tname        from student s,teacher t        where s.tid = t.id    &lt;/select&gt;    &lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt;    &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;    &lt;!--关联对象property 关联对象在Student实体类中的属性--&gt;    &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;        &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;    &lt;/association&gt;    &lt;/resultMap&gt;\n\n\n去mybatis-config文件中注入\n\n&lt;!--使用class绑定接口--&gt;&lt;mappers&gt;    &lt;mapper class=&quot;com.fang.mapper.StudentMapper&quot;/&gt;&lt;/mappers&gt;\n\n\n测试\n\n@Testpublic void testGetStudents2()&#123;    SqlSession session = MybatisUtils.getSession();    StudentMapper mapper = session.getMapper(StudentMapper.class);    List&lt;Student&gt; students = mapper.getStudents2();    for (Student student : students)&#123;        System.out.println(                &quot;学生名:&quot;+ student.getName()                        +&quot;\\t老师:&quot;+student.getTeacher().getName());    &#125;&#125;\n\n5.小结\n按照查询进行嵌套处理就像SQL中的子查询 \n按照结果进行嵌套处理就像SQL中的联表查询\n\n","tags":["Mybatis"]},{"title":"Mybatis之注解增删改","url":"/2022/05/05/Mybatis%E4%B9%8B%E6%B3%A8%E8%A7%A3%E5%A2%9E%E5%88%A0%E6%94%B9/","content":"1.使用注解实现增删改查改造MybatisUtils工具类的getSession( ) 方法，重载实现。（就是加一个true）\npublic static SqlSession getSession()&#123;    return sqlSessionFactory.openSession(true);&#125;\n\n查询：\n\n编写接口方法注解\n\n//根据id查询用户@Select(&quot;select * from mybatis.user where id = #&#123;id&#125;&quot;)User selectUserById(@Param(&quot;id&quot;) int id);\n\n\n测试\n\n@Testpublic void testSelectUserById() &#123;    SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接    UserMapper mapper = session.getMapper(UserMapper.class);    User user = mapper.selectUserById(2);    System.out.println(user);    session.close();&#125;\n\n新增：\n\n编写接口方法注解\n\n//添加一个用户@Insert(&quot;insert into user (id,name, pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)int addUser(User user);\n\n\n测试\n\n@Testpublic void testAddUser()&#123;    SqlSession session = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    User user = new User(6, &quot;我深度&quot;, &quot;zzz&quot;);    int i = mapper.addUser(user);    System.out.println(i);    session.close();&#125;\n\n修改：\n\n编写接口方法注解\n\n//修改一个用户@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;password&#125; where id = #&#123;id&#125;&quot;)int updateUser(User user);\n\n\n测试\n\n@Testpublic void testUpdateUser()&#123;    SqlSession session = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    User user = new User(6, &quot;sda&quot;, &quot;1111&quot;);    int i = mapper.updateUser(user);    System.out.println(i);    session.close();&#125;\n\n删除：\n\n编写接口方法注解\n\n//根据id删除用户@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)int deleteUser(@Param(&quot;id&quot;) int id);\n\n\n测试\n\n@Test    public void testdelete()&#123;    SqlSession session = MybatisUtils.getSession();    UserMapper mapper = session.getMapper(UserMapper.class);    mapper.deleteUser(6);    session.close();&#125;\n\n2.关于@Param@Param注解用于给方法参数起一个名字。以下是总结的使用原则： \n\n在方法只接受一个参数的情况下，可以不使用@Param。 \n在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。 如果参数是 JavaBean ， 则不能使用@Param。 \n不使用@Param注解时，参数只能有一个，并且Javabean。\n\n3.#与$的区别\n#{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符【推荐使用】在执行时再取值，可以防止sql注入。\n\nINSERT INTO user (name) VALUES (#&#123;name&#125;);INSERT INTO user (name) VALUES (?);\n\n\n${} 的作用是直接进行字符串替换\n\nINSERT INTO user (name) VALUES (&#x27;$&#123;name&#125;&#x27;);INSERT INTO user (name) VALUES (&#x27;kuangshen&#x27;);\n\n","tags":["Mybatis"]},{"title":"Mybatis之生命周期和作用域","url":"/2022/05/03/Mybatis%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"作用域（Scope）和生命周期\n理解我们目前已经讨论过的不同作用域和生命周期类是至关重要的，因为错误的使用会导致非常严重的 并发问题。\n分析一下Mybatis的执行过程！\n作用域理解\n\nSqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后， SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中， 而不要让其长期存在。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是 局部方法变量）。 \nSqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。 由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多 个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。 因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以说 SqlSessionFactory 的最佳作用域是应用作用域。 \n如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接 （Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback 等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所 以用 try…catch…finally… 语句来保证其正确关闭。\n所以 SqlSession 的最佳的作用域是请求或方法作用域。\n\n\n","tags":["Mybatis"]},{"title":"Mybatis之配置之别名优化","url":"/2022/05/03/Mybatis%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B9%8B%E5%88%AB%E5%90%8D%E4%BC%98%E5%8C%96/","content":"typeAliases优化类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全 限定名的冗余。\n在mybatis-config.xml中配置别名，当这样配置时， User 可以用在任何使用 com.kuang.pojo.User 的地方。\n &lt;!--配置别名,注意顺序--&gt;&lt;typeAliases&gt;    &lt;typeAlias type=&quot;com.fang.pojo.User&quot; alias=&quot;user&quot;/&gt;&lt;/typeAliases&gt;\n\n也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如:\n&lt;typeAliases&gt;    &lt;package name=&quot;com.fang.pojo&quot;/&gt;&lt;/typeAliases&gt;\n\n每一个在包 com.kuang.pojo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的 非限定类名来作为它的别名。\n若有注解，则别名为其注解值。见下面的例子：\n@Alias(&quot;user&quot;)public class User &#123;...&#125;\n\n","tags":["Mybatis"]},{"title":"Mybatis之配置之属性优化","url":"/2022/05/03/Mybatis%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B9%8B%E5%B1%9E%E6%80%A7%E4%BC%98%E5%8C%96/","content":"1.核心配置文件\nmybatis-config.xml 系统核心配置文件 \nMyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 \n能配置的内容如下：\n\nconfiguration（配置）properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器）&lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt;\n\n2.environments元素&lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;        &lt;transactionManager type=&quot;JDBC&quot;/&gt;        &lt;dataSource type=&quot;POOLED&quot;&gt;            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;SSL=true&quot;/&gt;            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;            &lt;property name=&quot;password&quot; value=&quot;自己的密码&quot;/&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;\n\n\n配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行 环境（通过default指定）\n子元素节点：environment\n具体的一套环境，通过设置id进行区别，id保证唯一！\n\n\n子元素节点：transactionManager - [ 事务管理器 ]\n\n&lt;!-- 语法 --&gt;&lt;transactionManager type=&quot;[ JDBC | MANAGED ]&quot;/&gt;\n\n\n子元素节点：数据源（dataSource）\n\ndataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。\n数据源是必须配置的。\n有三种内建的数据源类型\n\n\n\n type=&quot;[UNPOOLED|POOLED|JNDI]&quot;）\n\n\nunpooled： 这个数据源的实现只是每次被请求时打开和关闭连接。 \n\npooled： 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得 并发 Web 应用快速响应请求的流行处理方式。 \n\njndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以 集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 \n\n数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等…\n\n\n3.属性（Properties）数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。\n第一步：在资源目录下新建一个db.properties\ndriver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8username=rootpassword=自己的密码\n\n第二步 : 将文件导入properties 配置文件\n&lt;configuration&gt;    &lt;properties resource=&quot;db.properties&quot;/&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/fang/mapper/UserMapper.xml&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n","tags":["Mybatis"]},{"title":"Mybatis之配置之映射器说明","url":"/2022/05/03/Mybatis%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B9%8B%E6%98%A0%E5%B0%84%E5%99%A8%E8%AF%B4%E6%98%8E/","content":"1.mappers\n映射器（mapper） : 定义映射SQL语句文件 \n既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们 需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:&#x2F;&#x2F;&#x2F; 的 URL），或类名和包名等。映射器是MyBatis中最核心 的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配 置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL 语句，非常简洁。\n\n2..引入资源方式&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt;&lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;\n\n&lt;!--使用映射器接口实现类的完全限定类名需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt;&lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;&lt;/mappers&gt;\n\n&lt;!--将包内的映射器接口实现全部注册为映射器但是需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt;&lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt;\n\n\n\n","tags":["Mybatis"]},{"title":"SpringBoot基础篇之SSMP整合综合案例","url":"/2022/06/11/SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BSSMP%E6%95%B4%E5%90%88%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/","content":"SpringBoot能够整合的技术太多太多了，对于初学者来说慢慢来，一点点掌握。前面咱们做了4个整合了，下面就通过一个稍微综合一点的案例，将所有知识贯穿起来，同时做一个小功能，体会一下。不过有言在先，这个案例制作的时候，你可能会有这种感觉，说好的SpringBoot整合其他技术的案例，为什么感觉SpringBoot整合其他技术的身影不多呢？因为这东西书写太简单了，简单到瞬间写完，大量的时间做的不是这些整合工作。\n​\t先看一下这个案例的最终效果\n主页面\n\n添加\n\n删除\n\n分页\n\n条件查询\n\n整体案例中需要采用的技术如下：\n\n实体类开发————使用Lombok快速制作实体类\nDao开发————整合MyBatisPlus，制作数据层测试\nService开发————基于MyBatisPlus进行增量开发，制作业务层测试类\nController开发————基于Restful开发，使用PostMan测试接口功能\nController开发————前后端开发协议制作\n页面开发————基于VUE+ElementUI制作，前后端联调，页面数据处理，页面消息处理\n列表\n新增\n修改\n删除\n分页\n查询\n\n\n项目异常处理\n按条件查询————页面功能调整、Controller修正功能、Service修正功能\n\n\n1、模块创建下面我们就可以创建一个新的模块，加载要使用的技术对应的starter，修改配置文件格式为yml格式，并把web访问端口先设置成80。\napplication.yml\nserver:  port: 80\n\n2、实体类开发​\t本案例对应的模块表结构如下：\n-- ------------------------------ Table structure for tbl_book-- ----------------------------DROP TABLE IF EXISTS `tbl_book`;CREATE TABLE `tbl_book`  (  `id` INT(11) NOT NULL AUTO_INCREMENT,  `type` VARCHAR(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  `name` VARCHAR(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  `description` VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE) ENGINE = INNODB AUTO_INCREMENT = 51 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;-- ------------------------------ Records of tbl_book-- ----------------------------INSERT INTO `tbl_book` VALUES (1, &#x27;计算机理论&#x27;, &#x27;Spring实战 第5版&#x27;, &#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;);INSERT INTO `tbl_book` VALUES`tbl_book` (2, &#x27;计算机理论&#x27;, &#x27;Spring 5核心原理与30个类手写实战&#x27;, &#x27;十年沉淀之作，手写Spring精华思想&#x27;);INSERT INTO `tbl_book` VALUES (3, &#x27;计算机理论&#x27;, &#x27;Spring 5 设计模式&#x27;, &#x27;深入Spring源码剖析Spring源码中蕴含的10大设计模式&#x27;);INSERT INTO `tbl_book` VALUES (4, &#x27;计算机理论&#x27;, &#x27;Spring MVC+MyBatis开发从入门到项目实战&#x27;, &#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;);INSERT INTO `tbl_book` VALUES (5, &#x27;计算机理论&#x27;, &#x27;轻量级Java Web企业应用实战&#x27;, &#x27;源码级剖析Spring框架，适合已掌握Java基础的读者&#x27;);INSERT INTO `tbl_book` VALUES (6, &#x27;计算机理论&#x27;, &#x27;Java核心技术 卷I 基础知识（原书第11版）&#x27;, &#x27;Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;);INSERT INTO `tbl_book` VALUES (7, &#x27;计算机理论&#x27;, &#x27;深入理解Java虚拟机&#x27;, &#x27;5个维度全面剖析JVM，大厂面试知识点全覆盖&#x27;);INSERT INTO `tbl_book` VALUES (8, &#x27;计算机理论&#x27;, &#x27;Java编程思想（第4版）&#x27;, &#x27;Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;);INSERT INTO `tbl_book` VALUES (9, &#x27;计算机理论&#x27;, &#x27;零基础学Java（全彩版）&#x27;, &#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;);INSERT INTO `tbl_book` VALUES (10, &#x27;市场营销&#x27;, &#x27;直播就该这么做：主播高效沟通实战指南&#x27;, &#x27;李子柒、李佳琦、薇娅成长为网红的秘密都在书中&#x27;);INSERT INTO `tbl_book` VALUES (11, &#x27;市场营销&#x27;, &#x27;直播销讲实战一本通&#x27;, &#x27;和秋叶一起学系列网络营销书籍&#x27;);INSERT INTO `tbl_book` VALUES (12, &#x27;市场营销&#x27;, &#x27;直播带货：淘宝、天猫直播从新手到高手&#x27;, &#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;);\n\n​\t根据上述表结构，制作对应的实体类\n实体类\npublic class Book &#123;    private Integer id;    private String type;    private String name;    private String description;&#125;\n\n​\t实体类的开发可以自动通过工具手工生成get&#x2F;set方法，然后覆盖toString()方法，方便调试，等等。不过这一套操作书写很繁琐，有对应的工具可以帮助我们简化开发，介绍一个小工具，lombok。\n​\tLombok，一个Java类库，提供了一组注解，简化POJO实体类开发，SpringBoot目前默认集成了lombok技术，并提供了对应的版本控制，所以只需要提供对应的坐标即可，在pom.xml中添加lombok的坐标。\n&lt;!--lombok--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt;\n\n​\t使用lombok可以通过一个注解@Data完成一个实体类对应的getter，setter，toString，equals，hashCode等操作的快速添加\nimport lombok.Data;@Datapublic class Book &#123;    private Integer id;    private String type;    private String name;    private String description;&#125;\n\n总结\n实体类制作\n使用lombok简化开发\n导入lombok无需指定版本，由SpringBoot提供版本\n@Data注解\n\n\n\n3、数据层开发——基础CRUD数据层开发本次使用MyBatisPlus技术，数据源使用前面学习的Druid\n步骤①：导入MyBatisPlus与Druid对应的starter，当然mysql的驱动不能少\n&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;\n\n步骤②：配置数据库连接相关的数据源配置\nserver:  port: 80spring:  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC      username: root      password: root\n\n步骤③：使用MP的标准通用接口BaseMapper加速开发，别忘了@Mapper和泛型的指定\n@Mapperpublic interface BookDao extends BaseMapper&lt;Book&gt; &#123;&#125;\n\n步骤④：制作测试类测试结果，这个测试类制作是个好习惯，不过在企业开发中往往都为加速开发跳过此步，且行且珍惜吧\npackage com.example.Dao;import com.example.pojo.Book;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestpublic class BookDaoTestCase &#123;    @Autowired    private BookDao bookDao;    @Test    void testGetById()&#123;        System.out.println(bookDao.selectById(1));    &#125;    @Test    void testSave()&#123;        Book book = new Book();        book.setType(&quot;测试数据123&quot;);        book.setName(&quot;测试数据123&quot;);        book.setDescription(&quot;测试数据123&quot;);        bookDao.insert(book);    &#125;    @Test    void testUpdate()&#123;        Book book = new Book();        book.setId(53);        book.setType(&quot;测试数据abcdefg&quot;);        book.setName(&quot;测试数据123&quot;);        book.setDescription(&quot;测试数据123&quot;);        bookDao.updateById(book);    &#125;    @Test    void testDelete()&#123;        bookDao.deleteById(51);    &#125;    @Test    void testGetAll()&#123;        bookDao.selectList(null);    &#125;&#125;\n\n温馨提示\n​\tMP技术默认的主键生成策略为雪花算法，生成的主键ID长度较大，和目前的数据库设定规则不相符，需要配置一下使MP使用数据库的主键生成策略，方式嘛还是老一套，做配置。在application.yml中添加对应配置即可，具体如下\nserver:  port: 80spring:  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC      username: root      password: rootmybatis-plus:  global-config:    db-config:      table-prefix: tbl_      id-type: auto\n\n查看MP运行日志​\t在进行数据层测试的时候，因为基础的CRUD操作均由MP给我们提供了，所以就出现了一个局面，开发者不需要书写SQL语句了，这样程序运行的时候总有一种感觉，一切的一切都是黑盒的，作为开发者我们啥也不知道就完了。如果程序正常运行还好，如果报错了，这个时候就很崩溃，你甚至都不知道从何下手，因为传递参数、封装SQL语句这些操作完全不是你干预开发出来的，所以查看执行期运行的SQL语句就成为当务之急。\n​\tSpringBoot整合MP的时候充分考虑到了这点，通过配置的形式就可以查阅执行期SQL语句，配置如下\nmybatis-plus:  global-config:    db-config:      table-prefix: tbl_      id-type: auto  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n\n再来看运行结果，此时就显示了运行期执行SQL的情况。\nCreating a new SqlSessionSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6d0be7ab] was not registered for synchronization because synchronization is not activeJDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@14924f41] will not be managed by Spring==&gt;  Preparing: SELECT id,type,name,description FROM tbl_book==&gt; Parameters: &lt;==    Columns: id, type, name, description&lt;==        Row: 1, 计算机理论, Spring实战 第5版, Spring入门经典教程，深入理解Spring原理技术内幕&lt;==        Row: 2, 计算机理论, Spring 5核心原理与30个类手写实战, 十年沉淀之作，手写Spring精华思想&lt;==        Row: 3, 计算机理论, Spring 5 设计模式, 深入Spring源码剖析Spring源码中蕴含的10大设计模式&lt;==        Row: 4, 计算机理论, Spring MVC+MyBatis开发从入门到项目实战, 全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&lt;==        Row: 5, 计算机理论, 轻量级Java Web企业应用实战, 源码级剖析Spring框架，适合已掌握Java基础的读者&lt;==        Row: 6, 计算机理论, Java核心技术 卷I 基础知识（原书第11版）, Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&lt;==        Row: 7, 计算机理论, 深入理解Java虚拟机, 5个维度全面剖析JVM，大厂面试知识点全覆盖&lt;==        Row: 8, 计算机理论, Java编程思想（第4版）, Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉&lt;==        Row: 9, 计算机理论, 零基础学Java（全彩版）, 零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&lt;==        Row: 10, 市场营销, 直播就该这么做：主播高效沟通实战指南, 李子柒、李佳琦、薇娅成长为网红的秘密都在书中&lt;==        Row: 11, 市场营销, 直播销讲实战一本通, 和秋叶一起学系列网络营销书籍&lt;==        Row: 12, 市场营销, 直播带货：淘宝、天猫直播从新手到高手, 一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&lt;==        Row: 52, null, null, null&lt;==        Row: 53, 测试数据abcdefg, 测试数据123, 测试数据123&lt;==      Total: 14\n\n其中清晰的标注了当前执行的SQL语句是什么，携带了什么参数，对应的执行结果是什么，所有信息应有尽有。\n​\t此处设置的是日志的显示形式，当前配置的是控制台输出，当然还可以由更多的选择，根据需求切换即可\n\n总结\n手工导入starter坐标（2个），mysql驱动（1个）\n\n配置数据源与MyBatisPlus对应的配置\n\n开发Dao接口（继承BaseMapper）\n\n制作测试类测试Dao功能是否有效\n\n使用配置方式开启日志，设置日志输出方式为标准输出即可查阅SQL执行日志\n\n\n4、数据层开发——分页功能制作​\t前面仅仅是使用了MP提供的基础CRUD功能，实际上MP给我们提供了几乎所有的基础操作，这一节说一下如果实现数据库端的分页操作\n​\tMP提供的分页操作API如下\n@Testvoid testGetPage()&#123;    IPage page = new Page(2, 5);    bookDao.selectPage(page,null);    System.out.println(page.getCurrent());    System.out.println(page.getSize());    System.out.println(page.getTotal());    System.out.println(page.getPages());    System.out.println(page.getRecords());&#125;\n\n​\t其中selectPage方法需要传入一个封装分页数据的对象，可以通过new的形式创建这个对象，当然这个对象也是MP提供的，别选错包了。创建此对象时就需要指定分页的两个基本数据\n\n当前显示第几页\n\n每页显示几条数据\n 可以通过创建Page对象时利用构造方法初始化这两个数据\n\n\nIPage page = new Page(2,5);\n\n​\t将该对象传入到查询方法selectPage后，可以得到查询结果，但是我们会发现当前操作查询结果返回值仍然是一个IPage对象，这又是怎么回事？\nIPage page = bookDao.selectPage(page, null);\n\n​\t原来这个IPage对象中封装了若干个数据，而查询的结果作为IPage对象封装的一个数据存在的，可以理解为查询结果得到后，又塞到了这个IPage对象中，其实还是为了高度的封装，一个IPage描述了分页所有的信息。下面5个操作就是IPage对象中封装的所有信息了\n@Testvoid testGetPage()&#123;    IPage page = new Page(2,5);    bookDao.selectPage(page, null);    System.out.println(page.getCurrent());\t\t//当前页码值    System.out.println(page.getSize());\t\t\t//每页显示数    System.out.println(page.getTotal());\t\t//数据总量    System.out.println(page.getPages());\t\t//总页数    System.out.println(page.getRecords());\t\t//详细数据&#125;\n\n​\t到这里就知道这些数据如何获取了，但是当你去执行这个操作时，你会发现并不像我们分析的这样，实际上这个分页当前是无效的。为什么这样呢？这个要源于MP的内部机制。\n​\t对于MySQL的分页操作使用limit关键字进行，而并不是所有的数据库都使用limit关键字实现的，这个时候MP为了制作的兼容性强，将分页操作设置为基础查询操作的升级版，你可以理解为IPhone6与IPhone6S-PLUS的关系。\n​\t基础操作中有查询全部的功能，而在这个基础上只需要升级一下（PLUS）就可以得到分页操作。所以MP将分页操作做成了一个开关，你用分页功能就把开关开启，不用就不需要开启这个开关。而我们现在没有开启这个开关，所以分页操作是没有的。这个开关是通过MP的拦截器的形式存在的.\n定义MP拦截器并将其设置为Spring管控的bean\npackage com.example.config;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MPConfig &#123;    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        interceptor.addInnerInterceptor(new PaginationInnerInterceptor());        return interceptor;    &#125;&#125;\n\n​\t上述代码第一行是创建MP的拦截器栈，这个时候拦截器栈中没有具体的拦截器，第二行是初始化了分页拦截器，并添加到拦截器栈中。如果后期开发其他功能，需要添加全新的拦截器，按照第二行的格式继续add进去新的拦截器就可以了。\n总结\n\n使用IPage封装分页数据\n分页操作依赖MyBatisPlus分页拦截器实现功能\n借助MyBatisPlus日志查阅执行SQL语句\n\n5、数据层开发——条件查询功能制作​\t除了分页功能，MP还提供有强大的条件查询功能。以往我们写条件查询要自己动态拼写复杂的SQL语句，现在简单了，MP将这些操作都制作成API接口，调用一个又一个的方法就可以实现各种套件的拼装。这里给大家普及一下基本格式，详细的操作还是到MP的课程中查阅吧\n​\t下面的操作就是执行一个模糊匹配对应的操作，由like条件书写变为了like方法的调用\n@Testvoid testGetBy()&#123;    QueryWrapper&lt;Book&gt; qw = new QueryWrapper&lt;&gt;();    qw.like(&quot;name&quot;,&quot;Spring&quot;);    bookDao.selectList(qw);&#125;\n\n​\t其中第一句QueryWrapper对象是一个用于封装查询条件的对象，该对象可以动态使用API调用的方法添加条件，最终转化成对应的SQL语句。第二句就是一个条件了，需要什么条件，使用QueryWapper对象直接调用对应操作即可。比如做大于小于关系，就可以使用lt或gt方法，等于使用eq方法，等等，此处不做更多的解释了。\n​\t这组API使用还是比较简单的，但是关于属性字段名的书写存在着安全隐患，比如查询字段name，当前是以字符串的形态书写的，万一写错，编译器还没有办法发现，只能将问题抛到运行器通过异常堆栈告诉开发者，不太友好。\n​\tMP针对字段检查进行了功能升级，全面支持Lambda表达式，就有了下面这组API。由QueryWrapper对象升级为LambdaQueryWrapper对象，这下就变了上述问题的出现\n@Testvoid testGetBy2()&#123;    String name = &quot;1&quot;;    LambdaQueryWrapper&lt;Book&gt; lqw = new LambdaQueryWrapper&lt;Book&gt;();    lqw.like(Book::getName,name);    bookDao.selectList(lqw);&#125;\n\n​\t其实就是个格式，没有区别。\n总结\n使用QueryWrapper对象封装查询条件\n\n推荐使用LambdaQueryWrapper对象\n\n所有查询操作封装成方法调用\n\n查询条件支持动态条件拼装\n\n\n6、业务层开发​\t数据层开发告一段落，下面进行业务层开发，其实标准业务层开发很多初学者认为就是调用数据层，怎么说呢？这个理解是没有大问题的，更精准的说法应该是组织业务逻辑功能，并根据业务需求，对数据持久层发起调用。有什么差别呢？目标是为了组织出符合需求的业务逻辑功能，至于调不调用数据层还真不好说，有需求就调用，没有需求就不调用。\n​\t一个常识性的知识普及一下，业务层的方法名定义一定要与业务有关，例如登录操作\nlogin(String username,String password);\n\n​\t而数据层的方法名定义一定与业务无关，是一定，不是可能，也不是有可能，例如根据用户名密码查询\nselectByUserNameAndPassword(String username,String password);\n\n​\t我们在开发的时候是可以根据完成的工作不同划分成不同职能的开发团队的。比如一个哥们制作数据层，他就可以不知道业务是什么样子，拿到的需求文档要求可能是这样的\n接口：传入用户名与密码字段，查询出对应结果，结果是单条数据接口：传入ID字段，查询出对应结果，结果是单条数据接口：传入离职字段，查询出对应结果，结果是多条数据\n\n​\t但是进行业务功能开发的哥们，拿到的需求文档要求差别就很大\n接口：传入用户名与密码字段，对用户名字段做长度校验，4-15位，对密码字段做长度校验，8到24位，对喵喵喵字段做特殊字符校验，不允许存在空格，查询结果为对象。如果为null，返回BusinessException，封装消息码INFO_LOGON_USERNAME_PASSWORD_ERROR\n\n​\t你比较一下，能是一回事吗？差别太大了，所以说业务层方法定义与数据层方法定义差异化很大，只不过有些入门级的开发者手懒或者没有使用过公司相关的ISO标准化文档而已。\n​\t多余的话不说了，咱们做案例就简单制作了，业务层接口定义如下：\npublic interface BookService &#123;    Boolean save(Book book);    Boolean update(Book book);    Boolean delete(Integer id);    Book getById(Integer id);    List&lt;Book&gt; getAll();    IPage&lt;Book&gt; getPage(int currentPage,int pageSize);&#125;\n\n业务层实现类如下，转调数据层即可\npackage com.example.Service.Impl;import com.baomidou.mybatisplus.core.metadata.IPage;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.example.Dao.BookDao;import com.example.Service.BookService;import com.example.pojo.Book;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class BookServiceImpl implements BookService &#123;    @Autowired    private BookDao bookDao;    @Override    public Boolean save(Book book) &#123;        return bookDao.insert(book) &gt; 0;    &#125;    @Override    public Boolean update(Book book) &#123;        return bookDao.updateById(book) &gt; 0;    &#125;    @Override    public Boolean delete(Integer id) &#123;        return bookDao.deleteById(id) &gt; 0;    &#125;    @Override    public Book getById(Integer id) &#123;        return bookDao.selectById(id);    &#125;    @Override    public List&lt;Book&gt; getAll() &#123;        return bookDao.selectList(null);    &#125;    @Override    public IPage&lt;Book&gt; getPage(int currentPage, int pageSize) &#123;        IPage page = new Page(currentPage, pageSize);        bookDao.selectPage(page,null);        return page;    &#125;&#125;\n\n​\t别忘了对业务层接口进行测试，测试类如下\npackage com.example.Service;import com.baomidou.mybatisplus.core.metadata.IPage;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.example.pojo.Book;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestpublic class BookServiceTest &#123;    @Autowired    private BookService bookService;    @Test    void testGetById()&#123;        System.out.println(bookService.getById(4));    &#125;    @Test    void testSave()&#123;        Book book = new Book();        book.setType(&quot;测试数据123&quot;);        book.setName(&quot;测试数据123&quot;);        book.setDescription(&quot;测试数据123&quot;);        bookService.save(book);    &#125;    @Test    void testUpdate()&#123;        Book book = new Book();        book.setId(17);        book.setType(&quot;-----------------&quot;);        book.setName(&quot;测试数据123&quot;);        book.setDescription(&quot;测试数据123&quot;);        bookService.update(book);    &#125;    @Test    void testDelete()&#123;        bookService.delete(18);    &#125;    @Test    void testGetAll()&#123;        bookService.getAll();    &#125;    @Test    void testGetPage()&#123;        IPage&lt;Book&gt; page = bookService.getPage(2,5);        System.out.println(page.getCurrent());        System.out.println(page.getSize());        System.out.println(page.getTotal());        System.out.println(page.getPages());        System.out.println(page.getRecords());    &#125;&#125;\n\n总结\nService接口名称定义成业务名称，并与Dao接口名称进行区分\n制作测试类测试Service功能是否有效\n\n业务层快速开发​\t其实MP技术不仅提供了数据层快速开发方案，业务层MP也给了一个通用接口，个人观点不推荐使用，凑合能用吧，其实就是一个封装+继承的思想，代码给出，实际开发慎用\n​\t业务层接口快速开发\npublic interface IBookService extends IService&lt;Book&gt; &#123;    //添加非通用操作API接口    boolean saveBook(Book book);    boolean modify(Book book);    boolean delete(Integer id);        IPage&lt;Book&gt; getPage(int currentPage,int pageSize);&#125;\n\n​\t业务层接口实现类快速开发，关注继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类\n@Servicepublic class IBookServiceImpl extends ServiceImpl&lt;BookDao, Book&gt; implements IBookService &#123;    @Autowired    private BookDao bookDao;    @Override    public boolean saveBook(Book book) &#123;        return bookDao.insert(book) &gt; 0;    &#125;    @Override    public boolean modify(Book book) &#123;        return bookDao.updateById(book) &gt; 0;    &#125;    @Override    public boolean delete(Integer id) &#123;        return bookDao.deleteById(id) &gt; 0;    &#125;         @Override    public IPage&lt;Book&gt; getPage(int currentPage, int pageSize) &#123;        IPage page = new Page(currentPage, pageSize);        bookDao.selectPage(page,null);        return page;    &#125;    //添加非通用操作API&#125;\n\n​\t如果感觉MP提供的功能不足以支撑你的使用需要，其实是一定不能支撑的，因为需求不可能是通用的，在原始接口基础上接着定义新的API接口就行了，此处不再说太多了，就是自定义自己的操作了，但是不要和已有的API接口名冲突即可。\n总结\n使用通用接口（ISerivce）快速开发Service\n使用通用实现类（ServiceImpl&lt;M,T&gt;）快速开发ServiceImpl\n可以在通用接口基础上做功能重载或功能追加\n注意重载时不要覆盖原始操作，避免原始提供的功能丢失\n\n7、表现层开发终于做到表现层了，做了这么多都是基础工作。其实你现在回头看看，哪里还有什么SpringBoot的影子？前面1,2步就搞完了。继续完成表现层制作吧，咱们表现层的开发使用基于Restful的表现层接口开发，功能测试通过Postman工具进行\n​\t表现层接口如下:\n@RestController@RequestMapping(&quot;/books&quot;)public class BookController &#123;    @Autowired    private IBookService bookService;    @GetMapping    public List&lt;Book&gt; getAll()&#123;        return bookService.list();    &#125;    @PostMapping    public Boolean save(@RequestBody  Book book)&#123;        return bookService.save(book);    &#125;    @PutMapping    public Boolean update(@RequestBody Book book)&#123;        return bookService.modify(book);    &#125;    @DeleteMapping(&quot;&#123;id&#125;&quot;)    public Boolean delete(@PathVariable Integer id)&#123;        return bookService.delete(id);    &#125;    @GetMapping(&quot;id&quot;)    public Book getById(@PathVariable Integer id)&#123;        return bookService.getById(id);    &#125;    @GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)    public IPage&lt;Book&gt; getPage(@PathVariable int currentPage,@PathVariable int pageSize)&#123;        return bookService.getPage(currentPage,pageSize);    &#125;\n\n在实用Apifox测试时关注提交类型，对应上即可，不然就会报405的错误码了\n普通GET请求\n\nPUT请求传递json数据，后台实用@RequestBody接收数据\n\nGET请求传递路径变量，后台实用@PathVariable接收数据\n\n总结\n基于Restful制作表现层接口\n新增：POST\n删除：DELETE\n修改：PUT\n查询：GET\n\n\n接收参数\n实体数据：@RequestBody\n路径变量：@PathVariable\n\n\n\n8、表现层消息一致性处理​\t目前我们通过Apifox测试后业务层接口功能时通的，但是这样的结果给到前端开发者会出现一个小问题。不同的操作结果所展示的数据格式差异化严重\n​\t增删改操作结果\ntrue\n\n​\t查询单个数据操作结果\n&#123;    &quot;id&quot;: 1,    &quot;type&quot;: &quot;计算机理论&quot;,    &quot;name&quot;: &quot;Spring实战 第5版&quot;,    &quot;description&quot;: &quot;Spring入门经典教程&quot;&#125;\n\n​\t查询全部数据操作结果\n[    &#123;        &quot;id&quot;: 1,        &quot;type&quot;: &quot;计算机理论&quot;,        &quot;name&quot;: &quot;Spring实战 第5版&quot;,        &quot;description&quot;: &quot;Spring入门经典教程&quot;    &#125;,    &#123;        &quot;id&quot;: 2,        &quot;type&quot;: &quot;计算机理论&quot;,        &quot;name&quot;: &quot;Spring 5核心原理与30个类手写实战&quot;,        &quot;description&quot;: &quot;十年沉淀之作&quot;    &#125;]\n\n​\t每种不同操作返回的数据格式都不一样，而且还不知道以后还会有什么格式，这样的结果让前端人员看了是很容易让人崩溃的，必须将所有操作的操作结果数据格式统一起来，需要设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为前后端数据协议\npackage com.example.Controller.utils;import lombok.Data;@Datapublic class R &#123;    private Boolean flag;    private Object data;        public R()&#123;&#125;        public R(Boolean flag)&#123;        this.flag = flag;    &#125;        public R(Boolean flag,Object data)&#123;        this.flag = flag;        this.data = data;    &#125;&#125;\n\n​\t其中flag用于标识操作是否成功，data用于封装操作数据，现在的数据格式就变了\n&#123;    &quot;flag&quot;: true,    &quot;data&quot;:&#123;        &quot;id&quot;: 1,        &quot;type&quot;: &quot;计算机理论&quot;,        &quot;name&quot;: &quot;Spring实战 第5版&quot;,        &quot;description&quot;: &quot;Spring入门经典教程&quot;    &#125;&#125;\n\n​\t表现层开发格式也需要转换一下\npackage com.example.Controller;import com.baomidou.mybatisplus.core.metadata.IPage;import com.example.Controller.utils.R;import com.example.Service.IBookService;import com.example.pojo.Book;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;@RestController@RequestMapping(&quot;/books&quot;)public class BookController &#123;    @Autowired    private IBookService bookService;    @GetMapping    public R getAll()&#123;        return new R(true,bookService.list());    &#125;    @PostMapping    public R save(@RequestBody  Book book)&#123;       Boolean flag = bookService.save(book);       return new R(flag);    &#125;    @PutMapping    public R update(@RequestBody Book book)&#123;        Boolean flag = bookService.modify(book);        return new R(flag);    &#125;    @DeleteMapping(&quot;&#123;id&#125;&quot;)    public R delete(@PathVariable Integer id)&#123;        Boolean flag = bookService.delete(id);        return new R(flag);    &#125;    @GetMapping(&quot;&#123;id&#125;&quot;)    public R getById(@PathVariable Integer id)&#123;        Book book = bookService.getById(id);        return new R(true,book);    &#125;    @GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)    public R getPage(@PathVariable int currentPage,@PathVariable int pageSize)&#123;        return new R(true,bookService.getPage(currentPage,pageSize));    &#125;&#125;\n\n结果这么一折腾，全格式统一，现在后端发送给前端的数据格式就统一了，免去了不少前端解析数据的麻烦。\n总结\n设计统一的返回值结果类型便于前端开发读取数据\n\n返回值结果类型可以根据需求自行设定，没有固定格式\n\n返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议\n\n\n9.前后端联通性测试\n​\t后端的表现层接口开发完毕，就可以进行前端的开发了。\n​\t将前端人员开发的页面保存到lresources目录下的static目录中，建议执行maven的clean生命周期，避免缓存的问题出现。\n\n​\t在进行具体的功能开发之前，先做联通性的测试，通过页面发送异步提交（axios），这一步调试通过后再进行进一步的功能开发\n\n前端代码\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;!-- 页面meta --&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;title&gt;基于SpringBoot整合SSM案例&lt;/title&gt;    &lt;meta content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot; name=&quot;viewport&quot;&gt;    &lt;!-- 引入样式 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;../plugins/elementui/index.css&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;../plugins/font-awesome/css/font-awesome.min.css&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;../css/style.css&quot;&gt;&lt;/head&gt;&lt;body class=&quot;hold-transition&quot;&gt;&lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;content-header&quot;&gt;        &lt;h1&gt;图书管理&lt;/h1&gt;    &lt;/div&gt;    &lt;div class=&quot;app-container&quot;&gt;        &lt;div class=&quot;box&quot;&gt;            &lt;div class=&quot;filter-container&quot;&gt;                &lt;el-input placeholder=&quot;图书类别&quot; style=&quot;width: 200px;&quot; class=&quot;filter-item&quot;&gt;&lt;/el-input&gt;                &lt;el-input placeholder=&quot;图书名称&quot; style=&quot;width: 200px;&quot; class=&quot;filter-item&quot;&gt;&lt;/el-input&gt;                &lt;el-input placeholder=&quot;图书描述&quot; style=&quot;width: 200px;&quot; class=&quot;filter-item&quot;&gt;&lt;/el-input&gt;                &lt;el-button @click=&quot;getAll()&quot; class=&quot;dalfBut&quot;&gt;查询&lt;/el-button&gt;                &lt;el-button type=&quot;primary&quot; class=&quot;butT&quot; @click=&quot;handleCreate()&quot;&gt;新建&lt;/el-button&gt;            &lt;/div&gt;            &lt;el-table size=&quot;small&quot; current-row-key=&quot;id&quot; :data=&quot;dataList&quot; stripe highlight-current-row&gt;                &lt;el-table-column type=&quot;index&quot; align=&quot;center&quot; label=&quot;序号&quot;&gt;&lt;/el-table-column&gt;                &lt;el-table-column prop=&quot;type&quot; label=&quot;图书类别&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt;                &lt;el-table-column prop=&quot;name&quot; label=&quot;图书名称&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt;                &lt;el-table-column prop=&quot;description&quot; label=&quot;描述&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt;                &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot;&gt;                    &lt;template slot-scope=&quot;scope&quot;&gt;                        &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;handleUpdate(scope.row)&quot;&gt;编辑&lt;/el-button&gt;                        &lt;el-button type=&quot;danger&quot; size=&quot;mini&quot; @click=&quot;handleDelete(scope.row)&quot;&gt;删除&lt;/el-button&gt;                    &lt;/template&gt;                &lt;/el-table-column&gt;            &lt;/el-table&gt;            &lt;!--分页组件--&gt;            &lt;div class=&quot;pagination-container&quot;&gt;                &lt;el-pagination                        class=&quot;pagiantion&quot;                        @current-change=&quot;handleCurrentChange&quot;                        :current-page=&quot;pagination.currentPage&quot;                        :page-size=&quot;pagination.pageSize&quot;                        layout=&quot;total, prev, pager, next, jumper&quot;                        :total=&quot;pagination.total&quot;&gt;                &lt;/el-pagination&gt;            &lt;/div&gt;            &lt;!-- 新增标签弹层 --&gt;            &lt;div class=&quot;add-form&quot;&gt;                &lt;el-dialog title=&quot;新增图书&quot; :visible.sync=&quot;dialogFormVisible&quot;&gt;                    &lt;el-form ref=&quot;dataAddForm&quot; :model=&quot;formData&quot; :rules=&quot;rules&quot; label-position=&quot;right&quot; label-width=&quot;100px&quot;&gt;                        &lt;el-row&gt;                            &lt;el-col :span=&quot;12&quot;&gt;                                &lt;el-form-item label=&quot;图书类别&quot; prop=&quot;type&quot;&gt;                                    &lt;el-input v-model=&quot;formData.type&quot;/&gt;                                &lt;/el-form-item&gt;                            &lt;/el-col&gt;                            &lt;el-col :span=&quot;12&quot;&gt;                                &lt;el-form-item label=&quot;图书名称&quot; prop=&quot;name&quot;&gt;                                    &lt;el-input v-model=&quot;formData.name&quot;/&gt;                                &lt;/el-form-item&gt;                            &lt;/el-col&gt;                        &lt;/el-row&gt;                        &lt;el-row&gt;                            &lt;el-col :span=&quot;24&quot;&gt;                                &lt;el-form-item label=&quot;描述&quot;&gt;                                    &lt;el-input v-model=&quot;formData.description&quot; type=&quot;textarea&quot;&gt;&lt;/el-input&gt;                                &lt;/el-form-item&gt;                            &lt;/el-col&gt;                        &lt;/el-row&gt;                    &lt;/el-form&gt;                    &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;                        &lt;el-button @click=&quot;cancel()&quot;&gt;取消&lt;/el-button&gt;                        &lt;el-button type=&quot;primary&quot; @click=&quot;handleAdd()&quot;&gt;确定&lt;/el-button&gt;                    &lt;/div&gt;                &lt;/el-dialog&gt;            &lt;/div&gt;            &lt;!-- 编辑标签弹层 --&gt;            &lt;div class=&quot;add-form&quot;&gt;                &lt;el-dialog title=&quot;编辑检查项&quot; :visible.sync=&quot;dialogFormVisible4Edit&quot;&gt;                    &lt;el-form ref=&quot;dataEditForm&quot; :model=&quot;formData&quot; :rules=&quot;rules&quot; label-position=&quot;right&quot; label-width=&quot;100px&quot;&gt;                        &lt;el-row&gt;                            &lt;el-col :span=&quot;12&quot;&gt;                                &lt;el-form-item label=&quot;图书类别&quot; prop=&quot;type&quot;&gt;                                    &lt;el-input v-model=&quot;formData.type&quot;/&gt;                                &lt;/el-form-item&gt;                            &lt;/el-col&gt;                            &lt;el-col :span=&quot;12&quot;&gt;                                &lt;el-form-item label=&quot;图书名称&quot; prop=&quot;name&quot;&gt;                                    &lt;el-input v-model=&quot;formData.name&quot;/&gt;                                &lt;/el-form-item&gt;                            &lt;/el-col&gt;                        &lt;/el-row&gt;                        &lt;el-row&gt;                            &lt;el-col :span=&quot;24&quot;&gt;                                &lt;el-form-item label=&quot;描述&quot;&gt;                                    &lt;el-input v-model=&quot;formData.description&quot; type=&quot;textarea&quot;&gt;&lt;/el-input&gt;                                &lt;/el-form-item&gt;                            &lt;/el-col&gt;                        &lt;/el-row&gt;                    &lt;/el-form&gt;                    &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;                        &lt;el-button @click=&quot;cancel()&quot;&gt;取消&lt;/el-button&gt;                        &lt;el-button type=&quot;primary&quot; @click=&quot;handleEdit()&quot;&gt;确定&lt;/el-button&gt;                    &lt;/div&gt;                &lt;/el-dialog&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;!-- 引入组件库 --&gt;&lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../plugins/elementui/index.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../js/axios-0.18.0.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var vue = new Vue(&#123;        el: &#x27;#app&#x27;,        data:&#123;            dataList: [],//当前页要展示的列表数据            dialogFormVisible: false,//添加表单是否可见            dialogFormVisible4Edit:false,//编辑表单是否可见            formData: &#123;&#125;,//表单数据            rules: &#123;//校验规则                type: [&#123; required: true, message: &#x27;图书类别为必填项&#x27;, trigger: &#x27;blur&#x27; &#125;],                name: [&#123; required: true, message: &#x27;图书名称为必填项&#x27;, trigger: &#x27;blur&#x27; &#125;]            &#125;,            pagination: &#123;//分页相关模型数据                currentPage: 1,//当前页码                pageSize:10,//每页显示的记录数                total:0//总记录数            &#125;        &#125;,        //钩子函数，VUE对象初始化完成后自动执行        created() &#123;        &#125;,        methods: &#123;            //列表            getAll() &#123;            &#125;,            //弹出添加窗口            handleCreate() &#123;            &#125;,            //重置表单            resetForm() &#123;            &#125;,            //添加            handleAdd () &#123;            &#125;,            //取消            cancel()&#123;            &#125;,            // 删除            handleDelete(row) &#123;            &#125;,            //弹出编辑窗口            handleUpdate(row) &#123;            &#125;,            //修改            handleEdit() &#123;            &#125;,            //分页查询            //切换页码            handleCurrentChange(currentPage) &#123;            &#125;,            //条件查询        &#125;    &#125;)&lt;/script&gt;&lt;/html&gt;\n\n​\t在进行具体的功能开发之前，先做联通性的测试，通过页面发送异步提交（axios），这一步调试通过后再进行进一步的功能开发\ncreated() &#123;            this.getAll();        &#125;,            getAll() &#123;    axios.get(&quot;/books&quot;).then((res)=&gt;&#123;        console.log(res.data);    &#125;);&#125;,\n\n​\t只要后台代码能够正常工作，前端能够在日志中接收到数据，就证明前后端是通的，也就可以进行下一步的功能开发了\n总结\n单体项目中页面放置在resources&#x2F;static目录下\ncreated钩子函数用于初始化页面时发起调用\n页面使用axios发送异步请求获取数据后确认前后端是否联通\n\n10、页面基础功能开发1.列表功能（非分页版）​\t\t列表功能主要操作就是加载完数据，将数据展示到页面上，此处要利用VUE的数据模型绑定，发送请求得到数据，然后页面上读取指定数据即可\n​\t\t页面数据模型定义\ndata:&#123;\tdataList: [],//当前页要展示的列表数据\t...&#125;,\n\n​\t\t异步请求获取数据\ngetAll() &#123;    axios.get(&quot;/books&quot;).then((res)=&gt;&#123;        this.dataList = res.data.data;    &#125;);&#125;,\n\n​\t\t这样在页面加载时就可以获取到数据，并且由VUE将数据展示到页面上了\n总结：\n将查询数据返回到页面，利用前端数据绑定进行数据展示\n\n2.添加功能​\t\t添加功能用于收集数据的表单是通过一个弹窗展示的，因此在添加操作前首先要进行弹窗的展示，添加后隐藏弹窗即可。因为这个弹窗一直存在，因此当页面加载时首先设置这个弹窗为不可显示状态，需要展示，切换状态即可\n​\t默认状态\ndata:&#123;\tdialogFormVisible: false,//添加表单是否可见\t...&#125;,\n\n​\t\t切换为显示状态\n//弹出添加窗口handleCreate() &#123;    this.dialogFormVisible = true;&#125;,\n\n​\t\t由于每次添加数据都是使用同一个弹窗录入数据，所以每次操作的痕迹将在下一次操作时展示出来，需要在每次操作之前清理掉上次操作的痕迹\n​\t\t定义清理数据操作\n//重置表单resetForm() &#123;    this.formData = &#123;&#125;;&#125;,\n\n​\t切换弹窗状态时清理数据\n//弹出添加窗口handleCreate() &#123;    this.dialogFormVisible = true;    this.resetForm();&#125;,\n\n​\t\t至此准备工作完成，下面就要调用后台完成添加操作了\n​\t\t添加操作\n//添加handleAdd () &#123;    //发送异步请求    axios.post(&quot;/books&quot;,this.formData).then((res)=&gt;&#123;        //如果操作成功，关闭弹层，显示数据        if (res.data.flag)&#123;            this.dialogFormVisible = false;            this.$message.success(&quot;添加成功&quot;);        &#125;else&#123;            this.$message.error(&quot;添加失败&quot;);        &#125;    &#125;).finally(()=&gt;&#123;        this.getAll();    &#125;);&#125;,\n\n\n将要保存的数据传递到后台，通过post请求的第二个参数传递json数据到后台\n根据返回的操作结果决定下一步操作\n如何是true就关闭添加窗口，显示添加成功的消息\n如果是false保留添加窗口，显示添加失败的消息\n\n\n无论添加是否成功，页面均进行刷新，动态加载数据（对getAll操作发起调用）\n\n​\t\t取消添加操作\n//取消cancel()&#123;    this.dialogFormVisible = false;    this.$message.info(&quot;操作取消&quot;)&#125;,\n\n总结\n请求方式使用POST调用后台对应操作\n添加操作结束后动态刷新页面加载数据\n根据操作结果不同，显示对应的提示信息\n弹出添加Div时清除表单数据\n\n3.删除功能​\t模仿添加操作制作删除功能，差别之处在于删除操作仅传递一个待删除的数据id到后台即可\n​\t删除操作\n// 删除handleDelete(row) &#123;    axios.delete(&quot;/books/&quot;+row.id).then((res)=&gt;&#123;        if (res.data.flag)&#123;            this.$message.success(&quot;删除成功&quot;);        &#125;else&#123;            this.$message.error(&quot;删除失败&quot;);        &#125;    &#125;).finally(()=&gt;&#123;        this.getAll();    &#125;);&#125;,\n\n​\t删除操作提示信息\nhandleDelete(row) &#123;    //1.弹出提示框    this.$confirm(&quot;此操作永久删除当前数据，是否继续？&quot;,&quot;提示&quot;,&#123;        type:&#x27;info&#x27;    &#125;).then(()=&gt;&#123;          //2.做删除业务    axios.delete(&quot;/books/&quot;+row.id).then((res)=&gt;&#123;        if (res.data.flag)&#123;            this.$message.success(&quot;删除成功&quot;);        &#125;else&#123;            this.$message.error(&quot;删除失败&quot;);        &#125;    &#125;).finally(()=&gt;&#123;        this.getAll();    &#125;);&#125;).catch(()=&gt;&#123; //3.取消删除    this.$message.info(&quot;取消删除操作&quot;);&#125;);&#125;,\n\n总结\n请求方式使用Delete调用后台对应操作\n删除操作需要传递当前行数据对应的id值到后台\n删除操作结束后动态刷新页面加载数据\n根据操作结果不同，显示对应的提示信息\n删除操作前弹出提示框避免误操作\n\n4.修改功能​\t\t修改功能可以说是列表功能、删除功能与添加功能的合体。几个相似点如下：\n\n页面也需要有一个弹窗用来加载修改的数据，这一点与添加相同，都是要弹窗\n\n弹出窗口中要加载待修改的数据，而数据需要通过查询得到，这一点与查询全部相同，都是要查数据\n\n查询操作需要将要修改的数据id发送到后台，这一点与删除相同，都是传递id到后台\n\n查询得到数据后需要展示到弹窗中，这一点与查询全部相同，都是要通过数据模型绑定展示数据\n\n修改数据时需要将被修改的数据传递到后台，这一点与添加相同，都是要传递数据\n所以整体上来看，修改功能就是前面几个功能的大合体\n\n\n查询并展示数据\n//弹出编辑窗口handleUpdate(row) &#123;    axios.get(&quot;/books/&quot;+row.id).then((res)=&gt;&#123;        if(res.data.flag)&#123;            //展示弹层，加载数据            this.formData = res.data.data;            this.dialogFormVisible4Edit = true;        &#125;else&#123;            this.$message.error(&quot;数据同步失败，自动刷新&quot;);        &#125;    &#125;);&#125;,\n\n​\t修改操作\n//修改handleEdit() &#123;    axios.put(&quot;/books&quot;,this.formData).then((res)=&gt;&#123;        //如果操作成功，关闭弹层并刷新页面        if(res.data.flag)&#123;            this.dialogFormVisible4Edit = false;            this.$message.success(&quot;修改成功&quot;);        &#125;else &#123;            this.$message.error(&quot;修改失败，请重试&quot;);        &#125;    &#125;).finally(()=&gt;&#123;        this.getAll();    &#125;);&#125;,\n\n总结\n加载要修改数据通过传递当前行数据对应的id值到后台查询数据（同删除与查询全部）\n利用前端双向数据绑定将查询到的数据进行回显（同查询全部）\n请求方式使用PUT调用后台对应操作（同新增传递数据）\n修改操作结束后动态刷新页面加载数据（同新增）\n根据操作结果不同，显示对应的提示信息（同新增）\n\n11.业务消息一致性处理​\t目前的功能制作基本上达成了正常使用的情况，什么叫正常使用呢？也就是这个程序不出BUG，如果我们搞一个BUG出来，你会发现程序马上崩溃掉。比如后台手工抛出一个异常，看看前端接收到的数据什么样子\n&#123;    &quot;timestamp&quot;: &quot;2021-09-15T03:27:31.038+00:00&quot;,    &quot;status&quot;: 500,    &quot;error&quot;: &quot;Internal Server Error&quot;,    &quot;path&quot;: &quot;/books&quot;&#125;\n\n​\t看来不仅要对正确的操作数据格式做处理，还要对错误的操作数据格式做同样的格式处理\n​\t首先在当前的数据结果中添加消息字段，用来兼容后台出现的操作消息\npackage com.example.Controller.utils;import lombok.Data;@Datapublic class R &#123;    private Boolean flag;    private Object data;    private String msg;//用于封装消息    public R()&#123;&#125;    public R(Boolean flag)&#123;        this.flag = flag;    &#125;    public R(Boolean flag,Object data)&#123;        this.flag = flag;        this.data = data;    &#125;  public R(String msg)&#123;        this.flag = false;        this.msg = msg;    &#125;&#125;\n\n​\t然后在表现层做统一的异常处理，使用SpringMVC提供的异常处理器做统一的异常处理\npackage com.example.Controller.utils;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;@RestControllerAdvicepublic class ProjectExceptionAdvice &#123;    @ExceptionHandler(Exception.class)    public R doOtherException(Exception ex)&#123;    ex.printStackTrace();    return new R(&quot;系统错误，请稍后再试！&quot;);    &#125;&#125;\n\n​\t页面上得到数据后，先判定是否有后台传递过来的消息，标志就是当前操作是否成功，如果返回操作结果false，就读取后台传递的消息\n//添加handleAdd () &#123;    //发送异步请求    axios.post(&quot;/books&quot;,this.formData).then((res)=&gt;&#123;        //如果操作成功，关闭弹层，显示数据        if (res.data.flag)&#123;            this.dialogFormVisible = false;            this.$message.success(&quot;添加成功&quot;);        &#125;else&#123;            this.$message.error(res.data.msg);        &#125;    &#125;).finally(()=&gt;&#123;        this.getAll();    &#125;);&#125;,\n\n总结\n使用注解@RestControllerAdvice定义SpringMVC异常处理器用来处理异常的\n异常处理器必须被扫描加载，否则无法生效\n表现层返回结果的模型类中添加消息属性用来传递消息到页面\n\n12、页面功能开发1.分页功能​\t\t分页功能的制作用于替换前面的查询全部，其中要使用到elementUI提供的分页组件\n&lt;!--分页组件--&gt;&lt;div class=&quot;pagination-container&quot;&gt;    &lt;el-pagination\t\tclass=&quot;pagiantion&quot;\t\t@current-change=&quot;handleCurrentChange&quot;\t\t:current-page=&quot;pagination.currentPage&quot;\t\t:page-size=&quot;pagination.pageSize&quot;\t\tlayout=&quot;total, prev, pager, next, jumper&quot;\t\t:total=&quot;pagination.total&quot;&gt;    &lt;/el-pagination&gt;&lt;/div&gt;\n\n​\t\t为了配合分页组件，封装分页对应的数据模型\ndata:&#123;\tpagination: &#123;\t\t\t//分页相关模型数据\t\tcurrentPage: 1,\t//当前页码\t\tpageSize:10,\t//每页显示的记录数\t\ttotal:0,\t\t//总记录数\t&#125;&#125;,\n\n​\t\t修改查询全部功能为分页查询，通过路径变量传递页码信息参数\n//列表getAll() &#123;    axios.get(&quot;/books/&quot;+this.pagination.currentPage+&quot;/&quot;+this.pagination.pageSize).then((res)=&gt;&#123;    &#125;);&#125;,\n\n​\t页面根据分页操作结果读取对应数据，并进行数据模型绑定\ngetAll() &#123;    axios.get(&quot;/books/&quot;+this.pagination.currentPage+&quot;/&quot;+this.pagination.pageSize).then((res)=&gt;&#123;        this.pagination.total = res.data.data.total;        this.pagination.currentPage = res.data.data.current;        this.pagination.pagesize = res.data.data.size;        this.dataList = res.data.data.records;    &#125;);&#125;,\n\n​\t\t对切换页码操作设置调用当前分页操作\n//切换页码handleCurrentChange(currentPage) &#123;    this.pagination.currentPage =currentPage;    this.getAll()&#125;,\n\n总结\n使用el分页组件\n定义分页组件绑定的数据模型\n异步调用获取分页数据\n分页数据页面回显\n\n2.删除功能维护删除功能维护\n@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)public R getPage(@PathVariable int currentPage,@PathVariable int pageSize)&#123;    IPage&lt;Book&gt; page = bookService.getPage(currentPage, pageSize);    //如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值    if( currentPage &gt; page.getPages())&#123;        page = bookService.getPage((int)page.getPages(), pageSize);    &#125;    return new R(true, page);&#125;\n\n3.条件查询功能​\t\t最后一个功能来做条件查询，其实条件查询可以理解为分页查询的时候除了携带分页数据再多带几个数据的查询。这些多带的数据就是查询条件。比较一下不带条件的分页查询与带条件的分页查询差别之处，这个功能就好做了\n\n页面封装的数据：带不带条件影响的仅仅是一次性传递到后台的数据总量，由传递2个分页相关的数据转换成2个分页数据加若干个条件\n\n后台查询功能：查询时由不带条件，转换成带条件，反正不带条件的时候查询条件对象使用的是null，现在换成具体条件，差别不大\n\n查询结果：不管带不带条件，出来的数据只是有数量上的差别，其他都差别，这个可以忽略\n经过上述分析，看来需要在页面发送请求的格式方面做一定的修改，后台的调用数据层操作时发送修改，其他没有区别\n页面发送请求时，两个分页数据仍然使用路径变量，其他条件采用动态拼装url参数的形式传递\n\n\n页面封装查询条件字段\npagination: &#123;//分页相关模型数据    currentPage: 1,//当前页码    pageSize:10,//每页显示的记录数    total:0,//总记录数    name: &quot;&quot;,    type: &quot;&quot;,    description: &quot;&quot;&#125;\n\n页面添加查询条件字段对应的数据模型绑定名称\n&lt;div class=&quot;filter-container&quot;&gt;        &lt;el-input placeholder=&quot;图书类别&quot; v-model=&quot;pagination.type&quot; style=&quot;width: 200px;&quot; class=&quot;filter-item&quot;&gt;&lt;/el-input&gt;        &lt;el-input placeholder=&quot;图书名称&quot; v-model=&quot;pagination.name&quot; style=&quot;width: 200px;&quot; class=&quot;filter-item&quot;&gt;&lt;/el-input&gt;        &lt;el-input placeholder=&quot;图书描述&quot; v-model=&quot;pagination.description&quot; style=&quot;width: 200px;&quot; class=&quot;filter-item&quot;&gt;&lt;/el-input&gt;    &lt;el-button @click=&quot;getAll()&quot; class=&quot;dalfBut&quot;&gt;查询&lt;/el-button&gt;    &lt;el-button type=&quot;primary&quot; class=&quot;butT&quot; @click=&quot;handleCreate()&quot;&gt;新建&lt;/el-button&gt;&lt;/div&gt;\n\n将查询条件组织成url参数，添加到请求url地址中，这里可以借助其他类库快速开发，当前使用手工形式拼接，降低学习要求\ngetAll() &#123;    //1.获取查询条件,拼接查询条件    param = &quot;?name=&quot;+this.pagination.name;    param += &quot;&amp;type=&quot;+this.pagination.type;    param += &quot;&amp;description=&quot;+this.pagination.description;    console.log(&quot;-----------------&quot;+ param);    axios.get(&quot;/books/&quot;+this.pagination.currentPage+&quot;/&quot;+this.pagination.pageSize+param).then((res) =&gt; &#123;        this.dataList = res.data.data.records;    &#125;);&#125;,\n\n后台代码中定义实体类封查询条件\n@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)public R getPage(@PathVariable int currentPage,@PathVariable int pageSize,Book book)&#123;    IPage&lt;Book&gt; page = bookService.getPage(currentPage, pageSize,book);    //如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值    if( currentPage &gt; page.getPages())&#123;        page = bookService.getPage((int)page.getPages(), pageSize,book);    &#125;    return new R(null!=page, page);&#125;\n\n对应业务层接口与实现类进行修正\npublic interface IBookService extends IService&lt;Book&gt; &#123;    IPage&lt;Book&gt; getPage(Integer currentPage,Integer pageSize,Book queryBook);&#125;\n\n@Overridepublic IPage&lt;Book&gt; getPage(int currentPage, int pageSize,Book book) &#123;    IPage page = new Page(currentPage, pageSize);    LambdaQueryWrapper&lt;Book&gt; lqw = new LambdaQueryWrapper&lt;Book&gt;();    lqw.like(Strings.isNotEmpty(book.getName()),Book::getName,book.getName());    lqw.like(Strings.isNotEmpty(book.getType()),Book::getType,book.getType());    lqw.like(Strings.isNotEmpty(book.getDescription()),Book::getDescription,book.getDescription());    return bookDao.selectPage(page,lqw);&#125;\n\n页面回显数据\ngetAll() &#123;    //1.获取查询条件,拼接查询条件    param = &quot;?name=&quot;+this.pagination.name;    param += &quot;&amp;type=&quot;+this.pagination.type;    param += &quot;&amp;description=&quot;+this.pagination.description;    console.log(&quot;-----------------&quot;+ param);    axios.get(&quot;/books/&quot;+this.pagination.currentPage+&quot;/&quot;+this.pagination.pageSize+param).then((res) =&gt; &#123;        this.pagination.total = res.data.data.total;        this.pagination.currentPage = res.data.data.current;        this.pagination.pagesize = res.data.data.size;        this.dataList = res.data.data.records;    &#125;);&#125;,\n\n总结\n\n定义查询条件数据模型（当前封装到分页数据模型中）\n异步调用分页功能并通过请求参数传递数据到后台\n\n13、源代码链接：https://pan.baidu.com/s/1aOrjo4AIZocv5B1XeoktJQ提取码：lkym\n","tags":["SpringBoot"]},{"title":"SpringBoot基础篇之入门案例（Idea联网版）","url":"/2022/06/07/SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B%EF%BC%88Idea%E8%81%94%E7%BD%91%E7%89%88%EF%BC%89/","content":"Idea联网版：下面使用SpringBoot技术快速构建一个SpringMVC的程序，通过这个过程体会简化二字的含义\n步骤①：创建新模块，选择Spring Initializr，并配置模块相关基础信息\n\n特别关注：第3步点击Next时，Idea需要联网状态才可以进入到后面那一页，如果不能正常联网，就无法正确到达右面那个设置页了，会一直联网转转转\n​\t特别关注：第5步选择java版本和你计算机上安装的JDK版本匹配即可，但是最低要求为JDK8或以上版本，推荐使用8或11\n步骤②：选择当前模块需要使用的技术集\n\n​\t按照要求，左侧选择web，然后在中间选择Spring Web即可，选完右侧就出现了新的内容项，这就表示勾选成功了\n​\t关注：此处选择的SpringBoot的版本使用默认的就可以了，需要说一点，SpringBoot的版本升级速度很快，可能昨天创建工程的时候默认版本是2.5.4，今天再创建工程默认版本就变成2.5.5了，差别不大，无需过于纠结，回头可以到配置文件中修改对应的版本\n步骤③：开发控制器类\n@RestController@RequestMapping(&quot;/books&quot;)public class BookController &#123;    @GetMapping    public String getById()&#123;        System.out.println(&quot;springboot is running..&quot;);        return &quot;springboot is running..&quot;;    &#125;&#125;\n\n入门案例制作的SpringMVC的控制器基于Rest风格开发，当然此处使用原始格式制作SpringMVC的程序也是没有问题的，上例中的@RestController与@GetMapping注解是基于Restful开发的典型注解\n​\t关注：做到这里SpringBoot程序的最基础的开发已经做完了，现在就可以正常的运行Spring程序了。可能有些小伙伴会有疑惑，Tomcat服务器没有配置，&#x3D;-Spring也没有配置，什么都没有配置这就能用吗？这就是SpringBoot技术的强大之处。关于内部工作流程后面再说，先专心学习开发过程\n步骤④：运行自动生成的Application类\n\n​\t使用带main方法的java程序的运行形式来运行程序，运行完毕后，控制台输出上述信息。\n​\t不难看出，运行的信息中包含了8080的端口，Tomcat这种熟悉的字样，难道这里启动了Tomcat服务器？是的，这里已经启动了。那服务器没有配置，哪里来的呢？后面再说。现在你就可以通过浏览器访问请求的路径，测试功能是否工作正常了\n访问路径：\thttp://localhost:8080/books\n\n\npom.xml\n\n​\t这是maven的配置文件，描述了当前工程构建时相应的配置信息\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.7.0&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.example&lt;/groupId&gt;    &lt;artifactId&gt;springboot-01&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;springboot-01&lt;/name&gt;    &lt;description&gt;springboot-01&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n\n配置中有两个信息需要关注，一个是parent，也就是当前工程继承了另外一个工程，干什么用的后面再说，还有依赖坐标，干什么用的后面再说\n\nApplication类\n\n\n@SpringBootApplicationpublic class Springboot01Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Springboot01Application.class, args);    &#125;&#125;\n\n\n\n\n类配置文件\nSpring\nSpringBoot\n\n\n\npom文件中的坐标\n手工添加\n勾选添加\n\n\nweb3.0配置类\n手工制作\n无\n\n\nSpring&#x2F;SpringMVC配置类\n手工制作\n无\n\n\n控制器\n手工制作\n手工制作\n\n\n​\t一句话总结一下就是能少写就少写，能不写就不写\n总结\n开发SpringBoot程序可以根据向导进行联网快速制作\nSpringBoot程序需要基于JDK8以上版本进行制作\nSpringBoot程序中需要使用何种功能通过勾选选择技术，也可以手工添加对应的要使用的技术（后期讲解）\n运行SpringBoot程序通过运行Application程序入口进行\n\n思考​\t前面制作的时候说过，这个过程必须联网才可以进行，但是有些时候你会遇到一些莫名其妙的问题，比如基于Idea开发时，你会发现你配置了一些坐标，然后Maven下载对应东西的时候死慢死慢的，甚至还会失败。其实这和Idea这款IDE工具有关，万一Idea不能正常访问网络的话，我们是不是就无法制作SpringBoot程序了呢？\n","tags":["SpringBoot"]},{"title":"SpringBoot基础篇之SpringBoot简介","url":"/2022/06/08/SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8BSpringBoot%E7%AE%80%E4%BB%8B/","content":"SpringBoot简介SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程。\n​\t都简化了了哪些东西呢？其实就是针对原始的Spring程序制作的两个方面进行了简化：\n\nSpring程序缺点\n依赖设置繁琐\n以前写Spring程序，使用的技术都要自己一个一个的写，现在不需要了，如果做过原始SpringMVC程序的小伙伴应该知道，写SpringMVC程序，最基础的spring-web和spring-webmvc这两个坐标时必须的，就这还不包含你用json啊等等这些坐标，现在呢？一个坐标搞定面\n\n\n配置繁琐\n以前写配置类或者配置文件，然后用什么东西就要自己写加载bean这些东西，现在呢？什么都没写，照样能用\n\n\n\n\n\n\n回顾\n通过上面两个方面的定位，我们可以产生两个模糊的概念：\n\nSpringBoot开发团队认为原始的Spring程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的Spring程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的Spring程序至少有一个配置文件或配置类，用来描述Spring的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用Spring大部分情况下是做web开发，如果做web开发的话，还要在加载web环境时加载时加载指定的spring配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件&#x2F;配置类呢？那换了SpringBoot技术以后呢，这些还要写吗？\nSpringBoot开发团队认为原始的Spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给Spring容器管理，也就是配置成Spring容器管控的bean就可以了。这都是基本操作啊，难道这些东西SpringBoot也能帮我们简化？\n\n\n再来看看前面提出的两个问题，已经有答案了，都简化了，都不用写了，这就是SpringBoot给我们带来的好处。这些简化操作在SpringBoot中有专业的用语，也是SpringBoot程序的核心功能及优点：\n\n起步依赖（简化依赖配置）\n依赖配置的书写简化就是靠这个起步依赖达成的\n\n\n自动配置（简化常用工程相关配置）\n配置过于繁琐，使用自动配置就可以做响应的简化，但是内部还是很复杂的，后面具体展开说\n\n\n辅助功能（内置服务器，……）\n除了上面的功能，其实SpringBoot程序还有其他的一些优势，比如我们没有配置Tomcat服务器，但是能正常运行，这是SpringBoot程序的一个可以感知到的功能，也是SpringBoot的辅助功能之一。\n\n\n\n​\t下面结合入门程序来说说这些简化操作都在哪些方面进行体现的，一共分为4个方面\n\nparent\nstarter\n引导类\n内嵌tomcat\n\n1、parentSpringBoot关注到开发者在进行开发时，往往对依赖版本的选择具有固定的搭配格式，并且这些依赖版本的选择还不能乱搭配。比如A技术的2.0版与B技术的3.5版可以合作在一起，但是和B技术的3.7版合并使用时就有冲突。其实很多开发者都一直想做一件事情，就是将各种各样的技术配合使用的常见依赖版本进行收集整理，制作出了最合理的依赖版本配置方案，这样使用起来就方便多了。\n​\tSpringBoot一看这种情况so easy啊，于是将所有的技术版本的常见使用方案都给开发者整理了出来，以后开发者使用时直接用它提供的版本方案，就不用担心冲突问题了，相当于SpringBoot做了无数个技术版本搭配的列表，这个技术搭配列表的名字叫做parent。\nparent自身具有很多个版本，每个parent版本中包含有几百个其他技术的版本号，不同的parent间使用的各种技术的版本号有可能会发生变化。当开发者使用某些技术时，直接使用SpringBoot提供的parent就行了，由parent帮助开发者统一的进行各种技术的版本管理\n​\t比如你现在要使用Spring配合MyBatis开发，没有parent之前怎么做呢？选个Spring的版本，再选个MyBatis的版本，再把这些技术使用时关联的其他技术的版本逐一确定下来。当你Spring的版本发生变化需要切换时，你的MyBatis版本有可能也要跟着切换，关联技术呢？可能都要切换，而且切换后还可能出现问题。现在这一切工作都可以交给parent来做了。你无需关注这些技术间的版本冲突问题，你只需要关注你用什么技术就行了，冲突问题由parent负责处理。\n有人可能会提出来，万一parent给我导入了一些我不想使用的依赖怎么办？记清楚，这一点很关键，parent仅仅帮我们进行版本管理，它不负责帮你导入坐标，说白了用什么还是你自己定，只不过版本不需要你管理了。整体上来说，使用parent可以帮助开发者进行版本的统一管理\n​\t关注：parent定义出来以后，并不是直接使用的，仅仅给了开发者一个说明书，但是并没有实际使用，这个一定要确认清楚\n​\t那SpringBoot又是如何做到这一点的呢？可以查阅SpringBoot的配置源码，看到这些定义\n\n项目中的pom.xml中继承了一个坐标\n\n&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;\n\n\n打开后可以查阅到其中又继承了一个坐标\n\n&lt;parent&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;  &lt;version&gt;2.7.0&lt;/version&gt;&lt;/parent&gt;\n\n\n这个坐标中定义了两组信息，第一组是各式各样的依赖版本号属性，下面列出依赖版本属性的局部，可以看的出来，定义了若干个技术的依赖版本号\n\n&lt;properties&gt;    &lt;activemq.version&gt;5.16.3&lt;/activemq.version&gt;    &lt;aspectj.version&gt;1.9.7&lt;/aspectj.version&gt;    &lt;assertj.version&gt;3.19.0&lt;/assertj.version&gt;    &lt;commons-codec.version&gt;1.15&lt;/commons-codec.version&gt;    &lt;commons-dbcp2.version&gt;2.8.0&lt;/commons-dbcp2.version&gt;    &lt;commons-lang3.version&gt;3.12.0&lt;/commons-lang3.version&gt;    &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt;    &lt;commons-pool2.version&gt;2.9.0&lt;/commons-pool2.version&gt;    &lt;h2.version&gt;1.4.200&lt;/h2.version&gt;    &lt;hibernate.version&gt;5.4.32.Final&lt;/hibernate.version&gt;    &lt;hibernate-validator.version&gt;6.2.0.Final&lt;/hibernate-validator.version&gt;    &lt;httpclient.version&gt;4.5.13&lt;/httpclient.version&gt;    &lt;jackson-bom.version&gt;2.12.4&lt;/jackson-bom.version&gt;    &lt;javax-jms.version&gt;2.0.1&lt;/javax-jms.version&gt;    &lt;javax-json.version&gt;1.1.4&lt;/javax-json.version&gt;    &lt;javax-websocket.version&gt;1.1&lt;/javax-websocket.version&gt;    &lt;jetty-el.version&gt;9.0.48&lt;/jetty-el.version&gt;    &lt;junit.version&gt;4.13.2&lt;/junit.version&gt;&lt;/properties&gt;\n\n\n第二组是各式各样的的依赖坐标信息，可以看出依赖坐标定义中没有具体的依赖版本号，而是引用了第一组信息中定义的依赖版本属性值\n\n&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;            &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;\n\n关注：上面的依赖坐标定义是出现在&lt;dependencyManagement&gt;标签中的，其实是对引用坐标的依赖管理，并不是实际使用的坐标。因此当你的项目中继承了这组parent信息后，在不使用对应坐标的情况下，前面的这组定义是不会具体导入某个依赖的\n关注：因为在maven中继承机会只有一次，上述继承的格式还可以切换成导入的形式进行，并且在阿里云的starter创建工程时就使用了此种形式\n&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;scope&gt;import&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;\n\n总结\n开发SpringBoot程序要继承spring-boot-starter-parent\nspring-boot-starter-parent中定义了若干个依赖管理\n继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突\n继承parent的形式也可以采用引入依赖的形式实现效果\n\n思考​\tparent中定义了若干个依赖版本管理，但是也没有使用，那这个设定也就不生效啊，究竟谁在使用这些定义呢？\n2、starter​\tSpringBoot关注到开发者在实际开发时，对于依赖坐标的使用往往都有一些固定的组合方式，比如使用spring-webmvc就一定要使用spring-web。每次都要固定搭配着写，非常繁琐，而且格式固定，没有任何技术含量。\n​\tSpringBoot一看这种情况，看来需要给开发者带来一些帮助了。安排，把所有的技术使用的固定搭配格式都给开发出来，以后你用某个技术，就不用一次写一堆依赖了，还容易写错，我给你做一个东西，代表一堆东西，开发者使用的时候，直接用我做好的这个东西就好了，对于这样的固定技术搭配，SpringBoot给它起了个名字叫做starter。\n​\tstarter定义了使用某种技术时对于依赖的固定搭配格式，也是一种最佳解决方案，使用starter可以帮助开发者减少依赖配置\n​\t这个东西其实在入门案例里面已经使用过了，入门案例中的web功能就是使用这种方式添加依赖的。可以查阅SpringBoot的配置源码，看到这些定义\n\n项目中的pom.xml定义了使用SpringMVC技术，但是并没有写SpringMVC的坐标，而是添加了一个名字中包含starter的依赖\n\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n在spring-boot-starter-web中又定义了若干个具体依赖的坐标\n\n&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;5.3.20&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.3.20&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n之前提到过开发SpringMVC程序需要导入spring-webmvc的坐标和spring整合web开发的坐标，就是上面这组坐标中的最后两个了。\n但是我们发现除了这两个还有其他的，比如第二个，叫做spring-boot-starter-json。看名称就知道，这个是与json有关的坐标了，但是看名字发现和最后两个又不太一样，它的名字中也有starter，打开看看里面有什么？\n&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;5.3.20&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.13.3&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;    &lt;artifactId&gt;jackson-datatype-jdk8&lt;/artifactId&gt;    &lt;version&gt;2.13.3&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;    &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;    &lt;version&gt;2.13.3&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt;    &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt;    &lt;version&gt;2.13.3&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n我们可以发现，这个starter中又包含了若干个坐标，其实就是使用SpringMVC开发通常都会使用到Json，使用json又离不开这里面定义的这些坐标，看来还真是方便，SpringBoot把我们开发中使用的东西能用到的都给提前做好了。你仔细看完会发现，里面有一些你没用过的。的确会出现这种过量导入的可能性，没关系，可以通过maven中的排除依赖剔除掉一部分。不过你不管它也没事，大不了就是过量导入呗。\n​\t到这里基本上得到了一个信息，使用starter可以帮开发者快速配置依赖关系。以前写依赖3个坐标的，现在写导入一个就搞定了，就是加速依赖配置的。\n3、starter与parent的区别​\tstarter是一个坐标中定了若干个坐标，以前写多个的，现在写一个，是用来减少依赖配置的书写量的\n​\tparent是定义了几百个依赖版本号，以前写依赖需要自己手工控制版本，现在由SpringBoot统一管理，这样就不存在版本冲突了，是用来减少依赖冲突的\n实际开发应用方式\n\n实际开发中如果需要用什么技术，先去找有没有这个技术对应的starter\n\n如果有对应的starter，直接写starter，而且无需指定版本，版本由parent提供\n如果没有对应的starter，手写坐标即可\n\n\n实际开发中如果发现坐标出现了冲突现象，确认你要使用的可行的版本号，使用手工书写的方式添加对应依赖，覆盖SpringBoot提供给我们的配置管理\n\n方式一：直接写坐标\n方式二：覆盖&lt;properties&gt;中定义的版本号，就是下面这堆东西了，哪个冲突了覆盖哪个就OK了\n\n\n\n&lt;properties&gt;    &lt;activemq.version&gt;5.16.3&lt;/activemq.version&gt;    &lt;aspectj.version&gt;1.9.7&lt;/aspectj.version&gt;    &lt;assertj.version&gt;3.19.0&lt;/assertj.version&gt;    &lt;commons-codec.version&gt;1.15&lt;/commons-codec.version&gt;    &lt;commons-dbcp2.version&gt;2.8.0&lt;/commons-dbcp2.version&gt;    &lt;commons-lang3.version&gt;3.12.0&lt;/commons-lang3.version&gt;    &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt;    &lt;commons-pool2.version&gt;2.9.0&lt;/commons-pool2.version&gt;    &lt;h2.version&gt;1.4.200&lt;/h2.version&gt;    &lt;hibernate.version&gt;5.4.32.Final&lt;/hibernate.version&gt;    &lt;hibernate-validator.version&gt;6.2.0.Final&lt;/hibernate-validator.version&gt;    &lt;httpclient.version&gt;4.5.13&lt;/httpclient.version&gt;    &lt;jackson-bom.version&gt;2.12.4&lt;/jackson-bom.version&gt;    &lt;javax-jms.version&gt;2.0.1&lt;/javax-jms.version&gt;    &lt;javax-json.version&gt;1.1.4&lt;/javax-json.version&gt;    &lt;javax-websocket.version&gt;1.1&lt;/javax-websocket.version&gt;    &lt;jetty-el.version&gt;9.0.48&lt;/jetty-el.version&gt;    &lt;junit.version&gt;4.13.2&lt;/junit.version&gt;&lt;/properties&gt;\n\n温馨提示​\tSpringBoot官方给出了好多个starter的定义，方便我们使用，而且名称都是如下格式\n命名规则：spring-boot-starter-技术名称\n\n​\t所以以后见了spring-boot-starter-aaa这样的名字，这就是SpringBoot官方给出的starter定义。那非官方定义的也有吗？有的\n总结\n开发SpringBoot程序需要导入坐标时通常导入对应的starter\n每个不同的starter根据功能不同，通常包含多个依赖坐标\n使用starter可以实现快速配置的效果，达到简化配置的目的\n\n4、引导类前程序运行的入口就是SpringBoot工程创建时自带的那个类了，带有main方法的那个类，运行这个类就可以启动SpringBoot工程的运行\n@SpringBootApplicationpublic class Springboot01Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Springboot01Application.class, args);    &#125;&#125;\n\n​\tSpringBoot本身是为了加速Spring程序的开发的，而Spring程序运行的基础是需要创建自己的Spring容器对象（IoC容器）并将所有的对象交给Spring的容器管理，也就是一个一个的Bean。那还了SpringBoot加速开发Spring程序，这个容器还在吗？这个疑问不用说，一定在。当前这个类运行后就会产生一个Spring容器对象，并且可以将这个对象保存起来，通过容器对象直接操作Bean。\n@SpringBootApplicationpublic class Springboot01Application &#123;    public static void main(String[] args) &#123;        ConfigurableApplicationContext ctx = SpringApplication.run(Springboot01Application.class, args);        BookController bean = ctx.getBean(BookController.class);        System.out.println(&quot;bean=====&gt;&quot;+bean);    &#125;&#125;\n\n​\t通过上述操作不难看出，其实SpringBoot程序启动还是创建了一个Spring容器对象。这个类在SpringBoot程序中是所有功能的入口，称这个类为引导类。\n​\t作为一个引导类最典型的特征就是当前类上方声明了一个注解@SpringBootApplication\n总结\nSpringBoot工程提供引导类用来启动程序\nSpringBoot工程启动后创建并初始化Spring容器\n\n思考​\t程序现在已经运行了，通过引导类的main方法运行了起来。但是运行java程序不应该是执行完就结束了吗？但是我们现在明显是启动了一个web服务器啊，不然网页怎么能正常访问呢？这个服务器是在哪里写的呢？\n5、内嵌tomcat当前我们做的SpringBoot入门案例勾选了Spirng-web的功能，并且导入了对应的starter。\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\n\n下面就围绕着这个内置的web服务器，也可以说是内置的tomcat服务器来研究几个问题\n\n这个服务器在什么位置定义的\n这个服务器是怎么运行的\n这个服务器如果想换怎么换？虽然这个需求很垃圾，搞得开发者会好多web服务器一样，用别人提供好的不香么？非要自己折腾\n\n内嵌Tomcat定义位置&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\n\n打开查看web的starter导入了哪些东西\n&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;5.3.20&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.3.20&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n第三个依赖就是这个tomcat对应的东西了，居然也是一个starter，再打开看看\n&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;    &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;    &lt;version&gt;1.3.5&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;    &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;    &lt;version&gt;9.0.63&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;    &lt;exclusions&gt;      &lt;exclusion&gt;        &lt;artifactId&gt;tomcat-annotations-api&lt;/artifactId&gt;        &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;      &lt;/exclusion&gt;    &lt;/exclusions&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;    &lt;artifactId&gt;tomcat-embed-el&lt;/artifactId&gt;    &lt;version&gt;9.0.63&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;    &lt;artifactId&gt;tomcat-embed-websocket&lt;/artifactId&gt;    &lt;version&gt;9.0.63&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;    &lt;exclusions&gt;      &lt;exclusion&gt;        &lt;artifactId&gt;tomcat-annotations-api&lt;/artifactId&gt;        &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;      &lt;/exclusion&gt;    &lt;/exclusions&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n​\t\t这里面有一个核心的坐标，tomcat-embed-core，叫做tomcat内嵌核心。就是这个东西把tomcat功能引入到了我们的程序中。目前解决了第一个问题，找到根儿了，谁把tomcat引入到程序中的？spring-boot-starter-web中的spring-boot-starter-tomcat做的。之所以你感觉很奇妙的原因就是，这个东西是默认加入到程序中了，所以感觉很神奇，居然什么都不做，就有了web服务器对应的功能，再来说第二个问题，这个服务器是怎么运行的\n内嵌Tomcat运行原理Tomcat服务器是一款软件，而且是一款使用java语言开发的软件，熟悉的小伙伴可能有印象，tomcat安装目录中保存有jar，好多个jar。\n​\t下面的问题来了，既然是使用java语言开发的，运行的时候肯定符合java程序运行的原理，java程序运行靠的是什么？对象呀，一切皆对象，万物皆对象。那tomcat运行起来呢？也是对象。\n​\t如果是对象，那Spring容器是用来管理对象的，这个对象能不能交给Spring容器管理呢？把吗去掉，是个对象都可以交给Spring容器管理，行了，这下通了。tomcat服务器运行其实是以对象的形式在Spring容器中运行的，怪不得我们没有安装这个tomcat，而且还能用。闹了白天这东西最后是以一个对象的形式存在，保存在Spring容器中悄悄运行的。具体运行的是什么呢？其实就是上前面提到的那个tomcat内嵌核心\n&lt;dependency&gt;  &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;  &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;  &lt;version&gt;9.0.63&lt;/version&gt;  &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;\n\n​\t那既然是个对象，如果把这个对象从Spring容器中去掉是不是就没有web服务器的功能呢？是这样的，通过依赖排除可以去掉这个web服务器功能\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n上面对web-starter做了一个操作，使用maven的排除依赖去掉了使用tomcat的starter。这下好了，容器中肯定没有这个对象了，重新启动程序可以观察到程序运行了，但是并没有像之前那样运行后会等着用户发请求，而是直接停掉了，就是这个原因了。\n更换内嵌Tomcat​\t那根据上面的操作我们思考是否可以换个服务器呢？必须的嘛。根据SpringBoot的工作机制，用什么技术，加入什么依赖就行了。SpringBoot提供了3款内置的服务器\n\ntomcat(默认)：apache出品，粉丝多，应用面广，负载了若干较重的组件\n\njetty：更轻量级，负载性能远不及tomcat\n\nundertow：负载性能勉强跑赢tomcat\n想用哪个，加个坐标就OK。前提是把tomcat排除掉，因为tomcat是默认加载的。\n\n\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n​\t现在就已经成功替换了web服务器，核心思想就是用什么加入对应坐标就可以了。如果有starter，优先使用starter。\n总结\n内嵌Tomcat服务器是SpringBoot辅助功能之一\n内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理\n变更内嵌服务器思想是去除现有服务器，添加全新的服务器\n\n","tags":["SpringBoot"]},{"title":"SpringBoot基础篇之入门案例（官网创建版）","url":"/2022/06/07/SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B%EF%BC%88%E5%AE%98%E7%BD%91%E5%88%9B%E5%BB%BA%E7%89%88%EF%BC%89/","content":"官网创建版：步骤①：点击Spring Initializr后进入到创建SpringBoot程序的界面上，下面是输入信息的过程，和前面的一样，只是界面变了而已，根据自己的要求，在左侧选择对应信息和输入对应的信息即可\n\n步骤②：右侧的ADD DEPENDENCIES用于选择使用何种技术，和之前勾选的Spring WEB是在做同一件事，仅仅是界面不同而已，点击后打开网页版的技术选择界面\n\n步骤③：所有信息设置完毕后，点击下面左侧按钮，生成一个文件包\n步骤④：保存后得到一个压缩文件，这个文件打开后就是创建的SpringBoot工程文件夹了\t\t\n步骤⑤：解压缩此文件后，得到工程目录，在Idea中导入即可使用，和之前创建的东西完全一样。下面就可以自己创建一个Controller测试一下是否能用了。\n温馨提示​\t做到这里其实可以透漏一个小秘密，Idea工具中创建SpringBoot工程其实连接的就是SpringBoot的官网，走的就是这个过程，只不过Idea把界面给整合了一下，读取到了Spring官网给的信息，然后展示到了Idea的界面中而已。\n总结\n打开SpringBoot官网，选择Quickstart Your Project\n创建工程，并保存项目\n解压项目，通过IDE导入项目\n\n思考​\t现在创建工程靠的是访问国外的Spring主站，但是互联网访问是可以控制的，如果一天这个网站你在国内都无法访问了，那前面这两种方式都无法创建SpringBoot工程了，这时候又该怎么解决这个问题呢？\n","tags":["SpringBoot"]},{"title":"SpringBoot基础篇之入门案例（手工制作版）","url":"/2022/06/08/SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B%EF%BC%88%E6%89%8B%E5%B7%A5%E5%88%B6%E4%BD%9C%E7%89%88%EF%BC%89/","content":"​\t不能上网，还想创建SpringBoot工程，能不能做呢？能做，但是你要先问问自己联网和不联网到底差别是什么？这个信息找到以后，你就发现，你把联网要干的事情都提前准备好，就无需联网了。\n​\t联网做什么呢？首先SpringBoot工程也是基于Maven构建的，而Maven工程当使用了一些自己需要使用又不存在的东西时，就要去下载。其实SpringBoot工程创建的时候就是去下载一些必要的组件的。你把这些东西给提前准备好就可以了吗？是的，就是这样。\n\n步骤①：创建工程时，选择手工创建Maven工程\n\n步骤②：参照标准SpringBoot工程的pom文件，书写自己的pom文件即可,用什么写什么，不用的都可以不写。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.4&lt;/version&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.itheima&lt;/groupId&gt;    &lt;artifactId&gt;springboot_01_04_quickstart&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\n步骤③：之前运行SpringBoot工程需要一个类，这个缺不了，自己手写一个就行了，建议按照之前的目录结构来创。类名可以自定义，关联的名称一切修改即可\n@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(&lt;Application.class);    &#125;&#125;\n\n​\t关注：类上面的注解@SpringBootApplication千万别丢了，这个是核心，后面再介绍\n​\t关注：类名可以自定义，只要保障下面代码中使用的类名和你自己定义的名称一样即可，也就是run方法中的那个class对应的名称\n步骤④：下面就可以自己创建一个Controller测试一下是否能用了，和之前没有差别了\n​\t看到这里其实应该能够想明白了，通过向导或者网站创建的SpringBoot工程其实就是帮你写了一些代码，而现在是自己手写，写的内容都一样，仅此而已。\n温馨提示​\t如果你的计算机上从来没有创建成功过SpringBoot工程，自然也就没有下载过SpringBoot对应的坐标，那用手写创建的方式在不联网的情况下肯定该是不能用的。所谓手写，其实就是自己写别人帮你生成的东西，但是引用的坐标对应的资源必须保障maven仓库里面有才行，如果没有，还是要去下载的\n总结\n创建普通Maven工程\n继承spring-boot-starter-parent\n添加依赖spring-boot-starter-web\n制作引导类Application\n\n","tags":["SpringBoot"]},{"title":"SpringBoot基础篇之入门案例（阿里云版）","url":"/2022/06/08/SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91%E7%89%88%EF%BC%89/","content":"前面提到网站如果被限制访问了，该怎么办？开动脑筋想一想，不管是方式一还是方式二其实都是走的同一个地方，也就是SpringBoot的官网创建的SpringBoot工程，那如果我们国内有这么一个网站能提供这样的功能，是不是就解决了呢？必然的嘛，新的问题又来了，这个国内的网站有吗？还真有，阿里提供了一个，下面问题就简单了，网址告诉我们就OK了，没错，就是这样\n1、创建工程时切换选择starter服务路径，然后手工收入阿里云提供给我们的使用地址即可。地址：http://start.aliyun.com或https://start.aliyun.com\n\n阿里为了便于自己开发使用，因此在依赖坐标中添加了一些阿里相关的技术，也是为了推广自己的技术吧，所以在依赖选择列表中，你有了更多的选择。不过有一点需要说清楚，阿里云地址如果你想更换其他的版本，创建项目后手工修改即可，别忘了刷新一下，加载新版本信息\n\n2、注意：阿里云提供的工程创建地址初始化完毕后和实用SpringBoot官网创建出来的工程略有区别。主要是在配置文件的形式上有区别。这个信息在后面讲解Boot程序的执行流程时给大家揭晓\n3、总结\n选择start来源为自定义URL\n输入阿里云start地址\n创建项目\n\n4、思考​\t做到这里我们已经有了三种方式创建SpringBoot工程，但是每种方式都要求你必须能上网才能创建工程。假如有一天，你加入了一个保密级别比较高的项目组，整个项目组没有外网，整个事情是不是就不能做了呢？\n","tags":["SpringBoot"]},{"title":"SpringBoot基础篇之基础配置","url":"/2022/06/10/SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/","content":"如果我们想修改默认的配置，这个信息应该写在什么位置呢？目前我们接触的入门案例中一共有3个文件，第一是pom.xml文件，设置项目的依赖的，这个没什么好研究的，相关的高级内容咱们到原理篇再说，第二是引导类，这个是执行SpringBoot程序的入口，也不像是做配置的地方，其实还有一个信息，就是在resources目录下面有一个空白的文件，叫做application.properties。一看就是个配置文件，咱们这一章就来说说配置文件怎么写，能写什么，怎么干预SpringBoot的默认配置，修改成自己的配置。\n\n1、属性配置SpringBoot通过配置文件application.properties就可以修改默认的配置，那咱们就先找个简单的配置下手，当前访问tomcat的默认端口是8080，好熟悉的味道，但是不便于书写，我们先改成80，通过这个操作来熟悉一下SpringBoot的配置格式是什么样的\n\n那该如何写呢？properties格式的文件书写规范是key&#x3D;value\nname=itheima\n\n​\t这个格式肯定是不能颠覆的，那就尝试性的写就行了，改端口，写port。\nserver.port=80\n\n下面就可以直接运行程序，测试效果了。\n​\t其实到这里我们应该得到如下三个信息\n\nSpringBoot程序可以在application.properties文件中进行属性配置\napplication.properties文件中只要输入要配置的属性关键字就可以根据提示进行设置\nSpringBoot将配置信息集中在一个文件中写，不管你是服务器的配置，还是数据库的配置，总之都写在一起，逃离一个项目十几种配置文件格式的尴尬局面\n\n总结\nSpringBoot默认配置文件是application.properties\n\n\n​\t做完了端口的配置，趁热打铁，再做几个配置，目前项目启动时会显示一些日志信息，就来改一改这里面的一些设置。\n关闭运行日志图表（banner)\nspring.main.banner-mode=off\n\n设置运行日志的显示级别\nlogging.level.root=debug\n\n我们现在配置了3个信息，但是又有新的问题了。这个配置是随便写的吗？什么都能配？有没有一个东西显示所有能配置的项呢？此外这个配置和什么东西有关呢？会不会因为我写了什么东西以后才可以写什么配置呢？比如我现在没有写数据库相关的东西，能否配置数据呢？一个一个来，先说第一个问题，都能配置什么。\n​\t打开SpringBoot的官网，找到SpringBoot官方文档，打开查看附录中的Application Properties就可以获取到对应的配置项了，网址奉上：https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties\n​\t能写什么的问题解决了，再来说第二个问题，这个配置项和什么有关。在pom中注释掉导入的spring-boot-starter-web，然后刷新工程，你会发现配置的提示消失了。闹了半天是设定使用了什么技术才能做什么配置。也合理，不然配置的东西都没有使用对应技术，配了也是白配。\n温馨提示\n所有的starter中都会依赖下面这个starter，叫做spring-boot-starter。这个starter是所有的SpringBoot的starter的基础依赖，里面定义了SpringBoot相关的基础配置，关于这个starter我们到开发应用篇和原理篇中再深入讲解。\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.5.4&lt;/version&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;\n\n总结\n\nSpringBoot中导入对应starter后，提供对应配置属性\n书写SpringBoot配置采用关键字+提示形式书写\n\n2、配置文件分类现在已经能够进行SpringBoot相关的配置了，但是properties格式的配置写起来总是觉得看着不舒服，所以就期望存在一种书写起来更简便的配置格式提供给开发者使用。SpringBoot除了支持properties格式的配置文件，还支持另外两种格式的配置文件。分别如下:\n\nproperties格式\n\nyml格式\n\nyaml格式\n\napplication.properties（properties格式）\n\n\nserver.port=80\n\n\napplication.yml（yml格式）\n\nserver:  port: 81\n\n\napplication.yaml（yaml格式）\n\nserver:  port: 82\n\n仔细看会发现yml格式和yaml格式除了文件名后缀不一样，格式完全一样，是这样的，yml和yaml文件格式就是一模一样的，只是文件后缀不同，所以可以合并成一种格式来看。以后基本上都是用yml格式的.\n总结\nSpringBoot提供了3种配置文件的格式\nproperties（传统格式&#x2F;默认格式）\nyml（主流格式）\nyaml\n\n\n\n思考​\t现在我们已经知道使用三种格式都可以做配置了万一我三个都写了，他们三个谁说了算呢？\n3、配置文件优先级每个配置文件中的项都会生效，只不过如果多个配置文件中有相同类型的配置会优先级高的文件覆盖优先级的文件中的配置。如果配置项不同的话，那所有的配置项都会生效。\n总结\n配置文件间的加载优先级\tproperties（最高）&gt;  yml  &gt;  yaml（最低）\n不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留\n\n4、自动提示功能消失解决方案可能有些小伙伴会基于各种各样的原因导致配置文件中没有提示，这个确实很让人头疼，所以下面给大家说一下如果自动提示功能消失了怎么解决。\n​\t先要明确一个核心，就是自动提示功能不是SpringBoot技术给我们提供的，是我们在Idea工具下编程，这个编程工具给我们提供的。明白了这一点后，再来说为什么会出现这种现象。其实这个自动提示功能消失的原因还是蛮多的，如果想解决这个问题，就要知道为什么会消失，大体原因有如下3种：\n\nIdea认为你现在写配置的文件不是个配置文件，所以拒绝给你提供提示功能\n\nIdea认定你是合理的配置文件，但是Idea加载不到对应的提示信息\n这里我们主要解决第一个现象，第二种现象到原理篇再讲解。第一种现象的解决方式如下：\n\n\n步骤①：打开设置，【Files】→【Project Structure…】\n\n步骤②：在弹出窗口中左侧选择【Facets】，右侧选中Spring路径下对应的模块名称，也就是你自动提示功能消失的那个模块\n\n\n步骤③：点击Customize Spring Boot按钮，此时可以看到当前模块对应的配置文件是哪些了。如果没有你想要称为配置文件的文件格式，就有可能无法弹出提示\n\n\n\n步骤④：选择添加配置文件，然后选中要作为配置文件的具体文件就OK了\n\n总结\n指定SpringBoot配置文件\n\nSetting → Project Structure → Facets\n选中对应项目&#x2F;工程\nCustomize Spring Boot\n选择配置文件\n\n\n\n5、yaml数据格式SpringBoot的配置以后主要使用yml结尾的这种文件格式，并且在书写时可以通过提示的形式加载正确的格式。但是这种文件还是有严格的书写格式要求的。下面就来说一下具体的语法格式。\n​\tYAML（YAML Ain’t Markup Language），一种数据序列化格式。具有容易阅读、容易与脚本语言交互、以数据为核心，重数据轻格式的特点。常见的文件扩展名有两种：\n\n.yml格式（主流）\n\n.yaml格式\n 对于文件自身在书写时，具有严格的语法格式要求，具体如下：\n\n\n\n大小写敏感\n属性层级关系使用多行描述，每行结尾使用冒号结束\n使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）\n属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）\n#号 表示注释\n\n  上述规则不要死记硬背，按照书写习惯慢慢适应，并且在Idea下由于具有提示功能，慢慢适应着写格式就行了。核心的一条规则要记住，数据前面要加空格与冒号隔开\n​\t下面列出常见的数据书写格式，熟悉一下\nboolean: TRUE  \t\t\t\t\t\t#TRUE,true,True,FALSE,false，False均可float: 3.14    \t\t\t\t\t\t#6.8523015e+5  #支持科学计数法int: 123       \t\t\t\t\t\t#0b1010_0111_0100_1010_1110    #支持二进制、八进制、十六进制null: ~        \t\t\t\t\t\t#使用~表示nullstring: HelloWorld      \t\t\t#字符串可以直接书写string2: &quot;Hello World&quot;  \t\t\t#可以使用双引号包裹特殊字符date: 2018-02-17        \t\t\t#日期必须使用yyyy-MM-dd格式datetime: 2018-02-17T15:02:31+08:00  #时间和日期之间使用T连接，最后使用+代表时区\n\n此外，yaml格式中也可以表示数组，在属性名书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔\nsubject:\t- Java\t- 前端\t- 大数据enterprise:\tname: itcast    age: 16    subject:    \t- Java        - 前端        - 大数据likes: [王者荣耀,刺激战场]\t\t\t#数组书写缩略格式users:\t\t\t\t\t\t\t #对象数组格式一  - name: Tom   \tage: 4  - name: Jerry    age: 5users:\t\t\t\t\t\t\t #对象数组格式二  -      name: Tom    age: 4  -       name: Jerry    age: 5\t\t\t    users2: [ &#123; name:Tom , age:4 &#125; , &#123; name:Jerry , age:5 &#125; ]\t#对象数组缩略格式\n\n总结\nyaml语法规则\n大小写敏感\n属性层级关系使用多行描述，每行结尾使用冒号结束\n使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）\n属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）\n#号 表示注释\n\n\n注意属性名冒号后面与数据之间有一个空格\n字面值、对象数据格式、数组数据格式\n\n思考​\t现在我们已经知道了yaml具有严格的数据格式要求，并且已经可以正确的书写yaml文件了，那这些文件书写后其实是在定义一些数据。这些数据时给谁用的呢？大部分是SpringBoot框架内部使用，但是如果我们想配置一些数据自己使用，能不能用呢？答案是可以的，那如何读取yaml文件中的数据呢？\n6、yaml数据读取1.读取单一数据yaml中保存的单个数据，可以使用Spring中的注解直接读取，使用@Value可以读取单个数据，属性名引用方式：${一级属性名.二级属性名……}\n\n​\t记得使用@Value注解时，要将该注入写在某一个指定的Spring管控的bean的属性名上方。现在就可以读取到对应的单一数据行了\n2.yaml文件中的数据引用​\t如果你在书写yaml数据时，经常出现如下现象，比如很多个文件都具有相同的目录前缀\ncenter:\tdataDir: /usr/local/fire/data    tmpDir: /usr/local/fire/tmp    logDir: /usr/local/fire/log    msgDir: /usr/local/fire/msgDir\n\n​\t这个时候你可以使用引用格式来定义数据，其实就是搞了个变量名，然后引用变量了，格式如下：\nbaseDir: /usr/local/fire\tcenter:    dataDir: $&#123;baseDir&#125;/data    tmpDir: $&#123;baseDir&#125;/tmp    logDir: $&#123;baseDir&#125;/log    msgDir: $&#123;baseDir&#125;/msgDir\n\n​\t还有一个注意事项，在书写字符串时，如果需要使用转义字符，需要将数据字符串使用双引号包裹起来\nlesson: &quot;Spring\\tboot\\nlesson&quot;\n\n总结\n在配置文件中可以使用${属性名}方式引用属性值\n如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析\n\n3.读取全部数据​\t读取单一数据可以解决读取数据的问题，但是如果定义的数据量过大，这么一个一个书写肯定会累死人的，SpringBoot提供了一个对象，能够把所有的数据都封装到这一个对象中，这个对象叫做Environment，使用自动装配注解可以将所有的yaml数据封装到这个对象中\n\n​\t数据封装到了Environment对象中，获取属性时，通过Environment的接口操作进行，具体方法时getProperties（String），参数填写属性名即可\n总结\n使用Environment对象封装全部配置信息\n使用@Autowired自动装配数据到Environment对象中\n\n4.读取对象数据单一数据读取书写比较繁琐，全数据封装又封装的太厉害了，每次拿数据还要一个一个的getProperties（）,总之用起来都不是很舒服。由于Java是一个面向对象的语言，很多情况下，我们会将一组数据封装成一个对象。SpringBoot也提供了可以将一组yaml对象数据封装一个Java对象的操作\n​\t首先定义一个对象，并将该对象纳入Spring管控的范围，也就是定义成一个bean，然后使用注解@ConfigurationProperties指定该对象加载哪一组yaml中配置的信息。\n\n​\t这个@ConfigurationProperties必须告诉他加载的数据前缀是什么，这样当前前缀下的所有属性就封装到这个对象中。记得数据属性名要与对象的变量名一一对应啊，不然没法封装。其实以后如果你要定义一组数据自己使用，就可以先写一个对象，然后定义好属性，下面到配置中根据这个格式书写即可。\n\n总结\n使用@ConfigurationProperties注解绑定配置信息到封装类中\n封装类需要定义为Spring管理的bean，否则无法进行属性注入\n\n","tags":["SpringBoot"]},{"title":"SpringBoot基础篇之整合Druid","url":"/2022/06/11/SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88Druid/","content":"​\t使用SpringBoot整合了3个技术了，发现套路基本相同，导入对应的starter，然后做配置，各位小伙伴需要一直强化这套思想。下面再整合一个技术，继续深入强化此思想。\n​\t前面整合MyBatis和MP的时候，使用的数据源对象都是SpringBoot默认的数据源对象，下面我们手工控制一下，自己指定了一个数据源对象，Druid。\n​\t在没有指定数据源时，我们的配置如下：\n#2.配置相关信息spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai    username: root    password: root\n\n​\t此时虽然没有指定数据源，但是根据SpringBoot的德行，肯定帮我们选了一个它认为最好的数据源对象，这就是HiKari。通过启动日志可以查看到对应的身影。\n2021-11-29 09:39:15.202  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...2021-11-29 09:39:15.208  WARN 12260 --- [           main] com.zaxxer.hikari.util.DriverDataSource  : Registered driver with driverClassName=com.mysql.jdbc.Driver was not found, trying direct instantiation.2021-11-29 09:39:15.551  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n\n​\t上述信息中每一行都有HiKari的身影，如果需要更换数据源，其实只需要两步即可。\n\n导入对应的技术坐标\n配置使用指定的数据源类型\n\n​    下面就切换一下数据源对象\n步骤①：导入对应的坐标（注意，是坐标，此处不是starter）\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.1.16&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n步骤②：修改配置，在数据源配置中有一个type属性，专用于指定数据源类型\nspring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    username: root    password: root    type: com.alibaba.druid.pool.DruidDataSource\n\n​\t这里其实要提出一个问题的，目前的数据源配置格式是一个通用格式，不管你换什么数据源都可以用这种形式进行配置。但是新的问题又来了，如果对数据源进行个性化的配置，例如配置数据源对应的连接数量，这个时候就有新的问题了。每个数据源技术对应的配置名称都一样吗？肯定不是啊，各个厂商不可能提前商量好都写一样的名字啊，怎么办？就要使用专用的配置格式了。这个时候上面这种通用格式就不能使用了，怎么办？还能怎么办？按照SpringBoot整合其他技术的通用规则来套啊，导入对应的starter，进行相应的配置即可。\n步骤①：导入对应的starter\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.2.6&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n步骤②：修改配置\nspring:  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC      username: root      password: root\n\n​\t注意观察，配置项中，在datasource下面并不是直接配置url这些属性的，而是先配置了一个druid节点，然后再配置的url这些东西。言外之意，url这个属性时druid下面的属性，那你能想到吗？除了这4个常规配置外，还有druid专用的其他配置。通过提示功能可以打开druid相关的配置查阅\n\n​\t与druid相关的配置超过200条以上，这就告诉你，如果想做druid相关的配置，使用这种格式就可以了，这里就不展开描述了，太多了。\n​\t这是我们做的第4个技术的整合方案，还是那两句话：导入对应starter，使用对应配置。没了，SpringBoot整合其他技术就这么简单粗暴。\n总结\n\n整合Druid需要导入Druid对应的starter\n根据Druid提供的配置方式进行配置\n整合第三方技术通用方式\n导入对应的starter\n根据提供的配置格式，配置非默认值对应的配置项\n\n\n\n","tags":["SpringBoot"]},{"title":"SpringBoot基础篇之整合JUnit","url":"/2022/06/11/SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88JUnit/","content":"​\t\tSpringBoot技术的定位用于简化开发，再具体点是简化Spring程序的开发。所以在整合任意技术的时候，如果你想直观感触到简化的效果，你必须先知道使用非SpringBoot技术时对应的整合是如何做的，然后再看基于SpringBoot的整合是如何做的，才能比对出来简化在了哪里。\n​\t我们先来看一下不使用SpringBoot技术时，Spring整合JUnit的制作方式\n//加载spring整合junit专用的类运行器@RunWith(SpringJUnit4ClassRunner.class)//指定对应的配置信息@ContextConfiguration(classes = SpringConfig.class)public class AccountServiceTestCase &#123;    //注入你要测试的对象    @Autowired    private AccountService accountService;    @Test    public void testGetById()&#123;        //执行要测试的对象对应的方法        System.out.println(accountService.findById(2));    &#125;&#125;\n\n​\t其中核心代码是前两个注解，第一个注解@RunWith是设置Spring专用于测试的类运行器，简单说就是Spring程序执行程序有自己的一套独立的运行程序的方式，不能使用JUnit提供的类运行方式了，必须指定一下，但是格式是固定的，琢磨一下，每次都指定一样的东西，这个东西写起来没有技术含量啊，第二个注解@ContextConfiguration是用来设置Spring核心配置文件或配置类的，简单说就是加载Spring的环境你要告诉Spring具体的环境配置是在哪里写的，虽然每次加载的文件都有可能不同，但是仔细想想，如果文件名是固定的，这个貌似也是一个固定格式。似然有可能是固定格式，那就有可能每次都写一样的东西，也是一个没有技术含量的内容书写\n​\tSpringBoot就抓住上述两条没有技术含量的内容书写进行开发简化，能走默认值的走默认值，能不写的就不写，具体格式如下\n@SpringBootTestclass Springboot04JunitApplicationTests &#123;    //注入你要测试的对象    @Autowired    private BookDao bookDao;    @Test    void contextLoads() &#123;        //执行要测试的对象对应的方法        bookDao.save();        System.out.println(&quot;two...&quot;);    &#125;&#125;\n\n​\t看看这次简化成什么样了，一个注解就搞定了，而且还没有参数，再体会SpringBoot整合其他技术的优势在哪里，就两个字——简化。使用一个注解@SpringBootTest替换了前面两个注解。至于内部是怎么回事？和之前一样，只不过都走默认值。\n​\t这个时候有人就问了，你加载的配置类或者配置文件是哪一个？就是我们前面启动程序使用的&#x3D;&#x3D;引导类&#x3D;&#x3D;。如果想手工指定引导类有两种方式，第一种方式使用属性的形式进行，在注解@SpringBootTest中添加classes属性指定配置类\n@SpringBootTest(classes = Springboot04JunitApplication.class)class Springboot04JunitApplicationTests &#123;    //注入你要测试的对象    @Autowired    private BookDao bookDao;    @Test    void contextLoads() &#123;        //执行要测试的对象对应的方法        bookDao.save();        System.out.println(&quot;two...&quot;);    &#125;&#125;\n\n​\t第二种方式回归原始配置方式，仍然使用@ContextConfiguration注解进行，效果是一样的\n@SpringBootTest@ContextConfiguration(classes = Springboot04JunitApplication.class)class Springboot04JunitApplicationTests &#123;    //注入你要测试的对象    @Autowired    private BookDao bookDao;    @Test    void contextLoads() &#123;        //执行要测试的对象对应的方法        bookDao.save();        System.out.println(&quot;two...&quot;);    &#125;&#125;\n\n总结\n导入测试对应的starter\n测试类使用@SpringBootTest修饰\n使用自动装配的形式添加要测试的对象\n测试类如果存在于引导类所在包或子包中无需指定引导类\n测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类\n\n","tags":["SpringBoot"]},{"title":"SpringBoot基础篇之整合MyBatis","url":"/2022/06/11/SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88MyBatis/","content":"1、spring整合\n导入坐标，MyBatis坐标不能少，Spring整合MyBatis还有自己专用的坐标，此外Spring进行数据库操作的jdbc坐标是必须的，剩下还有mysql驱动坐标，本例中使用了Druid数据源，这个倒是可以不要\n\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.1.16&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.47&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--1.导入mybatis与spring整合的jar包--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;        &lt;version&gt;1.3.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--导入spring操作数据库必选的包--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\nSpring核心配置\n\n@Configuration@ComponentScan(&quot;com.itheima&quot;)@PropertySource(&quot;jdbc.properties&quot;)public class SpringConfig &#123;&#125;\n\n\nMyBatis要交给Spring接管的bean\n\n//定义mybatis专用的配置类@Configurationpublic class MyBatisConfig &#123;//    定义创建SqlSessionFactory对应的bean    @Bean    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123;        //SqlSessionFactoryBean是由mybatis-spring包提供的，专用于整合用的对象        SqlSessionFactoryBean sfb = new SqlSessionFactoryBean();        //设置数据源替代原始配置中的environments的配置        sfb.setDataSource(dataSource);        //设置类型别名替代原始配置中的typeAliases的配置        sfb.setTypeAliasesPackage(&quot;com.itheima.domain&quot;);        return sfb;    &#125;//    定义加载所有的映射配置    @Bean    public MapperScannerConfigurer mapperScannerConfigurer()&#123;        MapperScannerConfigurer msc = new MapperScannerConfigurer();        msc.setBasePackage(&quot;com.itheima.dao&quot;);        return msc;    &#125;&#125;\n\n\n数据源对应的bean，此处使用Druid数据源\n\n@Configurationpublic class JdbcConfig &#123;    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)    private String driver;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    private String url;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    private String userName;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    private String password;    @Bean(&quot;dataSource&quot;)    public DataSource dataSource()&#123;        DruidDataSource ds = new DruidDataSource();        ds.setDriverClassName(driver);        ds.setUrl(url);        ds.setUsername(userName);        ds.setPassword(password);        return ds;    &#125;&#125;\n\n\n数据库连接信息（properties格式）\n\njdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=falsejdbc.username=rootjdbc.password=root\n\n  上述格式基本上是简格式了，要写的东西还真不少。\n2、SpringBoot整合创建模块时勾选要使用的技术，MyBatis，由于要操作数据库，还要勾选对应数据库\n\n\n或者手工导入对应技术的starter，和对应数据库的坐标\n&lt;dependencies&gt;    &lt;!--1.导入对应的starter--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;2.2.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n步骤②：配置数据源相关信息，没有这个信息你连接哪个数据库都不知道\n#2.配置相关信息spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db    username: root    password: root\n\n​\t完了，就这么多，没了。有人就很纳闷，这就结束了？对，这就结束了，SpringBoot把配置中所有可能出现的通用配置都简化了。下面就可以写一下MyBatis程序运行需要的Dao（或者Mapper）就可以运行了\n实体类public class Book &#123;        private Integer id;        private String type;        private String name;       private String description;&#125;\n\n映射接口（Dao）@Mapperpublic interface BookDao &#123;    @Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)    public Book getById(Integer id);&#125;\n\n测试类@SpringBootTestclass Springboot05MybatisApplicationTests &#123;    @Autowired    private BookDao bookDao;    @Test    void contextLoads() &#123;        System.out.println(bookDao.getById(1));    &#125;&#125;\n\n3、常见问题处理​\t注意：当前使用的SpringBoot版本是2.5.4，对应的坐标设置中Mysql驱动使用的是8x版本。当SpringBoot2.4.3（不含）版本之前会出现一个小BUG，就是MySQL驱动升级到8以后要求强制配置时区，如果不设置会出问题。解决方案很简单，驱动url上面添加上对应设置就行了\n#2.配置相关信息spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    username: root    password: root\n\n这里设置的UTC是全球标准时间，你也可以理解为是英国时间，中国处在东八区，需要在这个基础上加上8小时，这样才能和中国地区的时间对应的，也可以修改配置不写UTC，写Asia&#x2F;Shanghai也可以解决这个问题。\n​\t如果不想每次都设置这个东西，也可以去修改mysql中的配置文件mysql.ini，在mysqld项中添加default-time-zone&#x3D;+8:00也可以解决这个问题。其实方式方法很多，这里就说这么多吧。\n此外在运行程序时还会给出一个提示，说数据库驱动过时的警告，根据提示修改配置即可，弃用com.mysql.jdbc.Driver，换用com.mysql.cj.jdbc.Driver。前面的例子中已经更换了驱动了，在此说明一下。\n4、总结\n整合操作需要勾选MyBatis技术，也就是导入MyBatis对应的starter\n\n数据库连接相关信息转换成配置\n\n数据库SQL映射需要添加@Mapper被容器识别到\n\nMySQL 8.X驱动强制要求设置时区\n\n修改url，添加serverTimezone设定\n修改MySQL数据库配置\n\n\n驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver\n\n\n","tags":["SpringBoot"]},{"title":"SpringBoot基础篇之整合MyBatisPlus","url":"/2022/06/11/SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88MyBatisPlus/","content":"​\t做完了两种技术的整合了，我们做这个整合究竟哪些是核心？总结下来就两句话\n\n导入对应技术的starter坐标\n根据对应技术的要求做配置\n\n​\t接下来在MyBatis的基础上再升级一下，整合MyBaitsPlus\n步骤①：导入对应的starter\n&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt;\n\n​\t关于这个坐标，此处要说明一点，之前我们看的starter都是spring-boot-starter-？？？，也就是说都是下面的格式\nSpring-boot-start-***\n\n​\t而这个坐标的名字书写比较特殊，是第三方技术名称在前，boot和starter在后。此处简单提一下命名规范\n\n\n\nstarter所属\n命名规则\n示例\n\n\n\n官方提供\nspring-boot-starter-技术名称\nspring-boot-starter-web spring-boot-starter-test\n\n\n第三方提供\n第三方技术名称-spring-boot-starter\ndruid-spring-boot-starter\n\n\n第三方提供\n第三方技术名称-boot-starter（第三方技术名称过长，简化命名）\nmybatis-plus-boot-starter\n\n\n温馨提示\n​\t有些小伙伴在创建项目时想通过勾选的形式找到这个名字，别翻了，没有。截止目前，SpringBoot官网还未收录此坐标，而我们Idea创建模块时读取的是SpringBoot官网的Spring Initializr，所以也没有。如果换用阿里云的url创建项目可以找到对应的坐标\n步骤②：配置数据源相关信息\n#2.配置相关信息spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db    username: root    password: root\n\n映射接口（Dao）\n@Mapperpublic interface BookDao extends BaseMapper&lt;Book&gt; &#123;&#125;\n\n​\t核心在于Dao接口继承了一个BaseMapper的接口，这个接口中帮助开发者预定了若干个常用的API接口，简化了通用API接口的开发工作。\n温馨提示\n​\t目前数据库的表名定义规则是tbl_模块名称，为了能和实体类相对应，需要做一个配置，配置application.yml文件，添加如下配置即可，设置所有表名的通用前缀名\nmybatis-plus:  global-config:    db-config:      table-prefix: tbl_\t\t#设置所有表的通用前缀名称为tbl_\n\n总结\n\n手工添加MyBatis-Plus对应的starter\n数据层接口使用BaseMapper简化开发\n需要使用的第三方技术无法通过勾选确定时，需要手工添加坐标\n\n","tags":["SpringBoot"]},{"title":"SpringBoot基础篇之隐藏文件或文件夹","url":"/2022/06/08/SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9/","content":"创建SpringBoot工程时，使用SpringBoot向导也好，阿里云也罢，其实都是为了一个目的，得到一个标准的SpringBoot工程文件结构。这个时候就有新的问题出现了，标准的工程结构中包含了一些未知的文件夹，在开发的时候看起来特别别扭，这一节就来说说这些文件怎么处理。\n​\t处理方案无外乎两种，如果你对每一个文件&#x2F;目录足够了解，没有用的完全可以删除掉，或者不删除，但是看着别扭，就设置文件为看不到就行了。删除不说了，直接Delete掉就好了，这一节说说如何隐藏指定的文件或文件夹信息。\n​\t既然是在Idea下做隐藏功能，肯定隶属于Idea的设置，设置方式如下。\n\n步骤①：打开设置，【Files】→【Settings】→【Editor】→【File Types】→【Ignored Files and Folders】，忽略文件或文件夹显示\n\n步骤②：添加你要隐藏的文件名称或文件夹名称，可以使用*号通配符，表示任意，设置完毕即可\n总结：\nIdea中隐藏指定文件或指定类型文件\n【Files】→【Settings】\n【Editor】→【File Types】→【Ignored Files and Folders】\n输入要隐藏的名称，支持*号通配符\n回车确认添加\n\n\n\n","tags":["SpringBoot"]},{"title":"SpringBoot运维实用篇之Boot工程快速启动（Linux版）","url":"/2022/06/14/SpringBoot%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BBoot%E5%B7%A5%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%EF%BC%88Linux%E7%89%88%EF%BC%89/","content":"​\t\t其实对于Linux系统下的程序运行与Windows系统下的程序运行差别不大，命令还是那组命令，只不过各位小伙伴可能对Linux指令不太熟悉，结果就会导致各种各样的问题发生。比如防火墙如何关闭，IP地址如何查询，JDK如何安装等等。\n","tags":["SpringBoot"]},{"title":"SpringBoot运维实用篇之SpringBoot程序打包失败处理","url":"/2022/06/13/SpringBoot%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BSpringBoot%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86/","content":"​\t有些小伙伴打包以后执行会出现一些问题，导致程序无法正常执行，例如下面的现象\n\n​\t\t要想搞清楚这个问题就要说说.jar文件的工作机制了，知道了这个东西就知道如何避免此类问题的发生了。\n​\t\t搞java开发平时会接触很多jar包，比如mysql的驱动jar包，而上面我们打包程序后得到的也是一个jar文件。这个时候如果你使用上面的java -jar指令去执行mysql的驱动jar包就会出现上述不可执行的现象，而我们的SpringBoot项目为什么能执行呢？其实是因为打包方式不一样。\n​\t\t在SpringBoot工程的pom.xml中有下面这组配置，这组配置决定了打包出来的程序包是否可以执行。\n&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n\n​\t我们分别开启这段配置和注释掉这段配置分别执行两次打包，然后观察两次打包后的程序包的差别，共有3处比较明显的特征\n\n打包后文件的大小不同\n打包后所包含的内容不同\n打包程序中个别文件内容不同\n\n​\t\t先看第一个现象，文件大小不同。带有配置时打包生成的程序包大小如下：\n\n​\t\t不难看出，带有配置的程序包体积比不带配置的大了30倍，那这里面都有什么呢？能差这么多？下面看看里面的内容有什么区别。\n\n\n​\t我们发现内容也完全不一样，仅有一个目录是一样的，叫做META-INF。打开容量大的程序包中的BOOT-INF目录下的classes目录，我们发现其中的内容居然和容量小的程序包中的内容完全一样。\n\n\n​\t原来大的程序包中除了包含小的程序包中的内容，还有别的东西。都有什么呢？回到BOOT-INF目录下，打开lib目录，里面显示了很多个jar文件。\n\n​\t\t仔细翻阅不难发现，这些jar文件都是我们制作这个工程时导入的坐标对应的文件。大概可以想明白了，SpringBoot程序为了让自己打包生成的程序可以独立运行，不仅将项目中自己开发的内容进行了打包，还把当前工程运行需要使用的jar包全部打包进来了。为什么这样做呢？就是为了可以独立运行。不依赖程序包外部的任何资源可以独立运行当前程序。这也是为什么大的程序包容量是小的程序包容量的30倍的主要原因。\n​\t\t再看看大程序包还有什么不同之处，在最外层目录包含一个org目录，进入此目录，目录名是org\\springframework\\boot\\loader，在里面可以找到一个JarLauncher.class的文件，先记得这个文件。再看这套目录名，明显是一个Spring的目录名，为什么要把Spring框架的东西打包到这个程序包中呢？不清楚。\n​\t\t回到两个程序包的最外层目录，查看名称相同的文件夹META-INF下都有一个叫做MANIFEST.MF的文件，但是大小不同，打开文件，比较内容区别\n\n小容量文件的MANIFEST.MF\n\nManifest-Version: 1.0Implementation-Title: springboot_08_ssmpImplementation-Version: 0.0.1-SNAPSHOTBuild-Jdk-Spec: 1.8Created-By: Maven Jar Plugin 3.2.0\n\n\n大容量文件的MANIFEST.MF\n\nManifest-Version: 1.0Spring-Boot-Classpath-Index: BOOT-INF/classpath.idxImplementation-Title: springboot_08_ssmpImplementation-Version: 0.0.1-SNAPSHOTSpring-Boot-Layers-Index: BOOT-INF/layers.idxStart-Class: com.itheima.SSMPApplicationSpring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Build-Jdk-Spec: 1.8Spring-Boot-Version: 2.5.4Created-By: Maven Jar Plugin 3.2.0Main-Class: org.springframework.boot.loader.JarLauncher\n\n​\t\t大文件中明显比小文件中多了几行信息，其中最后一行信息是Main-Class: org.springframework.boot.loader.JarLauncher。这句话什么意思呢？如果使用java -jar执行此程序包，将执行Main-Class属性配置的类，这个类恰巧就是前面看到的那个文件。原来SpringBoot打包程序中出现Spring框架的东西是为这里服务的。而这个org.springframework.boot.loader.JarLauncher类内部要查找Start-Class属性中配置的类，并执行对应的类。这个属性在当前配置中也存在，对应的就是我们的引导类类名。\n​\t现在这组设定的作用就搞清楚了\n\nSpringBoot程序添加配置后会打出一个特殊的包，包含Spring框架部分功能，原始工程内容，原始工程依赖的jar包\n首先读取MANIFEST.MF文件中的Main-Class属性，用来标记执行java -jar命令后运行的类\nJarLauncher类执行时会找到Start-Class属性，也就是启动类类名\n运行启动类时会运行当前工程的内容\n运行当前工程时会使用依赖的jar包，从lib目录中查找\n\n​\t\t看来SpringBoot打出来了包为了能够独立运行，简直是煞费苦心，将所有需要使用的资源全部都添加到了这个包里。这就是为什么这个jar包能独立运行的原因。\n​\t\t再来看之前的报错信息：\n\n​\t由于打包时没有使用那段配置，结果打包后形成了一个普通的jar包，在MANIFEST.MF文件中也就没有了Main-Class对应的属性了，所以运行时提示找不到主清单属性，这就是报错的原因。\n总结\nspring-boot-maven-plugin插件用于将当前程序打包成一个可以独立运行的程序包\n\n","tags":["SpringBoot"]},{"title":"SpringBoot运维实用篇之多环境开发","url":"/2022/06/14/SpringBoot%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91/","content":"​\t\t什么是多环境？其实就是说你的电脑上写的程序最终要放到别人的服务器上去运行。每个计算机环境不一样，这就是多环境。常见的多环境开发主要兼顾3种环境设置，开发环境——自己用的，测试环境——自己公司用的，生产环境——甲方爸爸用的。因为这是绝对不同的三台电脑，所以环境肯定有所不同，比如连接的数据库不一样，设置的访问端口不一样等等。\n\n1、多环境开发（yaml单一文件版）​\t那什么是多环境开发？就是针对不同的环境设置不同的配置属性即可。比如你自己开发时，配置你的端口如下：\nserver:  port: 80\n\n​\t\t如何想设计两组环境呢？中间使用三个减号分隔开\nserver:  port: 80---server:  port: 81\n\n​\t\t如何区分两种环境呢？\nspring:\tprofiles: proserver:\tport: 80---spring:\tprofiles: devserver:\tport: 81\n\n​\t\t那用哪一个呢？设置默认启动哪个就可以了\nspring:\tprofiles:\t\tactive: pro\t\t# 启动pro---spring:\tprofiles: proserver:\tport: 80---spring:\tprofiles: devserver:\tport: 81\n\n​\t\t其中关于环境名称定义上述格式是过时格式，标准格式如下\nspring:\tconfig:    \tactivate:        \ton-profile: pro\n\n总结\n多环境开发需要设置若干种常用环境，例如开发、生产、测试环境\nyaml格式中设置多环境使用—区分环境设置边界\n每种环境的区别在于加载的配置属性不同\n启用某种环境时需要指定启动时使用该环境\n\n2、多环境开发（yaml多文件版）​\t\t将所有的配置都放在一个配置文件中，尤其是每一个配置应用场景都不一样，这显然不合理，于是就有了将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好了。\n主配置文件\nspring:\tprofiles:\t\tactive: pro\t\t# 启动pro\n\n环境配置文件\nserver:\tport: 80\n\n​\t\t环境配置文件因为每一个都是配置自己的项，所以连名字都不用写里面了。那问题是如何区分这是哪一组配置呢？使用文件名区分。\napplication-pro.yaml\nserver:\tport: 80\n\napplication-dev.yaml\nserver:\tport: 81\n\n​\t\t文件的命名规则为：application-环境名.yml。\n​\t\t在配置文件中，如果某些配置项所有环境都一样，可以将这些项写入到主配置中，只有哪些有区别的项才写入到环境配置文件中。\n\n主配置文件中设置公共配置（全局）\n环境分类配置文件中常用于设置冲突属性（局部）\n\n总结\n可以使用独立配置文件定义环境属性\n独立配置文件便于线上系统维护更新并保障系统安全性\n\n3、多环境开发（properties多文件版）​\t\tSpringBoot最早期提供的配置文件格式是properties格式的，这种格式的多环境配置也了解一下吧。\n主配置文件\nspring.profiles.active=pro\n\n环境配置文件\napplication-pro.properties\nserver.port=80\n\napplication-dev.properties\nserver.port=81\n\n​\t\t文件的命名规则为：application-环境名.properties。\n总结\nproperties文件多环境配置仅支持多文件格式\n\n4、多环境开发独立配置文件书写技巧​\t\t作为程序员在搞配置的时候往往处于一种分久必合合久必分的局面。开始先写一起，后来为了方便维护就拆分。对于多环境开发也是如此，下面给大家说一下如何基于多环境开发做配置独立管理，务必掌握。\n准备工作\n​\t\t将所有的配置根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下\n\napplication-devDB.yml\napplication-devRedis.yml\napplication-devMVC.yml\n\n使用\n​\t\t使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔\nspring:\tprofiles:    \tactive: dev        include: devDB,devRedis,devMVC\n\n​\t\t比较一下，现在相当于加载dev配置时，再加载对应的3组配置，从结构上就很清晰，用了什么，对应的名称是什么\n注意\n​\t\t当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效\n改良\n​\t\t但是上面的设置也有一个问题，比如我要切换dev环境为pro时，include也要修改。因为include属性只能使用一次，这就比较麻烦了。SpringBoot从2.4版开始使用group属性替代include属性，降低了配置书写量。简单说就是我先写好，你爱用哪个用哪个。\nspring:\tprofiles:    \tactive: dev        group:        \t&quot;dev&quot;: devDB,devRedis,devMVC      \t\t&quot;pro&quot;: proDB,proRedis,proMVC      \t\t&quot;test&quot;: testDB,testRedis,testMVC\n\n​\t\t现在再来看，如果切换dev到pro，只需要改一下是不是就结束了？完美！\n总结\n多环境开发使用group属性设置配置文件分组，便于线上维护管理\n\n5、多环境开发控制​\t\t多环境开发到这里基本上说完了，最后说一个冲突问题。就是maven和SpringBoot同时设置多环境的话怎么搞。\n​\t\t要想处理这个冲突问题，你要先理清一个关系，究竟谁在多环境开发中其主导地位。也就是说如果现在都设置了多环境，谁的应该是保留下来的，另一个应该遵从相同的设置。\n​\t\tmaven是做什么的？项目构建管理的，最终生成代码包的，SpringBoot是干什么的？简化开发的。简化，又不是其主导作用。最终还是要靠maven来管理整个工程，所以SpringBoot应该听maven的。整个确认后下面就好做了。大体思想如下：\n\n先在maven环境中设置用什么具体的环境\n在SpringBoot中读取maven设置的环境即可\n\nmaven中设置多环境（使用属性方式区分环境）\n&lt;profiles&gt;    &lt;profile&gt;        &lt;id&gt;env_dev&lt;/id&gt;        &lt;properties&gt;            &lt;profile.active&gt;dev&lt;/profile.active&gt;        &lt;/properties&gt;        &lt;activation&gt;            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;\t\t&lt;!--默认启动环境--&gt;        &lt;/activation&gt;    &lt;/profile&gt;    &lt;profile&gt;        &lt;id&gt;env_pro&lt;/id&gt;        &lt;properties&gt;            &lt;profile.active&gt;pro&lt;/profile.active&gt;        &lt;/properties&gt;    &lt;/profile&gt;&lt;/profiles&gt;\n\nSpringBoot中读取maven设置值\nspring:\tprofiles:    \tactive: @profile.active@\n\n​\t\t上面的@属性名@就是读取maven中配置的属性值的语法格式。\n总结\n\n当Maven与SpringBoot同时对多环境进行控制时，以Mavn为主，SpringBoot使用@..@占位符读取Maven对应的配置属性值\n基于SpringBoot读取Maven配置属性的前提下，如果在Idea下测试工程时pom.xml每次更新需要手动compile方可生效\n\n","tags":["SpringBoot"]},{"title":"SpringBoot运维实用篇之工程打包与运行","url":"/2022/06/13/SpringBoot%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%89%93%E5%8C%85%E4%B8%8E%E8%BF%90%E8%A1%8C/","content":"​\t\t刚开始做开发学习的小伙伴可能在有一个知识上面有错误的认知，我们天天写程序是在Idea下写的，运行也是在Idea下运行的。但是实际开发完成后，我们的项目是不可能运行在自己的电脑上的。我们以后制作的程序是运行在专用的服务器上的，简单说就是将你做的程序放在一台独立运行的电脑上，这台电脑要比你开发使用的计算机更专业，并且安全等级各个方面要远超过你现在的电脑。\n​\t\t那我们的程序如何放置在这台专用的电脑上呢，这就要将我们的程序先组织成一个文件，然后将这个文件传输到这台服务器上。这里面就存在两个过程，一个是打包的过程，另一个是运行的过程。\n温馨提示\n​\t\t企业项目上线为了保障环境适配性会采用下面流程发布项目，这里不讨论此过程。\n\n开发部门使用Git、SVN等版本控制工具上传工程到版本服务器\n服务器使用版本控制工具下载工程\n服务器上使用Maven工具在当前真机环境下重新构建项目\n启动服务\n\n​\t继续说我们的打包和运行过程。所谓打包指将程序转换成一个可执行的文件，所谓运行指不依赖开发环境执行打包产生的文件。上述两个操作都有对应的命令可以快速执行。\n程序打包​\t\tSpringBoot程序是基于Maven创建的，在Maven中提供有打包的指令，叫做package。本操作可以在Idea环境下执行。\nmvn package\n\n​\t\t打包后会产生一个与工程名类似的jar文件，其名称是由模块名+版本号+.jar组成的。\n程序运行​\t\t程序包打好以后，就可以直接执行了。在程序包所在路径下，执行指令。\njava -jar 工程包名.jar\n\n​\t执行程序打包指令后，程序正常运行，与在Idea下执行程序没有区别。\n​\t\t特别关注：如果你的计算机中没有安装java的jdk环境，是无法正确执行上述操作的，因为程序执行使用的是java指令。\n​\t\t特别关注：在使用向导创建SpringBoot工程时，pom.xml文件中会有如下配置，这一段配置千万不能删除，否则打包后无法正常执行程序。\n&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n\n总结\nSpringBoot工程可以基于java环境下独立运行jar文件启动服务\nSpringBoot工程执行mvn命令package进行打包\n执行jar命令：java –jar 工程名.jar\n\n","tags":["SpringBoot"]},{"title":"SpringBoot运维实用篇之日志","url":"/2022/06/14/SpringBoot%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%97%A5%E5%BF%97/","content":"日志其实就是记录程序日常运行的信息，主要作用如下：\n\n编程期调试代码\n运营期记录信息\n记录日常运营重要信息（峰值流量、平均响应时长……）\n记录应用报错信息（错误堆栈）\n记录运维过程数据（扩容、宕机、报警……）\n\n1、代码中使用日志工具记录日志​\t\t日志的使用格式非常固定，直接上操作步骤：\n步骤①：添加日志记录操作\n@RestController@RequestMapping(&quot;/books&quot;)public class BookController extends BaseClass&#123;    private static final Logger log = LoggerFactory.getLogger(BookController.class);    @GetMapping    public String getById()&#123;        log.debug(&quot;debug...&quot;);        log.info(&quot;info...&quot;);        log.warn(&quot;warn...&quot;);        log.error(&quot;error...&quot;);        return &quot;springboot is running...2&quot;;    &#125;&#125;\n\n​\t\t上述代码中log对象就是用来记录日志的对象，下面的log.debug，log.info这些操作就是写日志的API了。\n步骤②：设置日志输出级别\n​\t\t日志设置好以后可以根据设置选择哪些参与记录。这里是根据日志的级别来设置的。日志的级别分为6种，分别是：\n\nTRACE：运行堆栈信息，使用率低\nDEBUG：程序员调试代码使用\nINFO：记录运维过程数据\nWARN：记录运维过程报警数据\nERROR：记录错误堆栈信息\nFATAL：灾难信息，合并计入ERROR\n\n​\t\t一般情况下，开发时候使用DEBUG，上线后使用INFO，运维信息记录使用WARN即可。下面就设置一下日志级别：\n# 开启debug模式，输出调试信息，常用于检查系统运行状况debug: true\n\n​\t\t这么设置太简单粗暴了，日志系统通常都提供了细粒度的控制\n# 开启debug模式，输出调试信息，常用于检查系统运行状况debug: true# 设置日志级别，root表示根节点，即整体应用日志级别logging:\tlevel:    \troot: debug\n\n​\t\t还可以再设置更细粒度的控制\n步骤③：设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别\nlogging:\t# 设置日志组    group:    \t# 自定义组名，设置当前组中所包含的包        ebank: com.itheima.controller    level:    \troot: warn        # 为对应组设置日志级别        ebank: debug    \t# 为对包设置日志级别        com.itheima.controller: debug\n\n​\t\t说白了就是总体设置一下，每个包设置一下，如果感觉设置的麻烦，就先把包分个组，对组设置，没了，就这些。\n总结\n日志用于记录开发调试与运维过程消息\n日志的级别共6种，通常使用4种即可，分别是DEBUG，INFO,WARN,ERROR\n可以通过日志组或代码包的形式进行日志显示级别的控制\n\n2、教你一招：优化日志对象创建代码​\t\t写代码的时候每个类都要写创建日志记录对象，这个可以优化一下，使用前面用过的lombok技术给我们提供的工具类即可。\n@RestController@RequestMapping(&quot;/books&quot;)public class BookController extends BaseClass&#123;    private static final Logger log = LoggerFactory.getLogger(BookController.class);\t//这一句可以不写了&#125;\n\n​\t\t导入lombok后使用注解搞定，日志对象名为log\n@Slf4j\t\t//这个注解替代了下面那一行@RestController@RequestMapping(&quot;/books&quot;)public class BookController extends BaseClass&#123;    private static final Logger log = LoggerFactory.getLogger(BookController.class);\t//这一句可以不写了&#125;\n\n总结\n基于lombok提供的@Slf4j注解为类快速添加日志对象\n\n3、日志输出格式控制​\t\t日志已经能够记录了，但是目前记录的格式是SpringBoot给我们提供的，如果想自定义控制就需要自己设置了。先分析一下当前日志的记录格式。\n\n​\t\t对于单条日志信息来说，日期，触发位置，记录信息是最核心的信息。级别用于做筛选过滤，PID与线程名用于做精准分析。了解这些信息后就可以DIY日志格式了。本课程不做详细的研究，有兴趣的小伙伴可以学习相关的知识。下面给出课程中模拟的官方日志模板的书写格式，便于大家学习。\nlogging:\tpattern:    \tconsole: &quot;%d %clr(%p) --- [%16t] %clr(%-40.40c)&#123;cyan&#125; : %m %n&quot;\n\n总结\n日志输出格式设置规则\n\n4、文件记录日志​\t\t日志信息显示，记录已经控制住了，下面就要说一下日志的转存了。日志不能仅显示在控制台上，要把日志记录到文件中，方便后期维护查阅。\n​\t\t对于日志文件的使用存在各种各样的策略，例如每日记录，分类记录，报警后记录等。这里主要研究日志文件如何记录。\n​\t\t记录日志到文件中格式非常简单，设置日志文件名即可。\nlogging:\tfile:    \tname: server.log\n\n​\t\t虽然使用上述格式可以将日志记录下来了，但是面对线上的复杂情况，一个文件记录肯定是不能够满足运维要求的，通常会每天记录日志文件，同时为了便于维护，还要限制每个日志文件的大小。下面给出日志文件的常用配置方式：\nlogging:\tlogback:    \trollingpolicy:        \tmax-file-size: 3KB            file-name-pattern: server.%d&#123;yyyy-MM-dd&#125;.%i.log\n\n​\t\t以上格式是基于logback日志技术设置每日日志文件的设置格式，要求容量到达3KB以后就转存信息到第二个文件中。文件命名规则中的%d标识日期，%i是一个递增变量，用于区分日志文件。\n总结\n日志记录到文件\n日志文件格式设置\n\n","tags":["SpringBoot"]},{"title":"SpringBoot运维实用篇之配置高级","url":"/2022/06/14/SpringBoot%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E9%85%8D%E7%BD%AE%E9%AB%98%E7%BA%A7/","content":"1、临时属性设置​\t\t目前我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了，比如配置了服务器的端口是8080。如果我要启动项目，发现当前我的服务器上已经有应用启动起来并且占用了8080端口，这个时候就尴尬了。难道要重新把打包好的程序修改一下吗？比如我要把打包好的程序启动端口改成80。\n​\t\tSpringBoot提供了灵活的配置方式，如果你发现你的项目中有个别属性需要重新配置，可以使用临时属性的方式快速修改某些配置。方法也特别简单，在启动的时候添加上对应参数就可以了。\njava –jar springboot.jar –-server.port=80\n\n​\t\t上面的命令是启动SpringBoot程序包的命令，在命令输入完毕后，空一格，然后输入两个-号。下面按照属性名&#x3D;属性值的形式添加对应参数就可以了。记得，这里的格式不是yaml中的书写格式，当属性存在多级名称时，中间使用点分隔，和properties文件中的属性格式完全相同。\n​\t\t如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。\njava –jar springboot.jar –-server.port=80 --logging.level.root=debug\n\n属性加载优先级​\t\t现在我们的程序配置受两个地方控制了，第一配置文件，第二临时属性。并且我们发现临时属性的加载优先级要高于配置文件的。那是否还有其他的配置方式呢？其实是有的，而且还不少，打开官方文档中对应的内容，就可以查看配置读取的优先顺序。地址奉上：https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config\n\n​\t\t我们可以看到，居然有14种配置的位置，而我们现在使用的是这里面的2个。第3条Config data说的就是使用配置文件，第11条Command line arguments说的就是使用命令行临时参数。而这14种配置的顺序就是SpringBoot加载配置的顺序，言外之意，命令行临时属性比配置文件的加载优先级高，所以这个列表上面的优先级低，下面的优先级高。其实这个东西不用背的，你就记得一点，你最终要什么效果，你自己是知道的，不管这个顺序是怎么个高低排序，开发时一定要配置成你要的顺序为准。这个顺序只是在你想不明白问题的时候帮助你分析罢了。\n​\t\t比如你现在加载了一个user.name属性。结果你发现出来的结果和你想的不一样，那肯定是别的优先级比你高的属性覆盖你的配置属性了，那你就可以看着这个顺序挨个排查。哪个位置有可能覆盖了你的属性。\n​\t\t在yaml中配置了user.name属性值，然后读取出来的时候居然不是自己的配置值，因为在系统属性中有一个属性叫做user.name，两个相互冲突了。而系统属性的加载优先顺序在上面这个列表中是5号，高于3号，所以SpringBoot最终会加载系统配置属性user.name。\n总结\n使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性\n临时属性添加方式：java –jar 工程名.jar –-属性名&#x3D;值\n多个临时属性之间使用空格分隔\n临时属性必须是当前boot工程支持的属性，否则设置无效\n\n2、开发环境中使用临时属性​\t\t临时使用目前是有了，但是上线的时候通过命令行输入的临时属性必须是正确的啊，那这些属性配置值我们必须在开发环境中测试好才行。下面说一下开发环境中如何使用临时属性，其实就是Idea界面下如何操作了。\n​\t\t打开SpringBoot引导类的运行界面，在里面找到配置项。其中Program arguments对应的位置就是添加临时属性的，可以加几个试试效果。\n\n​\t\t做到这里其实可以产生一个思考了，如果对java编程熟悉的小伙伴应该知道，我们运行main方法的时候，如果想使用main方法的参数，也就是下面的args参数，就是在上面这个位置添加的参数。\npublic static void main(String[] args) &#123;&#125;\n\n​\t\t原来是这样，通过这个args就可以获取到参数。再来看我们的引导类是如何书写的\npublic static void main(String[] args) &#123;    SpringApplication.run(SSMPApplication.class,args);&#125;\n\n​\t\t这个args参数居然传递给了run方法，看来在Idea中配置的临时参数就是通过这个位置传递到我们的程序中的。言外之意，这里如果不用这个args是不是就断开了外部传递临时属性的入口呢？是这样的，我们可以使用下面的调用方式，这样外部临时属性就无法进入到SpringBoot程序中了。\npublic static void main(String[] args) &#123;    SpringApplication.run(SSMPApplication.class);&#125;\n\n​\t\t或者还可以使用如下格式来玩这个操作，就是将配置不写在配置文件中，直接写成一个字符串数组，传递给程序入口。当然，这种做法并没有什么实际开发意义。\npublic static void main(String[] args) &#123;    String[] arg = new String[1];    arg[0] = &quot;--server.port=8082&quot;;    SpringApplication.run(SSMPApplication.class, arg);&#125;\n\n总结\n启动SpringBoot程序时，可以选择是否使用命令行属性为SpringBoot程序传递启动属性\n\n思考​\t\t现在使用临时属性可以在启动项目前临时更改配置了，但是新的问题又出来了。临时属性好用是好用，就是写的多了会很麻烦。比如我现在有个需求，上线的时候使用临时属性配置20个值，这下可麻烦了，能不能搞得简单点，集中管理一下呢？比如说搞个文件，加载指定文件？还真可以。怎么做呢？\n3、配置文件分类​\t\tSpringBoot提供了配置文件和临时属性的方式来对程序进行配置。前面一直说的是临时属性，这一节要说说配置文件了。其实这个配置文件我们一直在使用，只不过我们用的是SpringBoot提供的4级配置文件中的其中一个级别。4个级别分别是：\n\n类路径下配置文件（一直使用的是这个，也就是resources目录中的application.yml文件）\n类路径下config目录下配置文件\n程序包所在目录中配置文件\n程序包所在目录中config目录下配置文件\n\n​\t\t好复杂，一个一个说。其实上述4种文件是提供给你了4种配置文件书写的位置，功能都是一样的，都是做配置的。那大家关心的就是差别了，没错，就是因为位置不同，产生了差异。总体上来说，4种配置文件如果都存在的话，有一个优先级的问题，说白了就是加入4个文件我都有，里面都有一样的配置，谁生效的问题。上面4个文件的加载优先顺序为\n\nfile ：config&#x2F;application.yml 【最高】\nfile ：application.yml\nclasspath：config&#x2F;application.yml\nclasspath：application.yml  【最低】\n\n​\t\t那为什么设计这种多种呢？说一个最典型的应用吧。\n\n场景A：你作为一个开发者，你做程序的时候为了方便自己写代码，配置的数据库肯定是连接你自己本机的，咱们使用4这个级别，也就是之前一直用的application.yml。\n场景B：现在项目开发到了一个阶段，要联调测试了，连接的数据库是测试服务器的数据库，肯定要换一组配置吧。你可以选择把你之前的文件中的内容都改了，目前还不麻烦。\n场景C：测试完了，一切OK。你继续写你的代码，你发现你原来写的配置文件被改成测试服务器的内容了，你要再改回来。现在明白了不？场景B中把你的内容都改掉了，你现在要重新改回来，以后呢？改来改去吗？\n\n​\t\t解决方案很简单，用上面的3这个级别的配置文件就可以快速解决这个问题，再写一个配置就行了。两个配置文件共存，因为config目录中的配置加载优先级比你的高，所以配置项如果和级别4里面的内容相同就覆盖了，这样是不是很简单？\n总结\n配置文件分为4种\n\n项目类路径配置文件：服务于开发人员本机开发与测试\n项目类路径config目录中配置文件：服务于项目经理整体调控\n工程路径配置文件：服务于运维人员配置涉密线上环境\n工程路径config目录中配置文件：服务于运维经理整体调控\n\n\n多层级配置文件间的属性采用叠加并覆盖的形式作用于程序\n\n\n4、自定义配置文件​\t\t之前咱们做配置使用的配置文件都是application.yml，其实这个文件也是可以改名字的，这样方便维护。比如我2020年4月1日搞活动，走了一组配置，2020年5月1日活动取消，恢复原始配置，这个时候只需要重新更换一下配置文件就可以了。但是你总不能在原始配置文件上修改吧，不然搞完活动以后，活动的配置就留不下来了，不利于维护。\n​\t\t自定义配置文件方式有如下两种：\n方式一：使用临时属性设置配置文件名，注意仅仅是名称，不要带扩展名\n\n方式二：使用临时属性设置配置文件路径，这个是全路径名\n\n​\t\t也可以设置加载多个配置文件\n\n​\t\t使用的属性一个是spring.config.name，另一个是spring.config.location，这个一定要区别清楚。\n温馨提示\n​\t\t我们现在研究的都是SpringBoot单体项目，就是单服务器版本。其实企业开发现在更多的是使用基于SpringCloud技术的多服务器项目。这种配置方式和我们现在学习的完全不一样，所有的服务器将不再设置自己的配置文件，而是通过配置中心获取配置，动态加载配置信息。为什么这样做？集中管理。\n总结\n\n配置文件可以修改名称，通过启动参数设定\n配置文件可以修改路径，通过启动参数设定\n微服务开发中配置文件通过配置中心进行设置\n\n","tags":["SpringBoot"]},{"title":"SpringMVC之Controller配置总结","url":"/2022/05/18/SpringMVC%E4%B9%8BController%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/","content":"控制器Controller\n控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。\n控制器负责解析用户的请求并将其转换为一个模型。\n在Spring MVC中一个控制器类可以包含多个方法\n在Spring MVC中，对于Controller的配置方式有很多种\n\n实现Controller接口Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法；\n//实现该接口的类获得控制器功能public interface Controller &#123;   //处理请求且返回一个模型与视图对象   ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;&#125;\n\n测试\n\n在刚才的文件基础上, 我们进行操作！\n\n\n删掉HelloController\nmvc的配置文件只留下 视图解析器！\n\n\n编写一个Controller类，ControllerTest1\n\n\n//定义控制器//注意点：不要导错包，实现Controller接口，重写方法；public class ControllerTest1 implements Controller &#123;   public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;       //返回一个模型视图对象       ModelAndView mv = new ModelAndView();       mv.addObject(&quot;msg&quot;,&quot;Test1Controller&quot;);       mv.setViewName(&quot;test&quot;);       return mv;  &#125;&#125;\n\n\n编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类\n\n&lt;bean name=&quot;/t1&quot; class=&quot;com.fang.controller.ControllerTest1&quot;/&gt;\n\n\n编写前端test.jsp，注意在WEB-INF&#x2F;jsp目录下编写，对应我们的视图解析器\n\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;   &lt;title&gt;fang&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt;\n\n\n配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 &#x2F; ，所以请求不用加项目名，OK！\n\n说明：\n\n实现接口Controller定义控制器是较老的办法\n缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦；\n\n使用注解@Controller\n@Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）；\nSpring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。\n\n&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;&lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt;\n\n\n增加一个ControllerTest2类，使用注解实现；\n\n//@Controller注解的类会自动添加到Spring上下文中@Controllerpublic class ControllerTest2&#123;   //映射访问路径   @RequestMapping(&quot;/t2&quot;)   public String index(Model model)&#123;       //Spring MVC会自动实例化一个Model对象用于向视图中传值       model.addAttribute(&quot;msg&quot;, &quot;ControllerTest2&quot;);       //返回视图位置       return &quot;test&quot;;  &#125;&#125;\n\n可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。\n注解方式是平时使用的最多的方式！\n","tags":["Controller"]},{"title":"SpringMVC之Fastjson使用","url":"/2022/05/19/SpringMVC%E4%B9%8BFastjson%E4%BD%BF%E7%94%A8/","content":"fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。\nfastjson 的 pom依赖！\n&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.60&lt;/version&gt;&lt;/dependency&gt;\n\nfastjson 三个主要的类：\nJSONObject  代表 json 对象 \n\nJSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。\nJSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。\n\nJSONArray  代表 json 对象数组\n\n内部是有List接口中的方法来完成操作的。\n\nJSON代表 JSONObject和JSONArray的转化\n\nJSON类源码分析与使用\n仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。\n\n代码测试，我们新建一个FastJsonDemo 类\npackage com.fang;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.fang.pojo.User;import java.util.ArrayList;import java.util.List;public class FastJsonDemo &#123;    public static void main(String[] args) &#123;        //创建一个对象        User user1 = new User(&quot;方1号&quot;, 3, &quot;男&quot;);        User user2 = new User(&quot;方2号&quot;, 3, &quot;男&quot;);        User user3 = new User(&quot;方3号&quot;, 3, &quot;男&quot;);        User user4 = new User(&quot;方4号&quot;, 3, &quot;男&quot;);        List&lt;User&gt; list = new ArrayList&lt;User&gt;();        list.add(user1);        list.add(user2);        list.add(user3);        list.add(user4);        System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);        String str1 = JSON.toJSONString(list);        System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);        String str2 = JSON.toJSONString(user1);        System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);        System.out.println(&quot;\\n****** JSON字符串 转 Java对象*******&quot;);        User jp_user1=JSON.parseObject(str2,User.class);        System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);        System.out.println(&quot;\\n****** Java对象 转 JSON对象 ******&quot;);        JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);        System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));        System.out.println(&quot;\\n****** JSON对象 转 Java对象 ******&quot;);        User to_java_user = JSON.toJavaObject(jsonObject1, User.class);        System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);    &#125;&#125;\n\n这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！\n*******Java对象 转 JSON字符串*******JSON.toJSONString(list)==&gt;[&#123;&quot;age&quot;:3,&quot;name&quot;:&quot;方1号&quot;,&quot;sex&quot;:&quot;男&quot;&#125;,&#123;&quot;age&quot;:3,&quot;name&quot;:&quot;方2号&quot;,&quot;sex&quot;:&quot;男&quot;&#125;,&#123;&quot;age&quot;:3,&quot;name&quot;:&quot;方3号&quot;,&quot;sex&quot;:&quot;男&quot;&#125;,&#123;&quot;age&quot;:3,&quot;name&quot;:&quot;方4号&quot;,&quot;sex&quot;:&quot;男&quot;&#125;]JSON.toJSONString(user1)==&gt;&#123;&quot;age&quot;:3,&quot;name&quot;:&quot;方1号&quot;,&quot;sex&quot;:&quot;男&quot;&#125;****** JSON字符串 转 Java对象*******JSON.parseObject(str2,User.class)==&gt;User(name=方1号, age=3, sex=男)****** Java对象 转 JSON对象 ******(JSONObject) JSON.toJSON(user2)==&gt;方2号****** JSON对象 转 Java对象 ******JSON.toJavaObject(jsonObject1, User.class)==&gt;User(name=方2号, age=3, sex=男)\n\n","tags":["SpringMVC"]},{"title":"SpringMVC之Jackson使用","url":"/2022/05/19/SpringMVC%E4%B9%8BJackson%E4%BD%BF%E7%94%A8/","content":"Controller返回JSON数据Jackson应该是目前比较好的json解析工具了\n当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。\n我们这里使用Jackson，使用它需要导入它的jar包；\n&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt;\n\n配置SpringMVC需要的配置\nweb.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;!--1.注册DispatcherServlet--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;    &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;filter&gt;        &lt;filter-name&gt;encoding&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;utf-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encoding&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;\n\nspringmvc-servlet.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/mvc       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;    &lt;context:component-scan base-package=&quot;com.fang.controller&quot;/&gt;        &lt;!-- 视图解析器 --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;          id=&quot;internalResourceViewResolver&quot;&gt;        &lt;!-- 前缀 --&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;        &lt;!-- 后缀 --&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n我们随便编写一个User的实体类，然后我们去编写我们的测试Controller；\npackage com.fang.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123;    private String name;    private int age;    private String sex;&#125;\n\n这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法\n编写一个Controller；\npackage com.fang.controller;import com.fang.pojo.User;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class UserController &#123;    @RequestMapping(&quot;/json1&quot;)    @ResponseBody    public String json1() throws JsonProcessingException &#123;        //创建一个jackson的对象映射器，用来解析数据        ObjectMapper mapper = new ObjectMapper();        //创建一个对象        User user = new User(&quot;方&quot;, 3, &quot;男&quot;);        //将我们的对象解析成为json格式        String str = mapper.writeValueAsString(user);        //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便        return str;    &#125;&#125;\n\n配置Tomcat ， 启动测试一下！\nhttp://localhost:8080/json1\n\n发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型；\n通过@RequestMaping的produces属性来实现，修改下代码\n//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/json1&quot;,produces  = &quot;application/json;charset=utf-8&quot;)\n\n再次测试， http://localhost:8080/json1 ， 乱码问题OK！\n\n【注意：使用json记得处理乱码问题】\n代码优化乱码统一解决\n上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！\n我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！\n&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;        &lt;/bean&gt;        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;            &lt;property name=&quot;objectMapper&quot;&gt;                &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;                    &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;                &lt;/bean&gt;            &lt;/property&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;\n\n返回json字符串统一解决\n在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！\npackage com.fang.controller;import com.fang.pojo.User;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class UserController &#123;    //produces:指定响应体返回类型和编码    @RequestMapping(&quot;/json1&quot;)    public String json1() throws JsonProcessingException &#123;        //创建一个jackson的对象映射器，用来解析数据        ObjectMapper mapper = new ObjectMapper();        //创建一个对象        User user = new User(&quot;方&quot;, 3, &quot;男&quot;);        //将我们的对象解析成为json格式        String str = mapper.writeValueAsString(user);        //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便        return str;    &#125;&#125;\n\n启动tomcat测试，结果都正常输出！\n测试集合输出@RequestMapping(&quot;/json2&quot;)public String json2() throws JsonProcessingException &#123;    //创建一个jackson的对象映射器，用来解析数据    ObjectMapper mapper = new ObjectMapper();    //创建一个对象    User user1 = new User(&quot;方1号&quot;, 3, &quot;男&quot;);    User user2 = new User(&quot;方2号&quot;, 3, &quot;男&quot;);    User user3 = new User(&quot;方3号&quot;, 3, &quot;男&quot;);    User user4 = new User(&quot;方4号&quot;, 3, &quot;男&quot;);    List&lt;User&gt; list = new ArrayList&lt;User&gt;();    list.add(user1);    list.add(user2);    list.add(user3);    list.add(user4);    //将我们的对象解析成为json格式    String str = mapper.writeValueAsString(list);    return str;&#125;\n\n运行结果 : \n\n输出时间对象@RequestMapping(&quot;/json3&quot;)public String json3() throws JsonProcessingException &#123;    ObjectMapper mapper = new ObjectMapper();    //创建时间一个对象，java.util.Date    Date date = new Date();    //将我们的对象解析成为json格式    String str = mapper.writeValueAsString(date);    return str;&#125;\n\n运行结果 : \n\n\n默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！\nJackson 默认是会把时间转成timestamps形式\n\n解决方案：取消timestamps形式 ， 自定义时间格式\n@RequestMapping(&quot;/json4&quot;)public String json4() throws JsonProcessingException &#123;    ObjectMapper mapper = new ObjectMapper();    //不使用时间戳的方式    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false);    //自定义日期格式对象    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyy-MM-dd HH:mm:ss&quot;);    //指定日期格式    mapper.setDateFormat(sdf);    Date date = new Date();    String str = mapper.writeValueAsString(date);    return str;&#125;\n\n运行结果 : 成功的输出了时间！\n\n抽取为工具类如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下\npublic class JsonUtils &#123;      public static String getJson(Object object) &#123;       return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);  &#125;   public static String getJson(Object object,String dateFormat) &#123;       ObjectMapper mapper = new ObjectMapper();       //不使用时间差的方式       mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);       //自定义日期格式对象       SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);       //指定日期格式       mapper.setDateFormat(sdf);       try &#123;           return mapper.writeValueAsString(object);      &#125; catch (JsonProcessingException e) &#123;           e.printStackTrace();      &#125;       return null;  &#125;&#125;\n\n我们使用工具类，代码就更加简洁了！\n@RequestMapping(&quot;/json5&quot;)public String json5() throws JsonProcessingException &#123;    Date date = new Date();    String str = JsonUtils.getJson(date);   return str;&#125;\n","tags":["SpringMVC"]},{"title":"SpringMVC之RequestMapping说明","url":"/2022/05/18/SpringMVC%E4%B9%8BRequestMapping%E8%AF%B4%E6%98%8E/","content":"@RequestMapping\n\n@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n为了测试结论更加准确，我们可以加上一个项目名测试 myweb\n只注解在方法上面\n\n@Controllerpublic class TestController &#123;   @RequestMapping(&quot;/h1&quot;)   public String test()&#123;       return &quot;test&quot;;  &#125;&#125;\n\n访问路径：http://localhost:8080 &#x2F; 项目名 &#x2F; h1\n\n同时注解类与方法\n\n@Controller@RequestMapping(&quot;/admin&quot;)public class TestController &#123;   @RequestMapping(&quot;/h1&quot;)   public String test()&#123;       return &quot;test&quot;;  &#125;&#125;\n\n访问路径：http://localhost:8080 &#x2F; 项目名&#x2F; admin &#x2F;h1  , 需要先指定类的路径再指定方法的路径；\n","tags":["SpringMVC"]},{"title":"SpringMVC之RestFul风格","url":"/2022/05/18/SpringMVC%E4%B9%8BRestFul%E9%A3%8E%E6%A0%BC/","content":"概念Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。\n功能资源：互联网所有的事物都可以被抽象为资源\n资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。\n分别对应 添加、 删除、修改、查询。\n传统方式操作资源  ：通过不同的参数来实现不同的效果！方法单一，post 和 get\n​\thttp://127.0.0.1/item/queryItem.action?id=1 查询,GET\n​\thttp://127.0.0.1/item/saveItem.action 新增,POST\n​\thttp://127.0.0.1/item/updateItem.action 更新,POST\n​\thttp://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST\n使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！\n​\thttp://127.0.0.1/item/1 查询,GET\n​\thttp://127.0.0.1/item 新增,POST\n​\thttp://127.0.0.1/item 更新,PUT\n​\thttp://127.0.0.1/item/1 删除,DELETE\n学习测试\n在新建一个类 RestFulController\n\n@Controllerpublic class RestFulController &#123;&#125;\n\n\n在Spring MVC中可以使用  @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。\n\n@Controllerpublic class RestFulController &#123;    //映射访问路径    @RequestMapping(&quot;/rc/&#123;p1&#125;/&#123;p2&#125;&quot;)    public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123;        int result = p1+ p2;        //Spring MVC会自动实例化一个Model对象用于向视图中传值        model.addAttribute(&quot;msg&quot;,&quot;结果&quot;+result);        return &quot;test&quot;;    &#125;&#125;\n\n\n我们来测试请求查看下\n\n\n\n思考：使用路径变量的好处？\n使路径变得更加简洁；\n获得参数更加方便，框架会自动进行类型转换。\n通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是&#x2F;rc&#x2F;1&#x2F;a，则路径与方法不匹配，而不会是参数转换失败。\n\n\n\n\n\n我们来修改下对应的参数类型，再次测试\n\n@Controllerpublic class RestFulController &#123;    //映射访问路径    @RequestMapping(&quot;/rc/&#123;p1&#125;/&#123;p2&#125;&quot;)    public String index(@PathVariable int p1, @PathVariable String p2, Model model)&#123;        String result = p1+ p2;        //Spring MVC会自动实例化一个Model对象用于向视图中传值        model.addAttribute(&quot;msg&quot;,&quot;结果&quot;+result);        return &quot;test&quot;;    &#125;&#125;\n\n\n使用method属性指定请求类型用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等\n我们来测试一下：\n\n增加一个方法\n\n@Controllerpublic class RestFulController &#123;    //映射访问路径    @RequestMapping(value = &quot;/rc&quot;,method = &#123;RequestMethod.POST&#125;)    public String index(Model model)&#123;        model.addAttribute(&quot;msg&quot;,&quot;结果&quot;);        return &quot;test&quot;;    &#125;&#125;\n\n\n\n如果将POST修改为GET则正常了；\n\n@Controllerpublic class RestFulController &#123;    //映射访问路径    @RequestMapping(value = &quot;/rc&quot;,method = &#123;RequestMethod.GET&#125;)    public String index(Model model)&#123;        model.addAttribute(&quot;msg&quot;,&quot;结果&quot;);        return &quot;test&quot;;    &#125;&#125;\n\n\n小结Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。\n所有的地址栏请求默认都会是 HTTP GET 类型的。\n方法级别的注解变体有如下几个：组合注解\n@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping\n\n@GetMapping 是一个组合注解，平时使用的会比较多！\n它所扮演的是 @RequestMapping(method &#x3D;RequestMethod.GET) 的一个快捷方式。\n扩展：小黄鸭调试法场景一：我们都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题的经历，但是很多时候就在我们解释的过程中自己却想到了问题的解决方案，然后对方却一脸茫然。\n场景二：你的同行跑来问你一个问题，但是当他自己把问题说完，或说到一半的时候就想出答案走了，留下一脸茫然的你。\n其实上面两种场景现象就是所谓的小黄鸭调试法（Rubber Duck Debuging），又称橡皮鸭调试法，它是我们软件工程中最常使用调试方法之一。\n","tags":["SpringMVC"]},{"title":"SpringMVC之乱码问题解决","url":"/2022/05/19/SpringMVC%E4%B9%8B%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","content":"测试步骤：\n1、我们可以在首页编写一个提交的表单\n&lt;form action=&quot;/e/t&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;\n\n2、后台编写对应的处理类\n@Controllerpublic class Encoding &#123;    @RequestMapping(&quot;/e/t&quot;)    public String test(Model model,String name)&#123;        model.addAttribute(&quot;msg&quot;,name);//获取表单提交的值        return &quot;test&quot;;////跳转到test页面显示输入的值    &#125;&#125;\n\n3、输入中文测试，发现乱码\n\n以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 .\n修改了xml文件需要重启服务器！\n&lt;filter&gt;    &lt;filter-name&gt;encoding&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;encoding&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;\n\n\n但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 .\n处理方法 :\n1、修改tomcat配置文件 ：设置编码！\n&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;          connectionTimeout=&quot;20000&quot;          redirectPort=&quot;8443&quot; /&gt;\n\n2、自定义过滤器\npackage com.fang.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Map;/*** 解决get和post请求 全部乱码的过滤器*/public class GenericEncodingFilter implements Filter &#123;   @Override   public void destroy() &#123;  &#125;   @Override   public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;       //处理response的字符编码       HttpServletResponse myResponse=(HttpServletResponse) response;       myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);       // 转型为与协议相关对象       HttpServletRequest httpServletRequest = (HttpServletRequest) request;       // 对request包装增强       HttpServletRequest myrequest = new MyRequest(httpServletRequest);       chain.doFilter(myrequest, response);  &#125;   @Override   public void init(FilterConfig filterConfig) throws ServletException &#123;  &#125;&#125;//自定义request对象，HttpServletRequest的包装类class MyRequest extends HttpServletRequestWrapper &#123;   private HttpServletRequest request;   //是否编码的标记   private boolean hasEncode;   //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰   public MyRequest(HttpServletRequest request) &#123;       super(request);// super必须写       this.request = request;  &#125;   // 对需要增强方法 进行覆盖   @Override   public Map getParameterMap() &#123;       // 先获得请求方式       String method = request.getMethod();       if (method.equalsIgnoreCase(&quot;post&quot;)) &#123;           // post请求           try &#123;               // 处理post乱码               request.setCharacterEncoding(&quot;utf-8&quot;);               return request.getParameterMap();          &#125; catch (UnsupportedEncodingException e) &#123;               e.printStackTrace();          &#125;      &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123;           // get请求           Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();           if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次               for (String parameterName : parameterMap.keySet()) &#123;                   String[] values = parameterMap.get(parameterName);                   if (values != null) &#123;                       for (int i = 0; i &lt; values.length; i++) &#123;                           try &#123;                               // 处理get乱码                               values[i] = new String(values[i]                                      .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);                          &#125; catch (UnsupportedEncodingException e) &#123;                               e.printStackTrace();                          &#125;                      &#125;                  &#125;              &#125;               hasEncode = true;          &#125;           return parameterMap;      &#125;       return super.getParameterMap();  &#125;   //取一个值   @Override   public String getParameter(String name) &#123;       Map&lt;String, String[]&gt; parameterMap = getParameterMap();       String[] values = parameterMap.get(name);       if (values == null) &#123;           return null;      &#125;       return values[0]; // 取回参数的第一个值  &#125;   //取所有值   @Override   public String[] getParameterValues(String name) &#123;       Map&lt;String, String[]&gt; parameterMap = getParameterMap();       String[] values = parameterMap.get(name);       return values;  &#125;&#125;\n\n这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！\n然后在web.xml中配置这个过滤器即可！\n乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！\n","tags":["SpringMVC"]},{"title":"SpringMVC之什么是JSON？","url":"/2022/05/19/SpringMVC%E4%B9%8B%E4%BB%80%E4%B9%88%E6%98%AFJSON%EF%BC%9F/","content":"\nJSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。\n采用完全独立于编程语言的文本格式来存储和表示数据。\n简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。\n易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\n\n在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：\n\n对象表示为键值对，数据由逗号分隔\n花括号保存对象\n方括号保存数组\n\nJSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键&#x2F;值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值：\n&#123;&quot;name&quot;: &quot;QinJiang&quot;&#125;&#123;&quot;age&quot;: &quot;3&quot;&#125;&#123;&quot;sex&quot;: &quot;男&quot;&#125;\n\n很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：\nJSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。\nvar obj = &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;; //这是一个对象，注意键名也是可以使用引号包裹的var json = &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;; //这是一个 JSON 字符串，本质是一个字符串\n\nJSON 和 JavaScript 对象互转\n要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：\nvar obj = JSON.parse(&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;);//结果是 &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;\n\n要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：\nvar json = JSON.stringify(&#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;);//结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;\n\n测试：\n在web目录下新建一个 json.html ， 编写测试内容\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;fang&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;  //编写一个js对象  var user = &#123;      name:&quot;方&quot;,      age:23,      sex:&quot;男&quot;  &#125;;  //将js对象转换成json字符串  var str = JSON.stringify(user);  console.log(str);  //将json字符串转换成js对象  var user2 = JSON.parse(str);  console.log(user2);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n","tags":["SpringMVC"]},{"title":"SpringMVC之什么是SpringMVC","url":"/2022/05/17/SpringMVC%E4%B9%8B%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC/","content":"1.概述Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。\n查看官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web\n我们为什么要学习SpringMVC呢?\n Spring MVC的特点：\n\n轻量级，简单易学\n高效 , 基于请求响应的MVC框架\n与Spring兼容性好，无缝结合\n约定优于配置\n功能强大：RESTful、数据验证、格式化、本地化、主题等\n简洁灵活\n\nSpring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。\nDispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；\n正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 .\n最重要的一点还是用的人多 , 使用的公司多 . \n2.中心控制器Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。\n​\tSpring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。\n\nSpringMVC的原理如下图所示：\n​\t当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。\n\n3.SpringMVC执行原理\n底层原理\n\n\n\n实际上只需要实现\n\n\n图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。\n简要分析执行流程\n\nDispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。\n我们假设请求的url为 : http://localhost:8080/SpringMVC/hello\n如上url拆分成三部分：\nhttp://localhost:8080服务器域名\nSpringMVC部署在服务器上的web站点\nhello表示控制器\n通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。\n\nHandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。\n\nHandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。\n\nHandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。\n\nHandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。\n\nHandler让具体的Controller执行。\n\nController将具体的执行信息返回给HandlerAdapter,如ModelAndView。\n\nHandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。\n\nDispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。\n\n视图解析器将解析的逻辑视图名传给DispatcherServlet。\n\nDispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。\n\n最终视图呈现给用户。\n\n\n","tags":["SpringMVC"]},{"title":"SpringMVC之回顾MVC","url":"/2022/05/16/SpringMVC%E4%B9%8B%E5%9B%9E%E9%A1%BEMVC/","content":"1.什么是MVC\nMVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。\n是将业务逻辑、数据、显示分离的方法来组织代码。\nMVC主要作用是降低了视图与业务逻辑间的双向偶合。\nMVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。\n\nModel（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。\nView（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。\nController（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。\n最典型的MVC就是JSP + servlet + javabean的模式。\n\n2.Model1时代\n在web早期的开发中，通常采用的都是Model1。\nModel1中，主要分为两层，视图层和模型层。\n\n\nModel1优点：架构简单，比较适合小型项目开发；\nModel1缺点：JSP职责不单一，职责过重，不便于维护；\n3.Model2时代Model2把一个项目分成三部分，包括视图、控制、模型。\n\n\n用户发请求\nServlet接收请求数据，并调用对应的业务逻辑方法\n业务处理完毕，返回更新后的数据给servlet\nservlet转向到JSP，由JSP来渲染页面\n响应给前端更新后的页面\n\n职责分析：\nController：控制器\n\n取得表单数据\n调用业务逻辑\n转向指定的页面\n\nModel：模型\n\n业务逻辑\n保存数据的状态\n\nView：视图\n\n显示页面\n\nModel2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。\n","tags":["SpringMVC"]},{"title":"SpringMVC之回顾Servlet","url":"/2022/05/16/SpringMVC%E4%B9%8B%E5%9B%9E%E9%A1%BEServlet/","content":"1.新建一个Maven工程当做父工程！pom依赖！\n&lt;dependencies&gt;   &lt;dependency&gt;       &lt;groupId&gt;junit&lt;/groupId&gt;       &lt;artifactId&gt;junit&lt;/artifactId&gt;       &lt;version&gt;4.12&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;org.springframework&lt;/groupId&gt;       &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;       &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;javax.servlet&lt;/groupId&gt;       &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;       &lt;version&gt;2.5&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;       &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;       &lt;version&gt;2.2&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;javax.servlet&lt;/groupId&gt;       &lt;artifactId&gt;jstl&lt;/artifactId&gt;       &lt;version&gt;1.2&lt;/version&gt;   &lt;/dependency&gt;&lt;/dependencies&gt;\n\n2.建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！\n3.导入servlet 和 jsp 的 jar 依赖\n&lt;dependency&gt;   &lt;groupId&gt;javax.servlet&lt;/groupId&gt;   &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;   &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;   &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;   &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt;\n\n4.编写一个Servlet类，用来处理用户的请求\n//实现Servlet接口public class HelloServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        //取得参数        String method = req.getParameter(&quot;method&quot;);        if (method.equals(&quot;add&quot;))&#123;            req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;);        &#125;        if (method.equals(&quot;delete&quot;))&#123;            req.getSession().setAttribute(&quot;msg&quot;,&quot;执行力delete方法&quot;);        &#125;        //业务逻辑        //视图跳跃        req.getRequestDispatcher(&quot;/WEB-INF/jsp/hello.jsp&quot;).forward(req,resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req, resp);    &#125;&#125;\n\n5.编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt;\n\n6.在web.xml中注册Servlet\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;servlet.HelloServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/user&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n7.配置Tomcat，并启动测试\n\n\nlocalhost:8080&#x2F;user?method&#x3D;add\nlocalhost:8080&#x2F;user?method&#x3D;delete\n\n\n\nMVC框架要做哪些事情\n\n将url映射到java类或java类的方法 .\n封装用户提交的数据 .\n处理请求–调用相关的业务处理–封装响应数据 .\n将响应的数据进行渲染 . jsp &#x2F; html 等表示层数据 .\n\n说明：\n​\t常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等….\n","tags":["Servlet"]},{"title":"SpringMVC之拦截器是什么？","url":"/2022/05/22/SpringMVC%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","content":"概述SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。\n过滤器与拦截器的区别：拦截器是AOP思想的具体应用。\n过滤器\n\nservlet规范中的一部分，任何java web工程都可以使用\n在url-pattern中配置了&#x2F;*之后，可以对所有要访问的资源进行拦截\n\n拦截器 \n\n拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用\n拦截器只会拦截访问的控制器方法， 如果访问的是jsp&#x2F;html&#x2F;css&#x2F;image&#x2F;js是不会进行拦截的\n\n自定义拦截器那如何实现拦截器呢？\n想要自定义拦截器，必须实现 HandlerInterceptor 接口。\n1、新建一个Moudule ， springmvc-07-Interceptor  ， 添加web支持\n2、配置web.xml 和 springmvc-servlet.xml 文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;!--1.注册servlet--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;!--所有请求都会被springmvc拦截 --&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;filter&gt;        &lt;filter-name&gt;encoding&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;utf-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encoding&lt;/filter-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/mvc       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;    &lt;context:component-scan base-package=&quot;com.fang.controller&quot;/&gt;    &lt;mvc:annotation-driven&gt;        &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;            &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;                &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;            &lt;/bean&gt;            &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;                &lt;property name=&quot;objectMapper&quot;&gt;                    &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;                        &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;                    &lt;/bean&gt;                &lt;/property&gt;            &lt;/bean&gt;        &lt;/mvc:message-converters&gt;    &lt;/mvc:annotation-driven&gt;    &lt;!-- 视图解析器 --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;          id=&quot;internalResourceViewResolver&quot;&gt;        &lt;!-- 前缀 --&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;        &lt;!-- 后缀 --&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n3、编写一个拦截器\npackage com.fang.config;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor implements HandlerInterceptor &#123;    //在请求处理的方法之前执行    //如果返回true执行下一个拦截器    //如果返回false就不执行下一个拦截器    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        System.out.println(&quot;------------处理前------------&quot;);        return true;    &#125;    //在请求处理方法执行之后执行    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;------------处理后------------&quot;);    &#125;    //在dispatcherServlet处理后执行,做清理工作.    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;        System.out.println(&quot;------------清理------------&quot;);    &#125;&#125;\n\n4、在springmvc的配置文件中配置拦截器\n&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;!--/** 包括路径及其子路径--&gt;        &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;        &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;!--bean配置的就是拦截器--&gt;        &lt;bean class=&quot;com.fang.config.MyInterceptor&quot;/&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;\n\n5、编写一个Controller，接收请求\npackage com.fang.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;//测试拦截器的控制器@Controllerpublic class InterceptorController &#123;    @RequestMapping(&quot;interceptor&quot;)    @ResponseBody    public String testFunction()&#123;        System.out.println(&quot;控制器中方法执行了&quot;);        return &quot;hello&quot;;    &#125;&#125;\n\n7、启动tomcat 测试一下！\n\n","tags":["SpringMVC"]},{"title":"SpringMVC之接收请求参数及数据回显","url":"/2022/05/18/SpringMVC%E4%B9%8B%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE/","content":"处理提交数据1、提交的域名称和处理方法的参数名一致\n提交数据 : http://localhost:8080/hello?name=kuangshen\n处理方法 :\n@RequestMapping(&quot;/hello&quot;)public String hello(String name)&#123;   System.out.println(name);   return &quot;hello&quot;;&#125;\n\n2、提交的域名称和处理方法的参数名不一致\n提交数据 : http://localhost:8080/hello?username=kuangshen\n处理方法 :\n//@RequestParam(&quot;username&quot;) : username提交的域的名称 .@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name)&#123;   System.out.println(name);   return &quot;hello&quot;;&#125;\n\n3、提交的是一个对象\n要求提交的表单域和对象的属性名一致  , 参数使用对象即可\n1、实体类\npublic class User &#123;   private int id;   private String name;   private int age;   //构造   //get/set   //tostring()&#125;\n\n2、提交数据 : http://localhost:8080/mvc04/user?name=fang&amp;id=1&amp;age=15\n3、处理方法 :\n@RequestMapping(&quot;/user&quot;)public String user(User user)&#123;   System.out.println(user);   return &quot;hello&quot;;&#125;\n\n后台输出 : User { id&#x3D;1, name&#x3D;’fang’, age&#x3D;15 }\n说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。\n数据显示到前端第一种 : 通过ModelAndView\npublic class ControllerTest1 implements Controller &#123;   public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;       //返回一个模型视图对象       ModelAndView mv = new ModelAndView();       mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);       mv.setViewName(&quot;test&quot;);       return mv;  &#125;&#125;\n\n第二种 : 通过ModelMap\nModelMap\n@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model)&#123;   //封装要显示到视图中的数据   //相当于req.setAttribute(&quot;name&quot;,name);   model.addAttribute(&quot;name&quot;,name);   System.out.println(name);   return &quot;test&quot;;&#125;\n\n第三种 : 通过Model\nModel\n@RequestMapping(&quot;/ct2/hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123;   //封装要显示到视图中的数据   //相当于req.setAttribute(&quot;name&quot;,name);   model.addAttribute(&quot;msg&quot;,name);   System.out.println(name);   return &quot;test&quot;;&#125;\n\n对比就对于新手而言简单来说使用区别就是：\nModel 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。\n\n当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。\n请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。\n","tags":["SpringMVC"]},{"title":"SpringMVC之整合SSM框架","url":"/2022/05/21/SpringMVC%E4%B9%8B%E6%95%B4%E5%90%88SSM%E6%A1%86%E6%9E%B6/","content":"环境要求环境：\n\nIDEA\nMySQL 5.7.19\nTomcat 9\nMaven 3.6\n\n 要求：\n\n需要熟练掌握MySQL数据库，Spring，JavaWeb及MyBatis知识，简单的前端知识；\n\n数据库环境创建一个存放书籍数据的数据库表\nCREATE DATABASE `ssmbuild`;USE `ssmbuild`;DROP TABLE IF EXISTS `books`;CREATE TABLE `books` (                         `bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;书id&#x27;,                         `bookName` VARCHAR(100) NOT NULL COMMENT &#x27;书名&#x27;,                         `bookCounts` INT(11) NOT NULL COMMENT &#x27;数量&#x27;,                         `detail` VARCHAR(200) NOT NULL COMMENT &#x27;描述&#x27;,                         KEY `bookID` (`bookID`)) ENGINE=INNODB DEFAULT CHARSET=utf8;INSERT  INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES(1,&#x27;Java&#x27;,1,&#x27;从入门到放弃&#x27;);INSERT  INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES(2,&#x27;MySQL&#x27;,10,&#x27;从删库到跑路&#x27;);INSERT  INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES(3,&#x27;Linux&#x27;,5,&#x27;从进门到进牢&#x27;);\n\n基本环境搭建1、新建一Maven项目！ssmbuild ， 添加web的支持\n2、导入相关的pom依赖！\n&lt;dependencies&gt;    &lt;!--Junit--&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--数据库驱动--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.47&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 数据库连接池 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.mchange&lt;/groupId&gt;        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;        &lt;version&gt;0.9.5.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Servlet - JSP --&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;        &lt;version&gt;2.5&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;        &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;        &lt;version&gt;2.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;jstl&lt;/artifactId&gt;        &lt;version&gt;1.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Mybatis--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;        &lt;version&gt;2.0.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Spring--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n3、Maven资源过滤设置\n&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;\n\n4、建立基本结构和配置框架！\n\ncom.fang.pojo\ncom.fang.dao\ncom.fang.service\ncom.fang.controller\nmybatis-config.xml\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt;\n\n\napplicationContext.xml\n\nMybatis层编写1、数据库配置文件 database.properties\njdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useUnicode=true&amp;characterEncoding=utf-8jdbc.username =rootjdbc.password = 自己的密码\n\n2、IDEA关联数据库\n3、编写MyBatis的核心配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.fang.pojo&quot;/&gt;    &lt;/typeAliases&gt;    &lt;mappers&gt;        &lt;mapper resource=&quot;com/fang/dao/BookMapper.xml&quot;/&gt;    &lt;/mappers&gt;    &lt;/configuration&gt;\n\n4、编写数据库对应的实体类 com.fang.pojo.Books\n使用lombok插件！\npackage com.fang.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Books &#123;    private int bookID;    private String bookName;    private int bookCounts;    private String detail;&#125;\n\n5、编写Dao层的 Mapper接口！\npackage com.fang.dao;import com.fang.pojo.Books;import java.util.List;public interface BookMapper &#123;    //增加一个Book    int addBook(Books books);    //根据id删除一个Book    int deleteBookById(int id);    //更新Book    int updateBook(Books books);    ///根据id查询,返回一个Book    Books queryBookById(int id);    //查询全部Book,返回list集合    List&lt;Books&gt; queryAllBook();&#125;\n\n6、编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包；\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.fang.dao.BookMapper&quot;&gt;        &lt;!--增加一个Book--&gt;    &lt;insert id=&quot;addBook&quot; parameterType=&quot;Books&quot;&gt;        insert into ssmbuild.books(bookName, bookCounts, detail) values(#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;detail&#125;)    &lt;/insert&gt;    &lt;!--根据id删除一个Book--&gt;    &lt;delete id=&quot;deleteBookById&quot; parameterType=&quot;int&quot;&gt;        delete from ssmbuild.books where bookID=#&#123;bookID&#125;    &lt;/delete&gt;    &lt;!--更新Book--&gt;    &lt;update id=&quot;updateBook&quot; parameterType=&quot;Books&quot;&gt;        update ssmbuild.books        set bookName = #&#123;bookName&#125;,bookCounts = #&#123;bookCounts&#125;,detail = #&#123;detail&#125;        where bookID = #&#123;bookID&#125;    &lt;/update&gt;    &lt;!--根据id查询,返回一个Book--&gt;    &lt;select id=&quot;queryBookById&quot; resultType=&quot;Books&quot;&gt;        select * from ssmbuild.books        where bookID = #&#123;bookID&#125;    &lt;/select&gt;    &lt;!--查询全部Book--&gt;    &lt;select id=&quot;queryAllBook&quot; resultType=&quot;Books&quot;&gt;        SELECT * from ssmbuild.books    &lt;/select&gt;&lt;/mapper&gt;\n\n7、编写Service层的接口和实现类\n接口：\npackage com.fang.service;import com.fang.pojo.Books;import java.util.List;//BookService:底下需要去实现,调用dao层public interface BookService &#123;    //增加一个Book    int addBook(Books book);    //根据id删除一个Book    int deleteBookById(int id);    //更新Book    int updateBook(Books books);    //根据id查询,返回一个Book    Books queryBookById(int id);    //查询全部Book,返回list集合    List&lt;Books&gt; queryAllBook();&#125;\n\n实现类：\npackage com.fang.service;import com.fang.dao.BookMapper;import com.fang.pojo.Books;import java.util.List;public class BookServiceImpl implements BookService&#123;    //调用dao层的操作，设置一个set接口，方便Spring管理    private BookMapper bookMapper;    public void setBookMapper(BookMapper bookMapper)&#123;        this.bookMapper = bookMapper;    &#125;    @Override    public int addBook(Books book) &#123;        return bookMapper.addBook(book);    &#125;    @Override    public int deleteBookById(int id) &#123;        return bookMapper.deleteBookById(id);    &#125;    @Override    public int updateBook(Books books) &#123;        return bookMapper.updateBook(books);    &#125;    @Override    public Books queryBookById(int id) &#123;        return bookMapper.queryBookById(id);    &#125;    @Override    public List&lt;Books&gt; queryAllBook() &#123;        return bookMapper.queryAllBook();    &#125;&#125;\n\nSpring层1、配置Spring整合MyBatis，我们这里数据源使用c3p0连接池；\n2、我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 配置整合mybatis --&gt;    &lt;!-- 1.关联数据库文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;    &lt;!-- 2.数据库连接池 --&gt;    &lt;!--数据库连接池        dbcp 半自动化操作 不能自动连接        c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）    --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;!-- 配置连接池属性 --&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;        &lt;!-- c3p0连接池的私有属性 --&gt;        &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;        &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;        &lt;!-- 关闭连接后不自动commit --&gt;        &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;        &lt;!-- 获取连接超时时间 --&gt;        &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt;        &lt;!-- 当获取连接失败重试次数 --&gt;        &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 3.配置SqlSessionFactory对象 --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 注入数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;    &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;!-- 注入sqlSessionFactory --&gt;        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;        &lt;!-- 给出需要扫描Dao接口包 --&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.fang.dao&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n3、Spring整合service层\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;        &lt;!-- 扫描service相关的bean --&gt;        &lt;context:component-scan base-package=&quot;com.fang.service&quot;/&gt;        &lt;!--BookServiceImpl注入到IOC容器中--&gt;        &lt;bean id=&quot;BookServiceImpl&quot; class=&quot;com.fang.service.BookServiceImpl&quot;&gt;                &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt;        &lt;/bean&gt;        &lt;!-- 配置事务管理器 --&gt;        &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;                &lt;!-- 注入数据库连接池 --&gt;                &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;/bean&gt;&lt;/beans&gt;\n\nSpringMVC层1、web.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;!--DispatcherServlet--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;!--encodingFilter--&gt;    &lt;filter&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;utf-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;!--Session过期时间--&gt;    &lt;session-config&gt;        &lt;session-timeout&gt;15&lt;/session-timeout&gt;    &lt;/session-config&gt;&lt;/web-app&gt;\n\n2、spring-mvc.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/mvc   https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!-- 配置SpringMVC --&gt;    &lt;!-- 1.开启SpringMVC注解驱动 --&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!-- 2.静态资源默认servlet配置--&gt;    &lt;mvc:default-servlet-handler/&gt;    &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 4.扫描web相关的bean --&gt;    &lt;context:component-scan base-package=&quot;com.fang.controller&quot;/&gt;&lt;/beans&gt;\n\n3、Spring配置整合文件，applicationContext.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;import resource=&quot;spring-dao.xml&quot;/&gt;    &lt;import resource=&quot;spring-service.xml&quot;/&gt;    &lt;import resource=&quot;spring-mvc.xml&quot;/&gt;&lt;/beans&gt;\n\n配置文件，暂时结束！Controller 和 视图层编写\n1、BookController 类编写 ， 方法一：查询全部书籍\npackage com.fang.controller;import com.fang.pojo.Books;import com.fang.service.BookService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;@Controller@RequestMapping(&quot;/book&quot;)public class BookController &#123;    @Autowired    @Qualifier(&quot;BookServiceImpl&quot;)    private BookService bookService;    @RequestMapping(&quot;/allBook&quot;)    public String list(Model model)&#123;        List&lt;Books&gt; list = bookService.queryAllBook();        model.addAttribute(&quot;list&quot;,list);        return &quot;allBook&quot;;    &#125;&#125;\n\n2、编写首页 index.jsp\n&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;首页&lt;/title&gt;  &lt;style type=&quot;text/css&quot;&gt;    a &#123;      text-decoration: none;      color: black;      font-size: 18px;    &#125;    h3 &#123;      width: 180px;      height: 38px;      margin: 100px auto;      text-align: center;      line-height: 38px;      background: deepskyblue;      border-radius: 4px;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;  &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/allBook&quot;&gt;点击进入列表页&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;\n\n3、书籍列表页面 allbook.jsp\n&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;书籍列表&lt;/title&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;!-- 引入 Bootstrap --&gt;    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;row clearfix&quot;&gt;        &lt;div class=&quot;col-md-12 column&quot;&gt;            &lt;div class=&quot;page-header&quot;&gt;                &lt;h1&gt;                    &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;                &lt;/h1&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-md-4 column&quot;&gt;            &lt;a class=&quot;btn btn-primary&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toAddBook&quot;&gt;新增&lt;/a&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;row clearfix&quot;&gt;        &lt;div class=&quot;col-md-12 column&quot;&gt;            &lt;table class=&quot;table table-hover table-striped&quot;&gt;                &lt;thead&gt;                &lt;tr&gt;                    &lt;th&gt;书籍编号&lt;/th&gt;                    &lt;th&gt;书籍名字&lt;/th&gt;                    &lt;th&gt;书籍数量&lt;/th&gt;                    &lt;th&gt;书籍详情&lt;/th&gt;                    &lt;th&gt;操作&lt;/th&gt;                &lt;/tr&gt;                &lt;/thead&gt;                &lt;tbody&gt;                &lt;c:forEach var=&quot;book&quot; items=&quot;$&#123;requestScope.get(&#x27;list&#x27;)&#125;&quot;&gt;                    &lt;tr&gt;                        &lt;td&gt;$&#123;book.getBookID()&#125;&lt;/td&gt;                        &lt;td&gt;$&#123;book.getBookName()&#125;&lt;/td&gt;                        &lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;/td&gt;                        &lt;td&gt;$&#123;book.getDetail()&#125;&lt;/td&gt;                        &lt;td&gt;                            &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toUpdateBook?id=$&#123;book.getBookID()&#125;&quot;&gt;更改&lt;/a&gt; |                            &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/del/$&#123;book.getBookID()&#125;&quot;&gt;删除&lt;/a&gt;                        &lt;/td&gt;                    &lt;/tr&gt;                &lt;/c:forEach&gt;                &lt;/tbody&gt;            &lt;/table&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;\n\n4、BookController 类编写 ， 方法二：添加书籍\n@RequestMapping(&quot;/toAddBook&quot;)public String toAddPaper()&#123;    return &quot;addBook&quot;;&#125;@RequestMapping(&quot;/addBook&quot;)public String addPaper(Books books)&#123;    System.out.println(books);    bookService.addBook(books);    return &quot;redirect:/book/allBook&quot;;&#125;\n\n5、添加书籍页面：addBook.jsp\n&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;新增书籍&lt;/title&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;!-- 引入 Bootstrap --&gt;  &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;row clearfix&quot;&gt;    &lt;div class=&quot;col-md-12 column&quot;&gt;      &lt;div class=&quot;page-header&quot;&gt;        &lt;h1&gt;          &lt;small&gt;新增书籍&lt;/small&gt;        &lt;/h1&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/addBook&quot; method=&quot;post&quot;&gt;    书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;    书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;    书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt;  &lt;/form&gt;&lt;/div&gt;\n\n6、BookController 类编写 ， 方法三：修改书籍\n@RequestMapping(&quot;/toUpdateBook&quot;)public String toUpdateBook(Model model, int id) &#123;   Books books = bookService.queryBookById(id);   System.out.println(books);   model.addAttribute(&quot;book&quot;,books );   return &quot;updateBook&quot;;&#125;@RequestMapping(&quot;/updateBook&quot;)public String updateBook(Model model, Books book) &#123;   System.out.println(book);   bookService.updateBook(book);   Books books = bookService.queryBookById(book.getBookID());   model.addAttribute(&quot;books&quot;, books);   return &quot;redirect:/book/allBook&quot;;&#125;\n\n7、修改书籍页面  updateBook.jsp\n&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;修改信息&lt;/title&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;!-- 引入 Bootstrap --&gt;    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;row clearfix&quot;&gt;        &lt;div class=&quot;col-md-12 column&quot;&gt;            &lt;div class=&quot;page-header&quot;&gt;                &lt;h1&gt;                    &lt;small&gt;修改信息&lt;/small&gt;                &lt;/h1&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/updateBook&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;hidden&quot; name=&quot;bookID&quot; value=&quot;$&#123;book.getBookID()&#125;&quot;/&gt;        书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot; value=&quot;$&#123;book.getBookName()&#125;&quot;/&gt;        书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot; value=&quot;$&#123;book.getBookCounts()&#125;&quot;/&gt;        书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot; value=&quot;$&#123;book.getDetail() &#125;&quot;/&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;    &lt;/form&gt;&lt;/div&gt;\n\n8、BookController 类编写 ， 方法四：删除书籍\n@RequestMapping(&quot;/del/&#123;bookId&#125;&quot;)public String deleteBook(@PathVariable(&quot;bookId&quot;) int id) &#123;   bookService.deleteBookById(id);   return &quot;redirect:/book/allBook&quot;;&#125;\n\n配置Tomcat，进行运行！\n项目结构图 :allbook-&gt;allBook\n\n","tags":["SpringMVC"]},{"title":"SpringMVC之文件上传和下载回顾","url":"/2022/05/23/SpringMVC%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E5%9B%9E%E9%A1%BE/","content":"文件上传1、导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包；\n&lt;!--文件上传--&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--servlet-api导入高版本的--&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt;\n\n2、配置bean：multipartResolver\n【注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！】\n&lt;!--文件上传配置--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;    &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;    &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;    &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;&lt;/bean&gt;\n\nCommonsMultipartFile 的 常用方法：\n\nString getOriginalFilename()：获取上传文件的原名\nInputStream getInputStream()：获取文件流\nvoid transferTo(File dest)：将上传文件保存到一个目录文件中\n\n 我们去实际测试一下\n3、编写前端页面\n&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;    &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;&lt;/form&gt;\n\n4、Controller\npackage com.fang.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.commons.CommonsMultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.*;@Controllerpublic class FileController &#123;    //@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象    //批量上传CommonsMultipartFile则为数组即可    @RequestMapping(&quot;/upload&quot;)    public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123;        //获取文件名 : file.getOriginalFilename();        String uploadFileName = file.getOriginalFilename();        //如果文件名为空，直接回到首页！        if (&quot;&quot;.equals(uploadFileName))&#123;            return &quot;redirect:/index.jsp&quot;;        &#125;        System.out.println(&quot;上传文件名 : &quot;+uploadFileName);        //上传路径保存设置        String path = request.getServletContext().getRealPath(&quot;/upload&quot;);        //如果路径不存在，创建一个        File realPath = new File(path);        if (!realPath.exists())&#123;            realPath.mkdir();        &#125;        System.out.println(&quot;上传文件保存地址：&quot;+realPath);        InputStream is = file.getInputStream(); //文件输入流        OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流        //读取写出        int len=0;        byte[] buffer = new byte[1024];        while ((len=is.read(buffer))!=-1)&#123;            os.write(buffer,0,len);            os.flush();        &#125;        os.close();        is.close();        return &quot;redirect:/index.jsp&quot;;    &#125;&#125;\n\n采用file.Transto 来保存上传的文件\n1、编写Controller\n/* * 采用file.Transto 来保存上传的文件 */@RequestMapping(&quot;/upload2&quot;)public String  fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123;    //上传路径保存设置    String path = request.getServletContext().getRealPath(&quot;/upload&quot;);    File realPath = new File(path);    if (!realPath.exists())&#123;        realPath.mkdir();    &#125;    //上传文件地址    System.out.println(&quot;上传文件保存地址：&quot;+realPath);    //通过CommonsMultipartFile的方法直接写文件（注意这个时候）    file.transferTo(new File(realPath +&quot;/&quot;+ file.getOriginalFilename()));    return &quot;redirect:/index.jsp&quot;;&#125;\n\n2、前端表单提交地址修改\n3、访问提交测试，OK！\n文件下载文件下载步骤：\n1、设置 response 响应头\n2、读取文件 – InputStream\n3、写出文件 – OutputStream\n4、执行操作\n5、关闭流 （先开后关）\n代码实现：\npackage com.fang.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.net.URLEncoder;@Controllerpublic class FileController &#123;    @RequestMapping(value=&quot;/download&quot;)    public String downloads(HttpServletResponse response , HttpServletRequest request) throws Exception&#123;        //要下载的图片地址        String  path = request.getServletContext().getRealPath(&quot;/upload&quot;);        String  fileName = &quot;百度地图导航.html&quot;;        //1、设置response 响应头        response.reset(); //设置页面不缓存,清空buffer        response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码        response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据        //设置响应头        response.setHeader(&quot;Content-Disposition&quot;,                &quot;attachment;fileName=&quot;+ URLEncoder.encode(fileName, &quot;UTF-8&quot;));        File file = new File(path,fileName);        //2、 读取文件--输入流        InputStream input=new FileInputStream(file);        //3、 写出文件--输出流        OutputStream out = response.getOutputStream();        byte[] buff =new byte[1024];        int index=0;        //4、执行 写出操作        while((index= input.read(buff))!= -1)&#123;            out.write(buff, 0, index);            out.flush();        &#125;        out.close();        input.close();        return null;    &#125;   &#125;\n\n前端\n&lt;a href=&quot;/download&quot;&gt;点击下载&lt;/a&gt;\n","tags":["SpringMVC"]},{"title":"SpringMVC之登录判断验证","url":"/2022/05/22/SpringMVC%E4%B9%8B%E7%99%BB%E5%BD%95%E5%88%A4%E6%96%AD%E9%AA%8C%E8%AF%81/","content":"实现思路1、有一个登陆页面，需要写一个controller访问页面。\n2、登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。返回登陆成功。\n3、拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面\n测试：1、编写一个登陆页面  login.jsp\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/login&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n2、在创建一个success.jsp\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;fang&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;nihao&lt;/h4&gt;$&#123;user&#125;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/logout&quot;/&gt;注销&lt;/body&gt;&lt;/html&gt;\n\n3、编写一个Controller处理请求\npackage com.fang.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpSession;@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123;    //跳转到登录页面    @RequestMapping(&quot;/jumpLogin&quot;)    public String jumpLogin()&#123;        return &quot;login&quot;;    &#125;    //跳转到成功页面    @RequestMapping(&quot;jumpSuccess&quot;)    public String jumpSuccess()&#123;        return &quot;success&quot;;    &#125;    //登陆提交    @RequestMapping(&quot;login&quot;)    public String login(HttpSession session,String username,String pwd)&#123;        //向session记录用户的信息        System.out.println(&quot;接收前端信息===&quot;+username);        session.setAttribute(&quot;user&quot;,username);        return &quot;success&quot;;    &#125;    //退出登录    @RequestMapping(&quot;logout&quot;)    public String logout(HttpSession session)&#123;        //session过期        session.removeAttribute(&quot;user&quot;);        return &quot;login&quot;;    &#125;&#125;\n\n4、在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;$Title$&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;hr&gt;&lt;%--登录--%&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumpLogin&quot;&gt;登录&lt;/a&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumpSuccess&quot;&gt;成功页面&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&lt;/body&gt;&lt;/html&gt;\n\n5、编写用户登录拦截器\npackage com.fang.config;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LoginInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        //如果是登录页面则放行        System.out.println(&quot;url:&quot;+request.getRequestURI());        if (request.getRequestURI().contains(&quot;login&quot;))&#123;            return true;        &#125;        HttpSession session = request.getSession();        //如果用户已经登录也放行        if (session.getAttribute(&quot;user&quot;)!=null)&#123;            return true;        &#125;        //用户没有登录跳转到登陆页面        request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request,response);        return false;            &#125;&#125;\n\n6、在Springmvc的配置文件中注册拦截器\n&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;!--/** 包括路径及其子路径--&gt;        &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;        &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;!--bean配置的就是拦截器--&gt;        &lt;bean class=&quot;com.fang.config.LoginInterceptor&quot;/&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;\n\n7、再次重启Tomcat测试！\n","tags":["SpringMVC"]},{"title":"SpringMVC之第一个MVC程序","url":"/2022/05/17/SpringMVC%E4%B9%8B%E7%AC%AC%E4%B8%80%E4%B8%AAMVC%E7%A8%8B%E5%BA%8F/","content":"1.配置版1、新建一个Moudle ， springmvc-02-hello ， 添加web的支持！\n2、确定导入了SpringMVC 的依赖！\n3、配置web.xml  ， 注册DispatcherServlet\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;!--1.注册DispatcherServlet--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!--启动级别-1--&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;    &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n4、编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml  : [servletname]-servlet.xml\n说明，这里的名称要求是按照官方来的\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt;\n\n5、添加 处理映射器\n&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;\n\n6、添加 处理器适配器\n&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;\n\n7、添加 视图解析器\n&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;    &lt;!--前缀--&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;    &lt;!--后缀--&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;\n\n8、编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图；\npackage com.fang.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//注意：这里我们先导入Controller接口public class HelloController implements Controller &#123;    @Override    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;        //ModelAndView 模型和视图        ModelAndView mv = new ModelAndView();        //封装对象，放在ModelAndView中。Model        mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC!&quot;);        //封装要跳转的视图，放在ModelAndView中        mv.setViewName(&quot;hello&quot;);//: /WEB-INF/jsp/hello.jsp        return mv;    &#125;&#125;\n\n9、将自己的类交给SpringIOC容器，注册bean\n&lt;bean id=&quot;/hello&quot; class=&quot;com.fang.controller.HelloController&quot;/&gt;\n\n10、写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面；\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;fang&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt;\n\n可能遇到的问题：访问出现404，排查步骤：\n\n查看控制台输出，看一下是不是缺少了什么jar包。\n如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！\n重启Tomcat 即可解决！\n\n\n2.注解版1、新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！\n2、由于Maven可能存在资源过滤的问题，我们将配置完善\n&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;false&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;\n\n3、在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！\n4、配置web.xml\n注意点：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;!--1.注册DispatcherServlet--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;    &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n&#x2F; 和 &#x2F;* 的区别：&lt; url-pattern &gt; &#x2F; &lt;&#x2F; url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; &#x2F;* &lt;&#x2F; url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。\n\n\n注意web.xml版本问题，要最新版！\n注册DispatcherServlet\n关联SpringMVC的配置文件\n启动级别为1\n映射路径为 &#x2F; 【不要用&#x2F;*，会404】\n\n\n\n5、添加Spring MVC配置文件\n在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/mvc       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;    &lt;context:component-scan base-package=&quot;com.fang.controller&quot;/&gt;    &lt;!-- 让Spring MVC不处理静态资源 --&gt;    &lt;mvc:default-servlet-handler /&gt;    &lt;!--    支持mvc注解驱动        在spring中一般采用@RequestMapping注解来完成映射关系        要想使@RequestMapping注解生效        必须向上下文中注册DefaultAnnotationHandlerMapping        和一个AnnotationMethodHandlerAdapter实例        这两个实例分别在类级别和方法级别处理。        而annotation-driven配置帮助我们自动完成上述两个实例的注入。     --&gt;    &lt;mvc:annotation-driven /&gt;    &lt;!-- 视图解析器 --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;          id=&quot;internalResourceViewResolver&quot;&gt;        &lt;!-- 前缀 --&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;        &lt;!-- 后缀 --&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n在视图解析器中我们把所有的视图都存放在&#x2F;WEB-INF&#x2F;目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。\n\n\n让IOC的注解生效\n静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …..\nMVC的注解驱动\n配置视图解析器\n\n\n\n6、创建Controller\n编写一个Java控制类：com.fang.controller.HelloController , 注意编码规范\npackage com.fang.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Controller@RequestMapping(&quot;/HelloController&quot;)public class HelloController  &#123;    @RequestMapping(&quot;hello&quot;)    public String sayHello(Model model)&#123;        //向模型中添加属性msg与值，可以在JSP页面中取出并渲染        model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;);        //web-inf/jsp/hello.jsp        return &quot;hello&quot;;    &#125;&#125;\n\n\n@Controller是为了让Spring IOC容器初始化时自动扫描到；\n@RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是&#x2F;HelloController&#x2F;hello；\n方法中声明Model类型的参数是为了把Action中的数据带到视图中；\n方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF&#x2F;jsp&#x2F;hello.jsp。\n\n7、创建视图层\n在WEB-INF&#x2F; jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息；\n可以通过EL表示取出Model中存放的值，或者对象；\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;fang&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt;\n\n8、配置Tomcat运行\n配置Tomcat ，  开启服务器 ， 访问 对应的请求路径！\n3.小结实现步骤其实非常的简单：\n\n新建一个web项目\n导入相关jar包\n编写web.xml , 注册DispatcherServlet\n编写springmvc配置文件\n接下来就是去创建对应的控制类 , controller\n最后完善前端视图和controller之间的对应\n测试运行调试.\n\n使用springMVC必须配置的三大件：\n处理器映射器、处理器适配器、视图解析器\n通常，我们只需要手动配置视图解析器，而处理器映射器和处理器适配器只需要开启注解驱动即可，而省去了大段的xml配置\n","tags":["SpringMVC"]},{"title":"Spring之AOP","url":"/2022/05/11/Spring%E4%B9%8BAOP/","content":"1.什么是AOPAOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n\n2.AOP在Spring中的作用提供声明式事务；允许用户自定义切面 \n\n横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 …. \n切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 \n通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 \n目标（Target）：被通知对象。 \n代理（Proxy）：向目标对象应用通知之后创建的对象。 \n切入点（PointCut）：切面通知 执行的 “地点”的定义。 \n连接点（JointPoint）：与切入点匹配的执行点。\n\n\nSpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：\n\n即 AOP 在 不改变原有代码的情况下 , 去增加新的功能 \n3.使用Spring实现AOP【重点】使用AOP织入，需要导入一个依赖包！\n&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;    &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt;\n\n1.第一种方式：通过 Spring API 实现首先编写我们的业务接口和实现类：\npublic interface UserService &#123;   public void add();   public void delete();   public void update();   public void search();&#125;\n\npublic class UserServiceImpl implements UserService &#123;    @Override    public void add() &#123;        System.out.println(&quot;增加了一个用户&quot;);    &#125;    @Override    public void delete() &#123;        System.out.println(&quot;删除了一个用户&quot;);    &#125;    @Override    public void update() &#123;        System.out.println(&quot;更新了一个用户&quot;);    &#125;    @Override    public void search() &#123;        System.out.println(&quot;查询了一个用户&quot;);    &#125;&#125;\n\n然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强\npublic class Log implements MethodBeforeAdvice &#123;    //要执行的目标对象的方法    //objects : 被调用的方法的参数    //Object : 目标对象    @Override    public void before(Method method, Object[] objects, Object o) throws Throwable &#123;        System.out.println(o.getClass().getName()+&quot;的&quot;+method.getName()+&quot;方法被执行了&quot;);    &#125;&#125;\n\npublic class AfterLog implements AfterReturningAdvice &#123;    //returnValue 返回值 o    //method被调用的方法    //args 被调用的方法的对象的参数    //target 被调用的目标对象 o1    @Override    public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable &#123;        System.out.println(&quot;执行了&quot;+o1.getClass().getName()+&quot;的&quot;+method.getName()+&quot;方法,&quot;+&quot;返回值&quot;+o);    &#125;&#125;\n\n最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--注册bean--&gt;    &lt;bean id=&quot;userService&quot; class =&quot;com.fang.demo.UserServiceImpl&quot;/&gt;    &lt;bean id=&quot;log&quot; class =&quot;com.fang.demo.Log&quot;/&gt;    &lt;bean id=&quot;afterLog&quot; class =&quot;com.fang.demo.AfterLog&quot;/&gt;    &lt;!--aop的配置--&gt;    &lt;aop:config&gt;        &lt;!--切入点 expression:表达式匹配要执行的方法--&gt;        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.fang.demo.UserServiceImpl.*(..))&quot;/&gt;        &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;        &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;        &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n\n测试\npublic class test &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //动态代理的是接口        UserService userService = (UserService) context.getBean(&quot;userService&quot;);        userService.delete();    &#125;&#125;\n\nAOP的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 . \nSpring的AOP就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 .\n第二种方式：自定义类来实现Ao目标业务类不变依旧是userServiceImpl\n第一步 : 写我们自己的一个切入类\npublic class DiyPointcut &#123;    public void before()&#123;        System.out.println(&quot;---------方法执行前---------&quot;);    &#125;    public void after()&#123;        System.out.println(&quot;---------方法执行后---------&quot;);    &#125;&#125;\n\n​    第二步 : 去spring中配置\n    &lt;!--第二种方式自定义实现--&gt;    &lt;!--注册bean--&gt;    &lt;bean id=&quot;diy&quot; class=&quot;com.fang.demo.DiyPointcut&quot;/&gt;    &lt;bean id=&quot;userService&quot; class =&quot;com.fang.demo.UserServiceImpl&quot;/&gt;    &lt;!--aop的配置--&gt;    &lt;aop:config&gt;        &lt;!--第二种方式：使用AOP的标签实现--&gt;        &lt;aop:aspect ref=&quot;diy&quot;&gt;            &lt;aop:pointcut id=&quot;diyPointcut&quot; expression=&quot;execution(* com.fang.demo.UserServiceImpl.*(..))&quot;/&gt;            &lt;aop:before pointcut-ref=&quot;diyPointcut&quot; method=&quot;before&quot;/&gt;            &lt;aop:after pointcut-ref=&quot;diyPointcut&quot; method=&quot;after&quot;/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n\n第三步：测试\npublic class test &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //动态代理的是接口        UserService userService = (UserService) context.getBean(&quot;userService&quot;);        userService.add();    &#125;&#125;\n\n第三种方式：使用注解实现第一步：编写一个注解实现的增强类\npackage com.fang.demo;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class AnnotationPointcut &#123;    @Before(&quot;execution(* com.fang.demo.UserServiceImpl.*(..))&quot;)    public void before()&#123;        System.out.println(&quot;---------方法执行前---------&quot;);    &#125;    @After(&quot;execution(* com.fang.demo.UserServiceImpl.*(..))&quot;)    public void after()&#123;        System.out.println(&quot;---------方法执行后---------&quot;);    &#125;    @Around(&quot;execution(* com.fang.demo.UserServiceImpl.*(..))&quot;)    public void around(ProceedingJoinPoint jp) throws Throwable &#123;        System.out.println(&quot;环绕前&quot;);        System.out.println(&quot;签名:&quot;+jp.getSignature());//执行目标方法proceed        Object proceed = jp.proceed();        System.out.println(&quot;环绕后&quot;);        System.out.println(proceed);    &#125;&#125;\n\n第二步：在Spring配置文件中，注册bean，并增加支持注解的配置\n&lt;!--第三种方式:注解实现--&gt;&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.fang.demo.AnnotationPointcut&quot;/&gt;&lt;bean id=&quot;userService&quot; class =&quot;com.fang.demo.UserServiceImpl&quot;/&gt;&lt;aop:aspectj-autoproxy/&gt;\n\naop:aspectj-autoproxy：说明\n通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。\n\n第三步：测试：\npublic class test &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //动态代理的是接口        UserService userService = (UserService) context.getBean(&quot;userService&quot;);        userService.add();    &#125;&#125;//输出环绕前签名:void com.fang.demo.UserService.add()---------方法执行前---------增加了一个用户环绕后null---------方法执行后---------\n\n","tags":["Spring"]},{"title":"SpringMVC之重定向与转发","url":"/2022/05/18/SpringMVC%E4%B9%8B%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E8%BD%AC%E5%8F%91/","content":"ModelAndView设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 .\n页面 : {视图解析器前缀} + viewName +{视图解析器后缀}\n&lt;!-- 视图解析器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;      id=&quot;internalResourceViewResolver&quot;&gt;    &lt;!-- 前缀 --&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;    &lt;!-- 后缀 --&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt;\n\n对应的controller类\npublic class ControllerTest1 implements Controller &#123;   public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;       //返回一个模型视图对象       ModelAndView mv = new ModelAndView();       mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);       mv.setViewName(&quot;test&quot;);       return mv;  &#125;&#125;\n\nServletAPI通过设置ServletAPI , 不需要视图解析器 .\n1、通过HttpServletResponse进行输出\n2、通过HttpServletResponse实现重定向\n3、通过HttpServletResponse实现转发\n@Controllerpublic class ResultGo &#123;   @RequestMapping(&quot;/result/t1&quot;)   public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;       rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;);  &#125;   @RequestMapping(&quot;/result/t2&quot;)   public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;       rsp.sendRedirect(&quot;/index.jsp&quot;);  &#125;   @RequestMapping(&quot;/result/t3&quot;)   public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123;       //转发       req.setAttribute(&quot;msg&quot;,&quot;/result/t3&quot;);       req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,rsp);  &#125;&#125;\n\nSpringMVC通过SpringMVC来实现转发和重定向 - 无需视图解析器；\n测试前，需要将视图解析器注释掉\n@Controllerpublic class RestFulController &#123;    //映射访问路径    @RequestMapping(&quot;/rc/r1&quot;)    public String index()&#123;        //转发        return &quot;/WEB-INF/jsp/test.jsp&quot;;    &#125;    @RequestMapping(&quot;/rc/r2&quot;)    public String index2()&#123;        //转发二        return &quot;forward:/WEB-INF/jsp/test.jsp&quot;;    &#125;    @RequestMapping(&quot;/rc/r3&quot;)    public String index3()&#123;        //重定向        return &quot;redirect:/WEB-INF/jsp/test.jsp&quot;;    &#125;&#125;\n\n通过SpringMVC来实现转发和重定向 - 有视图解析器；\n重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题.\n可以重定向到另外一个请求实现 .\n@Controllerpublic class ResultSpringMVC2 &#123;   @RequestMapping(&quot;/rsm2/t1&quot;)   public String test1()&#123;       //转发       return &quot;test&quot;;  &#125;   @RequestMapping(&quot;/rsm2/t2&quot;)   public String test2()&#123;       //重定向       return &quot;redirect:/WEB-INF/jsp/test.jsp&quot;;       //return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/  &#125;&#125;\n","tags":["SpringMVC"]},{"title":"Spring之IOC创建对象方式","url":"/2022/05/08/Spring%E4%B9%8BIOC%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/","content":"通过无参构造方式来创建\nUser.java\n\npublic class User &#123;    private String name;    public User() &#123;        System.out.println(&quot;无参构造&quot;);    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void show()&#123;        System.out.println(&quot;name = &quot;+name);    &#125;&#125;\n\n\nbeans.xml\n\n&lt;bean id=&quot;user&quot; class=&quot;com.fang.pojo.User&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;xiaoxiao&quot;/&gt;&lt;/bean&gt;\n\n\n测试类\n\npublic class test &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        //在执行getBean的时候, user已经创建好了 , 通过无参构造        User user = (User) context.getBean(&quot;user&quot;);        //调用对象的方法 .        user.show();    &#125;&#125;//输出无参构造name = xiaoxiao\n\n结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！\n通过有参构造方法来创建\nUserT . java\n\npublic class UserT &#123;    private String name;    public UserT(String name) &#123;        this.name = name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void show()&#123;        System.out.println(&quot;name=&quot;+ name );    &#125;&#125;\n\n\nbeans.xml 有三种方式编写\n\n&lt;bean id=&quot;userT&quot; class=&quot;com.fang.pojo.UserT&quot;&gt;    &lt;!-- index指构造方法 , 下标从0开始 --&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;xiao1&quot;/&gt;&lt;/bean&gt;\n\n&lt;!-- 第二种根据参数名字设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.fang.pojo.UserT&quot;&gt;    &lt;!-- name指参数名 --&gt;    &lt;constructor-arg name=&quot;name&quot; value=&quot;xiao2&quot;/&gt;&lt;/bean&gt;\n\n&lt;!-- 第三种根据参数类型设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.fang.pojo.UserT&quot;&gt;    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;xiao3&quot;/&gt;&lt;/bean&gt;\n\n\n测试\n\npublic class test &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        UserT user = (UserT) context.getBean(&quot;userT&quot;);        user.show();    &#125;&#125;\n\n结论：在配置文件加载的时候。其中管理的对象都已经初始化了！\n","tags":["Spring"]},{"title":"Spring之IOC本质","url":"/2022/05/08/Spring%E4%B9%8BIOC%E6%9C%AC%E8%B4%A8/","content":"控制反转IOC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IOC的一种方法，也有人认为DI只是IOC的另一种说法。没有IOC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。\n\n\nIOC是Spring框架的核心内容，使用多种方式完美的实现了IOC，可以使用XML配置，也可以使用注解， 新版本的Spring也可以零配置实现IOC。 \nSpring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。\n\n\n\n采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为 一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 \n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IOC容器，其实现方法是依赖注入（Dependency Injection,DI）。\n","tags":["Spring"]},{"title":"Spring之Spring简介","url":"/2022/05/08/Spring%E4%B9%8BSpring%E7%AE%80%E4%BB%8B/","content":"Spring概述\nSpring简介\nSpring : 春天 —&gt;给软件行业带来了春天 \n2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。 \n2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版。 \n很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。 \nSpring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术\n\n官网 : http://spring.io/ \n官方下载地址 : https://repo.spring.io/libs-release-local/org/springframework/spring/ \nGitHub : https://github.com/spring-projects\n优点\nSpring是一个开源免费的框架 , 容器 . \nSpring是一个轻量级的框架 , 非侵入式的 . \n控制反转 IOC , 面向切面 AOP \n对事物的支持 , 对框架的支持 \n一句话概括：Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器（框架）。\n\n组成\n　Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式，组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。\n\n每个模块的功能如下：\n   核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。\n   Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。\n   Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。\n   Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。\n   Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。\n   Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。\n   Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。\n　　Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。\n拓展Spring Boot与Spring Cloud ：\n\nSpring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务; \nSpring Cloud是基于Spring Boot实现的； \nSpring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； \nSpring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使 用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。 \nSpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习 SpringBoot。\n\n","tags":["Spring"]},{"title":"Spring之IOC理论推导","url":"/2022/05/08/Spring%E4%B9%8BIOC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC/","content":"IOC基础原来方式我们先用我们原来的方式写一段代码 .\n\n先写一个UserDao接口\n\npublic interface UserDao &#123;    public void getUser();&#125;\n\n\n再去写Dao的实现类\n\npublic class UserDaoImpl implements UserDao&#123;    @Override    public void getUser() &#123;        System.out.println(&quot;获取用户暑假&quot;);    &#125;&#125;\n\n\n然后去写UserService的接口\n\npublic interface UserService &#123;    public void getUser();&#125;\n\n\n最后写Service的实现类\n\npublic class UserServiceImpl implements  UserService&#123;    private UserDao userDao = new UserDaoImpl();    @Override    public void getUser() &#123;        userDao.getUser();    &#125;&#125;\n\n\n测试\n\npublic class test &#123;    public static void main(String[] args) &#123;        UserService service = new UserServiceImpl();        service.getUser();    &#125;&#125;\n\n6.把Userdao的实现类增加一个 .\npublic class UserDaoMySqlImpl implements UserDao &#123;    @Override    public void getUser() &#123;        System.out.println(&quot;MySql获取用户数据&quot;);    &#125;&#125;\n\n\n紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现\n\npublic class UserServiceImpl implements  UserService&#123;    private UserDao userDao = new UserDaoMySqlImpl();    @Override    public void getUser() &#123;        userDao.getUser();    &#125;&#125;\n\n假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一 发而动全身 .\nIOC思想那我们如何去解决呢 ?\n\n我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set\n\npublic class UserServiceImpl implements  UserService&#123;    private UserDao userDao;    public void setUserDao(UserDao userDao) &#123;        this.userDao = userDao;    &#125;    @Override    public void getUser() &#123;        userDao.getUser();    &#125;&#125;\n\n\n测试\n\npublic class test &#123;    public static void main(String[] args) &#123;        UserService service = new UserServiceImpl();        ((UserServiceImpl)service).setUserDao(new UserDaoMySqlImpl());        service.getUser();        //又去实现UserDaoImpl        ((UserServiceImpl)service).setUserDao(new UserDaoImpl());        service.getUser();    &#125;&#125;\n\n\n以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 . \n这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !\n\n","tags":["Spring"]},{"title":"Spring之xml实现IOC","url":"/2022/05/08/Spring%E4%B9%8Bxml%E5%AE%9E%E7%8E%B0IOC/","content":"在上一个代码的基础上进行修改\n\n编写我们的spring文件 , 这里我们命名为beans.xml\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--bean就是java对象 , 由Spring创建和管理--&gt;    &lt;!--下面的两个就是我们接口的实现类--&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.fang.Dao.UserDaoImpl&quot;/&gt;    &lt;bean id=&quot;mysql&quot; class=&quot;com.fang.Dao.UserDaoMySqlImpl&quot;/&gt;     &lt;!--下面的这个就是我们业务层调用接口实现类的方法 就是set注入--&gt;    &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.fang.Service.UserServiceImpl&quot;&gt;        &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;        &lt;!--引用另外一个bean , 不是用value（具体的值 基本数据类型） 而是用 ref（引用spring创建好的值）--&gt;        &lt;property name=&quot;userDao&quot; ref=&quot;mysql&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n测试\n\npublic class test &#123;    public static void main(String[] args) &#123;        //解析beans.xml文件 , 生成管理相应的Bean对象        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        //getBean : 参数即为spring配置文件中bean的id .        UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(&quot;ServiceImpl&quot;);        serviceImpl.getUser();    &#125;&#125;\n\n思考：\n\nuser对象是谁创建的 ? 【 user对象是由Spring创建的 】\nuser对象的属性是怎么设置的 ? 【user对象的属性是由Spring容器设置的 】\n\n这个过程就叫控制反转 : \n\n控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 \n反转 : 程序本身不创建对象 , 而变成被动的接收对象 .\n\n依赖注入 : 就是利用set方法来进行注入的. \nIOC是一种编程思想，由主动的编程变成被动的接收 可以通过new ClassPathXmlApplicationContext去浏览一下底层源码 .到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IOC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !\n","tags":["Spring"]},{"title":"Spring之代理模式","url":"/2022/05/10/Spring%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","content":"为什么要学习代理模式，因为AOP的底层机制就是动态代理！ \n代理模式： \n\n静态代理\n动态代理\n\n\n1.静态代理静态代理角色分析 \n\n抽象角色 : 一般使用接口或者抽象类来实现 \n真实角色 : 被代理的角色 \n代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 . \n客户 : 使用代理角色来进行一些操作 .\n\n代码实现\nRent . java 即抽象角色\n//抽象角色：租房public interface Rent &#123;    public void rent();&#125;\n\nHost . java 即真实角色\n//真实角色: 房东，房东要出租房子public class Host implements Rent&#123;    @Override    public void rent() &#123;        System.out.println(&quot;房东要出租房子&quot;);    &#125;&#125;\n\nProxy . java 即代理角色\npublic class Proxy implements Rent&#123;    private Host host;    public Proxy() &#123;    &#125;    public Proxy(Host host) &#123;        this.host = host;    &#125;    @Override    public void rent() &#123;        seeHouse();        host.rent();        fare();    &#125;    //看房    public void seeHouse()&#123;        System.out.println(&quot;带房客看房&quot;);    &#125;    //收中介费    public void fare()&#123;        System.out.println(&quot;收中介费&quot;);    &#125;&#125;\n\nClient . java 即客户\n//客户类，一般客户都会去找代理！public class Client &#123;    public static void main(String[] args) &#123;        //房东要租房        Host host = new Host();        //中介帮助房东        Proxy proxy = new Proxy(host);        //你去找中介！        proxy.rent();    &#125;&#125;\n\n分析： 在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧 租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。\n1.静态代理的优缺点优点：\n\n可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . \n公共的业务由代理来完成 . 实现了业务的分工 \n公共业务发生扩展时变得更加集中和方便 .\n\n缺点 : \n\n类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 . 我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !\n\n2.静态代理再理解\n创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！\n\n//抽象角色：增删改查业务public interface UserService &#123;    void add();    void delete();    void update();    void query();&#125;\n\n\n我们需要一个真实对象来完成这些增删改查操作\n\n//真实对象，完成增删改查操作的人public class UserServiceImpl implements UserService &#123;    public void add() &#123;        System.out.println(&quot;增加了一个用户&quot;);    &#125;    public void delete() &#123;        System.out.println(&quot;删除了一个用户&quot;);    &#125;    public void update() &#123;        System.out.println(&quot;更新了一个用户&quot;);    &#125;    public void query() &#123;        System.out.println(&quot;查询了一个用户&quot;);    &#125;&#125;\n\n\n需求来了，现在我们需要增加一个日志功能，怎么实现！ \n\n思路1 ：在实现类上增加代码 【麻烦！】 \n思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！\n\n\n设置一个代理类来处理日志！ 代理角色\n\n\n//代理角色，在这里面增加日志的实现public class UserServiceProxy implements UserService &#123;    private UserServiceImpl userService;    public void setUserService(UserServiceImpl userService) &#123;        this.userService = userService;    &#125;    public void add() &#123;        log(&quot;add&quot;);        userService.add();    &#125;    public void delete() &#123;        log(&quot;delete&quot;);        userService.delete();    &#125;    public void update() &#123;        log(&quot;update&quot;);        userService.update();    &#125;    public void query() &#123;        log(&quot;query&quot;);        userService.query();    &#125;    public void log(String msg)&#123;        System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;);    &#125;&#125;\n\n\n测试\n\npublic class Client &#123;    public static void main(String[] args) &#123;        //真实业务        UserServiceImpl userService = new UserServiceImpl();        //代理类        UserServiceProxy userServiceProxy = new UserServiceProxy();        //使用代理类实现日志功能！        userServiceProxy.setUserService(userService);        userServiceProxy.add();    &#125;&#125;\n\n我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想\n【聊聊AOP：纵向开发，横向开发】\n\n2.动态代理\n动态代理的角色和静态代理的一样 . \n动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的 \n动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理 \n基于接口的动态代理—-JDK动态代理 \n基于类的动态代理–cglib \n现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist\n我们这里使用JDK的原生代码来实现，其余的道理都是一样的！\n\n\n\nJDK的动态代理需要了解两个类：核心 : InvocationHandler 和 Proxy ， 打开JDK帮助文档看看\n【InvocationHandler：调用处理程序】\n\nObject invoke(Object proxy, 方法 method, Object[] args)；//参数//proxy - 调用该方法的代理实例//method -所述方法对应于调用代理实例上的接口方法的实例。 方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。 原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean\n\n【Proxy : 代理】\n\n\n代码实现\n\nRent . java 即抽象角色\n\n//抽象角色：租房public interface Rent &#123;    public void rent();&#125;\n\n\nHost . java 即真实角色\n\n//真实角色: 房东，房东要出租房子public class Host implements Rent&#123;    public void rent() &#123;        System.out.println(&quot;房屋出租&quot;);    &#125;&#125;\n\n\nProxyInvocationHandler. java 即代理角色\n\npublic class ProxyInvocationHandler implements InvocationHandler &#123;    private Rent rent;    public void setRent(Rent rent) &#123;        this.rent = rent;    &#125;    //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色    public Object getProxy()&#123;        return Proxy.newProxyInstance(this.getClass().getClassLoader(),                rent.getClass().getInterfaces(),this);    &#125;    // proxy : 代理类 method : 代理类的调用处理程序的方法对象.    // 处理代理实例上的方法调用并返回结果    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws            Throwable &#123;        seeHouse();        //核心：本质利用反射实现！        Object result = method.invoke(rent, args);        fare();        return result;    &#125;    //看房    public void seeHouse()&#123;        System.out.println(&quot;带房客看房&quot;);    &#125;    //收中介费    public void fare()&#123;        System.out.println(&quot;收中介费&quot;);    &#125;&#125;\n\n\nClient . java\n\n//租客public class Client &#123;    public static void main(String[] args) &#123;        //真实角色        Host host = new Host();        //代理实例的调用处理程序        ProxyInvocationHandler pih = new ProxyInvocationHandler();        pih.setRent(host); //将真实角色放置进去！        Rent proxy = (Rent)pih.getProxy(); //动态生成对应的代理类！        proxy.rent();    &#125;&#125;\n\n核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！、\n1.深化理解我们来使用动态代理实现代理我们后面写的UserService！ \n我们也可以编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！\npublic class ProxyInvocationHandler implements InvocationHandler &#123;    private Object target;    public void setTarget(Object target) &#123;        this.target = target;    &#125;    //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色    public Object getProxy()&#123;        return Proxy.newProxyInstance(this.getClass().getClassLoader(),                target.getClass().getInterfaces(),this);    &#125;    // proxy : 代理类 method : 代理类的调用处理程序的方法对象.    // 处理代理实例上的方法调用并返回结果    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        log(method.getName());        //核心：本质利用反射实现！        Object result = method.invoke(target, args);                return result;    &#125;    public void log(String methodName)&#123;        System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;);    &#125;&#125;\n\n测试\npublic class Client &#123;    public static void main(String[] args) &#123;        //真实角色        UserServiceImpl userService = new UserServiceImpl();        //代理实例的调用处理程序        ProxyInvocationHandler pih = new ProxyInvocationHandler();        pih.setTarget(userService); //将真实角色放置进去！        UserService proxy = (UserService)pih.getProxy(); //动态生成对应的代理类！        proxy.delete();    &#125;&#125;//输出执行了delete方法删除了一个用户\n\n2.动态代理的好处静态代理有的它都有，静态代理没有的，它也有！ \n\n可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 . \n公共的业务由代理来完成 . 实现了业务的分工 , \n公共业务发生扩展时变得更加集中和方便 . \n一个动态代理 , 一般代理某一类业务 \n一个动态代理可以代理多个类，代理的是接口！\n\n","tags":["Spring"]},{"title":"Spring之使用JavaConfig实现配置","url":"/2022/05/10/Spring%E4%B9%8B%E4%BD%BF%E7%94%A8JavaConfig%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE/","content":"JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的 版本， JavaConfig 已正式成为 Spring4 的核心功能 。\n\n编写一个实体类，Dog\n\n@Componentpublic class Dog &#123;    @Value(&quot;dog&quot;)   public String name;&#125;\n\n\n新建一个config配置包，编写一个MyConfig配置类\n\n@Configuration//代表这是一个配置类public class MyConfig &#123;    @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！    public Dog dog()&#123;        return new Dog();    &#125;&#125;\n\n\n测试\n\npublic class test &#123;    public static void main(String[] args) &#123;        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyConfig.class);        Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;);        System.out.println(dog.name);    &#125;&#125;\n\n导入其他配置如何做呢？\n\n我们再编写一个配置类！\n\n@Configuration //代表这是一个配置类public class MyConfig2 &#123;&#125;\n\n\n在之前的配置类中我们来选择导入这个配置类\n\n@Configuration//代表这是一个配置类@Import(MyConfig2.class)//导入合并其他配置类，类似于配置文件中的 inculde 标签public class MyConfig &#123;    @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！    public Dog dog()&#123;        return new Dog();    &#125;&#125;\n","tags":["Spring"]},{"title":"Spring之依赖注入（DI）","url":"/2022/05/09/Spring%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89/","content":"\n依赖注入（Dependency Injection,DI）。 \n依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 . \n注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 .\n\n\n1.构造器注入之前已经已经学习了（有参构造那）\n2.set注入 (重点)要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is . \n\n创建pojo类 : Address.java\n\npublic class Address &#123;    private String address;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;    @Override    public String toString() &#123;        final StringBuffer sb = new StringBuffer(&quot;Address&#123;&quot;);        sb.append(&quot;address=&#x27;&quot;).append(address).append(&#x27;\\&#x27;&#x27;);        sb.append(&#x27;&#125;&#x27;);        return sb.toString();    &#125;&#125;\n\n\n再创建Student.java\n\npackage com.fang.pojo;import java.util.*;public class Student &#123;    private String name;    private Address address;    private String[] books;    private List&lt;String&gt; hobbys;    private Map&lt;String, String&gt; card;    private Set&lt;String&gt; games;    private String wife;    private Properties info;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setAddress(Address address) &#123;        this.address = address;    &#125;    public void setBooks(String[] books) &#123;        this.books = books;    &#125;    public void setHobbys(List&lt;String&gt; hobbys) &#123;        this.hobbys = hobbys;    &#125;    public void setCard(Map&lt;String, String&gt; card) &#123;        this.card = card;    &#125;    public void setGames(Set&lt;String&gt; games) &#123;        this.games = games;    &#125;    public void setWife(String wife) &#123;        this.wife = wife;    &#125;    public void setInfo(Properties info) &#123;        this.info = info;    &#125;    @Override    public String toString() &#123;        final StringBuffer sb = new StringBuffer(&quot;Student&#123;&quot;);        sb.append(&quot;name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, address=&quot;).append(address);        sb.append(&quot;, books=&quot;).append(books == null ? &quot;null&quot; : Arrays.asList(books).toString());        sb.append(&quot;, hobbys=&quot;).append(hobbys);        sb.append(&quot;, card=&quot;).append(card);        sb.append(&quot;, games=&quot;).append(games);        sb.append(&quot;, wife=&#x27;&quot;).append(wife).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, info=&quot;).append(info);        sb.append(&#x27;&#125;&#x27;);        return sb.toString();    &#125;&#125;\n\n1、常量注入&lt;bean id=&quot;student&quot; class=&quot;com.fang.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;xiaoxiao&quot;/&gt;&lt;/bean&gt;\n\n2、Bean注入&lt;bean id=&quot;addr&quot; class=&quot;com.fang.pojo.Address&quot;&gt;    &lt;property name=&quot;address&quot; value=&quot;天津&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.fang.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;xiaoxiao&quot;/&gt;    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;&lt;/bean&gt;\n\n3、数组注入&lt;bean id=&quot;student&quot; class=&quot;com.fang.pojo.Student&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;xiaoxiao&quot;/&gt;    &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;    &lt;property name=&quot;books&quot;&gt;        &lt;array&gt;            &lt;value&gt;罗通&lt;/value&gt;            &lt;value&gt;天道&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n4、List注入&lt;property name=&quot;hobbys&quot;&gt;       &lt;list&gt;           &lt;value&gt;唱歌&lt;/value&gt;           &lt;value&gt;跳舞&lt;/value&gt;       &lt;/list&gt;   &lt;/property&gt;\n\n5、Map注入&lt;property name=&quot;card&quot;&gt;    &lt;map&gt;        &lt;entry key=&quot;中国&quot; value=&quot;china&quot;/&gt;        &lt;entry key=&quot;美国&quot; value=&quot;dog&quot;/&gt;    &lt;/map&gt;&lt;/property&gt;\n\n6、set注入&lt;property name=&quot;games&quot;&gt;    &lt;set&gt;        &lt;value&gt;SAD&lt;/value&gt;        &lt;value&gt;FSD&lt;/value&gt;    &lt;/set&gt;&lt;/property&gt;\n\n7、Null注入&lt;property name=&quot;wife&quot;&gt;&lt;null/&gt;&lt;/property&gt;\n\n8、Properties注入&lt;property name=&quot;info&quot;&gt;    &lt;props&gt;        &lt;prop key=&quot;学号&quot;&gt;yj2123&lt;/prop&gt;        &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;    &lt;/props&gt;&lt;/property&gt;\n\n9.测试public class test &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        Student student = (Student) context.getBean(&quot;student&quot;);        System.out.println(student.toString());    &#125;&#125;\n\n10.输出Student&#123;name=&#x27;xiaoxiao&#x27;, address=Address&#123;address=&#x27;天津&#x27;&#125;, books=[罗通, 天道], hobbys=[唱歌, 跳舞], card=&#123;中国=china, 美国=dog&#125;, games=[SAD, FSD], wife=&#x27;null&#x27;, info=&#123;学号=yj2123, 性别=男&#125;&#125;\n\n3.拓展注入实现\n创建User.java ：这里需要加有参和无参构造，因为c命名空间注入需要\n\npublic class User &#123;    private String name;    private int age;    public User() &#123;    &#125;    public User(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n\nP命名空间注入 : 需要在头文件中假如约束文件\n\n导入约束:xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.fang.pojo.User&quot; p:name=&quot;xiao&quot; p:age=&quot;18&quot;/&gt;\n\n\nc 命名空间注入 : 需要在头文件中假如约束文件\n\n导入约束 : xmlns:c=&quot;http://www.springframework.org/schema/c&quot;&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;18&quot;/&gt;\n\n\n测试代码\n\npublic static void main(String[] args) &#123;    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);    User user = (User) context.getBean(&quot;user&quot;);    System.out.println(user);&#125;\n\n4.Bean的作用域在Spring中，那些组成应用程序的主体及由Spring IOC容器所管理的对象，被称之为bean。简单地讲， bean就是由IOC容器初始化、装配及管理的对象 .\n\n几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web 应用框架），只能用在基于web的Spring ApplicationContext环境。\n1、Singleton\n当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对 bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象 都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成 singleton，可以这样配置：\n&lt;bean id=&quot;ServiceImpl&quot; class=&quot;cn.csdn.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt;\n\n3、Prototype\n当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法） 时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：\n&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; scope=&quot;prototype&quot;/&gt;或者&lt;bean id=&quot;account&quot; class=&quot;com.foo.DefaultAccount&quot; singleton=&quot;false&quot;/&gt;\n\n3、Request当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP 请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：\n&lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt;\n\n针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。\n4、Session当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域 仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：\n&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;\n\n针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的 userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据 userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session 最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。\n","tags":["Spring"]},{"title":"Spring之声明式事务","url":"/2022/05/11/Spring%E4%B9%8B%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1/","content":"1.回顾事务\n事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ \n事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。\n\n事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。\n事务四个属性ACID\n\n原子性（atomicity） \n事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起 作用\n\n\n一致性（consistency） \n一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中\n\n\n隔离性（isolation） \n可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏\n\n\n持久性（durability）\n\n\n事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写 到持久化存储器中\n\n测试：\n\n编写UserMapper.java\n\npublic interface UserMapper &#123;    public List&lt;User&gt; selectUser();    //添加一个用户    int addUser(User user);    //根据id删除用户    int deleteUser(int id);&#125;\n\n\n编写mapper文件我们故意把 deletes 写错，测试！\n\n&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.fang.pojo.User&quot;&gt;    insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&lt;/insert&gt;&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;    delete from mybatis.user where id = #&#123;id&#125;&lt;/delete&gt;\n\n\n编写接口的实现类\n\npublic class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper&#123;    @Override    public List&lt;User&gt; selectUser() &#123;        User user = new User(7,&quot;小明&quot;,&quot;123456&quot;);        UserMapper mapper = getSqlSession().getMapper(UserMapper.class);        mapper.addUser(user);        mapper.deleteUser(7);        return mapper.selectUser();    &#125;    @Override    public int addUser(User user) &#123;        UserMapper mapper = getSqlSession().getMapper(UserMapper.class);        return mapper.addUser(user);    &#125;    @Override    public int deleteUser(int id) &#123;        UserMapper mapper = getSqlSession().getMapper(UserMapper.class);        return mapper.deleteUser(id);    &#125;&#125;\n\n\n测试类\n\n@Testpublic void test() &#123;    ApplicationContext context = new            ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);    List&lt;User&gt; user = mapper.selectUser();    System.out.println(user);&#125;\n\n报错：sql异常，第二步：delete写错了 \n结果 ：插入成功！ \n\n没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要事务！ \n以前我们都需要自己手动管理事务，十分麻烦！\n但是Spring给我们提供了事务管理，我们只需要配置即可；\n\n2.Spring中的事务管理Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以 使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。\n编程式事务管理\n\n将事务管理代码嵌到业务方法中来控制事务的提交和回滚 \n缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码\n\n声明式事务管理\n\n一般情况下比编程式事务好用。 \n将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 \n将事务管理作为横切关注点，通过AOP方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。\n\n使用Spring管理事务，注意头文件的约束导入 : tx\nxmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;http://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;\n\n事务管理器\n\n无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。 \n就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。\n\nJDBC事务\n&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;\n\n配置好事务管理器后我们需要去配置事务的通知\n&lt;!--配置事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;    &lt;tx:attributes&gt;        &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;        &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;\n\nspring事务传播特性：\n事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行 为：\n\npropagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这 个事务中，这是最常见的选择。 \npropagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 \npropagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 \npropagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 \npropagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 \npropagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 \npropagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 propagation_required类似的操作\n\nSpring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。 \n假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的 调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。 \n就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！\n配置AOP\n导入aop的头文件！\n&lt;!--配置aop织入事务--&gt;&lt;aop:config&gt;    &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.fang.Dao.*.*(..))&quot;/&gt;    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;&lt;/aop:config&gt;\n\n进行测试 删掉刚才插入的数据，再次测试！\n为什么需要配置事务？ \n\n如果不配置，就需要我们手动提交控制事务； \n事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！\n\n","tags":["Spring"]},{"title":"Spring之整合Mybatis","url":"/2022/05/11/Spring%E4%B9%8B%E6%95%B4%E5%90%88Mybatis/","content":"1.整合Mybatis步骤：\n\n导入相关jar包\n\n&lt;dependencies&gt;    &lt;!--1. junit--&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--2. mybatis--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.5.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--3. mysql-connector-java--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.47&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--4. spring相关--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--5. aspectJ AOP 织入器--&gt;    &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.9.4&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--6. mybatis-spring整合包 【重点】--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;        &lt;version&gt;2.0.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--实体类那个--&gt;    &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.16.10&lt;/version&gt;        &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!--7. 配置Maven静态资源过滤问题！--&gt;&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;true&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;\n\n\n编写配置文件 \n代码实现\n\n2.回忆MyBatis\n编写pojo实体类\n\n@Datapublic class User &#123;    private int id; //id    private String name; //姓名    private String pwd; //密码&#125;\n\n\n实现mybatis的配置文件\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.fang.pojo&quot;/&gt;    &lt;/typeAliases&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot;                          value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;自己的&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;package name=&quot;com.fang.dao&quot;/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n\nUserDao接口编写\n\npublic interface UserMapper &#123;    public List&lt;User&gt; selectUser();&#125;\n\n\n接口对应的Mapper映射文件\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.fang.Dao.UserMapper&quot;&gt;    &lt;select id=&quot;selectUser&quot; resultType=&quot;User&quot;&gt;        select * from mybatis.user    &lt;/select&gt;&lt;/mapper&gt;\n\n\n测试类\n\n@Testpublic void selectUser() throws IOException &#123;    String resource = &quot;mybatis.xml&quot;;    InputStream inputStream = Resources.getResourceAsStream(resource);    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);    SqlSession sqlSession = sqlSessionFactory.openSession(true);    UserMapper mapper = sqlSession.getMapper(UserMapper.class);    List&lt;User&gt; userList = mapper.selectUser();    for (User user : userList) &#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;\n\n3.MyBatis-Spring学习引入Spring之前需要了解mybatis-spring包中的一些重要类； http://www.mybatis.org/spring/zh/index.html\n什么是 MyBatis-Spring？ \nMyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。\n如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：\n&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;\n\n要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类。 \n在 MyBatis-Spring 中，可使用 SqlSessionFactoryBean 来创建 SqlSessionFactory 。 要配置 这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中：\n&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\t&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;\n\n注意： SqlSessionFactory 需要一个 DataSource （数据源）。 这可以是任意的 DataSource ，只需要和配置其它 Spring 数据库连接一样配置它就可以了\n在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。 而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建。\n在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession 。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你 可以关闭 session。\nSqlSessionFactory 有一个唯一的必要属性：用于 JDBC 的 DataSource 。这可以是任意的 DataSource 对象，它的配置方法和其它 Spring 数据库连接是一样的。\n一个常用的属性是 configLocation ，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是settings或typeAliases元素。\n需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置 （environments  ），数据源（DataSource  ）和 MyBatis 的事务管理器 （ transactionManager ）都会被忽略。 SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（ Environment ），并按要求设置自定义环境的值。\nSqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可 以使用它无缝代替你代码中已经在使用的 SqlSession 。\n模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总 是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程 序中的不同类之间混杂使用可能会引起数据一致性的问题。\n可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象。\n&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;\t&lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt;\n\n现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样：\npublic class UserDaoImpl implements UserDao &#123;\tprivate SqlSession sqlSession;    public void setSqlSession(SqlSession sqlSession) &#123;    \tthis.sqlSession = sqlSession;    &#125;    public User getUser(String userId) &#123;    \treturn sqlSession.getMapper...;\t&#125;&#125;\n\n按下面这样，注入 SqlSessionTemplate \n&lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt;\t&lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot; /&gt;&lt;/bean&gt;\n\n整合实现一\n引入Spring配置文件beans.xml\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt;\n\n\n配置数据源替换mybaits的数据源\n\n&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;mima&quot;/&gt;&lt;/bean&gt;\n\n\n配置SqlSessionFactory，关联MyBatis\n\n&lt;!--配置SqlSessionFactory--&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;!--关联Mybatis--&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;mybatis.xml&quot;/&gt;    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/fang/Dao/*.xml&quot;/&gt;&lt;/bean&gt;\n\n\n注册sqlSessionTemplate，关联sqlSessionFactory；\n\n&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;    &lt;!--利用构造器注入--&gt;    &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;\n\n\n增加Dao接口的实现类；私有化sqlSessionTemplate\n\npublic class UserDaoImpl implements UserMapper&#123;    //sqlSession不用我们自己创建了，Spring来管理    private SqlSessionTemplate sqlSession;    public void setSqlSession(SqlSessionTemplate sqlSession) &#123;        this.sqlSession = sqlSession;    &#125;    @Override    public List&lt;User&gt; selectUser() &#123;        UserMapper mapper = sqlSession.getMapper(UserMapper.class);        return mapper.selectUser();    &#125;&#125;\n\n\n注册bean实现\n\n&lt;bean id=&quot;userDao&quot; class=&quot;com.fang.Dao.UserDaoImpl&quot;&gt;    &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt;\n\n\n测试\n\n@Testpublic void test()&#123;    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);    List&lt;User&gt; users = mapper.selectUser();    for (User user : users) &#123;        System.out.println(user);    &#125;&#125;\n\n整合实现二dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起方式1 , 不 需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看\n\n测试：\n\n将我们上面写的UserDaoImpl修改一下\n\npublic class UserDaoImpl extends SqlSessionDaoSupport implements UserMapper&#123;        @Override    public List&lt;User&gt; selectUser() &#123;        return getSqlSession().getMapper(UserMapper.class).selectUser();    &#125;&#125;\n\n\n修改bean的配置\n\n&lt;bean id=&quot;userDao&quot; class=&quot;com.fang.Dao.UserDaoImpl&quot;&gt;    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;\n\n总结 : 整合到spring中以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还 可以使用注解来实现\n","tags":["Spring"]},{"title":"Spring之注解开发","url":"/2022/05/09/Spring%E4%B9%8B%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","content":"1.说明在spring4之后，想要使用注解形式，必须得要引入aop的包，引入spring-webmvc时就已经引入了\n在配置文件当中，还得要引入一个context约束\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:annotation-config/&gt;&lt;/beans&gt;\n\n2.Bean的实现我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！ \n\n在xml中配置扫描哪些包下的注解\n\n&lt;!--指定注解扫描包--&gt;&lt;context:component-scan base-package=&quot;com.fang.pojo&quot;/&gt;\n\n\n在指定包下编写类，增加注解\n\n@Component(&quot;people&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class People &#123;    public String name = &quot;xiao&quot;;&#125;\n\n\n测试\n\npublic class test &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        People people = context.getBean(&quot;people&quot;, People.class);        System.out.println(people.name);    &#125;&#125;\n\n3.属性注入使用注解注入属性 \n\n可以不用提供set方法，直接在直接名上添加@value(“值”)\n\n@Component(&quot;people&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class People &#123;    @Value(&quot;xiao&quot;)    public String name ;&#125;\n\n\n如果提供了set方法，在set方法上添加@value(“值”)\n\n@Component(&quot;people&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class People &#123;    public String name ;    @Value(&quot;xiao&quot;)    public void setName(String name) &#123;        this.name = name;    &#125;&#125;\n\n4.衍生注解我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！ \n@Component三个衍生注解 \n为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。 \n\n@Controller：controller层 \n@Service：service层 \n@Repository：dao层\n\n写上这些注解，就相当于将这个类交给Spring管理装配了！\n5.作用域@scope \n\nsingleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 \nprototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收\n\n@Component(&quot;people&quot;)@Scope(&quot;prototype&quot;)// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;public class People &#123;    public String name ;    @Value(&quot;xiao&quot;)    public void setName(String name) &#123;        this.name = name;    &#125;&#125;\n\n6.小结XML与注解比较 \n\nXML可以适用任何场景 ，结构清晰，维护方便 \n注解不是自己提供的类使用不了，开发简单方便\n\nxml与注解整合开发 ：推荐最佳实践 \n\nxml管理Bean \n注解完成属性注入 \n使用过程中， 可以不用扫描，扫描是为了类上的注解\n\n&lt;context:annotation-config/&gt;\n\n作用： \n\n进行注解驱动注册，从而使注解生效 \n用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册 \n如果不扫描包，就需要手动配置bean \n如果不加注解驱动，则注入的值为null！\n\n","tags":["Spring"]},{"title":"Spring之自动装配Bean","url":"/2022/05/09/Spring%E4%B9%8B%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8DBean/","content":"\n自动装配是使用spring满足bean依赖的一种方法 \nspring会在应用上下文中为某个bean寻找其依赖的bean。\n\nSpring中bean有三种装配机制，分别是： \n\n在xml中显式配置； \n在java中显式配置； \n隐式的bean发现机制和自动装配。\n\n这里我们主要使用第三种：自动化的装配bean。 \nSpring的自动装配需要从两个角度来实现，或者说是两个操作： \n\n组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； \n自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC&#x2F;DI；\n\n组件扫描和自动装配组合发挥巨大威力，使的显示的配置降低到最少。 推荐不使用自动装配xml配置 , 而使用注解 \n\n1.测试环境搭建\n新建两个实体类，Cat Dog 都有一个叫的方法\n\npublic class Dog &#123;    public void shot()&#123;        System.out.println(&quot;wang~&quot;);    &#125;&#125;\n\npublic class Cat &#123;    public void shot()&#123;        System.out.println(&quot;miao~&quot;);    &#125;&#125;\n\n\n新建一个用户类 People\n\npublic class People &#123;    private String name;    private Dog dog;    private Cat cat;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Dog getDog() &#123;        return dog;    &#125;    public void setDog(Dog dog) &#123;        this.dog = dog;    &#125;    public Cat getCat() &#123;        return cat;    &#125;    public void setCat(Cat cat) &#123;        this.cat = cat;    &#125;    @Override    public String toString() &#123;        final StringBuffer sb = new StringBuffer(&quot;People&#123;&quot;);        sb.append(&quot;name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, dog=&quot;).append(dog);        sb.append(&quot;, cat=&quot;).append(cat);        sb.append(&#x27;&#125;&#x27;);        return sb.toString();    &#125;&#125;\n\n\n编写Spring配置文件\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;dog&quot; class=&quot;com.fang.pojo.Dog&quot;/&gt;    &lt;bean id=&quot;cat&quot; class=&quot;com.fang.pojo.Cat&quot;/&gt;    &lt;bean id=&quot;people&quot; class=&quot;com.fang.pojo.People&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;小&quot;/&gt;        &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;        &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n测试\n\npublic class test &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        People people = context.getBean(&quot;people&quot;, People.class);        people.getCat().shot();        people.getDog().shot();    &#125;\n\n2.byNameautowire byName (按名称自动装配)由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。 采用自动装配将避免这些错误，并且使配置简单化。\n测试： \n\n修改bean配置，增加一个属性 autowire&#x3D;”byName”\n\n&lt;bean id=&quot;people&quot; class=&quot;com.fang.pojo.People&quot; autowire=&quot;byName&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;小&quot;/&gt; &lt;/bean&gt;\n\n\n通过测试上面修改成功输出\n我们将 cat 的bean id修改为 catXXX\n再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。\n\n小结： \n当一个bean节点带有 autowire byName的属性时。 \n\n将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。 \n去spring容器中寻找是否有此字符串名称id的对象。 \n如果有，就取出注入；如果没有，就报空指针异常。\n\n3.byTypeautowire byType (按类型自动装配) \n使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一 的异常。\n测试： \n\n将user的bean配置修改一下 ： autowire&#x3D;”byType”\n\n&lt;bean id=&quot;people&quot; class=&quot;com.fang.pojo.People&quot; autowire=&quot;byType&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;小&quot;/&gt;&lt;/bean&gt;\n\n\n测试，正常输出 \n在注册一个cat 的bean对象！\n\n&lt;bean id=&quot;dog&quot; class=&quot;com.fang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.fang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;catxxx&quot; class=&quot;com.fang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;people&quot; class=&quot;com.fang.pojo.People&quot; autowire=&quot;byType&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;小&quot;/&gt;&lt;/bean&gt;\n\n\n测试，报错：NoUniqueBeanDefinitionException \n删掉catxxx，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。 这就是按照类型自动装配！\n\n4.使用注解jdk1.5开始支持注解，spring2.5开始全面支持注解。 \n准备工作： 利用注解的方式注入属性。 \n\n在spring配置文件中引入context文件头\n\nxmlns:context=&quot;http://www.springframework.org/schema/context&quot;http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd\n\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n\n开启属性注解支持！\n\n&lt;context:annotation-config/&gt;\n\n@Autowired\n@Autowired直接再属性上使用即可，也可以再set方法上使用\n使用Autowired我们可以不用编写set方法，前提是这个自动装配的属性在IOC（Spring）容器中存在。\n@Autowired是按类型自动转配的，不支持id匹配。\n需要导入 spring-aop的包！\n\n测试： \n\n将People类中的set方法去掉，使用@Autowired注解\n\npublic class People &#123;    private String name;    @Autowired    private Dog dog;    @Autowired    private Cat cat;    public String getName() &#123;        return name;    &#125;    public Dog getDog() &#123;        return dog;    &#125;    public Cat getCat() &#123;        return cat;    &#125;    @Override    public String toString() &#123;        final StringBuffer sb = new StringBuffer(&quot;People&#123;&quot;);        sb.append(&quot;name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, dog=&quot;).append(dog);        sb.append(&quot;, cat=&quot;).append(cat);        sb.append(&#x27;&#125;&#x27;);        return sb.toString();    &#125;&#125;\n\n\n此时配置文件内容\n\n&lt;context:annotation-config/&gt;&lt;bean id=&quot;dog&quot; class=&quot;com.fang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.fang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;people&quot; class=&quot;com.fang.pojo.People&quot;/&gt;\n\n\n测试，成功输出结果！\n\n@Autowired(required&#x3D;false) 说明： false，对象可以为null；true，对象必须存对象，不能为null。\n//如果允许对象为null，设置required = false,默认为true@Autowired(required = false)private Cat cat;\n\n@Qualifier\n@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配 \n@Qualifier不能单独使用。\n\n测试实验步骤： \n\n配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！\n\n&lt;bean id=&quot;dog2&quot; class=&quot;com.fang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;dog1&quot; class=&quot;com.fang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.fang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.fang.pojo.Cat&quot;/&gt;\n\n\n没有加Qualifier测试，直接报错 \n在属性上添加Qualifier注解\n\n@Autowired@Qualifier(value = &quot;dog2&quot;)private Dog dog;@Autowired@Qualifier(value = &quot;cat2&quot;)private Cat cat;\n\n\n测试，成功输出！\n\n@Resource\n@Resource如有指定的name属性，先按该属性进行byName方式查找装配； \n其次再进行默认的byName方式进行装配；\n如果以上都不成功，则按byType的方式自动装配。 \n都不成功，则报异常。\n\n实体类：\npublic class User &#123;    //如果允许对象为null，设置required = false,默认为true    @Resource(name = &quot;cat2&quot;)    private Cat cat;    @Resource    private Dog dog;    private String str;&#125;\n\nbeans.xml\n&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;\n\n测试：结果OK\n配置文件2：beans.xml ， 删掉cat2\n&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;\n\n实体类上只保留注解\n@Resourceprivate Cat cat;@Resourceprivate Dog dog;\n\n结果：OK \n结论：先进行byName查找，失败；再进行byType查找，成功。\n小结:@Autowired与@Resource异同： \n\n@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。 \n@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required&#x3D;false) ，如果我 们想使用名称装配可以结合@Qualifier注解进行使用 \n@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在 setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。\n\n它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先 byName。\n","tags":["Spring"]},{"title":"Spring之配置说明","url":"/2022/05/09/Spring%E4%B9%8B%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/","content":"别名alias 设置别名 , 为bean设置别名 , 可以设置多个别名，但是每次使用只能设置一个别名\n&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;&lt;alias name=&quot;userT&quot; alias=&quot;t&quot;/&gt;\n\nBean的配置而bean标签里的name也可以取别名，并且一次可以取多个别名，用（，或者空格）隔开\n&lt;!--bean就是java对象,由Spring创建和管理--&gt;&lt;!--id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符如果配置id,又配置了name,那么name是别名name可以设置多个别名,可以用逗号,分号,空格隔开如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;class是bean的全限定名=包名+类名--&gt;&lt;bean id=&quot;userT&quot; name=&quot;h1 h2,h3;h4&quot; class=&quot;com.fang.pojo.UserT&quot;&gt;    &lt;!-- index指构造方法 , 下标从0开始 --&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;xiao1&quot;/&gt;&lt;/bean&gt;\n\nimport团队的合作通过import来实现 .可以将一个配置文件合并成一个，例如三个人开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并成一个总的。\n\n新建一个applicationContext.xml，在xmlbeans标签下引入这个import，然后修改测试中获取的xml名称就行了。\n\n&lt;import resource=&quot;beans.xml&quot;/&gt;&lt;import resource=&quot;beans1.xml&quot;/&gt;\n","tags":["Spring"]},{"title":"Vue之Axios异步通信","url":"/2022/05/28/Vue%E4%B9%8BAxios%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/","content":"1、什么是AxiosAxios 是一个开源的可以用在浏览器端和 NodeJS 的异步通信框架，她的主要作用就是实现 AJAX 异步通信，其功能特点如下： \n\n从浏览器中创建 XMLHttpRequests \n从 node.js 创建 http 请求 \n支持 Promise API [ JS中链式编程 ] \n拦截请求和响应 \n转换请求数据和响应数据 \n取消请求 \n自动转换 JSON 数据 \n客户端支持防御 XSRF（跨站请求伪造）\n\nGitHub：https://github.com/axios/axios \n中文文档：http://www.axios-js.com/\n2、为什么要使用 Axios由于 Vue.js 是一个 视图层框架并且作者（尤雨溪）严格准守 SoC （关注度分离原则），所以 Vue.js 并不包含 AJAX 的通信功能，为了解决通信问题，作者单独开发了一个名为 vue-resource 的插件，不过在进入 2.0 版本以后停止了对该插件的维护并推荐了 Axios 框架。少用 jQuery，因为它操作Dom太频繁！\n3、第一个 Axios 应用程序1、咱们开发的接口大部分都是采用 JSON 格式，可以先在项目里模拟一段 JSON 数据，数据内容如下： 创建一个名为 data.json 的文件并填入上面的内容，放在项目的根目录下。\n&#123;  &quot;name&quot;: &quot;小fang&quot;,  &quot;url&quot;: &quot;https://ainianxu.github.io/&quot;,  &quot;page&quot;: 1,  &quot;address&quot;: &#123;    &quot;street&quot;: &quot;洪崖洞&quot;,    &quot;city&quot;: &quot;重庆市&quot;,    &quot;country&quot;: &quot;中国&quot;  &#125;&#125;\n\n2、测试代码\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Title&lt;/title&gt;  &lt;style&gt;    [v-cloak]&#123;        display: none;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot; v-cloak&gt;  &lt;div&gt;名称:&#123;&#123;info.name&#125;&#125;&lt;/div&gt;  &lt;div&gt;地址：&#123;&#123;info.address.country&#125;&#125;-&#123;&#123;info.address.city&#125;&#125;- &#123;&#123;info.address.street&#125;&#125;&lt;/div&gt;  &lt;div&gt;链接:&lt;a v-bind:href=&quot;info.url&quot;&gt;&#123;&#123;info.url&#125;&#125;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;  var vm =new Vue(&#123;      el:&#x27;#app&#x27;,      data()&#123;          return&#123;              info:&#123;                  name:null,                  address:&#123;                      country: null,                      city: null,                      street: null                  &#125;,                  url:null              &#125;          &#125;      &#125;,     mounted()&#123;//钩子函数          axios              .get(&#x27;data.json&#x27;)              .then(response=&gt;(this.info = response.data));     &#125;  &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n说明 : \n\n在这里使用了 v-bind 将 a:href 的属性值与 Vue 实例中的数据进行绑定 \n使用 axios 框架的 get 方法请求 AJAX 并自动将数据封装进了 Vue 实例的数据对象中 \n我们在data中的数据结构必须要和 Ajax 响应回来的数据格式匹配！\n\n4、Vue的生命周期官方文档：https://cn.vuejs.org/v2/guide/instance.html#生命周期图示 \nVue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载 DOM、渲染→更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。 \n在 Vue 的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册 JS 方法，可以让我们用自己注册的 JS 方法控制整个大局，在这些事件响应方法中的 this 直接指向的是 Vue 的实例。\n\n","tags":["Vue"]},{"title":"Vue之MVVM模式","url":"/2022/05/23/Vue%E4%B9%8BMVVM%E6%A8%A1%E5%BC%8F/","content":"MVVM模式\n什么是MVVM模式？\n\nMVVM（Model-View-ViewModel）是一种软件架构设计模式，由微软 WPF（用于替代 WinForm，以 前就是用这个技术开发桌面应用程序的）和 Silverlight（类似于 Java Applet，简单点说就是在浏览器上 运行的 WPF） 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。 由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于 2005 年在他的博客上发表。 \nMVVM 源自于经典的 MVC（Model-View-Controller）模式。MVVM 的核心是 ViewModel 层，负责转换 Model 中的数据对象来让数据变得更容易管理和使用，其作用如下： \n\n该层向上与视图层进行双向数据绑定 \n向下与 Model 层通过接口请求进行数据交互\n\n\nMVVM 已经相当成熟了，当下流行的 MVVM 框架有 Vue.js ， AngularJS 等。\n\n为什么要使用 MVVM\n\nMVVM 模式和 MVC 模式一样，主要目的是分离视图（View）和模型（Model），有几大好处： \n\n低耦合： 视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。 \n可复用： 你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 View 重用这段视图逻辑。 \n独立开发： 开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 \n可测试： 界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。\n\n\nMVVM 的组成部分\n\n\nView： \nView 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建，为了更方便地展现 ViewModel 或者 Model层的数据，已经产生了各种各样的前后端模板语言，比如 FreeMarker、 Thymeleaf 等等，各大 MVVM 框架如 Vue.js，AngularJS，EJS 等也都有自己用来构建用户界面的内置 模板语言。\n Model：\n Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。这里的难点主要在于需要和前端约定统一的接口规则 \nViewModel： \nViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。\n需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模 型是只包含状态的。 \n\n比如页面的这一块展示什么，那一块展示什么这些都属于视图状态（展示）\n页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交 互）\n\n视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。 由于实现了双向绑定，ViewModel 的内容会实时展现在 View 层，这是激动人心的，因为前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图。 MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就 会自动得到相应更新，真正实现事件驱动编程 。 \nView 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。\n","tags":["Vue"]},{"title":"Vue之NPM包管理器","url":"/2022/06/06/Vue%E4%B9%8BNPM%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/","content":"1、简介NPM全称Node Package Manager，是Node.js包管理工具，是全球最大的模块生态系统，里面所有的 模块都是开源免费的；也是Node.js的包管理工具，相当于前端的Maven 。\n#在命令提示符输入 npm -v 可查看当前npm版本npm -v\n\n2、使用npm管理项目#建立一个空文件夹，在命令提示符进入该文件夹 执行命令初始化npm init#按照提示输入相关信息，如果是用默认值则直接回车即可。#name: 项目名称#version: 项目版本号#description: 项目描述#keywords: &#123;Array&#125;关键词，便于用户搜索到我们的项目#最后会生成package.json文件，这个是包的配置文件，相当于maven的pom.xml#我们之后也可以根据需要进行修改。#如果想直接生成 package.json 文件，那么可以使用命令npm init -y\n\n3、修改npm镜像1、修改npm镜像\nNPM官方的管理的包都是从 http://npmjs.com下载的，但是这个网站在国内速度很慢。 \n这里推荐使用淘宝 NPM 镜像 http://npm.taobao.org/\n淘宝 NPM 镜像是一个完整 npmjs.com 镜像，同步频率目前为 10分钟一次，以保证尽量与官方服 务同步。\n\n2、设置镜像地址#经过下面的配置，以后所有的 npm install 都会经过淘宝的镜像地址下载npm config set registry https://registry.npm.taobao.org#查看npm配置信息npm config list\n\n4、npm install#使用 npm install 安装依赖包的最新版，#模块安装的位置：项目目录\\node_modules#安装会自动在项目目录下添加 package-lock.json文件，这个文件帮助锁定安装包的版本#同时package.json 文件中，依赖包会被添加到dependencies节点下，类似maven中的&lt;dependencies&gt;npm install jquery#如果安装时想指定特定的版本npm install jquery@2.1.x#devDependencies节点：开发时的依赖包，项目打包到生产环境的时候不包含的依赖#使用 -D参数将依赖添加到devDependencies节点npm install --save-dev eslint#或npm install -D eslint#全局安装#Node.js全局安装的npm包和工具的位置：用户目录\\AppData\\Roaming\\npm\\node_modules#一些命令行工具常使用全局安装的方式npm install -g webpack#npm管理的项目在备份和传输的时候一般不携带node_modules文件夹npm install #根据package.json中的配置下载依赖，初始化项目\n\n5、其他命令#更新包（更新到最新版本）npm update 包名#全局更新npm update -g 包名#卸载包npm uninstall 包名#全局卸载npm uninstall -g 包名\n\n","tags":["Vue"]},{"title":"Vue之Vue组件讲解","url":"/2022/05/28/Vue%E4%B9%8BVue%E7%BB%84%E4%BB%B6%E8%AE%B2%E8%A7%A3/","content":"1、什么是组件组件是可复用的 Vue 实例，说白了就是一组可以重复使用的模板，跟 JSTL 的自定义标签、 Thymeleaf 的 th:fragment 等框架有着异曲同工之妙。通常一个应用会以一棵嵌套的组件树的形式来组织：\n\n例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。\n2、第一个 Vue 组件注意：在实际开发中，我们并不会用以下方式开发组件，以下方法只是为了让大家理解什么是组件。 \n使用 Vue.component() 方法注册组件：\n06-vue-component.html\n&lt;body&gt;&lt;div id=&quot;app&quot;&gt;  &lt;ul&gt;    &lt;!-- 有点类似自定义标签 --&gt;    &lt;my-component-li&gt;&lt;/my-component-li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  //先注册组件  Vue.component(&#x27;my-component-li&#x27;,&#123;      template:&#x27;&lt;li&gt;Hello li &lt;/li&gt;&#x27;  &#125;);  //再实例化Vue  var vm =new Vue(&#123;      el:&#x27;#app&#x27;  &#125;);&lt;/script&gt;&lt;/body&gt;\n\n说明： \n\nVue.component()：注册组件 \nmy-component-li：自定义组件的名字 \ntemplate：组件的模板\n\n3、使用 props 属性传递参数像上面那样用组件没有任何意义，所以我们是需要传递参数到组件的，此时就需要使用 props 属性了！\n注意：默认规则下 props 属性里的值不能为大写：\n&lt;body&gt;&lt;div id=&quot;app&quot;&gt;  &lt;ul&gt;    &lt;!-- 有点类似自定义标签 --&gt;    &lt;my-component-li v-for=&quot;item in items&quot; v-bind:item=&quot;item&quot;&gt;    &lt;/my-component-li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  //先注册组件  Vue.component(&#x27;my-component-li&#x27;,&#123;      props:[&#x27;item&#x27;],      template:&#x27;&lt;li&gt;Hello&#123;&#123;itemid&#125;&#125;&lt;/li&gt;&#x27;  &#125;);  //再实例化Vue  var vm =new Vue(&#123;      el:&#x27;#app&#x27;,      data:&#123;          items:[&quot;张三&quot;,&quot;里斯&quot;]      &#125;  &#125;);&lt;/script&gt;&lt;/body&gt;\n\n说明： \n\nv-for&#x3D;”item in items” ：遍历 Vue 实例中定义的名为 items 的数组，并创建同等数量的组件； \nv-bind:item&#x3D;”item” ：将遍历的 item 项绑定到组件中 props 定义的名为 item 属性上； \n&#x3D; 号左边的 item 为 props 定义的属性名，右边的为 item in items 中遍历的 item 项的值；\n\n","tags":["Vue"]},{"title":"Vue之vue+elementUI","url":"/2022/06/04/Vue%E4%B9%8Bvue-elementUI/","content":"&#x3D;&#x3D;我们采用实战教学模式并结合ElementUI组件库，将所需知识点应用到实际中。&#x3D;&#x3D;\n\n创建工程注意，命令行都要使用管理员模式运行\n\n创建一个名为hello-vue的工程 vue init webpack hello-vue\n安装依赖：vue-router、element-ui、sass-loader和node-sass四个插件\n\n#进入工程目录cd hello-vue#安装vue-routernpm install vue-router --save-dev#安装element-uinpm i element-ui -S#安装依赖npm install#安装SASS加载器npm install sass-loader node-sass --save-dev#启动测试npm run dev\n\n\n创建首页视图，再views目录下创建一个Main.vue的视图组件\n\n&lt;template&gt;  &lt;div&gt;    首页  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Main&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n\n创建登录页视图在views目录下创建一个名为Login.vue的视图组件，其中el-*的元素为ElementUI组件\n\n&lt;template&gt;  &lt;div&gt;    &lt;el-form ref=&quot;loginForm&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot; class=&quot;login-box&quot;&gt;      &lt;h3 class=&quot;login-title&quot;&gt;欢迎 登录&lt;/h3&gt;      &lt;el-form-item label=&quot; 账号&quot; prop=&quot;username&quot;&gt;        &lt;el-input type=&quot;text&quot; placeholder=&quot;请输入账号&quot; v-model=&quot;form.username&quot;/&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot; 密码&quot; prop=&quot;password&quot;&gt;        &lt;el-input type=&quot;password&quot; placeholder=&quot; 请输入密码&quot; v-model=&quot;form.password&quot;/&gt;      &lt;/el-form-item&gt;      &lt;el-form-item&gt;        &lt;el-button type=&quot;primary&quot; v-on:click=&quot;onSubmit( &#x27;loginForm&#x27; )&quot;&gt;登录&lt;/el-button&gt;      &lt;/el-form-item&gt;    &lt;/el-form&gt;    &lt;el-dialog      title=&quot;温馨提示&quot;      :visible.sync=&quot;dialogVisible&quot;      width=&quot;30%&quot;      :before-close=&quot;handLeClose&quot;&gt;      &lt;span&gt;请输入账号和密码&lt;/span&gt;      &lt;span slot=&quot;footer&quot; class=&quot;dialog- footer&quot;&gt;        &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确定&lt;/el-button&gt;      &lt;/span&gt;    &lt;/el-dialog&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Login&quot;,  data() &#123;    return &#123;      form: &#123;        username: &#x27;&#x27;,        password: &#x27;&#x27;      &#125;,      //表单验证，需要在el-form-item 元素中增加prop 属性      rules: &#123;        username: [          &#123;required: true, message: &quot; 账号不可为空&quot;, trigger: &#x27;blur&#x27;&#125;        ],        password: [          &#123;required: true, message: &quot; 密码不可为空 &quot;, trigger: &#x27;blur&#x27;&#125;        ]      &#125;,//对话框显示和隐藏      dialogVisible: false    &#125;  &#125;,  methods: &#123;    onSubmit(formName) &#123;//为表单绑定验证功能      this.$refs [formName].validate((valid) =&gt; &#123;        if (valid) &#123;//使用vue-router路由到指定页面，该方式称之为编程式导航          this.$router.push(&quot;/main&quot;);        &#125; else &#123;          this.dialogVisible = true;          return false;        &#125;      &#125;);    &#125;  &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.login-box &#123;  border: 1px solid #DCDFE6;  width: 350px;  margin: 180px auto;  padding: 35px 35px 15px 35px;  border-radius: 5px;  -webkit-border-radius: 5px;  -moz-border-radius: 5px;  box-shadow: 0 0 25px #909399;&#125;.login-title &#123;  text-align: center;  margin: 0 auto 40px auto;  color: #303133;&#125;&lt;/style&gt;\n\n\n配置路由\n\nimport Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;import Main from &#x27;../views/Main&#x27;import Login from &#x27;../views/Login&#x27;Vue.use(Router)export default new Router(&#123;  routes: [    &#123;      path: &#x27;/main&#x27;,      component: Main    &#125;,    &#123;      path: &#x27;/login&#x27;,      component: Login    &#125;  ]&#125;)\n\n\n路由写完了需要配置到main.js\n\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import router from &#x27;./router&#x27;import ElementUI from &#x27;element-ui&#x27;;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;vue.use(router);vue.use(ElementUI);new Vue(&#123;  el: &#x27;#app&#x27;,  router,  render: h =&gt; h(App)&#125;)\n\n\n页面在App.vue中展示\n\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;App&#x27;&#125;&lt;/script&gt;\n","tags":["Vue"]},{"title":"Vue之vue-router路由","url":"/2022/05/30/Vue%E4%B9%8Bvue-router%E8%B7%AF%E7%94%B1/","content":"1、说明Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反 掌。包含的功能有：\n\n嵌套的路由&#x2F;视图表 \n模块化的、基于组件的路由配置 \n路由参数、查询、通配符 \n基于 Vue.js 过渡系统的视图过渡效果\n细粒度的导航控制 \n带有自动激活的 CSS class 的链接 \nHTML5 历史模式或 hash 模式，在 IE9 中自动降级 \n自定义的滚动条行为\n\n2、安装基于第一个 vue-cli进行测试学习;先查看node_modules中是否存在 vue-router\nue-router 是一个插件包，所以我们还是需要用 npm&#x2F;cnpm 来进行安装的。打开命令行工具，进入你 的项目目录，输入下面命令。\n npm install vue-router@3.5.2\n\n如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能：\nimport Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;// 显示的使用Vue.use(VueRouter);\n\n3、测试1、components 目录下存放我们自己编写的组件 \n2、定义组件 Content.vue 组件\n&lt;template&gt;&lt;div&gt;  &lt;h1&gt;内容页&lt;/h1&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Content&quot;&#125;&lt;/script&gt;\n\n3、安装路由,在src目录下,新建一个文件夹 : router ,专门存放路由，写入 index.js\nimport Vue from &#x27;vue&#x27;//导入路由插件import Router from &#x27;vue-router&#x27;//导入上面定义的组件import Content from &#x27;../components/Content&#x27;//安装路由Vue.use(Router);//配置路由export default new Router(&#123;  routes:[    &#123;      //路由路径      path:&#x27;/content&#x27;,      //路由名称      name:&#x27;content&#x27;      //跳转到组件      component:Content    &#125;  ]&#125;);\n\n4、我们在新建一个 Main.vue 组件\n&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;首页&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Main&quot;&#125;&lt;/script&gt;\n\n5、将Main组件也配置到路由中！\nimport Vue from &#x27;vue&#x27;//导入路由插件import Router from &#x27;vue-router&#x27;//导入上面定义的组件import Content from &#x27;../components/Content&#x27;import Main from &#x27;../components/Main&#x27;//安装路由Vue.use(Router);//配置路由export default new Router(&#123;  routes:[    &#123;      //路由路径      path:&#x27;/content&#x27;,      //路由名称      name:&#x27;content&#x27;,      //跳转到组件      component:Content    &#125;,    &#123;      //路由路径      path:&#x27;/main&#x27;,      //路由名称      name:&#x27;main&#x27;,      //跳转到组件      component:Main    &#125;,  ]&#125;);\n\n6、在 main.js 中配置路由\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;// 导入上面创建的路由配置目录import router from &#x27;./router&#x27;Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123;  el: &#x27;#app&#x27;,  router,  components: &#123; App &#125;,  template: &#x27;&lt;App/&gt;&#x27;&#125;)\n\n7、在 App.vue 中使用路由\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;router-link to=&quot;/main&quot;&gt;首页&lt;/router-link&gt;    &lt;router-link to=&quot;/content&quot;&gt;内容&lt;/router-link&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;\n\n4、路由模式与404路由模式有两种： \n\nhash：路径带 # 符号，如 http://localhost/#/login \nhistory：路径不带 # 符号，如 http://localhost/login\n\n修改路由配置，代码如下：\nexport default new Router(&#123;mode: &#x27;history&#x27;,routes: []&#125;);\n\n处理 404 创建一个名为 NotFound.vue 的视图组件，代码如下：\n&lt;template&gt;    &lt;div&gt;        页面不存在，请重试！      &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;NotFound&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n修改路由配置，代码如下：\nimport NotFound from &#x27;../components/NotFound&#x27;&#123;    path: &#x27;*&#x27;,    component: NotFound&#125;\n\n5.路由钩子钩子就是我们前面说的vue生命周期中的钩子函数，路由钩子就是在请求对应的路由的时候，可以在请求到这个子组件之前添加一些自定义操作，在离开这个路由到的组件的时候做一些操作\n\n\nbeforeRouteEnter：在进入路由前执行\nbeforeRouteLeave：在离开路由后执行\n\n1.路由钩子的使用路由钩子需要设置在我们需要设置设置它的子组件中，比如我们使用Profile.vue组件设置路由钩子\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;用户信息页&lt;/h2&gt;    &#123;&#123;id&#125;&#125;---&#123;&#123;name&#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: [&#x27;id&#x27;,&#x27;name&#x27;],  name: &quot;profile&quot;,  beforeRouteEnter: (to,from,next)=&gt;&#123;    console.log(&quot;进入我的信息页之前&#x27;&quot;),      next()  &#125;,  beforeRouteLeave: (to,from,next)=&gt;&#123;    console.log(&quot;离开我的信息页之前&quot;)    next()  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n参数说明\n\nto：路由将要跳转的路径信息\nfrom：路径跳转前的路径信息\nnext：路由的控制参数\nnext() 跳入下一个页面\nnext(’&#x2F;path’) 改变路由的跳转方向，使其跳到另外一个路由\nnext(false) 返回原来的页面\nnext((vm)&#x3D;&gt;{}) 仅在 beforeRouteEnter 中可用，vm 是组件实例\n\n2.在钩子函数中使用异步请求我们应该将我们的异步请求和路由钩子合并起来使用，比如在加载用户信息页面的时候，我们将请求用户数据的异步请求放在beforeRouteEnter里去执行，这样用户在请求到页面的时候数据已经加载过来了，我们只需要将数据取出来渲染到视图组件上即可\n安装注：npm不行就cnpm\nnpm install --save axios vue-axios\n\n\nmain.js引用 Axios\n\nimport axios from &#x27;axios&#x27;import VueAxios from &#x27;vue-axios&#x27;Vue.use(VueAxios, axios)\n\n在static文件夹(只有static文件夹下的资源才能直接请求到)下创建一个用于测试的JSON格式数据，首先创建一个名为mock的文件夹，开发中一般都将自己的测试用的假数据放在这个文件夹中；在这个文件夹中创建一个json格式的文件data.json\n&#123;  &quot;name&quot;: &quot;Java&quot;,  &quot;url&quot;: &quot;ainianxu.github.io&quot;,  &quot;page&quot;: 1,  &quot;isNonProfit&quot;: true,  &quot;address&quot;: &#123;    &quot;street&quot;: &quot;含光门&quot;,    &quot;city&quot;: &quot;陕西西安&quot;,    &quot;country&quot;: &quot;中国&quot;  &#125;,  &quot;links&quot;: [    &#123;      &quot;name&quot;: &quot;bilibili&quot;,      &quot;url&quot;: &quot;ainianxu.github.io&quot;    &#125;,    &#123;      &quot;name&quot;: &quot;java&quot;,      &quot;url&quot;: &quot;ainianxu.github.io&quot;    &#125;,    &#123;      &quot;name&quot;: &quot;百度&quot;,      &quot;url&quot;: &quot;https://www.baidu.com/&quot;    &#125;  ]&#125;\n\n\n在Profile.vue中新增使用axios进行异步通信的方法\n\nmethods:&#123;  getData:function () &#123;    this.axios(&#123;      method:&quot;get&quot;,      url:&quot;http://localhost:8080/static/mock/data.json&quot;    &#125;).then(response=&gt;console.log(response))  &#125;&#125;\n\n\n在beforeRouteEnter中调用这个方法\n\nbeforeRouteEnter: (to,from,next)=&gt;&#123;  console.log(&quot;进入&#x27;我的信息页&#x27;之前&quot;),    next(vm =&gt; &#123;      vm.getData();    &#125;);&#125;,\n\n\n将获取的数据渲染到数据模板上\n\n&lt;template&gt;  &lt;div&gt;    &lt;h2&gt;用户信息页&lt;/h2&gt;    &#123;&#123;id&#125;&#125;---&#123;&#123;name&#125;&#125;&lt;br&gt;    &#123;&#123;info.name&#125;&#125;---&#123;&#123;info.url&#125;&#125;---&#123;&#123;info.address&#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: [&#x27;id&#x27;,&#x27;name&#x27;],  name: &quot;profile&quot;,  data()&#123;    return&#123;      info:&#123;        name: null,        url: null,        address: &#123;          street: null,          city: null,          country: null        &#125;      &#125;    &#125;  &#125;,  beforeRouteEnter: (to,from,next)=&gt;&#123;    console.log(&quot;进入&#x27;我的信息页&#x27;之前&quot;),      next(vm =&gt; &#123;        vm.getData();      &#125;);  &#125;,  beforeRouteLeave: (to,from,next)=&gt;&#123;    console.log(&quot;离开&#x27;我的信息页&#x27;之前&quot;)    next()  &#125;,  methods:&#123;    getData:function () &#123;      this.axios(&#123;        method:&quot;get&quot;,        url:&quot;http://localhost:8080/static/mock/data.json&quot;      &#125;).then(response=&gt;console.log(this.info = response.data))    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n6、小结\n路由模式：就是我们使用的VueRouter对象实例化的时候的一个对象属性mode，它默认值为hash，这导致我们的vue项目的路径中总有一个#符号；我们可以将mode显式的设置为history，这样url中就没有#符号了\n处理404：就是将没有在我们配置的路由文件中的url请求全部转到我们自定义的404组件即可\n路由钩子：就是通过路由在跳转到某一个组件之前我们可以通过路由钩子函数做一些事情，在离开这个通过路由跳转的组件的前一刻，我们也可以通过路由钩子函数做一些事情，这些事情都是我们根据自己的需求自定义的(这其实就和前面学习的vue对象的生命周期中使用的钩子函数是一个道理)\n路由钩子的使用：就是在要跳转的那个组件中直接按照使用钩子函数的语法使用路由钩子即可\n在钩子函数中使用异步请求：就是将axios的异步通信功能和路由钩子的功能进行融合，注意我们需要自己在这个组件中定义一个方法来实现axios异步通信，再在路由钩子中的next(vm &#x3D;&gt; {vm.方法名称})来调用这个方法\n\n","tags":["Vue"]},{"title":"Vue之前后分离的演变史","url":"/2022/05/23/Vue%E4%B9%8B%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E7%9A%84%E6%BC%94%E5%8F%98%E5%8F%B2/","content":"后端为主的 MVC 时代为了降低开发的复杂度，以后端为出发点，比如：Struts、SpringMVC 等框架的使用，就是后端的 MVC 时代\n以 SpringMVC 流程为例：\n\n\n发起请求到前端控制器( DispatcherServlet ) \n前端控制器请求 HandlerMapping 查找 Handler ，可以根据 xml 配置、注解进行查找 \n处理器映射器 HandlerMapping 向前端控制器返回 Handler \n前端控制器调用处理器适配器去执行 Handler \n处理器适配器去执行 Handler \nHandler 执行完成给适配器返回 ModelAndView \n处理器适配器向前端控制器返回 ModelAndView ， ModelAndView 是 SpringMVC 框架的 一个底层对象，包括 Model 和 View \n前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图( JSP ) \n视图解析器向前端控制器返回 View \n前端控制器进行视图渲染，视图渲染将模型数据(在 ModelAndView 对象中)填充到 request 域 \n前端控制器向用户响应结果\n\n优点：\nMVC 是一个非常好的协作模式，能够有效降低代码的耦合度，从架构上能够让开发者明白代码应该写在 哪里。为了让 View 更纯粹，还可以使用 Thymeleaf、Freemarker 等模板引擎，使模板里无法写入 Java 代码，让前后端分工更加清晰。 \n缺点： \n前端开发重度依赖开发环境，开发效率低，这种架构下，前后端协作有两种模式： \n1、第一种是前端写 DEMO，写好后，让后端去套模板。好处是 DEMO 可以本地开发，很高效。不足是 还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大； \n2、另一种协作模式是前端负责浏览器端的所有开发和服务器端的 View 层模板开发。好处是 UI 相关的 代码都是前端去写就好，后端不用太关注，不足就是前端开发重度绑定后端环境，环境成为影响前端开 发效率的重要因素。 \n前后端职责纠缠不清：模板引擎功能强大，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这 样，只要前端弱势一点，往往就会被后端要求在模板层写出不少业务代码。还有一个很大的灰色地带是 Controller ，页面路由等功能本应该是前端最关注的，但却是由后端来实现。 Controller 本 身与 Model 往往也会纠缠不清，看了让人咬牙的业务代码经常会出现在 Controller 层。这些问 题不能全归结于程序员的素养，否则 JSP 就够了。 \n对前端发挥的局限性：性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作；\n注：在这期间（2005 年以前），包括早期的 JSP、PHP 可以称之为 Web 1.0 时代。在这里想说一句， 如果你是一名 Java 初学者，请你不要再把一些陈旧的技术当回事了，比如 JSP，因为时代在变、技术在 变、什么都在变（引用扎克伯格的一句话：唯一不变的是变化本身）\n基于 AJAX 带来的 SPA 时代时间回到 2005 年 AJAX （Asynchronous JavaScript And XML，异步 JavaScript 和 XML，老技术新 用法） 被正式提出并开始使用 CDN 作为静态资源存储，于是出现了 JavaScript 王者归来（在这之前 JS 都是用来在网页上贴狗皮膏药广告的）的 SPA（Single Page Application）单页面应用时代。\n\n优点： \n这种模式下，前后端的分工非常清晰，前后端的关键协作点是 AJAX 接口。看起来是如此美妙，但回过头来看看的话，这与 JSP 时代区别不大。复杂度从服务端的 JSP 里移到了浏览器的 JavaScript，浏览器端变得很复杂。类似 Spring MVC，这个时代开始出现浏览器端的分层架构：\n\n缺点： \n\n前后端接口的约定： 如果后端的接口一塌糊涂，如果后端的业务模型不够稳定，那么前端开发会很 痛苦；不少团队也有类似尝试，通过接口规则、接口平台等方式来做。有了和后端一起沉淀的 接口 规则，还可以用来模拟数据，使得前后端可以在约定接口后实现高效并行开发。 \n前端开发的复杂度控制： SPA 应用大多以功能交互型为主，JavaScript 代码过十万行很正常。大量 JS 代码的组织，与 View 层的绑定等，都不是容易的事情。\n\n前端为主的 MV* 时代此处的 MV* 模式如下： \n\nMVC（同步通信为主）：Model、View、Controller\nMVP（异步通信为主）：Model、View、Presenter \nMVVM（异步通信为主）：Model、View、ViewModel \n为了降低前端开发复杂度，涌现了大量的前端框架，比如： AngularJS 、 React 、 Vue.js 、 EmberJS 等，这些框架总的原则是先按类型分层，比如 Templates、Controllers、 Models，然后再在层内做切分，如下图：\n\n\n优点： \n\n前后端职责很清晰： 前端工作在浏览器端，后端工作在服务端。清晰的分工，可以让开发并行，测试数据的模拟不难，前端可以本地开发。后端则可以专注于业务逻辑的处理，输出 RESTful等接口。 \n前端开发的复杂度可控： 前端代码很重，但合理的分层，让前端代码能各司其职。这一块蛮有意思 的，简单如模板特性的选择，就有很多很多讲究。并非越强大越好，限制什么，留下哪些自由，代 码应该如何组织，所有这一切设计，得花一本书的厚度去说明。 \n部署相对独立： 可以快速改进产品体验\n\n缺点： \n\n代码不能复用。比如后端依旧需要对数据做各种校验，校验逻辑无法复用浏览器端的代码。如果可以复用，那么后端的数据校验可以相对简单化。 \n全异步，对 SEO 不利。往往还需要服务端做同步渲染的降级方案。 \n性能并非最佳，特别是移动互联网环境下。 \nSPA 不能满足所有需求，依旧存在大量多页面应用。URL Design 需要后端配合，前端无法完全掌 控。\n\nNodeJS 带来的全栈时代前端为主的 MV* 模式解决了很多很多问题，但如上所述，依旧存在不少不足之处。随着 NodeJS 的兴 起，JavaScript 开始有能力运行在服务端。这意味着可以有一种新的研发模式：\n\n在这种研发模式下，前后端的职责很清晰。对前端来说，两个 UI 层各司其职： \n\nFront-end UI layer 处理浏览器层的展现逻辑。通过 CSS 渲染样式，通过 JavaScript 添加交互功 能，HTML 的生成也可以放在这层，具体看应用场景。 \nBack-end UI layer 处理路由、模板、数据获取、Cookie 等。通过路由，前端终于可以自主把控 URL Design，这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以摆脱 对展现的强关注，转而可以专心于业务逻辑层的开发。\n\n通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要 SEO 的场景可 以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不 足，通过这种模式几乎都能完美解决掉。 \n与 JSP 模式相比，全栈模式看起来是一种回归，也的确是一种向原始开发模式的回归，不过是一种螺旋 上升式的回归。\n小结前后分离的开发思想主要是基 于 SoC （关注度分离原则），上面种种模式，都是让前后端的职责更清晰，分工更合理高效。\n","tags":["Vue"]},{"title":"Vue之前端核心分析","url":"/2022/05/23/Vue%E4%B9%8B%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E5%88%86%E6%9E%90/","content":"前端体系想要成为真正的“互联网 Java 全栈工程师”还有很长的一段路要走，其中“我大前端”是绕不开的一门必修课。 \n\n前端三要素\n前端三要素\n\n\nHTML（结构）：超文本标记语言（Hyper Text Markup Language），决定网页的结构和内容 \nCSS（表现）：层叠样式表（Cascading Style Sheets），设定网页的表现样式 \nJavaScript（行为）：是一种弱类型脚本语言，其源代码不需经过编译，而是由浏览器解释运行， 用于控制网页的行为\n\n\n结构层（HTML）\n\n\n略\n\n\n表现层（CSS）\n\nCSS 层叠样式表是一门标记语言，并不是编程语言，因此不可以自定义变量，不可以引用等，换句话说 就是不具备任何语法支持，它主要缺陷如下： \n\n语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器； \n没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难 以维护；\n\n这就导致了我们在工作中无端增加了许多工作量。为了解决这个问题，前端开发人员会使用一种称之为 【CSS 预处理器】 的工具，提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了前端在样式上的开发效率。\n\n什么是 CSS 预处理器?\n\nCSS 预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行 CSS 的编码工作。转化成通俗易懂的话来说就是“用一种专门的编程语言，进行 Web 页面样式设计，再通过编译器转化为正常的 CSS 文 件，以供项目使用”。\n\n常用的 CSS 预处理器有哪些：\n\n\nSASS：基于 Ruby，通过服务端处理，功能强大。解析效率高。需要学习 Ruby 语言，上手难度高于LESS。 \nLESS：基于 NodeJS，通过客户端处理，使用简单。功能比 SASS 简单，解析效率也低于 SASS，但 在实际开发中足够了，所以我们后台人员如果需要的话，建议使用 LESS。\n\n\n行为层（JavaScript）\n\nJavaScript 一门弱类型脚本语言，其源代码在发往客户端运行之前不需经过编译，而是将文本格式的字符代码发送给浏览器由浏览器解释运行。\n\nNative 原生 JS 开发\n\n原生 JS 开发，也就是让我们按照 【ECMAScript】 标准的开发方式，简称是 ES，特点是所有浏览器都 支持。ES 标准已发布如下版本：ES3~ES9\n\nTypeScript 微软的标准\n\nTypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这 个语言添加了可选的静态类型和基于类的面向对象编程。由安德斯·海尔斯伯格（C#、Delphi、 TypeScript 之父；.NET 创立者）主导。\nJavaScript 框架\njQuery库\n\n大家最熟知的 JavaScript 库，优点是简化了 DOM 操作，缺点是 DOM 操作太频繁，影响前端性能；在 前端眼里使用它仅仅是为了兼容 IE6、7、8；\n\nAngular\n\nGoogle 收购的前端框架，由一群 Java 程序员开发，其特点是将后台的 MVC 模式搬到了前端并增加了模 块化开发的理念，与微软合作，采用 TypeScript 语法开发；对后台程序员友好，对前端程序员不太友好；最大的缺点是版本迭代不合理（如：1代 -&gt; 2代，除了名字，基本就是两个东西；已推出了 Angular6）\n\nReact\n\nFacebook 出品，一款高性能的 JS 前端框架；特点是提出了新概念 【虚拟 DOM】 用于减少真实 DOM 操作，在内存中模拟 DOM 操作，有效的提升了前端渲染效率；缺点是使用复杂，因为需要额外学习一 门 【JSX】 语言；\n\nVue\n\n一款渐进式 JavaScript 框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态 管理等新特性。其特点是综合了 Angular（模块化） 和 React（虚拟 DOM） 的优点；\n\nAxios\n\n前端通信框架；因为 Vue 的边界很明确，就是为了处理 DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用 jQuery 提供的 AJAX 通信功能；\nJavaScript 构建工具\nBabel：JS 编译工具，主要用于浏览器不支持的 ES 新特性，比如用于编译 TypeScript \nWebPack：模块打包器，主要作用是打包、压缩、合并及按序加载\n\n前端所需后端技术前端人员为了方便开发也需要掌握一定的后端技术，但我们 Java 后台人员知道后台知识体系极其庞大复杂，所以为了方便前端人员开发后台应用，就出现了 NodeJS 这样的技术。 \nNodeJS 的作者已经声称放弃 NodeJS，开始开发全新架构的 Deno。 \n既然是后台技术，那肯定也需要框架和项目管理工具，NodeJS 框架及项目管理工具如下：\n\nExpress：NodeJS 框架 \nKoa：Express 简化版 \nNPM：项目综合管理工具，类似于 Maven \nYARN：NPM 的替代方案，类似于 Maven 和 Gradle 的关系\n\nUI 框架\n常用\n\n\nAnt-Design：阿里巴巴出品，基于 React 的 UI 框架 \nElementUI、iview、ice：饿了么出品，基于 Vue 的 UI 框架 \nBootstrap：Twitter 推出的一个用于前端开发的开源工具包 \nAmazeUI：又叫“妹子 UI”，一款 HTML5 跨屏前端框架 \nLayui：轻量级框架\n\n\niView\n\niview 是一个强大的基于 Vue 的 UI 库，有很多实用的基础组件比 elementui 的组件更丰富，主要服务于 PC 界面的中后台产品。使用单文件的 Vue 组件化开发模式 基于 npm + webpack + babel 开发，支持 ES2015 高质量、功能丰富友好的 API ，自由灵活地使用空间。 \n\n[官网地址] https://www.iviewui.com/ \n[Github] https://github.com/TalkingData/iview-weapp\n[iview-admin] https://github.com/iview/iview-admin\n\n备注：属于前端主流框架，选型时可考虑使用，主要特点是移动端支持较多\n\nElementUI\n\nElement 是饿了么前端开源维护的 Vue UI 组件库，组件齐全，基本涵盖后台所需的所有组件，文档讲 解详细，例子也很丰富。主要用于开发 PC 端的页面，是一个质量比较高的 Vue UI 组件库。 \n\n[官网地址] http://element-cn.eleme.io/#/zh-CN \n[Github] https://github.com/ElementUI/element-starter \n[vue-element-admin] https://github.com/PanJiaChen/vue-element-admin\n\n备注：属于前端主流框架，选型时可考虑使用，主要特点是桌面端支持较多\n\nICE\n\n飞冰是阿里巴巴团队基于 React&#x2F;Angular&#x2F;Vue 的中后台应用解决方案，在阿里巴巴内部，已经有 270 多 个来自几乎所有 BU 的项目在使用。飞冰包含了一条从设计端到开发端的完整链路，帮助用户快速搭建 属于自己的中后台应用。 \n\n[官网地址] https://alibaba.github.io/ice \n[Github] https://github.com/alibaba/ice\n\n备注：主要组件还是以 React 为主，截止 2019 年 02 月 17 日更新博客前对 Vue 的支持还不太完善， 目前尚处于观望阶段\n\nVantUI\n\nVant UI 是有赞前端团队基于有赞统一的规范实现的 Vue 组件库，提供了一整套 UI 基础组件和业务组 件。通过 Vant，可以快速搭建出风格统一的页面，提升开发效率。 \n\n[官网地址] https://youzan.github.io/vant/#/zh-CN/intro \n[Github] https://github.com/youzan/vant\n\n\nAtUI\n\nat-ui 是一款基于 Vue 2.x 的前端 UI 组件库，主要用于快速开发 PC 网站产品。 它提供了一套 npm + webpack + babel 前端开发工作流程，CSS 样式独立，即使采用不同的框架实现都能保持统一的 UI 风 格。 \n\n[官网地址] https://at-ui.github.io/at-ui/#/zh \n[Github] https://github.com/at-ui/at-ui\n\n\nCubeUI\n\ncube-ui 是滴滴团队开发的基于 Vue.js 实现的精致移动端组件库。支持按需引入和后编译，轻量灵活； 扩展性强，可以方便地基于现有组件实现二次开发。\n\n[官网地址] https://didi.github.io/cube-ui/#/zh-CN \n[Github] https://github.com/didi/cube-ui/\n\n\nFlutter\n\nFlutter 是谷歌的移动端 UI 框架，可在极短的时间内构建 Android 和 iOS 上高质量的原生级应用。 Flutter 可与现有代码一起工作, 它被世界各地的开发者和组织使用, 并且 Flutter 是免费和开源的。 \n\n[官网地址] https://flutter.dev/docs \n[Github] https://github.com/flutter/flutte\n\n备注：Google 出品，主要特点是快速构建原生 APP 应用程序，如做混合应用该框架为必选框架\n\nIonic\n\nIonic 既是一个 CSS 框架也是一个 Javascript UI 库，Ionic 是目前最有潜力的一款 HTML5 手机应用开发框架。通过 SASS 构建应用程序，它提供了很多 UI 组件来帮助开发者开发强大的应用。它使用 JavaScript MVVM 框架和 AngularJS&#x2F;Vue 来增强应用。提供数据的双向绑定，使用它成为 Web 和移动 开发者的共同选择。 \n\n[官网地址] https://ionicframework.com/ \n[官网文档] https://ionicframework.com/docs/\n[Github] https://github.com/ionic-team/ionic\n\n\nmpvue\n\nmpvue 是美团开发的一个使用 Vue.js 开发小程序的前端框架，目前支持微信小程序、百度智能小程 序，头条小程序和支付宝小程序。 框架基于 Vue.js，修改了的运行时框架 runtime 和代码编译器 compiler 实现，使其可运行在小程序环境中，从而为小程序开发引入了 Vue.js 开发体验。 \n\n[官网地址] http://mpvue.com/ \n[Github] https://github.com/Meituan-Dianping/mpvue\n\n备注：完备的 Vue 开发体验，并且支持多平台的小程序开发，推荐使用\n\n WeUI\n\nWeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序 量身设计，令用户的使用感知更加统一。包含 button、cell、dialog、toast、article、icon 等各式元素。\n\n[官网地址] https://weui.io/ \n[Github] https://github.com/weui/weui.git\n\n","tags":["Vue"]},{"title":"Vue之基础语法","url":"/2022/05/24/Vue%E4%B9%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","content":"我们对于基础语法，说白了就是实现元素赋值，循环，判断，以及事件响应即可！\n1、v-bind我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们在控制台操作对象属 性，界面可以实时更新！\n我们还可以使用 v-bind 来绑定元素特性!\n代码：01-v-bind.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;!--    如果要将模型数据绑定在html属性中    则使用 v-bind 指令,此时title中显示的是模型数据    --&gt;    &lt;h1 v-bind:title=&quot;message&quot;&gt;鼠标悬停几秒钟查看此处动态绑定的提示信息！&lt;/h1&gt;    &lt;!-- v-bind 指令的简写形式： 冒号（:） --&gt;    &lt;h1 :title=&quot;message&quot;&gt;我是标题&lt;/h1&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    new Vue(&#123;        el: &#x27;#app&#x27;,        data:&#123;            message:&#x27;页面加载于&#x27;+new Date().toLocaleString()        &#125;    &#125;)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n你看到的 v-bind 特性被称为指令。指令带有前缀 v- ，以表示它们是 Vue 提供的特殊特性。 除了使用插值表达式进行数据渲染，也可以使用 v-bind指令，它的简写的形式就是一个冒号（:）\n2、v-if 系列什么是条件判断语句,以下两个属性！  \n\nv-if \nv-else-if \nv-else\n\n代码：02-v-if.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h1 v-if=&quot;type === &#x27;A&#x27;&quot;&gt;A&lt;/h1&gt;    &lt;h1 v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;B&lt;/h1&gt;    &lt;h1 v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;C&lt;/h1&gt;    &lt;h1 v-else&gt;who&lt;/h1&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue(&#123;        el: &#x27;#app&#x27;,        data:&#123;            type:&#x27;A&#x27;        &#125;    &#125;)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n测试：观察在控制台输入 vm.type &#x3D; ‘B’、’C’、’D’ 的变化\n3、v-for语法格式：\n&lt;div id=&quot;vue&quot;&gt;    &lt;li v-for=&quot;item in items&quot;&gt;  \t  &#123;&#123; item.message &#125;&#125;    &lt;/li&gt;&lt;/div&gt;\n\n注：items 是数组，item是数组元素迭代的别名。和Thymeleaf模板引擎的语法和这个十分的相似！\n代码：03-v-for.html\n&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;li v-for=&quot;item in items&quot;&gt;      &#123;&#123;item.message&#125;&#125;    &lt;/li&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue(&#123;        el: &#x27;#app&#x27;,        data:&#123;            items:[                &#123;message:&#x27;xiaofang&#x27;&#125;,                &#123;message:&#x27;xiaoxiao&#x27;&#125;            ]        &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;\n\n测试 ：在控制台输入 vm.items.push({message: ‘123’}) ，尝试追加一条数据，你会发现 浏览器中显示的内容会增加一条 123 .\n4、v-onv-on 监听事件： \n事件有Vue的事件、和前端页面本身的一些事件！我们这 click 是vue的事件，可以绑定到Vue中的 methods 中的方法事件！\n代码：04-v-on.html\n&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;!--    在这里我们使用了 v-on 绑定了 click 事件    并指定了名为 sayHi 的方法    --&gt;    &lt;button v-on:click=&quot;sayHi&quot;&gt;点我&lt;/button&gt;    &lt;!-- v-on 指令的简写形式 @ --&gt;    &lt;button @click=&quot;sayHi&quot;&gt;点我&lt;/button&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue(&#123;        el: &#x27;#app&#x27;,        data:&#123;            message:&#x27;Hello&#x27;        &#125;,        methods:&#123;            sayHi:function ()&#123;                // `this` 在方法里指向当前 Vue 实例                alert(this.message);            &#125;        &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;\n\n5、v-model\n双向数据绑定\n\nVue.js 是一个 MVVM 框架，即数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。这也算是 Vue.js 的精髓之处了。 \n值得注意的是，我们所说的数据双向绑定，一定是对于 UI 控件来说的，非 UI 控件不会涉及到数据双向绑定。对于我们处理表单，Vue.js 的双向数据绑定用起来就特别舒服了。 \n你可以用 v-model 指令在表单 &lt; input&gt;、&lt; textarea&gt; 及&lt; select&gt; 元元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。\n\n测试代码\n\n代码：05-v-bind-1.html 文本框\n&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;!-- v-bind:value只能进行单向的数据渲染 --&gt;    &lt;input type=&quot;text&quot; v-bind:value=&quot;searchMap.keyWord&quot;&gt;    &lt;!-- v-model 可以进行双向的数据绑定 --&gt;    &lt;input type=&quot;text&quot; v-model=&quot;searchMap.keyWord&quot;&gt;    &lt;p&gt;您要查询的是：&#123;&#123;searchMap.keyWord&#125;&#125;&lt;/p&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue(&#123;        el: &#x27;#app&#x27;,        data:&#123;            searchMap:&#123;                keyWord:&#x27;xiao&#x27;            &#125;        &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;\n\n代码：05-v-bind-2.html 单复选框\n&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    单复选框：    &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;    &amp;nbsp;&amp;nbsp;    &lt;label for=&quot;checkbox&quot;&gt;&#123;&#123;checked&#125;&#125;&lt;/label&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue(&#123;        el: &#x27;#app&#x27;,        data:&#123;            checked:false        &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;\n\n代码：05-v-bind-3.html 多复选框\n&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    多复选框：    &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;jack&quot; v-model=&quot;checkedNames&quot;&gt;    &amp;nbsp;&amp;nbsp;    &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;    &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;john&quot; v-model=&quot;checkedNames&quot;&gt;    &amp;nbsp;&amp;nbsp;    &lt;label for=&quot;john&quot;&gt;john&lt;/label&gt;    &lt;input type=&quot;checkbox&quot; id=&quot;Mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;    &amp;nbsp;&amp;nbsp;    &lt;label for=&quot;jack&quot;&gt;Mike&lt;/label&gt;    &lt;span&gt;选中的值: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue(&#123;        el: &#x27;#app&#x27;,        data:&#123;            checkedNames: []        &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;\n\n代码：05-v-bind-4.html 单选按钮\n&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    单选按钮：    &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;    &amp;nbsp;&amp;nbsp;    &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;    &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;    &amp;nbsp;&amp;nbsp;    &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;    &lt;span&gt;选中的值: &#123;&#123; picked &#125;&#125;&lt;/span&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue(&#123;        el: &#x27;#app&#x27;,        data:&#123;            picked: &#x27;&#x27;        &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;\n\n代码：05-v-bind-5.html 下拉框\n&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    下拉框：    &lt;select v-model=&quot;selected&quot;&gt;      &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt;      &lt;option&gt;A&lt;/option&gt;      &lt;option&gt;B&lt;/option&gt;      &lt;option&gt;C&lt;/option&gt;    &lt;/select&gt;    &lt;span&gt;选中的值: &#123;&#123; selected &#125;&#125;&lt;/span&gt;  &lt;/div&gt;  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue(&#123;        el: &#x27;#app&#x27;,        data:&#123;            selected: &#x27;&#x27;        &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;\n\n注意：如果 v-model 表达式的初始值未能匹配任何选项，&lt; select&gt; 元素将被渲染为“未选中”状态。 在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此， 更推荐像上面这样提供一个值为空的禁用选项。\n","tags":["Vue"]},{"title":"Vue之插槽slot","url":"/2022/05/29/Vue%E4%B9%8B%E6%8F%92%E6%A7%BDslot/","content":"在 Vue 中我们使用&lt; slot &gt;元素，作为承载分发内容的出口，作者称其为插槽，可以应用在组合组 件的场景中; \n比如准备制作一个待办事项组件（todo），该组件由待办标题（todo-title）和待办内容（todo-items） 组成，但这三个组件又是相互独立的，该如何操作呢？\n第一步: 定义一个待办事项的组件\n&lt;todo&gt;&lt;/todo&gt;// 定义一个待办事项的组件Vue.component(&#x27;todo&#x27;,&#123;    template:&#x27;&lt;div&gt;\\                &lt;div&gt;待办事项&lt;/div&gt;\\                  &lt;ul&gt;\\                      &lt;li&gt;vue&lt;/li&gt;\\                  &lt;/ul&gt;\\                &lt;/div&gt;&#x27;&#125;);\n\n\n第二步: 我们需要让待办事项的标题和值实现动态绑定,怎么做呢? 我们可以留出一个插槽!\n1、将上面的代码留出一个插槽,即 slot\nVue.component(&#x27;todo&#x27;,&#123;    template:&#x27;&lt;div&gt;\\                &lt;slot name=&quot;todo-title&quot;&gt;&lt;/slot&gt;\\                  &lt;ul&gt;\\                      &lt;slot name=&quot;todo-item&quot;&gt;&lt;/slot&gt;\\                  &lt;/ul&gt;\\                &lt;/div&gt;&#x27;&#125;);\n\n2、定义一个名为todo-title的待办标题组件和todo-items的待办内容组件\nVue.component(&#x27;todo-title&#x27;,&#123;    props:[&#x27;title&#x27;],    template: &#x27;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;&#x27;&#125;);//这里的index,就是数组的下标,使用for循环遍历的时候,可以循环出来!Vue.component(&#x27;todo-items&#x27;,&#123;    props: [&#x27;item&#x27;,&#x27;index&#x27;],    template:&#x27;&lt;li&gt;&#123;&#123;index+1&#125;&#125;.&#123;&#123;item&#125;&#125;&lt;/li&gt;&#x27;&#125;);\n\n3、实例化 Vue 并初始化数据\nvar vm =new Vue(&#123;    el:&#x27;#app&#x27;,      data:&#123;        title:&#x27;xiaofang&#x27;,        todoItems: [&#x27;Java&#x27;, &#x27;运维&#x27;, &#x27;前端&#x27;]      &#125;&#125;);\n\n4、将这些值,通过插槽插入\n&lt;div id=&quot;app&quot; &gt;&lt;todo&gt;  &lt;todo-title slot=&quot;todo-title&quot; v-bind:title=&quot;title&quot;&gt;&lt;/todo-title&gt;  &lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;(item,index) in todoItems&quot; v-bind:item=&quot;item&quot; v-bind:index=&quot;index&quot;&gt;&lt;/todo-items&gt;&lt;/todo&gt;&lt;/div&gt;\n\n\n说明:我们的 todo-title 和 todo-items 组件分别被分发到了 todo 组件的 todo-title 和 todo-items 插槽中\n","tags":["Vue"]},{"title":"Vue之第一个 vue-cli 应用程序","url":"/2022/05/30/Vue%E4%B9%8B%E7%AC%AC%E4%B8%80%E4%B8%AA-vue-cli-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","content":"什么是vue-clivue-cli 官方提供的一个脚手架,用于快速生成一个 vue 的项目模板 ;\n预先定义好的目录结构及基础代码，就好比咱们在创建 Maven 项目时可以选择创建一个骨架项目，这 个骨架项目就是脚手架,我们的开发更加的快速;\n主要的功能 : \n\n统一的目录结构 \n本地调试 \n热部署 \n单元测试 \n集成打包上线\n\n需要的环境安装 vue-cli（vue3）npm install -g @vue/cli# ORyarn global add @vue/cli\n\n安装之后，你就可以在命令行中访问 vue 命令。你可以通过简单运行 vue，看看是否展示出了一份所有可用命令的帮助信息，来验证它是否安装成功。\n你还可以用这个命令来检查其版本是否正确：\nvue --version\n\n拉取 2.x 模板 (旧版本)Vue CLI &gt;&#x3D; 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具：\nnpm install -g @vue/cli-init# `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同vue init webpack my-project# 一路都选择no即可;\n\n说明 : \n\nProject name：项目名称，默认回车即可 \nProject description：项目描述，默认 回车 即可 \nAuthor：项目作者，默认 回车 即可 \nInstall vue-router：是否安装 vue-router，选择 n 不安装（后期需要再手动添加） \nUse ESLint to lint your code：是否使用 ESLint 做代码检查，选择 n 不安装（后期需要再手动添加） \nSet up unit tests：单元测试相关，选择 n 不安装（后期需要再手动添加） \nSetup e2e tests with Nightwatch：单元测试相关，选择 n 不安装（后期需要再手动添加） \nShould we run npm install for you after the project has been created：创建完成后直接初始 化，选择 n，我们手动执行;运行结果!\n\n\n初始化并运行cd myvuenpm run dev\n\nVue-cli目录结构\n\nbuild 和 config：WebPack 配置文件 \nnode_modules：用于存放 npm install 安装的依赖文件 \nsrc： 项目源码目录 \nstatic：静态资源文件 \n.babelrc：Babel 配置文件，主要作用是将 ES6 转换为 ES5 \n.editorconfig：编辑器配置 \neslintignore：需要忽略的语法检查配置文件 \n.gitignore：git 忽略的配置文件 \n.postcssrc.js：css 相关配置文件，其中内部的 module.exports 是 NodeJS 模块化语法 \nindex.html：首页，仅作为模板页，实际开发时不使用 \npackage.json：项目的配置文件\nname：项目名称 \nversion：项目版本 \ndescription：项目描述 \nauthor：项目作者 \nscripts：封装常用命令 \ndependencies：生产环境依赖 \ndevDependencies：开发环境依赖\n\n\n\nmain.js项目的入口文件，我们知道所有的程序都会有一个入口\n// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123;  el: &#x27;#app&#x27;,  components: &#123; App &#125;,  template: &#x27;&lt;App/&gt;&#x27;&#125;)\n\n\nimport Vue from &#39;vue&#39; ：ES6 写法，会被转换成 require(“vue”); （require 是 NodeJS 提供 的模块加载器） \nimport App from &#39;./App&#39; ：意思同上，但是指定了查找路径，.&#x2F; 为当前目录 \nVue.config.productionTip = false ：关闭浏览器控制台关于环境的相关提示\nnew Vue(&#123;...&#125;) ：实例化 Vue \nel: &#39;#app&#39; ：查找 index.html 中 id 为 app 的元素 \ntemplate: &#39;&#39; ：模板，会将 index.html 中 替换为 \ncomponents: &#123; App &#125; ：引入组件，使用的是 import App from ‘.&#x2F;App’ 定义的 App 组件;\n\n\n\nApp.vue&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;img src=&quot;./assets/logo.png&quot;&gt;    &lt;HelloWorld/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from &#x27;./components/HelloWorld&#x27;export default &#123;  name: &#x27;App&#x27;,  components: &#123;    HelloWorld  &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;  font-family: &#x27;Avenir&#x27;, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;&#125;&lt;/style&gt;\n\n\ntemplate：HTML 代码模板，会替换 &lt; App &#x2F;&gt; 中的内容 \nimport HelloWorld from ‘.&#x2F;components&#x2F;HelloWorld’：引入 HelloWorld 组件用于替换 template 中的 &lt; HelloWorld&#x2F;&gt; \nexport default{…}：导出 NodeJS 对象，作用是可以通过 import 关键字导入 \nname: ‘App’：定义组件的名称 \ncomponents: { HelloWorld }：定义子组件\n\n\n在hello,Vue中,关于 &lt; style scoped&gt; 的说明：CSS 样式仅在当前组件有效，声明了样式的作用域, 是当前的界面私有的!\n\n第一个 vue-cli 应用程序运行以下命令来创建一个新项目：\nvue create hello-world\n\n初始化并运行cd hello-worldnpm run serve\n\n安装并运行成功后在浏览器输入：http://localhost:8080\n\n效果：\n\n","tags":["Vue"]},{"title":"Vue之第一个Vue程序","url":"/2022/05/23/Vue%E4%B9%8B%E7%AC%AC%E4%B8%80%E4%B8%AAVue%E7%A8%8B%E5%BA%8F/","content":"简介Vue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架，发布于 2014 年 2 月。与其它 大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上 手，还便于与第三方库（如：vue-router，vue-resource，vuex）或既有项目整合。\nMVVM 模式的实现者\nModel：模型层，在这里表示 JavaScript 对象 \nView：视图层，在这里表示 DOM（HTML 操作的元素） \nViewModel：连接视图和数据的中间件，Vue.js 就是 MVVM 中的 ViewModel 层的实现者\n\n在 MVVM 架构中，是不允许数据和视图直接通信的，只能通过 ViewModel 来通信，而 ViewModel 就是定义了一个 Observer 观察者。 \n\nViewModel 能够观察到数据的变化，并对视图对应的内容进行更新\nViewModel能够监听到视图的变化，并能够通知数据发生改变\n\n至此，我们就明白了，Vue.js 就是一个 MVVM 的实现者，他的核心就是实现了 DOM 监听与数据绑定\n为什么要使用 Vue.js\n轻量级，体积小是一个重要指标。Vue.js 压缩后有只有 20多kb （Angular 压缩后 56kb+，React 压缩后 44kb+） \n移动优先。更适合移动端，比如移动端的 Touch 事件\n易上手，学习曲线平稳，文档齐全\n吸取了 Angular（模块化）和 React（虚拟 DOM）的长处，并拥有自己独特的功能，如：计算属 性 \n开源，社区活跃度高\n\n第一个Vue程序准备注意：Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所 有兼容 ECMAScript 5 的浏览器。 \n开发版本 \n\n包含完整的警告和调试模式：https://vuejs.org/js/vue.js \n删除了警告，30.96KB min + gzip：https://vuejs.org/js/vue.min.js\n\nCDN\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt;\n\n\nHello,Vue\n\nVue.js 的核心是实现了 MVVM 模式，她扮演的角色就是 ViewModel 层，那么所谓的第一个应用程序就 是展示她的 数据绑定 功能，操作流程如下：\n1、创建一个 HTML 文件 01-hello.html\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;fang&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n2、引入 Vue.js\n&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;\n\n3、创建一个 Vue 的实例\n&lt;script type=&quot;text/javascript&quot;&gt;  var vm = new Vue(&#123;      el:&#x27;#vue&#x27;,      data:&#123;          message:&#x27;Hello Vue!&#x27;      &#125;  &#125;);&lt;/script&gt;\n\n说明：\n el:’#vue’ ：绑定元素的 ID \ndata:{message:’Hello Vue!’} ：数据对象中有一个名为 message 的属性，并设置了初始值 Hello Vue!\n4、将数据绑定到页面元素（视图层）\n&lt;div id=&quot;vue&quot;&gt;  &#123;&#123;message&#125;&#125;&lt;/div&gt;\n\n说明：只需要在绑定的元素中使用 双花括号 将 Vue 创建的名为 message 属性包裹起来，即可实现数据 绑定功能，也就实现了 ViewModel 层所需的效果，是不是和 EL 表达式非常像？\n测试： \n为了能够更直观的体验 Vue 带来的数据绑定功能，我们需要在浏览器测试一番，操作流程如下： \n1、在浏览器上运行第一个 Vue 应用程序，进入开发者工具 \n2、在控制台输入 vm.message &#x3D; ‘Hello World’ ，然后回车，你会发现浏览器中显示的内容会直 接变成 Hello World \n此时就可以在控制台直接输入 vm.message 来修改值，中间是可以省略 data 的，在这个操作中，我并没有主动操作 DOM，就让页面的内容发生了变化，这就是借助了 Vue 的 数据绑定功能实现的；MVVM 模式中要求 ViewModel 层就是使用观察者模式来实现数据的监听与绑定，以做到数据与视图的快速响应。\n","tags":["Vue"]},{"title":"Vue之自定义事件内容分发","url":"/2022/05/29/Vue%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/","content":"1、进阶：自定义事件通过以上代码不难发现，数据项在 Vue 的实例中，但删除操作要在组件中完成，那么组件如何才能删除 Vue 实例中的数据呢？此时就涉及到参数传递与事件分发了，Vue 为我们提供了自定义事件的功能很好的帮助我们解决了这个问题；使用 this.$emit(‘自定义事件名’, 参数)，操作过程如下:\n1、在vue的实例中,增加了 methods 对象并定义了一个名为 removeTodoItems 的方法\n var vm =new Vue(&#123;    el:&#x27;#app&#x27;,      data:&#123;        title:&#x27;xiaofang&#x27;,        todoItems: [&#x27;Java&#x27;, &#x27;运维&#x27;, &#x27;前端&#x27;]      &#125;,      methods:&#123;          // 该方法可以被模板中自定义事件触发          removeTodoItems:function (index)&#123;              // splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目              // 其中 index 为添加/删除项目的位置，1 表示删除的数量              this.todoItems.splice(index,1);          &#125;      &#125;&#125;);\n\n2、修改 todo-items 待办内容组件的代码,增加一个删除按钮,并且绑定事件!\nVue.component(&#x27;todo-items&#x27;,&#123;    props: [&#x27;item&#x27;,&#x27;index&#x27;],    template:&#x27;&lt;li&gt;&#123;&#123;index+1&#125;&#125;.&#123;&#123;item&#125;&#125; &lt;button @click=&quot;remove_component&quot;&gt;删除&lt;/button&gt;&lt;/li&gt;&#x27;,    methods:&#123;        remove_component:function (index)&#123;            // 这里的 remove 是自定义事件的名称，需要在 HTML 中使用 v-on:remove 的方式指派            this.$emit(&#x27;remove&#x27;,index);        &#125;    &#125;&#125;);\n\n3、修改 todo-items 待办内容组件的 HTML 代码,增加一个自定义事件,比如叫 remove,可以和组件的方法绑定,然后绑定到vue的方法中!\n&lt;!--增加了 v-on:remove=&quot;removeTodoItems(index)&quot; 自定义事件，该事件会调用 Vue 实例中定义的名为 removeTodoItems 的方法--&gt;&lt;todo-items slot=&quot;todo-items&quot; v-for=&quot;(item,index) in todoItems&quot; v-bind:item=&quot;item&quot; v-bind:index=&quot;index&quot; v-on:remove=&quot;removeTodoItems(index)&quot;&gt;&lt;/todo-items&gt;\n\n2、逻辑理解\n3、Vue 入门小结核心 : 数据驱动 , 组件化 \n优点 : 借鉴了 AngulaJS 的模块化开发 和 React 的虚拟Dom , 虚拟Dom就是把Dom操作放到内存中执行 ; \n常用的属性 :\n\nv-if \nv-else-if \nv-else \nv-for \nv-on 绑定事件 , 简写 @ \nv-model 数据双向绑定 \nv-bind 给组件绑定参数,简写 :\n\n组件化 :\n\n组合组件， slot 插槽。 \n组件内部绑定事件需要使用到 this.$emit(“事件名”,参数) ; \n计算属性的特色,缓存计算数据\n\n遵循SoC 关注度分离原则,Vue是纯粹的视图框架,并不包含,比如Ajax之类的通信功能,为了解决通信问题, 我们需要使用Axios 框架做异步通信；\n","tags":["Vue"]},{"title":"Vue之计算属性","url":"/2022/05/28/Vue%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/","content":"计算属性的重点突出在属性两个字上（属性是名词），首先它是个 属性 其次这个属性有计算的能力（计算是动词），这里的 计算 就是个函数；简单点说，它就是一个能够将计算结果缓存 起来的属性（将行为转化成了静态的属性），仅此而已；可以想象为缓存！\n代码测试：\n&lt;body&gt;&lt;div id=&quot;app&quot; &gt;  &lt;!--注意，一个是方法，一个是属性--&gt;  &lt;p&gt;调用当前时间的方法：&#123;&#123;currentTime1()&#125;&#125;&lt;/p&gt;  &lt;p&gt;当前时间的计算属性：&#123;&#123;currentTime2&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  var vm =new Vue(&#123;      el:&#x27;#app&#x27;,      data:&#123;          message:&#x27;Hello&#x27;      &#125;,      methods:&#123;          currentTime1:function ()&#123;              return Date.now();          &#125;      &#125;,      computed:&#123;          currentTime2:function ()&#123;              this.message;              return Date.now();          &#125;      &#125;  &#125;);&lt;/script&gt;&lt;/body&gt;\n\n注意：methods 和 computed 里的东西不能重名\n说明：\n\nmethods：定义方法，调用方法使用 currentTime1()，需要带括号； \ncomputed：定义计算属性，调用属性使用 currentTime2，不需要带括号；this.message 是为了能够让 currentTime2 观察到数据变化而变化； \n如果在方法中的值发生了变化，则缓存就会刷新！可以在控制台使用 vm.message&#x3D;”xiao” 改变下数据的值，再次测试观察效果！\n\n结论： \n调用方法时，每次都需要进行计算，既然有计算过程则必定产生系统开销，那如果这个结果是不经常变化的呢？此时就可以考虑将这个结果缓存起来，采用计算属性可以很方便的做到这一点，计算属性的主要特性就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销;\n","tags":["Vue"]},{"title":"Vue之路由嵌套、参数传递以及重定向","url":"/2022/06/06/Vue%E4%B9%8B%E8%B7%AF%E7%94%B1%E5%B5%8C%E5%A5%97%E3%80%81%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%BB%A5%E5%8F%8A%E9%87%8D%E5%AE%9A%E5%90%91/","content":"1、路由嵌套\n对于组件来说只是对局部的改变\n\n主要流程\n创建两个组件\n路由注册两个组件\n首页通过路径点击事件通过路由找到组件，将组件渲染上去\n\n\n\n\n在views中创建user列表，分别创建List.vue和Profile.vue\n\n&lt;template&gt;  &lt;h1&gt;用户列表&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;List&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n&lt;template&gt;  &lt;h1&gt;个人信息&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Profile&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n\n修改Main.vue\n\n&lt;template&gt;  &lt;el-container style=&quot;height: 500px; border: 1px solid #eee&quot;&gt;    &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt;      &lt;el-menu :default-openeds=&quot;[&#x27;1&#x27;, &#x27;3&#x27;]&quot;&gt;        &lt;el-submenu index=&quot;1&quot;&gt;          &lt;template slot=&quot;title&quot;&gt;            &lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt;用户管理          &lt;/template&gt;          &lt;el-menu-item-group&gt;            &lt;el-menu-item index=&quot;1-1&quot;&gt;              &lt;router-link to=&quot;/user/profile&quot;&gt;个人信息&lt;/router-link&gt;            &lt;/el-menu-item&gt;            &lt;el-menu-item index=&quot;1-2&quot;&gt;              &lt;router-link to=&quot;/user/list&quot;&gt;用户列表&lt;/router-link&gt;            &lt;/el-menu-item&gt;          &lt;/el-menu-item-group&gt;        &lt;/el-submenu&gt;        &lt;el-submenu index=&quot;2&quot;&gt;          &lt;template slot=&quot;title&quot;&gt;            &lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;内容管理          &lt;/template&gt;          &lt;el-menu-item-group&gt;            &lt;el-menu-item index=&quot;2-1&quot;&gt;分类管理&lt;/el-menu-item&gt;            &lt;el-menu-item index=&quot;2-2&quot;&gt;内容列表&lt;/el-menu-item&gt;          &lt;/el-menu-item-group&gt;        &lt;/el-submenu&gt;      &lt;/el-menu&gt;    &lt;/el-aside&gt;    &lt;el-container&gt;      &lt;el-header style=&quot;text-align: right; font-size: 12px&quot;&gt;        &lt;el-dropdown&gt;          &lt;i class=&quot;el-icon-setting&quot; style=&quot;margin-right: 15px&quot;&gt;&lt;/i&gt;          &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;            &lt;el-dropdown-item&gt;个人信息&lt;/el-dropdown-item&gt;            &lt;el-dropdown-item&gt;退出登录&lt;/el-dropdown-item&gt;          &lt;/el-dropdown-menu&gt;        &lt;/el-dropdown&gt;      &lt;/el-header&gt;      &lt;el-main&gt;        &lt;router-view&gt;&lt;/router-view&gt;      &lt;/el-main&gt;    &lt;/el-container&gt;  &lt;/el-container&gt;&lt;/template&gt;&lt;style&gt;.el-header &#123;  background-color: #b3c0d1;  color: #333;  line-height: 60px;&#125;.el-aside &#123;  color: #333;&#125;&lt;/style&gt;\n\n\n将两个组件导入到路由组件中\n\nimport Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;import Main from &#x27;../views/Main&#x27;import Login from &#x27;../views/Login&#x27;import List from &quot;../Views/user/List&quot;import Profile from &quot;../Views/user/Profile&quot;Vue.use(Router)export default new Router(&#123;  routes: [    &#123;      path: &#x27;/main&#x27;,      component: Main,      children:[        &#123;          path:&quot;/user/profile&quot;,          component:Profile        &#125;,&#123;          path:&quot;/user/list&quot;,          component:List        &#125;      ]    &#125;,    &#123;      path: &#x27;/login&#x27;,      component: Login    &#125;  ]&#125;)\n\n2、参数传递通过前端url传递参数，对应的路径添加params接收，显示参数\n\n修改Main.vue\n\n&lt;el-menu-item index=&quot;1-1&quot;&gt;  &lt;router-link v-bind:to=&quot;&#123;name:&#x27;UserProfile&#x27;,params:&#123;id:1&#125;&#125;&quot;&gt;个人信息&lt;/router-link&gt;&lt;/el-menu-item&gt;\n\n\n修改路由\n\nchildren:[  &#123;    path:&quot;/user/profile/:id&quot;,    name:&quot;Profile&quot;，    component:Profile  &#125;\n\n为了方便对接router，所以设定了一个名字，使用路径看着可能会清楚点\n\n修改Profile.vue\n\n&lt;div&gt;  &lt;h1&gt;个人信息&lt;/h1&gt;  &#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;\n\n不能放在根目录下，要不然会报错，注意是route，不是router\n另一种编写方式\n\n路由\n\nchildren:[  &#123;    path:&quot;/user/profile/:id&quot;,    name:&quot;Profile&quot;,    component:Profile,    props:true  &#125;\n\n\n修改Profile.vue\n\n&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;个人信息&lt;/h1&gt;    &#123;&#123;id&#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    props:[&#x27;id&#x27;],    name: &quot;Profile&quot;  &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n3、重定向\n修改Main.vue\n\n&lt;el-menu-item index=&quot;1-3&quot;&gt;  &lt;router-link to=&quot;/goHome&quot;&gt;回到首页&lt;/router-link&gt;&lt;/el-menu-item&gt;\n\n\n添加一个跳转路径为goHome，作用跳转回首页\n\n&#123;  path: &#x27;/goHome&#x27;,  redirect:&quot;/main&quot;&#125;\n","tags":["Vue"]},{"title":"java day01 Typora","url":"/2021/07/06/java%20day01%20Typora/","content":"Typora的使用熟练使用Markdown语法\n标题的使用一级标题为**#**\n二级标题为**##**\n三级标题为**###**\n字体的使用粗体 hello-&gt;左右两个*\n斜体hello-&gt;左右一个*\n斜体加粗hello-&gt;左右三个*\n删除线hello-&gt;左右两个~\n引用的使用\n引用别人文章时使用，左侧一个&gt;\n\n分割线\n\n左侧三个-\n左侧三个*\n\n\n图片\n本地图片\n\n\n\n网络图片\n\n\n通用方法：**!+[名字]+()**\n超链接CSDN\n方法：**[名称]+(链接)**\n列表\n前面使用的都是有序列表\n方法：数字+.+空格\n\n无须列表方法：**-+空格**\n\nA\nB\n\n\n\n表格\n\n\n名字\n性别\n年龄\n\n\n\n小昊\n女\n20\n\n\n格式如下所示：\n名字|性别|年龄\n–|–|–\n小昊|女|20\n代码public\n\n方法如下：\n英文下的&#96;&#96;&#96;(tab上面的按键)+想要写的语言\n被忽略的windows快捷键\nalt+F4：关闭所在页面\nshift+delete：永久删除\nwindows+tab：切换程序\n\n","tags":["java基础"]},{"title":"java day01 基础","url":"/2021/07/07/java%20day01%20%E5%9F%BA%E7%A1%80/","content":"01 注释单行注释：\n// 单行注释可以注释一行文字\n\n多行注释：\n/*多行注释可以注释一段文字*/\n\n文档注释：\n/***配合JavaDoc使用*/\n\n02 标识符与关键字关键字：class,public等Java硬性要求的代码。\n标识符：类名，变量名，方法名都是标识符。\n标识符的注意事项：\n\n所有标识符都应该以字母，$，或者下划线(_)开始\nString name = &quot;xiaofang&quot;;String $name = &quot;xiaofang&quot;;String _name = &quot;xiaofang&quot;;\n\n首字母之后可以是字母，$，或者下划线(_)或者数字\nString A$ = &quot;xiaofang&quot;;String A_ = &quot;xiaofang&quot;;String A1 = &quot;xiaofang&quot;;\n\n\n\n不能使用关键字作为变量名或方法名\n\n标识符不建议使用中文\n\n标识符是大小写敏感的\n\n\n03 数据类型Java是强类型语言，要求所有变量都必须定义后才能使用。\n\n基本数据类型如下表所示：\n\n\n\n整数类型\n浮点类型\n字符类型\n布尔类型\n\n\n\nbyte占1字节\nfloat占4字节\nchar占2字节\ntrue占1位\n\n\nshort占2字节\ndouble占8字节\n\nfalse占1位\n\n\nint占4字节\n\n\n\n\n\nlong占8字节\n\n\n\n\n\n//整数byte num = 10;short num1 = 15;int num2 = 20;long num3 = 30L;//long类型要在数字后加上L//浮点数float num5 = 10.1f;//float类型要在数字后加上fdouble num6 = 10.33333;//字符char name = &#x27;f&#x27;;//注意String不是关键字//布尔boolean flag = true;boolean flag1 = false;\n\n字节与位的关系：1 Byte&#x3D;8 bit\n\n数据类型面试拓展\n\n整型拓展：\n\nint i = 10;//输出10int i2 = 010;//八进制0开头 输出8int i3 = 0x10;//十六进制0x开头（范围：0~9 A~F） 输出16\n\n\n浮点数拓展：\n由于浮点数有舍入误差，接近但不等于的特点，最好不适用浮点数进行比较，可以使用BigDecimal提供的方法进行比较。\n\n字符拓展：\n所有字符的本质还是数字\nchar s1 = &#x27;a&#x27;;char s2 = &#x27;小&#x27;;System.out.println(s1);//输出 aSystem.out.println((int)s1);//强制转换 输出 97System.out.println(s2);//输出 小System.out.println((int)s2);//强制转换 输出 23567\n\n布尔拓展：\nboolean flag =true;if(flag)&#123;&#125; == if(flag==true)&#123;&#125;//二者是等价的\n\n04 类型转换\n强制类型转换：一般是高容量转换到低容量的转换。格式：**(类型)变量名**\n\nint i = 12;byte b = (byte)i;System.out.println(i);//输出12System.out.println(b);//输出12\n\n\n自动类型转化：低容量到高容量直接转换。\n低 -------------------------------------&gt;高 byte,short,char-&gt;int-&gt;long-&gt;float-&gt;double\n\nint i = 12;double b = i;System.out.println(i);//输出12System.out.println(b);//输出12.0\n\n注意点\n\n布尔类型不能进行转换\n转换的时候可能出现内存溢出，或者精度问题\n\n\n\n//溢出问题int money = 10_0000_0000;//数字之间可以用下划线分割int year = 20;int total = money*year;//计算时溢出 输出为-1474836480long total1 = money*year;//默认为int类型，转换之前就出了问题。所以输出依旧是-1474836480long total2 = money*((long)year);//输出20000000000\n\n//精度问题System.out.println((int)23.7);//输出23System.out.println((int)-20.4f);//输出-20\n\n","tags":["java基础"]},{"title":"java day02 基础","url":"/2021/07/08/java%20day02%20%E5%9F%BA%E7%A1%80/","content":"01 变量、作用域、常量1.1 变量\n变量的格式： 数据类型  变量名 &#x3D; 值\n注意事项：\n数据类型可以是基本类型，还可以是引用类型\n变量名必须是合法的标识符\n变量声明必须以;结尾\n\n\n\nchar x = &#x27;A&#x27;;//基本数据类型int a = 1;//基本数据类型String name = &quot;xiaofang&quot;;//引用类型\n\n1.2 变量作用域public class Hello &#123;    static double salary = 1000;//类变量在类中不在方法中，由static修饰符修饰    String name;//实例变量从属于对象，整型变量默认值为0；布尔变量默认值为false;基本数据类型外默认值都为null。    public static void main(String[] args) &#123;        //定义在方法中为局部变量        int i =10;        System.out.println(i);//输出10        //使用实例变量如下所示：        Hello hello = new Hello();//变量类型 变量名 = new 变量类型        System.out.println(hello.name);//输出null        //类变量        System.out.println(salary);//输出1000.0    &#125;&#125;\n\n1.3 常量\n常量初始化后，值不能再改变\n初始化格式：final 常量名 &#x3D; 值；\n常量名都用大写字母\n\n\n命名规则\n类成员变量：首字母小写+驼峰原则：除了第一个单词外，后面单词首字母大写。xiaoFang\n局部变量：首字母小写+驼峰原则\n常量：大写字母+下划线：XIAO_FANG\n类名：首字母大写+驼峰原则\n方法名：小写+驼峰原则\n\n02 运算符2.1 二元运算符int a = 10;int b = 20;int c = 21;System.out.println(a+b);//输出30System.out.println(a-b);//输出-10System.out.println(a*b);//输出200System.out.println(a/b);//由于int类型，需要舍弃小数点，所以输出0System.out.println(a/(double)b);//输出0.5System.out.println(c%a);//输出1(取余)\n\n2.2 类型转换long a = 101010120121L;int b = 20;short c = 10;byte d = 8;//如果有一个数是long类型，那么最后输出也是long类型System.out.println(a+b+c+d);//输出101010120159//下面自动转为int类型System.out.println(b+c+d);//输出38System.out.println(c+d);//输出18\n\n2.3 关系运算符//关系运算符输出结果是布尔类型int a = 2;int b = 3;System.out.println(a&gt;b);//输出falseSystem.out.println(a&lt;b);//输出trueSystem.out.println(a==b);//输出falseSystem.out.println(a!=b);//输出true\n\n2.4 一元运算符int a = 10;int b = a++;//先赋值再自增int c = ++a;//先自增再赋值System.out.println(a);//输出12System.out.println(b);//输出10System.out.println(c);//输出12\n\n2.5 Math类double pow =Math.pow(3,2);//幂运算System.out.println(pow);//输出9.0\n\n2.6 逻辑运算符boolean a = true;boolean b = false;//逻辑与，两个变量都为真，结果才为真，否则为假System.out.println(&quot;a &amp;&amp; b:&quot;+(a &amp;&amp; b));//输出a &amp;&amp; b:false//逻辑或，两个变量只要有一个为真，结果就为真System.out.println(&quot;a || b:&quot;+(a || b));//输出a || b:true//逻辑否，真变假，假变真System.out.println(&quot;!(a &amp;&amp; b):&quot;+!(a &amp;&amp; b));//输出!(a &amp;&amp; b):true//短路原则int c = 5;boolean d = (c&lt;4)&amp;&amp;(c++&lt;4);//与运算，当第一个为假时，结果就以确定，不再进行下面操作。System.out.println(d);//输出falseSystem.out.println(c);//输出5\n\n2.7 位运算符A = 0011 1100;B = 0000 1101;A&amp;B = 0000 1100;//位与运算，同1才为1，否则为0A|B = 0011 1101;//位或运算，有一就为1，否则为0A^B = 0011 0001;//位异或运算，相同为0，不同为1~A = 1100 0011;//0变1，1变02&gt;&gt;1// 右移/2输出12&lt;&lt;1//左移*2输出4\n\n2.8 字符串连接符a = 10;int b = 20;System.out.println(&quot;&quot;+a+b);//输出1020，String类型在前面+用于连接System.out.println(a+b+&quot;&quot;);//输出30，String类型在后面正常输出\n\n2.9 三元运算符//x ? y : z//如果x==true,则结果为y，否则为zint x =62;String type = x&gt;60 ? &quot;及格&quot; : &quot;不及格&quot;;System.out.println(type);//输出及格\n\n","tags":["java基础"]},{"title":"java day03 基础","url":"/2021/07/09/java%20day03%20%E5%9F%BA%E7%A1%80/","content":"01 包机制\n包就是相当于一个文件夹\n包语句的语法格式：\n\n//package pkg1.pkg2；package com.fang;\n\n\n一般利用公司域名倒置作为包名\n使用某一个包的成员，需要用”import”导入，格式：\n\n//import package1.package1.classname；import com.fang.demo；\n\n02 JavaDoc生成文档/** * @author Fang //@author 用于标记作者 * @version 1.0 //@version 用于标记当前版本，默认为1.0 * @since 1.8 //@since 一般用于标记文件创建时项目当时对应的版本，跟版本号，也可以跟是一个时间，表示文件当前创建的时间 */public class Hello &#123;    String name;    /**     * @param name //@param用于标记参数     * @return //@return 用于返回值     * @throws Exception //@throws 用于抛出异常     */    public String test(String name)throws Exception&#123;        return name;    &#125;&#125;\n\n\n使用cmd生成文档\n\njavadoc -encoding UTF-8 -charset UTF-8 Hello.java\n\n\n使用IDEA生成文档\n\n在IDEA找到工具里的生成JavaDoc文档，配置其他命令行参数-encoding UTF-8 -charset UTF-8防止乱码。\n","tags":["java基础"]},{"title":"java day03 流程控制","url":"/2021/07/09/java%20day03%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","content":"01 Scanner对象\n基本语法：\n\nScanner s = new Scanner(System.in);\n\n\n通过Scanner类的next()和nextLine()方法获取输入字符串，在读取之前一般采用hasNext()与hasNextLine()判断是否还有输入数据。\n\n//创建一个扫描对象，用于接收数据Scanner scanner = new Scanner(System.in);System.out.println(&quot;请输入数据&quot;);//判断用户有没有输入字符if(scanner.hasNext())&#123;//使用next接收String str = scanner.next();//输入xiao fangSystem.out.println(&quot;输出内容为&quot;+str);//输出 输出内容为xiao&#125;scanner.close();//使用完一定要给关闭掉，节省资源\n\n//创建一个扫描对象，用于接收数据Scanner scanner = new Scanner(System.in);System.out.println(&quot;请输入数据&quot;);//判断用户有没有输入字符if(scanner.hasNextLine())&#123;//使用nextLine接收String str = scanner.nextLine();//输入xiao fangSystem.out.println(&quot;输出内容为&quot;+str);//输出 输出内容为xiao fang&#125;scanner.close();//使用完一定要给关闭掉，节省资源\n\n\nnext()与nextLine()的区别\nnext()以有效字符之后的空格作为分隔符胡总和结束符，对于之前遇到的空格，next()会将其去掉；nextLine()以Enter作为结束符。\nnext()不能获得带有空格的字符；nextLine()能获得带有空格的字符。\n\n\n\n02 Scanner进阶使用我们可以输入多个数字，并求其总数及平均值，每输入一个数字用回车确认，通过输入非数字结束输入并输出结果。\npublic class Hello &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        double sum = 0;        int count = 0;        while(scanner.hasNextDouble())&#123;            double x = scanner.nextDouble();            count++;            sum +=x;            System.out.println(&quot;输入第&quot;+count+&quot;个数据,总和为&quot;+sum);        &#125;        System.out.println(&quot;总和为&quot;+sum);        System.out.println(&quot;平均数为&quot;+sum/count);        scanner.close();    &#125;&#125;\n\n","tags":["java基础"]},{"title":"java day04 流程控制","url":"/2021/07/10/java%20day04%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","content":"01 顺序结构\nJava的最基本的结构就是顺序结构\n它是任何一个算法都离不开的一种基本算法结构\n\n02 if选择结构2.1 if单选择结构public class Hello &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入&quot;);        String str = scanner.nextLine();        //判断字符串是否相等        if(str.equals(&quot;hello&quot;))&#123;            System.out.println(str);        &#125;        System.out.println(&quot;end&quot;);        scanner.close();    &#125;&#125;\n\n2.2 if双选择结构//考试分数大于60就是及格，小于60就是不及格public class Hello &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入&quot;);        int num = scanner.nextInt();        if(num&gt;60)&#123;            System.out.println(&quot;及格&quot;);        &#125;else &#123;            System.out.println(&quot;不及格&quot;);        &#125;        scanner.close();    &#125;&#125;\n\n2.3 多选择结构public class Hello &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入&quot;);        int num = scanner.nextInt();        if(num&lt;=100 &amp;&amp; num&gt;=90)&#123;            System.out.println(&quot;A&quot;);        &#125;else if(num&lt;90 &amp;&amp; num&gt;=80)&#123;            System.out.println(&quot;B&quot;);        &#125;else if(num&lt;80 &amp;&amp; num&gt;=70)&#123;            System.out.println(&quot;C&quot;);        &#125;else if(num&lt;70 &amp;&amp; num&gt;=60)&#123;            System.out.println(&quot;D&quot;);        &#125;else&#123;            System.out.println(&quot;成绩不对&quot;);        &#125;        scanner.close();    &#125;&#125;\n\n03 switch多选择结构public class Hello &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入&quot;);        String str = scanner.nextLine();        switch (str)&#123;//JDK7之后就可以用字符串            case &quot;fang&quot;:                System.out.println(&quot;fang&quot;);                break;            case &quot;xiao&quot;:                System.out.println(&quot;xiao&quot;);                break;            default:                System.out.println(&quot;wu&quot;);        &#125;        scanner.close();    &#125;&#125;\n\n\ncase穿透：如果没有break，则会按顺序执行，直到遇到break或者程序结束\n\n","tags":["java基础"]},{"title":"java day05 流程控制","url":"/2021/07/11/java%20day05%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","content":"01 while循环\n只要布尔表达式为true，循环就会一直执行下去。\n我们大多数的情况需要让循环停止下来，需要一个让表达式失效的方式来结束循环。\n先判断在执行\n正常业务应该尽量避免死循环。\n如果不满足条件，则不能进入循环。\n\n//1+2.....+100int i = 0;int sum = 0;while(i&lt;100)&#123;    i++;    sum+=i;&#125;\n\n02 do…..while循环\ndo…..while循环至少执行一次\n先执行后判断\n\n//1+2.....+100int i = 0;int sum = 0;do&#123;    i++;    sum+=i;&#125;while (i&lt;100);\n\n\nwhile与do while区别\n\nint i = 0;while (i&lt;0)&#123;    System.out.println(i);//不输出&#125;System.out.println(&quot;..........................&quot;);do&#123;    System.out.println(i);//输出0&#125;while (i&lt;0);\n\n03 For循环\nfor循环语句时支持迭代的一种通用结构，最有效、最灵活的循环结构。\nfor循环执行的次数是在执行前就确定的。\nfor循环也有死循环，格式如下：\n\nfor ( ; ; )&#123; &#125;\n\n\n计算0到100之间的奇数和偶数的和\n\npublic class Hello &#123;    public static void main(String[] args) &#123;        int oddSum = 0;        int evenSum = 0;        for (int i = 0; i &lt;= 100; i++) &#123;            if(i%2==0)&#123;                evenSum+=i;            &#125;else&#123;                oddSum+=i;            &#125;        &#125;        System.out.println(&quot;偶数和&quot;+evenSum);        System.out.println(&quot;奇数和&quot;+oddSum);    &#125;&#125;\n\n\n循环输出1-1000之间能被5整除的数，并且每行输出3个\n\npublic class Hello &#123;    public static void main(String[] args) &#123;        for (int i = 0; i &lt;= 1000; i++) &#123;            if(i%5==0)&#123;                System.out.print(i+&quot;\\t&quot;);//\\t加空格            &#125;            if(i%(5*3)==0)&#123;                System.out.println();//输出完自动换行                //System.out.print(&quot;\\n&quot;);输出完不会换行            &#125;        &#125;    &#125;&#125;\n\n\n打印九九乘法表\n\npublic class Hello &#123;    public static void main(String[] args) &#123;        for (int i = 1; i &lt;= 9; i++) &#123;            for(int j = 1; j&lt;=i;j++)&#123;                System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+(i*j)+&quot;\\t&quot;);            &#125;            System.out.println();        &#125;    &#125;&#125;\n\n04 增强for循环\n主要用来遍历数组与集合\n格式：for(声明语句 ：表达式){ }\n声明语句：是声明局部变量，该变量类型必须和数组元素的类型匹配。\n表达式：是要访问的数组名，或者是返回值是数组的方法。\n\n\n\npublic class Hello &#123;    public static void main(String[] args) &#123;        int[] number = &#123;10, 20, 30, 40&#125;;        for (int x : number)&#123;            System.out.println(x);        &#125;    &#125;&#125;\n\n05 break与continue\nbreak用于强制退出循环，不再执行循环中剩余语句。\ncontinue用于终止某次循环结构，进行下次循环\n\npublic class Hello &#123;    public static void main(String[] args) &#123;       int i = 1;       while (i&lt;100)&#123;           i++;           if(i%10==0)&#123;               System.out.println();               continue;//1               //break;2           &#125;           System.out.print(i+&quot; &quot;);       &#125;    &#125;&#125;1./*1 2 3 4 5 6 7 8 9               2.   1 2 3 4 5 6 7 8 9 11 12 13 14 15 16 17 18 19 21 22 23 24 25 26 27 28 29 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46 47 48 49 51 52 53 54 55 56 57 58 59 61 62 63 64 65 66 67 68 69 71 72 73 74 75 76 77 78 79 81 82 83 84 85 86 87 88 89 91 92 93 94 95 96 97 98 99 */\n\n\n打印三角形\n\npublic class Hello &#123;    public static void main(String[] args) &#123;        for (int i = 1; i &lt;= 5; i++) &#123;            for (int j = 5; j &gt;= i; j--) &#123;                System.out.print(&quot; &quot;);            &#125;            for (int j = 1; j &lt;= i; j++)&#123;                System.out.print(&quot;*&quot;);            &#125;            for (int j = 1; j &lt; i; j++)&#123;                System.out.print(&quot;*&quot;);            &#125;            System.out.println();        &#125;    &#125;&#125;","tags":["java基础"]},{"title":"java day06 方法","url":"/2021/07/12/java%20day06%20%E6%96%B9%E6%B3%95/","content":"01 方法定义和调用1.1 方法定义//类.对象.方法System.out.println();\n\n\nJava一定是值传递\nJava方法是语句的集合，他们在一起执行一个功能。\n方法包括在类或对象中。\n方法在程序中被创建，在其他地方被引用。\n一个方法只完成一个功能。\n\n//修饰符+返回值类型+方法名（参数类型+参数名）public static int max(int num1,int num2)&#123;    return 0;&#125;\n\n//比较大小public class Hello &#123;    public static void main(String[] args) &#123;        int max =max(3,2);        System.out.println(max);    &#125;    public static int max(int num1,int num2)&#123;        int result = 0;        if(num1 == num2)&#123;            System.out.println(&quot;等价&quot;);        &#125;else if(num1&gt;num2)&#123;            result = num1;        &#125;else&#123;            result = num2;        &#125;        return result;    &#125;&#125;\n\n1.2 方法调用\n调用方法：对象名.方法名（实参列表）\n当方法返回一个值时，方法调用通常被当作一个值。例如\n\nint max =max(3,2);\n\n\n当方法返回值是void，方法调用一定是一条语句。\n\nSystem.out.println(&quot;hello&quot;);\n\n02 方法的重载\n重载就是在一个类中，有相同的函数名称，但形式参数不同的函数。\n方法重载的规则：\n方法名称必须相同。\n参数列表必须不同（个数不同、类型不同、参数排列顺序不同）。\n返回类型可以相同也可以不同。\n仅仅返回类型不同，不是方法的重载。\n\n\n\npublic static int max(int num1,int num2)public static int max(double num1,double num2)","tags":["java基础"]},{"title":"java day07 数组","url":"/2021/07/13/java%20day07%20%E6%95%B0%E7%BB%84/","content":"01 数组的定义\n数组是相同数据类型的有序集合\n按照一定的先后次序排列组合而成\n每一个数据称作一个数组元素，每个数组元素都可以通过一个下标来进行访问\n\n02 数组的声明及创建\n数组的元素是通过索引访问的，数组索引从0开始\n获得数组的长度：arrays.length\n声明数组：\n\nint[] arrays;//首选int arrays[];//不是首选\n\n\n创建一个数组：\n\narrays = new int[10];\n\n\n声明+创建数组：\n\nint[] arrays = new int[10];","tags":["java基础"]},{"title":"java day07 方法","url":"/2021/07/13/java%20day07%20%E6%96%B9%E6%B3%95/","content":"01 可变参数\n在方法声明时，在（ ）中指定参数类型后加…\n一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。\n\npublic class Hello &#123;    public static void main(String[] args) &#123;       max(1, 2, 3, 4, 5);       max(0.45, 0.55, 0.12);    &#125;    public static void max(double ...i)&#123;//i为可变参数        if(i.length == 0)&#123;            System.out.println(&quot;No Print&quot;);        &#125;        double result = i[0];        for(int number = 0;number&lt;i.length;number++)&#123;            if(result&lt;i[number])&#123;                result = i[number];            &#125;        &#125;        System.out.println(&quot;The Max is&quot;+result);    &#125;&#125;\n\n02 递归\n递归就是：自己调用自己\n递归结构包括：\n递归头：什么时候不调用自身方法。\n递归体：什么时候需要调用自身方法。\n\n\n\npublic class Hello &#123;    public static void main(String[] args) &#123;        System.out.println(f(4));    &#125;    public static int f(int i)&#123;      if(i == 1)&#123;          return 1;      &#125;else&#123;          return i*f(i-1);      &#125;    &#125;&#125;\n\n\n递归的形式：\n\n\n","tags":["java基础"]},{"title":"java day08 数组","url":"/2021/07/15/java%20day08%20%E6%95%B0%E7%BB%84/","content":"01 三种初始化及内存分析\n内存分析\n堆是用来存放new的对象和数组；可以被所有线程共享，不会存放别的对象引用\n栈是用来存放基本变量类型（包含具体数值）；或者存放引用对象变量\n方法区包括了所有的class和static变量\n\n\n\n\n\n三种初始化\n\n静态初始化\n\nint[] arrays = &#123;1,2,3,4,5,6,7&#125;;Man[] man = &#123;new Man(),new Man()&#125;;//在此之前先创建个Man类，进行引用\n\n\n动态初始化\n\nint[] a = new int[2];a[0] = 1;a[1] = 2;\n\n\n默认初始化：数组分配空间后，int类型默认为0\n\n\n\n02 下标越界\n数组的四个基本特点\n\n其长度是确定的，数组一旦被创建，它的大小就是不可以改变的。\n其元素必须是相同类型的。\n数组中的元素可以是任何数据类型，包括基本类型和引用类型。\n数组对象本身是在堆中的,数组元素相当于对象的成员变量。\n\n\n下标的合法区间：[0,length-1]\n\n\n","tags":["java基础"]},{"title":"java day09 数组","url":"/2021/07/16/java%20day09%20%E6%95%B0%E7%BB%84/","content":"01 数组的使用\n配合for循环使用\n\npublic class Hello &#123;    public static void main(String[] args) &#123;      int[] a = &#123;1,2,3,4,5&#125;;      //打印全部的数组元素        for(int i = 0;i&lt;a.length;i++)&#123;            System.out.println(a[i]);        &#125;        System.out.println(&quot;============&quot;);        //计算所有数组的和        int sum = 0;        for(int i = 0;i&lt;a.length;i++)&#123;            sum+=a[i];        &#125;        System.out.println(&quot;总和&quot;+sum);        System.out.println(&quot;============&quot;);        //查找最大的数        int max = a[0];        for(int i = 0;i&lt;a.length;i++)&#123;           if(a[i]&gt;max)&#123;               max = a[i];           &#125;        &#125;        System.out.println(&quot;最大数&quot;+max);    &#125;&#125;\n\n\nFor-Each循环\n\npublic class Hello &#123;    public static void main(String[] args) &#123;      int[] a = &#123;1,2,3,4,5&#125;;        for (int i : a) &#123;//i就是数组元素，a就代表数组            System.out.println(i);        &#125;    &#125;&#125;\n\n\n数组作方法入参\n\n////打印全部的数组元素public class Hello &#123;    public static void main(String[] args) &#123;      int[] a = &#123;1,2,3,4,5&#125;;      printArray(a);    &#125;    public static  void printArray(int[] a)&#123;        for (int i = 0;i&lt;a.length;i++)&#123;            System.out.println(a[i]);        &#125;    &#125;&#125;\n\n\n数组作返回值\n\n//反转数组public class Hello &#123;    public static void main(String[] args) &#123;      int[] a = &#123;1,2,3,4,5&#125;;      int[] reverse = reverse(a);      printArray(reverse);    &#125;    public  static int[] reverse(int[] a)&#123;        int[] b = new int[a.length];        for(int i = 0,j = b.length-1;i&lt;b.length;i++,j--)&#123;            b[j] = a[i];        &#125;        return b;    &#125;    public static  void printArray(int[] a)&#123;        for (int i = 0;i&lt;a.length;i++)&#123;            System.out.println(a[i]);        &#125;    &#125;&#125;\n\n02 二维数组int a[][] = new int[2][5];int[][] b = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;\n\n03 Arrays类\n数组的工具类java.util.Arrays\nArrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而不用适用对象来调用。\n\nint[] a =&#123;1,2,3,55645,121,11&#125;;//数组进行排序   Arrays.sort(a);//数组进行填充   Arrays.fill(a,2,4,0);//从2到4之间进行填充//打印数组元素   System.out.println(Arrays.toString(a));","tags":["java基础"]},{"title":"java day10 冒泡排序","url":"/2021/07/17/java%20day10%20%E6%95%B0%E7%BB%84/","content":"01 冒泡排序冒泡排序：两层循环，外层冒泡轮数，里层依次比较。\npublic class Hello &#123;    public static void main(String[] args) &#123;        int[] a = &#123;1, 2, 3, 8, 11, 1, 55, 12&#125;;        int[] array = sort(a);        System.out.println(Arrays.toString(array));    &#125;    public static int[] sort(int[] array) &#123;        int temp = 0;        for (int i = 0; i &lt; array.length - 1; i++) &#123;            boolean flag = false;            for (int j = 0; j &lt; array.length - 1; j++) &#123;                if (array[j + 1] &lt; array[j]) &#123;                    temp = array[j + 1];                    array[j + 1] = array[j];                    array[j] = temp;                    flag = true;                &#125;            &#125;                if (flag == false) &#123;                    break;                &#125;        &#125;        return array;    &#125;&#125;\n\n","tags":["java基础"]},{"title":"java day11 稀疏数组","url":"/2021/07/18/java%20day11%20%E6%95%B0%E7%BB%84/","content":"稀疏数组public class Hello &#123;    public static void main(String[] args) &#123;        //1.创建一个二维数组11*11        int[][] array1 = new int[11][11];        array1[1][2] = 1;        array1[2][3] = 2;        //2.输出原始数组        System.out.println(&quot;输出原始数组&quot;);        for (int[] ints : array1) &#123;//ints 相当于array1的每一行            for (int anInt : ints) &#123;//anInt相当于每一个元素                System.out.print(anInt+&quot;\\t&quot;);            &#125;            System.out.println();        &#125;        //3.获取有效数值        int sum = 0;        for (int i = 0; i &lt; 11; i++) &#123;            for (int j = 0; j &lt; 11; j++) &#123;                if(array1[i][j]!=0)&#123;                    sum++;                &#125;            &#125;        &#125;        System.out.println(&quot;有效个数&quot;+sum);        //4.创建一个稀疏矩阵数组        int[][] array2 = new int[sum+1][3];        array2[0][0] = 11;        array2[0][1] = 11;        array2[0][2] = 2;        //5.遍历二位数组，有非零值，存放在稀疏矩阵中        int cout = 0;        for(int i =0;i&lt;array1.length;i++)&#123;            for(int j =0;j&lt;array1[i].length;j++)&#123;                if(array1[i][j]!=0)&#123;                    cout++;                    array2[cout][0] = i;                    array2[cout][1] = j;                    array2[cout][2] = array1[i][j];                &#125;            &#125;        &#125;        //6.输出稀疏数组        System.out.println(&quot;稀疏数组：&quot;);        for (int i = 0;i&lt; array2.length;i++)&#123;            System.out.println(array2[i][0]+&quot;\\t&quot;                    +array2[i][1]+&quot;\\t&quot;                    +array2[i][2]+&quot;\\t&quot; );        &#125;        //7.读取稀疏矩阵        int[][] array3 = new int[array2[0][0]][array2[0][1]];        //8.给其他元素还原        for(int i = 1;i&lt; array2.length;i++)&#123;            array3[array2[i][0]][array2[i][1]] = array2[i][2];        &#125;        //9.打印        System.out.println(&quot;还原数组：&quot;);        for (int[] ints : array3) &#123;//ints 相当于array1的每一行            for (int anInt : ints) &#123;//anInt相当于每一个元素                System.out.print(anInt+&quot;\\t&quot;);            &#125;            System.out.println();        &#125;&#125;    &#125;\n\n输出原始数组0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t2\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t有效个数2稀疏数组：11\t11\t2\t1\t2\t1\t2\t3\t2\t还原数组：0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t2\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n\n","tags":["java基础"]},{"title":"java day12 面向对象","url":"/2021/07/20/java%20day12%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"01 什么是面向对象\n属性+方法&#x3D;类 \n面向过程思想\n步骤清晰简单，第一步做什么，第二部做什么….\n面向过程适合处理一些较为简单的问题\n\n\n面向对象思想\n物以类聚，分类的思维模式\n面向对象适合处理复杂的问题\n\n\n对于描述复杂的事务，为了从宏观上把握，从整体上合理分析，我们需要使用面向对象的思想来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思想。\n面向对象编程的本质：以类的方式组织代码，以对象的组织（封装）数据。\n三大特性：封装、继承、多态\n\n02 回顾方法\n当一个类调用静态方法时，调用形式：类名+方法名\n\npublic class Student &#123;    public static void say() &#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;public class Hello &#123;    public static void main(String[] args) &#123;        Student.say();&#125;    &#125;\n\n\n当调用非静态方法时，调用形式：将这个类实例化\n\npublic class Student &#123;    public  void say() &#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;public class Hello &#123;    public static void main(String[] args) &#123;        Student student = new Student();        student.say();&#125;    &#125;\n\n\nstatic是和类一起加载的，而不含static的是在类实例化之后才存在，所以下面代码是错误的\n\npublic  static void a()&#123;        b();&#125;public void b()&#123;&#125;\n\n\n一个类中只有一个public class,但是有很多class。\n\n03 类和对象的关系\n使用new关键字创建对象，除了分配内存空间，还会初始化，以及对类中构造器的使用。\n一个项目应该只存在一个main方法\n\npublic class Student &#123;    //属性:字段    String name;    int age;    //方法    public  void study() &#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;        //类：抽象的，实例化        //类实例化后会返回一个自己的对象        //student对象就是一个Student类的具体实例。        Student xm = new Student();        Student xh = new Student();        xm.name = &quot;xiaoming&quot;;        xm.age = 3;        System.out.println(xm.name);//xiaoming        System.out.println(xm.age);//3        System.out.println(xh.name);//默认值null        System.out.println(xh.age);//默认值0        xh.study();//hello    &#125;&#125;\n\n04 构造器详解\n一个类即使什么都不写，也会构造一个方法。\n\n构造器：\n\n特点：必须和类的名字相同；必须没有返回类型，也不能写void。\n作用：new本质就是调用构造方法；初始化对象的值。\n注意点：定义有参构造之后，如果想使用无参构造，必须显示的定义一个无参构造。\n\n\n调用无参构造函数\n\n\n\npublic class Student &#123;    String name;    public Student()&#123;        this.name = &quot;xiaofang&quot;;    &#125;    public Student(String name)&#123;        this.name = name;//this.name代表对象本身的name,name是传递下来的name。    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;     Student student = new Student();        System.out.println(student.name);//xiaofang    &#125;&#125;\n\n\n调用有参构造函数\n\npublic class Student &#123;    String name;    public Student()&#123;        this.name = &quot;xiaofang&quot;;    &#125;    public Student(String name)&#123;        this.name = name;//this.name代表对象本身的name,name是传递下来的name。    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;     Student student = new Student(&quot;xiaoxu&quot;);        System.out.println(student.name);//xiaoxu    &#125;&#125;","tags":["java基础"]},{"title":"java day13 面向对象三大特征2","url":"/2021/07/28/java%20day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A72/","content":"01 方法重写\n重写：需要有继承关系，子类重写父类的方法！\n\n方法名必须相同\n参数列表必须相同\n修饰符：范围可以扩大但是不能缩小（public&gt;Protected&gt;Default&gt;private）\n抛出的异常：范围可以缩小但是不能扩大\n快捷键：Alt+Insert(override)\n\n\n为什么需要重写：因为父类的功能，子类不一定需要，或者不一定满足\n\n静态的方法和非静态方法差别很大：\n\n静态方法：方法的调用只和左边定义的数据类型有关\n\npublic class Person &#123;    public static void print()&#123;        System.out.println(&quot;Person&quot;);    &#125;&#125;public class Student extends Person &#123;    public static void print()&#123;        System.out.println(&quot;Student&quot;);    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;        Student student = new Student();        student.print();//Student        //父类的引用指向了子类        Person person = new Student();        person.print();//Person    &#125;&#125;\n\n\n非静态方法：重写\n\n\n\npublic class Person &#123;    public void print()&#123;        System.out.println(&quot;Person&quot;);    &#125;&#125;public class Student extends Person &#123;    public void print()&#123;        System.out.println(&quot;Student&quot;);    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;        Student student = new Student();        student.print();//Student        //父类的引用指向了子类        Person person = new Student();        person.print();//Student    &#125;&#125;\n\n02 多态多态就是同一方法可以根据发送对象的不同而采用多种不同的行为方式。\n\n\n多态注意事项：\n\n多态时方法的多态，属性没有多态\n存在条件：继承关系，方法需要重写，父亲引用指向子类对象\n\n\n不能重写的方法：\n\nstatic方法属于类不属于实例\nfinal常量\nprivate方法\n\n\n\npublic class Person &#123;    public void print()&#123;        System.out.println(&quot;Person&quot;);    &#125;&#125;public class Student extends Person &#123;    public void print()&#123;        System.out.println(&quot;Student&quot;);    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;        //一个对象的实际类型是确定的--&gt;new Student(); new Person()        //可以指向的引用类型就不确定了：父类的引用指向子类        //Student能调用的方法都是自己的或者继承父类的        Student student = new Student();        student.print();//Student        //Person父类型可以指向子类，但是不能调用子类独有的方法        Person person = new Student();        person.print();//Student    &#125;&#125;\n\n","tags":["java基础"]},{"title":"java day13 面向对象三大特征1","url":"/2021/07/21/java%20day13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A71/","content":"01 封装\n我们程序设计追求高内聚低耦合。\n高内聚：类的内部数据操作细节自己完成，不允许外部干涉。\n低耦合：仅暴露少量的方法给外部使用。\n\n\n封装的意义：\n提高程序的安全性，保护数据\n隐藏代码的实现细节\n统一接口\n系统可维护增加了\n\n\n属性私有，get&#x2F;set\n信息隐藏：禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问。\n\npublic class Student &#123;    //属性私有    private String name;//姓名    private int id;//学号    private char sex;//性别    //get 获得这个数据    public String getName()&#123;        return this.name;    &#125;    //set 给这个数据设置值    public void setName(String name)&#123;        this.name = name;    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;        Student student = new Student();        student.setName(&quot;小方&quot;);        System.out.println(student.getName());    &#125;&#125;\n\n02 继承\n继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。\nextends的意思是”扩展”。子类是父类的扩展。\nJAVA只有单继承，没有多继承。一个爸爸可以有多个儿子，一个儿子只能有一个爸爸。\n继承是类与类之间的一种关系\n\npublic class Person &#123;    public void say()&#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;public class Student extends Person &#123;&#125;public class Application &#123;    public static void main(String[] args) &#123;        Student student = new Student();        student.say();//hello    &#125;&#125;\n\n\n私有的东西无法被继承。\n在Java中，所有的类，都默认直接或者间接继承object\n\n03 Super\nsuper注意点：\n\nsuper调用父类的构造方法，必须在构造方法的第一个\nsuper必须只能出现在子类的方法或者构造方法中。\nsuper和this不能同时调用构造方法。\n\n\nsuper VS this\n\n代表的对象不同：this（本身调用这个对象），super（代表父类对象的引用）。\n前提：this（没有继承也可以使用），super（只有在继承条件下才可以使用）。\n构造方法：this():本类的构造，super():父类的构造\n\n\n\npublic class Person &#123;    public Person()&#123;        System.out.println(&quot;Person无参&quot;);    &#125;    protected String name = &quot;xiaofang&quot;;    public void print()&#123;        System.out.println(&quot;Person&quot;);    &#125;&#125;public class Student extends Person &#123;    //隐藏代码：调用父类的无参构造    public Student()&#123;        super();        System.out.println(&quot;Student无参&quot;);    &#125;    private String name = &quot;xiaoxu&quot;;    public void print()&#123;        System.out.println(&quot;student&quot;);    &#125;    public  void test(String name)&#123;        System.out.println(name);//方        System.out.println(this.name);//xiaoxu        System.out.println(super.name);//xiaofang    &#125;    public  void test1()&#123;        print();//student        this.print();//student        super.print();//Person    &#125;&#125;public class Application &#123;    public Application() &#123;    &#125;    public static void main(String[] args) &#123;        Student student = new Student();//先调用父类Person无参，在调用子类Student无参        student.test(&quot;方&quot;);        student.test1();    &#125;&#125;\n\n\n\n","tags":["java基础"]},{"title":"java day14 面向对象","url":"/2021/07/29/java%20day14%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"01 instanceof和类型转换\ninstanceof的格式是System.out.println(x instanceof y);如果x和y是同一类型或者能类型转换（兄弟之间不能类型转换，父子之间可以类型转换）则编译通过，否则不通过。编译通过后会把x和y比较，如果x是y本类或者子类的对象，结果就是true，反之就是flase。\n\npublic class Application &#123;    public static void main(String[] args) &#123;        //Object &gt; String        //Object &gt; Person &gt; Teacher        //Object &gt; Person &gt; Student        Object object = new Student();        System.out.println(object instanceof Object);//true        System.out.println(object instanceof Person);//true        System.out.println(object instanceof Teacher);//false        System.out.println(object instanceof Student);//true        System.out.println(object instanceof String);//false        System.out.println(&quot;=========================&quot;);        Person person = new Student();        System.out.println(person instanceof Object);//true        System.out.println(person instanceof Person);//true        System.out.println(person instanceof Teacher);//false        System.out.println(person instanceof Student);//true        //System.out.println(person instanceof String);编译不通过        System.out.println(&quot;=========================&quot;);        Student student = new Student();        System.out.println(student instanceof Object);//true        System.out.println(student instanceof Person);//true        //System.out.println(student instanceof Teacher);编译不通过        System.out.println(student instanceof Student);//true        //System.out.println(student instanceof String);编译不通过        System.out.println(&quot;=========================&quot;);    &#125;&#125;\n\n\n类型转换：\n把子类转换成父类，向上转型\n把父类转换成子类，向下转型：强制转换\n\n\n\npublic class Student extends Person &#123;    public void go()&#123;        System.out.println(&quot;Student&quot;);    &#125;&#125;public class Application &#123;    public static void main(String[] args) &#123;        //高转低        Person obj = new Student();        //方法一        Student student = (Student) obj;        student.go();//Student        //方法二        ((Student) obj).go();//Student        //低转高可能丢失一些自己本来的方法        Student student = new Student();        Person person = student;       //person.go();报错！    &#125;&#125;\n\n02 static关键字详解\n对于代码块来说：\n\npublic class Person &#123;    &#123;        System.out.println(&quot;匿名代码块&quot;);    &#125;    static &#123;        System.out.println(&quot;静态代码块&quot;);//只执行一次    &#125;    public Person()&#123;        System.out.println(&quot;构造方法&quot;);    &#125;    public static void main(String[] args) &#123;        Person p1 = new Person();        System.out.println(&quot;==========&quot;);        Person p2 = new Person();    &#125;&#125;                                /*静态代码块                                匿名代码块                                构造方法                                ==========                                匿名代码块                                构造方法*/\n\n\n非静态方法和静态方法可以调用静态方法，而静态方法不能调用非静态方法。\n静态导入包：\n\n//静态导入包import static java.lang.Math.random;public class Person &#123;    public static void main(String[] args) &#123;        System.out.println(random());//这就可以直接使用random()，而不用Math.random()    &#125;&#125;\n\n\n调用非静态方法必须new一个对象进行调用，而调用静态方法可以直接用类调用，比如Student.run()。\n在方法中调用变量：调用非静态变量不能直接用类调用，要创建一个对象进行调用，而调用静态变量既可以用类进行调用，也可以用对象进行调用。\n\n03 抽象类\nabstract修饰符，如果修饰方法就是抽象方法，如果修饰类就是抽象类。\n抽象类中可以没有抽象方法，但是只要有抽象方法，必须声明抽象类。\n抽象类不能用new实例化。\n抽象方法只有方法的声明而没有具体实现，实现是让子类来完成的。\n子类继承抽象类，就必须实现抽象类中没有实现的抽象方法，否则子类也要声明为抽象类。\n\npublic abstract class Application &#123;   public abstract void run();   public void go()&#123;       System.out.println(&quot;有普通方法也是可以的&quot;);   &#125;&#125;\n\n04 接口\n接口的本质是契约，是对对象的抽象\n用interface定义接口\n接口的作用：\n约束\n定义一些方法，让不同的人实现（10个人可以实现一个接口）\n接口中的所有定义的方法其实都是抽象的 public abstract\n接口中的所有定义的变量其实都是静态常量 public static final\n接口也不能被实例化（没有构造方法）\nimplements可以实现多个接口，就是相当于多继承\n实现接口，必须要做重写接口中方法\n\n\n\npublic interface Person &#123;    void add(String name);    void delete(String name);    void update(String name);    void query(String name);&#125;public interface Teacher  &#123;    void run();&#125;//Ait+insert直接生成的重写方法public class Student implements Person,Teacher &#123;    @Override    public void add(String name) &#123;    &#125;    @Override    public void delete(String name) &#123;    &#125;    @Override    public void update(String name) &#123;    &#125;    @Override    public void query(String name) &#123;    &#125;    @Override    public void run() &#123;    &#125;&#125;\n\n","tags":["java基础"]},{"title":"java day15 异常","url":"/2021/07/30/java%20day15%E5%BC%82%E5%B8%B8/","content":"01 Error和Exception\n异常是指程序运行时出现的不期而至的各种状况，如：文件找不到、网络连接失败、非法参数。\n三种类型的异常：\n检查性异常：是用户错误或问题引起的异常，这时程序员无法遇见的。比如打开一个不存在的文件。\n运行时异常：是可能被程序员避免的异常。\n错误：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如堆栈溢出，在编译时也检测不到。\n\n\nJava把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。\n这些异常通常分为两大类：错误Error和异常Exception\n在Exception分支中有一个重要的子类RuntimeException（运行时异常）：\nArrayIndexOutOfBoundsException（数组下标越界）\nNullPointerException（空指针异常）\nArithmeticException（算数异常）\nMissingResourceException（丢失资源）\nClassNotFoundException（找不到类）\n\n\n\n02 捕获和抛出异常\n异常处理五个关键字：try、catch、finally、throw、throws\n\n//方法一public abstract class Application &#123;    public static void main(String[] args) &#123;        int a = 1;        int b = 0;        //假设要捕获多个异常：从小到大        try&#123;//try监控区域            System.out.println(a/b);        &#125;catch(Error e)&#123;            System.out.println(&quot;Error&quot;);        &#125;catch(Exception e)&#123;            System.out.println(&quot;Exception&quot;);        &#125;catch (Throwable t)&#123;            System.out.println(&quot;Throwable&quot;);        &#125;finally &#123;//处理善后工作            System.out.println(&quot;finally&quot;);        &#125;    &#125;&#125;//打印出Exception和finally//方法二public abstract class Application &#123;    public static void main(String[] args) &#123;        int a = 1;        int b = 0;        //通过Ctrl+Alt+t快捷键来完成        try &#123;            System.out.println(a/b);        &#125; catch (Exception e) &#123;            e.printStackTrace();//打印错误的栈信息        &#125; finally &#123;        &#125;    &#125;&#125;//打印出ava.lang.ArithmeticException: / by zero//方法三public  class Application &#123;    public static void main(String[] args) &#123;        new Application().test(1,0);    &#125;    public void test(int a, int b)&#123;        if(b==0)&#123;            throw new ArithmeticException();//主动抛出异常        &#125;    &#125;&#125;//打印出Exception in thread &quot;main&quot; java.lang.ArithmeticException//方法四public  class Application &#123;    public static void main(String[] args) &#123;        try &#123;            new Application().test(1,0);        &#125; catch (ArithmeticException e) &#123;            e.printStackTrace();        &#125;    &#125;    //假设方法处理不了这个异常。那么就将其向上抛出，在方法上抛出。    public void test(int a, int b)throws ArithmeticException&#123;        if(b==0)&#123;            throw new ArithmeticException();//主动抛出异常        &#125;    &#125;&#125;//输出java.lang.ArithmeticException\n\n03 自定义异常\n自定义异常类，大体可以分为以下几个步骤：\n创建自定义异常类\n在方法中通过throw关键字抛出异常对象\n如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作\n在出现异常方法的调用者中捕获并处理异常\n\n\n\npublic class MyException extends Exception&#123;    //传递数字&gt;10    private  int detail;    public MyException(int a) &#123;        this.detail = a;    &#125;    //toString:异常的打印信息    @Override    public String toString() &#123;        return &quot;MyException&#123;&quot; + &quot;detail=&quot; + detail + &#x27;&#125;&#x27;;    &#125;&#125;public  class Application &#123;    public static void main(String[] args) &#123;        try &#123;            new Application().test(11);        &#125; catch (MyException e) &#123;            System.out.println(&quot;MyException=&gt;&quot;+e);        &#125;    &#125;    //假设方法处理不了这个异常。那么就将其向上抛出，在方法上抛出。    public void test(int a)throws MyException&#123;        System.out.println(&quot;传递的参数为：&quot;+a);        if(a&gt;10)&#123;            throw new MyException(a);//主动抛出异常        &#125;        System.out.println(&quot;OK&quot;);    &#125;&#125;\n\n\n在实际应用中的经验：\n处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理\n在多重catch块后面，可以加一个catch(Exception)来处理可能会被遗漏的异常\n对于不确定的代码，也可以加上try-catch，处理潜在的异常（当在IDEA中出现红色波浪线可以Alt+Enter）\n尽量去处理异常，不要只是简单的调用printStackTrace()去打印输出\n尽量添加finally语句块去释放占用资源\n\n\n\n","tags":["java基础"]},{"title":"乱七八糟之调用百度智慧云让图片变清晰","url":"/2022/04/30/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E4%B9%8B%E8%AE%A9%E5%9B%BE%E7%89%87%E5%8F%98%E6%B8%85%E6%99%B0/","content":"\n首先我们建立一个百度智慧云账号登录进去就可以创建应用了\n\n\nhttps://login.bce.baidu.com/?account=&amp;redirect=http%3A%2F%2Fconsole.bce.baidu.com%2Fai%2F%3F_%3D%26fromai%3D1#/ai/imageprocess/app/list\n\n\n然后我们拿到API Key和Secret Key获取token\n\nimport org.json.JSONObject;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import java.util.List;import java.util.Map;/** * 获取token类 */public class AuthService &#123;    /**     * 获取权限token     * @return 返回示例：     * &#123;     * &quot;access_token&quot;: &quot;24.460da4889caad24cccdb1fea17221975.2592000.1491995545.282335-1234567&quot;,     * &quot;expires_in&quot;: 2592000     * &#125;     */    public static String getAuth() &#123;        // 官网获取的 API Key 更新为你注册的        String clientId = &quot;&quot;;        // 官网获取的 Secret Key 更新为你注册的        String clientSecret = &quot;&quot;;        return getAuth(clientId, clientSecret);    &#125;    /**     * 获取API访问token     * 该token有一定的有效期，需要自行管理，当失效时需重新获取.     * @param ak - 百度云官网获取的 API Key     * @param sk - 百度云官网获取的 Securet Key     * @return assess_token 示例：     * &quot;24.460da4889caad24cccdb1fea17221975.2592000.1491995545.282335-1234567&quot;     * &quot;25.1aa6f421270dd76cd9a44e50e2a43a5e.315360000.1889591154.282335-17812626&quot;     */    public static String getAuth(String ak, String sk) &#123;        // 获取token地址        String authHost = &quot;https://aip.baidubce.com/oauth/2.0/token?&quot;;        String getAccessTokenUrl = authHost                // 1. grant_type为固定参数                + &quot;grant_type=client_credentials&quot;                // 2. 官网获取的 API Key                + &quot;&amp;client_id=&quot; + ak                // 3. 官网获取的 Secret Key                + &quot;&amp;client_secret=&quot; + sk;        try &#123;            URL realUrl = new URL(getAccessTokenUrl);            // 打开和URL之间的连接            HttpURLConnection connection = (HttpURLConnection) realUrl.openConnection();            connection.setRequestMethod(&quot;GET&quot;);            connection.connect();            // 获取所有响应头字段            Map&lt;String, List&lt;String&gt;&gt; map = connection.getHeaderFields();            // 遍历所有的响应头字段            for (String key : map.keySet()) &#123;                System.err.println(key + &quot;---&gt;&quot; + map.get(key));            &#125;            // 定义 BufferedReader输入流来读取URL的响应            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));            String result = &quot;&quot;;            String line;            while ((line = in.readLine()) != null) &#123;                result += line;            &#125;            /**             * 返回结果示例             */            System.err.println(&quot;result:&quot; + result);            JSONObject jsonObject = new JSONObject(result);            String access_token = jsonObject.getString(&quot;access_token&quot;);            return access_token;        &#125; catch (Exception e) &#123;            System.err.printf(&quot;获取token失败！&quot;);            e.printStackTrace(System.err);        &#125;        return null;    &#125;    public static void main(String[] args) &#123;        getAuth();    &#125;&#125;\n\n\n获取token我们就可以进行调用接口啥的了，这里创建一个图片增强\n\npackage com.inage;import com.inage.FileUtil;import com.inage.Base64Util;import com.inage.HttpUtil;import java.net.URLEncoder;/** * 图像清晰度增强 */public class Image_definition_enhance &#123;    /**     * 重要提示代码中所需工具类     * com.inage.FileUtil,Base64Util,HttpUtil,GsonUtils请从     * https://ai.baidu.com/file/658A35ABAB2D404FBF903F64D47C1F72     * https://ai.baidu.com/file/C8D81F3301E24D2892968F09AE1AD6E2     * https://ai.baidu.com/file/544D677F5D4E4F17B4122FBD60DB82B3     * https://ai.baidu.com/file/470B3ACCA3FE43788B5A963BF0B625F3     * 下载     */    public static String image_definition_enhance() &#123;        // 请求url        String url = &quot;https://aip.baidubce.com/rest/2.0/image-process/v1/image_definition_enhance&quot;;        try &#123;            // 本地文件路径            String filePath = &quot;C:\\\\Users\\\\1\\\\Desktop\\\\fang\\\\java\\\\cookie-session\\\\cookie-session\\\\src\\\\main\\\\java\\\\com\\\\inage\\\\1.jpg&quot;;            byte[] imgData = FileUtil.readFileByBytes(filePath);            String imgStr = Base64Util.encode(imgData);            String imgParam = URLEncoder.encode(imgStr, &quot;UTF-8&quot;);            String param = &quot;image=&quot; + imgParam;            // 注意这里仅为了简化编码每一次请求都去获取access_token，线上环境access_token有过期时间， 客户端可自行缓存，过期后重新获取。            String accessToken = &quot;你自己的&quot;;            String result = HttpUtil.post(url, accessToken, param);            System.out.println(result);            return result;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;    public static void main(String[] args) &#123;        Image_definition_enhance.image_definition_enhance();    &#125;&#125;\n\n\n然后就可以得到Base64图片数据，然后我们使用这个网站将Base64数据转化为图片\n\nhttps://blog.51cto.com/u_14475876/2834925\n\n\n在这中间出现了一个问题，就是Base64数据太长了，IDEA显示的不全，这是因为缓存超过多少M就自动清空前面多余的。解决方法就是打开IDEA的bin目录里的idea.properties文件，修改代码为false\n\n\n#---------------------------------------------------------------------# This option controls console cyclic buffer: keeps the console output size not higher than the specified buffer size (KiB).# Older lines are deleted. In order to disable cycle buffer use idea.cycle.buffer.size=disabled#---------------------------------------------------------------------idea.cycle.buffer.size=disabled\n\n","tags":["乱七八糟"]},{"title":"反射之Java反射","url":"/2022/05/01/%E5%8F%8D%E5%B0%84%E4%B9%8BJava%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/","content":"\n1. 类的加载过程\n2.类的加载与ClassLoader的理解加载： \n\n将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构， 然后生成一个代表这个类的java.lang.Class对象.\n\n链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。 \n\n验证：确保加载的类信息符合JVM规范，没有安全方面的问题 \n准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。\n解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。\n\n初始化： \n\n执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作 和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造 器）。 \n当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。\n虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步。\n\n\npublic class demo1 &#123;    public static void main(String[] args) &#123;        A a = new A();        System.out.println(A.m);        /*        1.加载到内存，会产生一个类对应的class对象        2.链接，链接结束后m=0        3.初始化            &lt;clint&gt;()&#123;             System.out.println(&quot;A类静态代码块&quot;);            m = 300;            m =100;            &#125;        */    &#125;&#125;class A&#123;    static &#123;        System.out.println(&quot;A类静态代码块&quot;);        m = 300;    &#125;    static int m =100;    public A()&#123;        System.out.println(&quot;A类的无参构造初始化&quot;);    &#125;&#125;\n\n3. 分析类初始化什么时候会发生类初始化？\n\n类的主动引用（一定会发生类的初始化） \n\n当虚拟机启动，先初始化main方法所在的类 \n\nnew一个类的对象 \n\n调用类的静态成员（除了final常量）和静态方法 \n\n使用java.lang.reflect包的方法对类进行反射调用 \n\n当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类 \n\n类的被动引用（不会发生类的初始化） \n\n当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 \n\n通过数组定义类引用，不会触发此类的初始化 \n\n引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）\n\n&#96;&#96;&#96;javapublic class demo1 {public static void main(String[] args) throws ClassNotFoundException {    System.out.println(“main方法”);    &#x2F;&#x2F;1.主动引用    Son son &#x3D; new Son();    &#x2F;&#x2F;2.反射也会产生引用    Class.forName(“Son”);    &#x2F;&#x2F;3.当通过子类引用父类的静态变量，不会导致子类初始化    System.out.println(Son.b);    &#x2F;&#x2F;4.通过数组定义类引用，不会触发此类的初始化    Son[] array &#x3D; new Son[5];    &#x2F;&#x2F;引用常量不会触发此类的初始化    System.out.println(Son.M);}}class Father{static int b &#x3D; 2;static {    System.out.println(“父类被加载”);}   }class Son extends Father{static {    System.out.println(“子类被加载”);    m &#x3D; 300;}static int m &#x3D;100;static final int M &#x3D; 1;}&#x2F;&#x2F;输出1.main方法父类被加载子类被加载&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;2.main方法父类被加载子类被加载&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;3.main方法父类被加载2&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;4.main方法&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;5.main方法1\n## 4.类加载器**类加载器的作用** - 类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数 据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入 口。 - 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象![image-20220502084248456](https://s2.loli.net/2022/05/02/NwkOl8EMJFiBgjZ.png)- 类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器![image-20220502084324842](https://s2.loli.net/2022/05/02/CcgbE8KFzaQRehG.png)```javapublic class demo1 &#123;    public static void main(String[] args) throws Exception &#123;        //获取系统类的加载器        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();        System.out.println(systemClassLoader);        //获取系统类加载器的父类加载器-&gt;扩展类加载器        ClassLoader parent = systemClassLoader.getParent();        System.out.println(parent);        //获取扩展类加载器的父类加载器-&gt;根加载器        ClassLoader parent1 = parent.getParent();        System.out.println(parent1);        //测试当前类是哪个加载器加载的        ClassLoader classLoader = Class.forName(&quot;demo1&quot;).getClassLoader();        System.out.println(classLoader);        //测试JDK内置的类是哪个加载器加载的        classLoader = Class.forName(&quot;java.lang.Object&quot;).getClassLoader();        System.out.println(classLoader);        //如何获取系统类加载器可以加载的路径        System.out.println(System.getProperty(&quot;java.class.path&quot;));    &#125;&#125;//输出sun.misc.Launcher$AppClassLoader@14dad5dcsun.misc.Launcher$ExtClassLoader@2503dbd3nullsun.misc.Launcher$AppClassLoader@14dad5dcnullC:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\rt.jar;C:\\Users\\1\\Desktop\\fang\\java\\cookie-session\\cookie-session\\target\\classes;C:\\Environment\\maven\\maven-repo\\javax\\servlet\\jsp\\jstl\\jstl-api\\1.2\\jstl-api-1.2.jar;C:\\Environment\\maven\\maven-repo\\javax\\servlet\\servlet-api\\2.5\\servlet-api-2.5.jar;C:\\Environment\\maven\\maven-repo\\taglibs\\standard\\1.1.2\\standard-1.1.2.jar;C:\\Environment\\maven\\maven-repo\\mysql\\mysql-connector-java\\5.1.47\\mysql-connector-java-5.1.47.jar;C:\\Environment\\maven\\maven-repo\\org\\json\\json\\20160810\\json-20160810.jar;C:\\Environment\\maven\\maven-repo\\commons-io\\commons-io\\2.4\\commons-io-2.4.jar;C:\\Program Files\\JetBrains\\IntelliJ IDEA 2021.2.3\\lib\\idea_rt.jar\n\n\n\n5.获取类的运行时结构通过反射获取运行时类的完整结构： Field、Method、Constructor、Superclass、Interface、Annotation 实现的全部接口 所继承的父类 全部的构造器 全部的方法 全部的Field 注解 …….\nimport java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class demo1 &#123;    public static void main(String[] args) throws Exception &#123;        Class c1 = Class.forName(&quot;User&quot;);        //获取类的名字        System.out.println(c1.getName());//获取包名+类名        System.out.println(c1.getSimpleName());//获取类名        //获取类的属性        System.out.println(&quot;==================&quot;);        Field[] fields = c1.getFields();//只能找到public属性        fields = c1.getDeclaredFields();//找到全部的属性        for (Field field : fields) &#123;            System.out.println(field);        &#125;        //获取指定属性的值        Field name = c1.getDeclaredField(&quot;name&quot;);        System.out.println(name);        //获得类的方法        System.out.println(&quot;==================&quot;);        Method[] methods = c1.getMethods();//获取本类及其父类所有的public方法        for (Method method : methods) &#123;            System.out.println(&quot;正常的&quot;+method);        &#125;        methods = c1.getDeclaredMethods();        for (Method method : methods) &#123;            System.out.println(&quot;getDeclaredMethods&quot;+method);//获取本类所有的方法        &#125;        //获取指定的方法        Method getName = c1.getMethod(&quot;getName&quot;, null);        Method setName = c1.getMethod(&quot;setName&quot;, String.class);        System.out.println(getName);        System.out.println(setName);        //获取指定的构造器        System.out.println(&quot;==================&quot;);        Constructor[] constructors = c1.getConstructors();        for (Constructor constructor : constructors) &#123;            System.out.println(constructor);        &#125;        constructors = c1.getDeclaredConstructors();        for (Constructor constructor : constructors) &#123;            System.out.println(&quot;#&quot;+constructor);        &#125;        //获得指定得构造器        Constructor declaredConstructor = c1.getDeclaredConstructor( int.class, int.class,String.class);        System.out.println(&quot;指定&quot;+declaredConstructor);    &#125;&#125;//1. 创建一个实体类class User&#123;    private int id;    private int age;    private String name;    public User() &#123;    &#125;    public User(int id, int age, String name) &#123;        this.id = id;        this.age = age;        this.name = name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, age=&quot; + age +                &quot;, name=&quot; + name +                &#x27;&#125;&#x27;;    &#125;&#125;//输出UserUser==================private int User.idprivate int User.ageprivate java.lang.String User.nameprivate java.lang.String User.name==================正常的public java.lang.String User.toString()正常的public java.lang.String User.getName()正常的public int User.getId()正常的public void User.setName(java.lang.String)正常的public void User.setId(int)正常的public int User.getAge()正常的public void User.setAge(int)正常的public final void java.lang.Object.wait() throws java.lang.InterruptedException正常的public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException正常的public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException正常的public boolean java.lang.Object.equals(java.lang.Object)正常的public native int java.lang.Object.hashCode()正常的public final native java.lang.Class java.lang.Object.getClass()正常的public final native void java.lang.Object.notify()正常的public final native void java.lang.Object.notifyAll()getDeclaredMethodspublic java.lang.String User.toString()getDeclaredMethodspublic java.lang.String User.getName()getDeclaredMethodspublic int User.getId()getDeclaredMethodspublic void User.setName(java.lang.String)getDeclaredMethodspublic void User.setId(int)getDeclaredMethodspublic int User.getAge()getDeclaredMethodspublic void User.setAge(int)public java.lang.String User.getName()public void User.setName(java.lang.String)==================public User()public User(int,int,java.lang.String)#public User()#public User(int,int,java.lang.String)指定public User(int,int,java.lang.String)\n\n6.动态创建对象执行有了Class对象,能做什么? \n\n创建类的对象：调用Class对象的newInstance()方法 \n\n类必须有一个无参数的构造器。 \n类的构造器的访问权限需要足够\n\n\n思考？难道没有无参的构造器就不能创建对象了吗？只要在操作的时候明确的调用类中的构造器， 并将参数传递进去之后，才可以实例化操作。\n\n步骤如下： \n\n通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器 \n\n向构造器的形参中传递一个对象数组进去，\n\n里面包含了构造器中所需的各个参数。 通过Constructor实例化对象\n\n\n调用指定的方法 \n\n通过反射，调用类中的方法，通过Method类完成。 \n通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对 象，并设置此方法操作时所需要的参数类型。 \n之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对 象的参数信息。\nObject 对应原方法的返回值，若原方法无返回值，此时返回null \n若原方法若为静态方法，此时形参Object obj可为null \n若原方法形参列表为空，则Object[] args为null \n若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的 setAccessible(true)方法，将可访问private的方法。\n\n\n\n\nsetAccessible \n\nMethod和Field、Constructor对象都有setAccessible()方法。 \n\nsetAccessible作用是启动和禁用访问安全检查的开关。 \n\n参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。 \n\n提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。 \n\n使得原本无法访问的私有成员也可以访问 \n\n参数值为false则指示反射的对象应该实施Java语言访问检查\n import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;//动态创建对象通过反射public class demo1 &#123;    public static void main(String[] args) throws Exception &#123;        //获取class对象        Class c1 = Class.forName(&quot;User&quot;);        //构造一个对象       User user = (User) c1.newInstance();            System.out.println(user);        //通过构造器创建对象        Constructor constructor = c1.getDeclaredConstructor(int.class, int.class, String.class);        User user2 = (User) constructor.newInstance(001, 18, &quot;xiao&quot;);        System.out.println(user2);        //通过反射调用普通方法        User user3 = (User) c1.newInstance();        //通过反射获取普通方法        Method setName = c1.getDeclaredMethod(&quot;setName&quot;, String.class);        setName.invoke(user3,&quot;xiao&quot;);        System.out.println(user3.getName());        //通过反射操作属性        System.out.println(&quot;============&quot;);        User user4 = (User) c1.newInstance();        Field name = c1.getDeclaredField(&quot;name&quot;);        //不能直接操作私有属性，我们需要关闭程序的安全检测        name.setAccessible(true);        name.set(user4,&quot;xiaoxiao&quot;);        System.out.println(user4.getName());    &#125;&#125;//1. 创建一个实体类class User&#123;    private int id;    private int age;    private String name;    public User() &#123;    &#125;    public User(int id, int age, String name) &#123;        this.id = id;        this.age = age;        this.name = name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, age=&quot; + age +                &quot;, name=&quot; + name +                &#x27;&#125;&#x27;;    &#125;&#125;//输出User&#123;id=0, age=0, name=null&#125;User&#123;id=1, age=18, name=xiao&#125;xiao============xiaoxiao\n\n7.性能对比分析import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;//分析性能问题public class demo1 &#123;       //普通调用方法        public static void test01()&#123;            User user = new User();            long startTime = System.currentTimeMillis();            for (int i = 0; i &lt; 1000000000; i++) &#123;                user.getName();            &#125;            long endTime = System.currentTimeMillis();            System.out.println(&quot;普通方法执行10亿次&quot;+(endTime-startTime)+&quot;ms&quot;);        &#125;        //反射方式调用        public static void test02() throws InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;            User user = new User();            Class c1 = user.getClass();            Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null);            long startTime = System.currentTimeMillis();            for (int i = 0; i &lt; 1000000000; i++) &#123;                getName.invoke(user,null);            &#125;            long endTime = System.currentTimeMillis();            System.out.println(&quot;反射方法执行10亿次&quot;+(endTime-startTime)+&quot;ms&quot;);        &#125;        //反射方式调用，关闭检测        public static void test03() throws InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;            User user = new User();            Class c1 = user.getClass();            Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null);            getName.setAccessible(true);            long startTime = System.currentTimeMillis();            for (int i = 0; i &lt; 1000000000; i++) &#123;                getName.invoke(user,null);            &#125;            long endTime = System.currentTimeMillis();            System.out.println(&quot;关闭检测方法执行10亿次&quot;+(endTime-startTime)+&quot;ms&quot;);        &#125;    public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;        test01();        test02();        test03();    &#125;&#125;//1. 创建一个实体类class User&#123;    private int id;    private int age;    private String name;    public User() &#123;    &#125;    public User(int id, int age, String name) &#123;        this.id = id;        this.age = age;        this.name = name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, age=&quot; + age +                &quot;, name=&quot; + name +                &#x27;&#125;&#x27;;    &#125;&#125;//输出普通方法执行10亿次4ms反射方法执行10亿次4366ms关闭检测方法执行10亿次1757ms\n\n8.反射操作泛型\nJava采用泛型擦除的机制来引入泛型 , Java中的泛型仅仅是给编译器javac使用的,确保数据的安全性 和免去强制类型转换问题 , 但是 , 一旦编译完成 , 所有和泛型有关的类型全部擦除 \n\n为了通过反射操作这些类型 , Java新增了 ParameterizedType , GenericArrayType , TypeVariable 和 WildcardType 几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型. \n\nParameterizedType : 表示一种参数化类型,比如Collection \n\nGenericArrayType : 表示一种元素类型是参数化类型或者类型变量的数组类型 \n\nTypeVariable : 是各种类型变量的公共父接口 \n\nWildcardType : 代表一种通配符类型表达式\n\n\nimport java.lang.reflect.*;import java.util.List;import java.util.Map;//分析性能问题public class demo1 &#123;       public void test01(Map&lt;String,User&gt; map, List&lt;User&gt; list)&#123;           System.out.println(&quot;test01&quot;);       &#125;       public Map&lt;String,User&gt; test02()&#123;           System.out.println(&quot;test02&quot;);           return null;       &#125;    public static void main(String[] args) throws NoSuchMethodException &#123;        Method method = demo1.class.getMethod(&quot;test01&quot;, Map.class, List.class);        Type[] genericParameterTypes = method.getGenericParameterTypes();        for (Type genericParameterType : genericParameterTypes) &#123;            System.out.println(&quot;#&quot;+genericParameterTypes);            if (genericParameterType instanceof ParameterizedType) &#123;                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();                for (Type actualTypeArgument : actualTypeArguments) &#123;                    System.out.println(actualTypeArgument);                &#125;            &#125;        &#125;        method = demo1.class.getMethod(&quot;test02&quot;, null);        Type genericReturnType = method.getGenericReturnType();            if (genericReturnType instanceof ParameterizedType) &#123;                Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();                for (Type actualTypeArgument : actualTypeArguments) &#123;                    System.out.println(actualTypeArgument);            &#125;        &#125;    &#125;&#125;//1. 创建一个实体类class User&#123;    private int id;    private int age;    private String name;    public User() &#123;    &#125;    public User(int id, int age, String name) &#123;        this.id = id;        this.age = age;        this.name = name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, age=&quot; + age +                &quot;, name=&quot; + name +                &#x27;&#125;&#x27;;    &#125;&#125;//输出#[Ljava.lang.reflect.Type;@2503dbd3class java.lang.Stringclass User#[Ljava.lang.reflect.Type;@2503dbd3class Userclass java.lang.Stringclass User\n\n9.反射操作注解\ngetAnnotations \n\ngetAnnotation\n import java.lang.annotation.*;import java.lang.reflect.*;import java.util.List;import java.util.Map;//分析性能问题public class demo1 &#123;    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123;        Class c1 = Class.forName(&quot;student&quot;);        //通过反射获得注解        Annotation[] annotations = c1.getAnnotations();        for (Annotation annotation : annotations) &#123;            System.out.println(annotation);        &#125;        //获得注解的value的值        Table table = (Table)c1.getAnnotation(Table.class);        String value = table.value();        System.out.println(value);        //获得类指定的注解        Field f = c1.getDeclaredField(&quot;name&quot;);        File annotation = f.getAnnotation(File.class);        System.out.println(annotation.columnName());        System.out.println(annotation.type());        System.out.println(annotation.length());    &#125;&#125;@Table(&quot;student&quot;)class student&#123;    @File(columnName = &quot;id&quot;,type = &quot;int&quot;,length = 10)    private int id;    @File(columnName = &quot;age&quot;,type = &quot;int&quot;,length = 10)    private int age;    @File(columnName = &quot;name&quot;,type = &quot;varchar&quot;,length = 3)    private String name;    public student() &#123;    &#125;    public student(int id, int age, String name) &#123;        this.id = id;        this.age = age;        this.name = name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        final StringBuffer sb = new StringBuffer(&quot;student&#123;&quot;);        sb.append(&quot;id=&quot;).append(id);        sb.append(&quot;, age=&quot;).append(age);        sb.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;);        sb.append(&#x27;&#125;&#x27;);        return sb.toString();    &#125;&#125;//类名的注解@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface Table&#123;    String value();&#125;//属性的注解@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface File&#123;    String columnName();    String type();    int length();&#125;//输出@Table(value=student)studentnamevarchar3\n\n","tags":["反射"]},{"title":"反射之Java内存分析","url":"/2022/05/01/%E5%8F%8D%E5%B0%84%E4%B9%8BJava%E5%8F%8D%E5%B0%84/","content":"\n1. 类的加载过程\n2.类的加载与ClassLoader的理解加载： \n\n将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构， 然后生成一个代表这个类的java.lang.Class对象.\n\n链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。 \n\n验证：确保加载的类信息符合JVM规范，没有安全方面的问题 \n准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。\n解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。\n\n初始化： \n\n执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作 和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造 器）。 \n当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。\n虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步。\n\n\npublic class demo1 &#123;    public static void main(String[] args) &#123;        A a = new A();        System.out.println(A.m);        /*        1.加载到内存，会产生一个类对应的class对象        2.链接，链接结束后m=0        3.初始化            &lt;clint&gt;()&#123;             System.out.println(&quot;A类静态代码块&quot;);            m = 300;            m =100;            &#125;        */    &#125;&#125;class A&#123;    static &#123;        System.out.println(&quot;A类静态代码块&quot;);        m = 300;    &#125;    static int m =100;    public A()&#123;        System.out.println(&quot;A类的无参构造初始化&quot;);    &#125;&#125;\n\n3. 分析类初始化什么时候会发生类初始化？\n\n类的主动引用（一定会发生类的初始化） \n\n当虚拟机启动，先初始化main方法所在的类 \n\nnew一个类的对象 \n\n调用类的静态成员（除了final常量）和静态方法 \n\n使用java.lang.reflect包的方法对类进行反射调用 \n\n当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类 \n\n类的被动引用（不会发生类的初始化） \n\n当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 \n通过数组定义类引用，不会触发此类的初始化 \n引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）\n\n\n\npublic class demo1 &#123;    public static void main(String[] args) throws ClassNotFoundException &#123;        System.out.println(&quot;main方法&quot;);        //1.主动引用        Son son = new Son();        //2.反射也会产生引用        Class.forName(&quot;Son&quot;);        //3.当通过子类引用父类的静态变量，不会导致子类初始化        System.out.println(Son.b);        //4.通过数组定义类引用，不会触发此类的初始化        Son[] array = new Son[5];        //引用常量不会触发此类的初始化        System.out.println(Son.M);    &#125;&#125;class Father&#123;    static int b = 2;    static &#123;        System.out.println(&quot;父类被加载&quot;);    &#125;   &#125;class Son extends Father&#123;    static &#123;        System.out.println(&quot;子类被加载&quot;);        m = 300;    &#125;    static int m =100;    static final int M = 1;&#125;//输出1.main方法父类被加载子类被加载/////////    2.main方法父类被加载子类被加载/////////   3.main方法父类被加载2/////////   4.main方法/////////    5.main方法1\n\n4.类加载器类加载器的作用 \n\n类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数 据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入 口。 \n\n类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象\n\n类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器\n\n\npublic class demo1 &#123;    public static void main(String[] args) throws Exception &#123;        //获取系统类的加载器        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();        System.out.println(systemClassLoader);        //获取系统类加载器的父类加载器-&gt;扩展类加载器        ClassLoader parent = systemClassLoader.getParent();        System.out.println(parent);        //获取扩展类加载器的父类加载器-&gt;根加载器        ClassLoader parent1 = parent.getParent();        System.out.println(parent1);        //测试当前类是哪个加载器加载的        ClassLoader classLoader = Class.forName(&quot;demo1&quot;).getClassLoader();        System.out.println(classLoader);        //测试JDK内置的类是哪个加载器加载的        classLoader = Class.forName(&quot;java.lang.Object&quot;).getClassLoader();        System.out.println(classLoader);        //如何获取系统类加载器可以加载的路径        System.out.println(System.getProperty(&quot;java.class.path&quot;));    &#125;&#125;//输出sun.misc.Launcher$AppClassLoader@14dad5dcsun.misc.Launcher$ExtClassLoader@2503dbd3nullsun.misc.Launcher$AppClassLoader@14dad5dcnullC:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_40\\jre\\lib\\rt.jar;C:\\Users\\1\\Desktop\\fang\\java\\cookie-session\\cookie-session\\target\\classes;C:\\Environment\\maven\\maven-repo\\javax\\servlet\\jsp\\jstl\\jstl-api\\1.2\\jstl-api-1.2.jar;C:\\Environment\\maven\\maven-repo\\javax\\servlet\\servlet-api\\2.5\\servlet-api-2.5.jar;C:\\Environment\\maven\\maven-repo\\taglibs\\standard\\1.1.2\\standard-1.1.2.jar;C:\\Environment\\maven\\maven-repo\\mysql\\mysql-connector-java\\5.1.47\\mysql-connector-java-5.1.47.jar;C:\\Environment\\maven\\maven-repo\\org\\json\\json\\20160810\\json-20160810.jar;C:\\Environment\\maven\\maven-repo\\commons-io\\commons-io\\2.4\\commons-io-2.4.jar;C:\\Program Files\\JetBrains\\IntelliJ IDEA 2021.2.3\\lib\\idea_rt.jar\n\n5.获取类的运行时结构通过反射获取运行时类的完整结构： Field、Method、Constructor、Superclass、Interface、Annotation 实现的全部接口 所继承的父类 全部的构造器 全部的方法 全部的Field 注解 …….\nimport java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class demo1 &#123;    public static void main(String[] args) throws Exception &#123;        Class c1 = Class.forName(&quot;User&quot;);        //获取类的名字        System.out.println(c1.getName());//获取包名+类名        System.out.println(c1.getSimpleName());//获取类名        //获取类的属性        System.out.println(&quot;==================&quot;);        Field[] fields = c1.getFields();//只能找到public属性        fields = c1.getDeclaredFields();//找到全部的属性        for (Field field : fields) &#123;            System.out.println(field);        &#125;        //获取指定属性的值        Field name = c1.getDeclaredField(&quot;name&quot;);        System.out.println(name);        //获得类的方法        System.out.println(&quot;==================&quot;);        Method[] methods = c1.getMethods();//获取本类及其父类所有的public方法        for (Method method : methods) &#123;            System.out.println(&quot;正常的&quot;+method);        &#125;        methods = c1.getDeclaredMethods();        for (Method method : methods) &#123;            System.out.println(&quot;getDeclaredMethods&quot;+method);//获取本类所有的方法        &#125;        //获取指定的方法        Method getName = c1.getMethod(&quot;getName&quot;, null);        Method setName = c1.getMethod(&quot;setName&quot;, String.class);        System.out.println(getName);        System.out.println(setName);        //获取指定的构造器        System.out.println(&quot;==================&quot;);        Constructor[] constructors = c1.getConstructors();        for (Constructor constructor : constructors) &#123;            System.out.println(constructor);        &#125;        constructors = c1.getDeclaredConstructors();        for (Constructor constructor : constructors) &#123;            System.out.println(&quot;#&quot;+constructor);        &#125;        //获得指定得构造器        Constructor declaredConstructor = c1.getDeclaredConstructor( int.class, int.class,String.class);        System.out.println(&quot;指定&quot;+declaredConstructor);    &#125;&#125;//1. 创建一个实体类class User&#123;    private int id;    private int age;    private String name;    public User() &#123;    &#125;    public User(int id, int age, String name) &#123;        this.id = id;        this.age = age;        this.name = name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, age=&quot; + age +                &quot;, name=&quot; + name +                &#x27;&#125;&#x27;;    &#125;&#125;//输出UserUser==================private int User.idprivate int User.ageprivate java.lang.String User.nameprivate java.lang.String User.name==================正常的public java.lang.String User.toString()正常的public java.lang.String User.getName()正常的public int User.getId()正常的public void User.setName(java.lang.String)正常的public void User.setId(int)正常的public int User.getAge()正常的public void User.setAge(int)正常的public final void java.lang.Object.wait() throws java.lang.InterruptedException正常的public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException正常的public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException正常的public boolean java.lang.Object.equals(java.lang.Object)正常的public native int java.lang.Object.hashCode()正常的public final native java.lang.Class java.lang.Object.getClass()正常的public final native void java.lang.Object.notify()正常的public final native void java.lang.Object.notifyAll()getDeclaredMethodspublic java.lang.String User.toString()getDeclaredMethodspublic java.lang.String User.getName()getDeclaredMethodspublic int User.getId()getDeclaredMethodspublic void User.setName(java.lang.String)getDeclaredMethodspublic void User.setId(int)getDeclaredMethodspublic int User.getAge()getDeclaredMethodspublic void User.setAge(int)public java.lang.String User.getName()public void User.setName(java.lang.String)==================public User()public User(int,int,java.lang.String)#public User()#public User(int,int,java.lang.String)指定public User(int,int,java.lang.String)\n\n6.动态创建对象执行有了Class对象,能做什么? \n\n创建类的对象：调用Class对象的newInstance()方法 \n\n类必须有一个无参数的构造器。 \n类的构造器的访问权限需要足够\n\n\n思考？难道没有无参的构造器就不能创建对象了吗？只要在操作的时候明确的调用类中的构造器， 并将参数传递进去之后，才可以实例化操作。\n\n步骤如下： \n\n通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器 \n\n向构造器的形参中传递一个对象数组进去，\n\n里面包含了构造器中所需的各个参数。 通过Constructor实例化对象\n\n\n调用指定的方法 \n\n通过反射，调用类中的方法，通过Method类完成。 \n通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。 \n之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对 象的参数信息。\nObject 对应原方法的返回值，若原方法无返回值，此时返回null \n若原方法若为静态方法，此时形参Object obj可为null \n若原方法形参列表为空，则Object[] args为null \n若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的 setAccessible(true)方法，将可访问private的方法。\n\n\n\n\nsetAccessible \n\nMethod和Field、Constructor对象都有setAccessible()方法。 \n\nsetAccessible作用是启动和禁用访问安全检查的开关。 \n\n参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。 \n\n提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。 \n\n使得原本无法访问的私有成员也可以访问 \n\n参数值为false则指示反射的对象应该实施Java语言访问检查\n import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;//动态创建对象通过反射public class demo1 &#123;    public static void main(String[] args) throws Exception &#123;        //获取class对象        Class c1 = Class.forName(&quot;User&quot;);        //构造一个对象       User user = (User) c1.newInstance();            System.out.println(user);        //通过构造器创建对象        Constructor constructor = c1.getDeclaredConstructor(int.class, int.class, String.class);        User user2 = (User) constructor.newInstance(001, 18, &quot;xiao&quot;);        System.out.println(user2);        //通过反射调用普通方法        User user3 = (User) c1.newInstance();        //通过反射获取普通方法        Method setName = c1.getDeclaredMethod(&quot;setName&quot;, String.class);        setName.invoke(user3,&quot;xiao&quot;);        System.out.println(user3.getName());        //通过反射操作属性        System.out.println(&quot;============&quot;);        User user4 = (User) c1.newInstance();        Field name = c1.getDeclaredField(&quot;name&quot;);        //不能直接操作私有属性，我们需要关闭程序的安全检测        name.setAccessible(true);        name.set(user4,&quot;xiaoxiao&quot;);        System.out.println(user4.getName());    &#125;&#125;//1. 创建一个实体类class User&#123;    private int id;    private int age;    private String name;    public User() &#123;    &#125;    public User(int id, int age, String name) &#123;        this.id = id;        this.age = age;        this.name = name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, age=&quot; + age +                &quot;, name=&quot; + name +                &#x27;&#125;&#x27;;    &#125;&#125;//输出User&#123;id=0, age=0, name=null&#125;User&#123;id=1, age=18, name=xiao&#125;xiao============xiaoxiao\n\n7.性能对比分析import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;//分析性能问题public class demo1 &#123;       //普通调用方法        public static void test01()&#123;            User user = new User();            long startTime = System.currentTimeMillis();            for (int i = 0; i &lt; 1000000000; i++) &#123;                user.getName();            &#125;            long endTime = System.currentTimeMillis();            System.out.println(&quot;普通方法执行10亿次&quot;+(endTime-startTime)+&quot;ms&quot;);        &#125;        //反射方式调用        public static void test02() throws InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;            User user = new User();            Class c1 = user.getClass();            Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null);            long startTime = System.currentTimeMillis();            for (int i = 0; i &lt; 1000000000; i++) &#123;                getName.invoke(user,null);            &#125;            long endTime = System.currentTimeMillis();            System.out.println(&quot;反射方法执行10亿次&quot;+(endTime-startTime)+&quot;ms&quot;);        &#125;        //反射方式调用，关闭检测        public static void test03() throws InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;            User user = new User();            Class c1 = user.getClass();            Method getName = c1.getDeclaredMethod(&quot;getName&quot;, null);            getName.setAccessible(true);            long startTime = System.currentTimeMillis();            for (int i = 0; i &lt; 1000000000; i++) &#123;                getName.invoke(user,null);            &#125;            long endTime = System.currentTimeMillis();            System.out.println(&quot;关闭检测方法执行10亿次&quot;+(endTime-startTime)+&quot;ms&quot;);        &#125;    public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;        test01();        test02();        test03();    &#125;&#125;//1. 创建一个实体类class User&#123;    private int id;    private int age;    private String name;    public User() &#123;    &#125;    public User(int id, int age, String name) &#123;        this.id = id;        this.age = age;        this.name = name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id = id;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, age=&quot; + age +                &quot;, name=&quot; + name +                &#x27;&#125;&#x27;;    &#125;&#125;//输出普通方法执行10亿次4ms反射方法执行10亿次4366ms关闭检测方法执行10亿次1757ms\n\n8.反射操作泛型\nJava采用泛型擦除的机制来引入泛型 , Java中的泛型仅仅是给编译器javac使用的,确保数据的安全性 和免去强制类型转换问题 , 但是 , 一旦编译完成 , 所有和泛型有关的类型全部擦除 \n为了通过反射操作这些类型 , Java新增了 ParameterizedType , GenericArrayType , TypeVariable 和 WildcardType 几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型. \nParameterizedType : 表示一种参数化类型,比如Collection \nGenericArrayType : 表示一种元素类型是参数化类型或者类型变量的数组类型 \nTypeVariable : 是各种类型变量的公共父接口 \nWildcardType : 代表一种通配符类型表达式\n\n","tags":["反射"]},{"title":"反射之反射概述","url":"/2022/05/01/%E5%8F%8D%E5%B0%84%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0/","content":"1、静态 VS 动态语言动态语言\n\n是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的 函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自 身结构。\n\n主要动态语言：Object-C、C#、JavaScript、PHP、Python等。 \n//体现动态语言的代码function test() &#123;var x = &quot;var a=3;var b=5;alert(a+b)&quot;;eval(x);&#125;\n\n静态语言 \n\n与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。\nJava不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用 反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活！\n\n2、Java ReflectionReflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取 得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 \nClass c = Class.forName(&quot;java.lang.String&quot;)\n\n加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子， 透过这个镜子看到类的结构，所以，我们形象的称之为：反射\n3. 获得反射对象Java反射机制提供的功能\n\n在运行时判断任意一个对象所属的类 \n在运行时构造任意一个类的对象 \n在运行时判断任意一个类所具有的成员变量和方法 \n在运行时获取泛型信息 \n在运行时调用任意一个对象的成员变量和方法 \n在运行时处理注解 生成动态代理 ……\n\nJava反射优点和缺点 \n\n优点：可以实现动态创建对象和编译，体现出很大的灵活性 ! \n缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。\n\nimport java.lang.annotation.*;public class demo1  &#123;    public static void main(String[] args) throws ClassNotFoundException &#123;        Class&lt;?&gt; c1 = Class.forName(&quot;User&quot;);        //一个类被加载后 , 类的整个结构信息会被放到对应的Class对象中        System.out.println(c1);//一个类只对应一个Class对象        Class&lt;?&gt; c2 = Class.forName(&quot;User&quot;);        System.out.println(c1.hashCode());        System.out.println(c2.hashCode());    &#125;&#125;    //1. 创建一个实体类    class User&#123;        private int id;        private int age;        private String name;        public User() &#123;        &#125;        public User(int id, int age, String name) &#123;            this.id = id;            this.age = age;            this.name = name;        &#125;        public int getId() &#123;            return id;        &#125;        public void setId(int id) &#123;            this.id = id;        &#125;        public int getAge() &#123;            return age;        &#125;        public void setAge(int age) &#123;            this.age = age;        &#125;        public String getName() &#123;            return name;        &#125;        public void setName(String name) &#123;            this.name = name;        &#125;        @Override        public String toString() &#123;            return &quot;User&#123;&quot; +                    &quot;id=&quot; + id +                    &quot;, age=&quot; + age +                    &quot;, name=&quot; + name +                    &#x27;&#125;&#x27;;        &#125;    &#125;\n\n4.得到Class类的几种方式在Object类中定义了以下的方法，此方法将被所有子类继承\npublic final Class getClass();\n\n以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来 看也很好理解，即：可以通过对象反射求出类的名称。\n对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个 类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构 (class&#x2F;interface&#x2F;enum&#x2F;annotation&#x2F;primitive type&#x2F;void&#x2F;[])的有关信息。\n\nClass 本身也是一个类 \n\nClass 对象只能由系统建立对象 \n\n一个加载的类在 JVM 中只会有一个Class实例 \n\n一个Class对象对应的是一个加载到JVM中的一个.class文件 \n\n每个类的实例都会记得自己是由哪个Class 实例所生成 \n\n通过Class可以完整地得到一个类中的所有被加载的结构 \n\nClass类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象\nimport java.lang.annotation.*;public class demo1  &#123;    public static void main(String[] args) throws ClassNotFoundException &#123;        Person person = new Student();        System.out.println(&quot;这个人是：&quot;+person.name);        //获得class办法一:通过对象获得        Class class1 = person.getClass();        ////获得class办法二:通过字符串获得(包名+类名)        Class class2 = Class.forName(&quot;Student&quot;);        //获得class办法三:通过类的静态成员class获得        Class class3 = Person.class;        //获得class办法四:只针对内置的基本数据类型        Class class4 = Integer.TYPE;        //获得父类类型        Class class5 = class2.getSuperclass();        System.out.println(class1);        System.out.println(class2);        System.out.println(class3);        System.out.println(class4);        System.out.println(class5);    &#125;&#125;class Person &#123;    public String name;    public Person() &#123;    &#125;    public Person(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;class Student extends Person&#123;    public Student()&#123;        this.name = &quot;学生&quot;;    &#125;&#125;class Teacher extends Person&#123;    public Teacher()&#123;        this.name = &quot;老师&quot;;    &#125;&#125;//输出结果这个人是：学生class Studentclass Studentclass Personintclass Person\n\nClass类的常用方法\n\n\n\n方法名\n功能说明\n\n\n\nstatic ClassforName(String name)\n返回指定类名name的Class对象\n\n\nObject newInstance()\n调用缺省构造函数，返回Class对象的一个实例\n\n\ngetName()\n返回此Class对象所表示的实体（类，接口，数组类或 void）的名称。\n\n\nClass getSuperClass()\n返回当前Class对象的父类的Class对象\n\n\nClass[] getinterfaces()\n获取当前Class对象的接口\n\n\nClassLoader getClassLoader()\n返回该类的类加载器\n\n\nConstructor[] getConstructors()\n返回一个包含某些Constructor对象的数组\n\n\nMethod getMothed(String name,Class.. T)\n返回一个Method对象，此对象的形参类型为paramType\n\n\nField[] getDeclaredFields()\n返回Field对象的一个数组\n\n\n获取Class类的实例\na）若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高。\nClass clazz = Person.class;\n\nb）已知某个类的实例，调用该实例的getClass()方法获取Class对象 \nClass clazz = person.getClass();\n\nc）已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出 ClassNotFoundException \nClass clazz = Class.forName(&quot;demo01.Student&quot;);\n\nd）内置基本数据类型可以直接用类名.Type \ne）还可以利用ClassLoader我们之后讲解\n5.所有类型的Class对象\nclass：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类。 \n\ninterface：接口 \n\n[]：数组 \n\nenum：枚举 \n\nannotation：注解@interface \n\nprimitive type：基本数据类型 \n\nvoid\nimport java.lang.annotation.*;public class demo1 &#123;    public static void main(String[] args) &#123;        Class c1 = Object.class;        Class c2 = Comparable.class;        Class c3 = String[].class;        Class c4 = int[][].class;        Class c5 = ElementType.class;        Class c6 = Override.class;        Class c7 = Integer.class;        Class c8 = void.class;        Class c9 = Class.class;        int[] a = new int[10];        int[] b = new int[100];        Class c10 = a.getClass();        Class c11 = b.getClass();        System.out.println(c1);        System.out.println(c2);        System.out.println(c3);        System.out.println(c4);        System.out.println(c5);        System.out.println(c6);        System.out.println(c7);        System.out.println(c8);        System.out.println(c9);        System.out.println(c10);        System.out.println(c11);        //只要元素类型与维度一样,就是同一个Class        System.out.println(c11==c10);    &#125;&#125;//输出class java.lang.Objectinterface java.lang.Comparableclass [Ljava.lang.String;class [[Iclass java.lang.annotation.ElementTypeinterface java.lang.Overrideclass java.lang.Integervoidclass java.lang.Classclass [Iclass [Itrue\n\n","tags":["反射"]},{"title":"完整项目之Spring Cloud + Vue 前后端分离2-1","url":"/2022/02/07/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E4%B9%8BSpring%20Cloud%20+%20Vue%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%202-1/","content":"第6章 通用代码生成器开发本章将演示代码生成器的制作，学习模板引擎freemarker的使用。通过代码生成器可以快速生成dto、service、controller和vue界面代码，再配合上mybatis generator，可以快速完成单表的增删改查管理功能，极大的提高开发效率。另外，本章的知识也可应用于静态页面生成、导出复杂excel等涉及文件生成的场景。…\n6-1 代码生成器原理介绍1.增加generator模块，用于代码生成2.集成freemarker\n\n\nfreemarker和thymeleaf代码风格：前一个的逻辑主要写在自定义标签中；后一个的逻辑主要写在标签的属性中，web开发时可读性好一点。\n\n步骤1：在父pom.xml中添加freemarker.jar依赖\n\n\n&lt;!-- 模板引擎freemarker --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.freemarker&lt;/groupId&gt;   &lt;artifactId&gt;freemarker&lt;/artifactId&gt;   &lt;version&gt;2.3.29&lt;/version&gt;&lt;/dependency&gt;\n\n\n步骤2：增加generator子模块，代码生成器专用，并添加freemarker.jar依赖\n\n&lt;!-- 模板引擎freemarker --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.freemarker&lt;/groupId&gt;    &lt;artifactId&gt;freemarker&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n步骤3：添加模板文件test.ftl和启动文件TestUtil.java\n\npackage com.course.generator.test;public class Test &#123;/*** ID111*/private String id;&#125;\n\npackage com.course.generator.test;import freemarker.template.Configuration;import freemarker.template.DefaultObjectWrapper;import freemarker.template.Template;import freemarker.template.TemplateException;import java.io.BufferedWriter;import java.io.File;import java.io.FileWriter;import java.io.IOException;public class TestUtil &#123;        static String ftlPath = &quot;generator\\\\src\\\\main\\\\java\\\\com\\\\course\\\\generator\\\\test\\\\&quot;;        static String toPath = &quot;generator\\\\src\\\\main\\\\java\\\\com\\\\course\\\\generator\\\\test\\\\&quot;;        public static void main(String[] args) throws IOException, TemplateException &#123;                Configuration cfg = new Configuration(Configuration.VERSION_2_3_29);                cfg.setDirectoryForTemplateLoading(new File(ftlPath));                cfg.setObjectWrapper(new DefaultObjectWrapper(Configuration.VERSION_2_3_29));                Template temp = cfg.getTemplate(&quot;test.ftl&quot;);                FileWriter fw = new FileWriter(toPath + &quot;Test.java&quot;);                BufferedWriter bw = new BufferedWriter(fw);                temp.process(null, bw);                bw.flush();                fw.close();        &#125;&#125;\n\n\n.ftl是freemarker约定的模板后缀名，也可以改成任意其他后缀；ftlPath：模板文件所在的路径；toPath：要生成的文件的路径\n\n6-2 controller层和service层代码生成小节表持久层代码生成：\n\n创建一个all.sql\n\n# 小节DROP TABLE IF EXISTS `Section`;create table `Section`(    `id`         CHAR(8)     NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;ID&#x27;,    `title`      VARCHAR(50) NOT NULL COMMENT &#x27;标题&#x27;,    `course_id`  CHAR(8) COMMENT &#x27;课程|course.id&#x27;,    `chapter_id` CHAR(8) COMMENT &#x27;大章|chapter.id&#x27;,    `video`      VARCHAR(200) COMMENT &#x27;视频&#x27;,    `time`       INT COMMENT &#x27;时长|单位秒&#x27;,    `charge`     CHAR(1) COMMENT &#x27;收费|C 收费;F 免费&#x27;,    `sort`       INT COMMENT &#x27;顺序&#x27;,    `created_at` DATETIME(3) COMMENT &#x27;创建时间&#x27;,    `updated_at` DATETIME(3) COMMENT &#x27;修改时间&#x27;,    PRIMARY KEY (`id`))engine =innodb default charset=utf8mb4 comment=&#x27;小节&#x27;;INSERT INTO `section`(id,title,course_id,chapter_id,video,time,charge,sort,created_at,updated_at)VALUES(&#x27;00000001&#x27;,&#x27;测试小节01&#x27;,&#x27;00000001&#x27;,&#x27;00000000&#x27;,&#x27;&#x27;,500,&#x27;F&#x27;,1,now(),now());\n\n\n再在generatorconfig中添加代码，运用mybatis-generator代码生成器。\n\nservice层代码生成：\n1.制作freemarkerUtil，简化生成器的使用2.新增ServerGenerator，用于生成后端代码;controller,service,dto\n\n\nftlPath是统一放模板的地方，这个属性值一般不会变，所以可以直接放在工具类里\n\n首先建立FreemarkerUtil\n\n\npackage com.course.generator.server;import com.course.generator.util.DbUtil;import com.course.generator.util.Field;import com.course.generator.util.FreemarkerUtil;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.io.File;import java.util.*;public class ServerGenerator &#123;    static String MODULE = &quot;business&quot;;    static String toDtoPath = &quot;server\\\\src\\\\main\\\\java\\\\com\\\\course\\\\server\\\\dto\\\\&quot;;    static String toServicePath = &quot;server\\\\src\\\\main\\\\java\\\\com\\\\course\\\\server\\\\service\\\\&quot;;    static String toControllerPath = MODULE + &quot;\\\\src\\\\main\\\\java\\\\com\\\\course\\\\&quot; + MODULE + &quot;\\\\controller\\\\admin\\\\&quot;;    static String generatorConfigPath = &quot;server\\\\src\\\\main\\\\resources\\\\generator\\\\generatorConfig.xml&quot;;    public static void main(String[] args) throws Exception &#123;        String module = MODULE;        // 只生成配置文件中的第一个table节点        File file = new File(generatorConfigPath);        SAXReader reader=new SAXReader();        //读取xml文件到Document中        Document doc=reader.read(file);        //获取xml文件的根节点        Element rootElement=doc.getRootElement();        //读取context节点        Element contextElement = rootElement.element(&quot;context&quot;);        //定义一个Element用于遍历        Element tableElement;        //取第一个“table”的节点        tableElement=contextElement.elementIterator(&quot;table&quot;).next();        String Domain = tableElement.attributeValue(&quot;domainObjectName&quot;);        String tableName = tableElement.attributeValue(&quot;tableName&quot;);        String tableNameCn = DbUtil.getTableComment(tableName);        String domain = Domain.substring(0, 1).toLowerCase() + Domain.substring(1);        System.out.println(&quot;表：&quot;+tableElement.attributeValue(&quot;tableName&quot;));        System.out.println(&quot;Domain：&quot;+tableElement.attributeValue(&quot;domainObjectName&quot;));        List&lt;Field&gt; fieldList = DbUtil.getColumnByTableName(tableName);        Set&lt;String&gt; typeSet = getJavaTypes(fieldList);        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;Domain&quot;, Domain);        map.put(&quot;domain&quot;, domain);        map.put(&quot;tableNameCn&quot;, tableNameCn);        map.put(&quot;module&quot;, module);        map.put(&quot;fieldList&quot;, fieldList);        map.put(&quot;typeSet&quot;, typeSet);        // 生成dto        FreemarkerUtil.initConfig(&quot;dto.ftl&quot;);        FreemarkerUtil.generator(toDtoPath + Domain + &quot;Dto.java&quot;, map);        // 生成service        FreemarkerUtil.initConfig(&quot;service.ftl&quot;);        FreemarkerUtil.generator(toServicePath + Domain + &quot;Service.java&quot;, map);        // 生成controller        FreemarkerUtil.initConfig(&quot;controller.ftl&quot;);        FreemarkerUtil.generator(toControllerPath + Domain + &quot;Controller.java&quot;, map);    &#125;    /**     * 获取所有的Java类型，使用Set去重     */    private static Set&lt;String&gt; getJavaTypes(List&lt;Field&gt; fieldList) &#123;        Set&lt;String&gt; set = new HashSet&lt;&gt;();        for (int i = 0; i &lt; fieldList.size(); i++) &#123;            Field field = fieldList.get(i);            set.add(field.getJavaType());        &#125;        return set;    &#125;&#125;\n\n\n其次建立启动类ServerGenerator\n\npackage com.course.generator.server;import com.course.generator.util.FreemarkerUtil;import freemarker.template.TemplateException;import java.io.IOException;public class ServerGenerator &#123;    static String toPath = &quot;generator\\\\src\\\\main\\\\java\\\\com\\\\course\\\\generator\\\\test\\\\&quot;;    public static void main(String[] args) throws IOException, TemplateException &#123;        FreemarkerUtil.initConfig(&quot;test.ftl&quot;);        FreemarkerUtil.generator(toPath+&quot;Test.java&quot;);    &#125;&#125;\n\n1.生成器开发，增加生成service层的代码\n\n\n首先创建service.ftl，就是把chapterservice复制一份，把Chapter改成${Domain}，chapter改成${domain}\n\npackage com.course.server.service;import com.course.server.domain.$&#123;Domain&#125;;import com.course.server.domain.$&#123;Domain&#125;Example;import com.course.server.dto.$&#123;Domain&#125;Dto;import com.course.server.dto.PageDto;import com.course.server.mapper.$&#123;Domain&#125;Mapper;import com.course.server.util.CopyUtil;import com.course.server.util.UuidUtil;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import org.springframework.beans.BeanUtils;import org.springframework.stereotype.Service;import org.springframework.util.StringUtils;import javax.annotation.Resource;import java.util.ArrayList;import java.util.List;@Servicepublic class $&#123;Domain&#125;Service &#123;    @Resource    private $&#123;Domain&#125;Mapper $&#123;domain&#125;Mapper;    /**     * 列表查询     */    public void list(PageDto pageDto)&#123;        PageHelper.startPage(pageDto.getPage(),pageDto.getSize());        $&#123;Domain&#125;Example $&#123;domain&#125;Example = new $&#123;Domain&#125;Example();        List&lt;$&#123;Domain&#125;&gt; $&#123;domain&#125;List = $&#123;domain&#125;Mapper.selectByExample($&#123;domain&#125;Example);        PageInfo&lt;$&#123;Domain&#125;&gt; pageInfo =new PageInfo&lt;&gt;($&#123;domain&#125;List);        pageDto.setTotal(pageInfo.getTotal());        ArrayList&lt;$&#123;Domain&#125;Dto&gt; $&#123;domain&#125;DtoArrayList = new ArrayList&lt;$&#123;Domain&#125;Dto&gt;();        for (int i = 0, l=$&#123;domain&#125;List.size(); i &lt;l ; i++) &#123;            $&#123;Domain&#125; $&#123;domain&#125; = $&#123;domain&#125;List.get(i);            $&#123;Domain&#125;Dto $&#123;domain&#125;Dto = new $&#123;Domain&#125;Dto();            BeanUtils.copyProperties($&#123;domain&#125;,$&#123;domain&#125;Dto);            $&#123;domain&#125;DtoArrayList.add($&#123;domain&#125;Dto);        &#125;        pageDto.setList($&#123;domain&#125;DtoArrayList);    &#125;    /**     * 保存，id有值时更新，无值时新增     */    public void save($&#123;Domain&#125;Dto $&#123;domain&#125;Dto)&#123;        $&#123;Domain&#125; $&#123;domain&#125; = CopyUtil.copy($&#123;domain&#125;Dto, $&#123;Domain&#125;.class);        if(StringUtils.isEmpty($&#123;domain&#125;Dto.getId()))&#123;            this.insert($&#123;domain&#125;);        &#125;else&#123;            this.update($&#123;domain&#125;);        &#125;    &#125;    /**     * 插入     */    private void insert($&#123;Domain&#125; $&#123;domain&#125;)&#123;        $&#123;domain&#125;.setId(UuidUtil.getShortUuid());        $&#123;domain&#125;Mapper.insert($&#123;domain&#125;);    &#125;    /**     * 更新     */    private void update($&#123;Domain&#125; $&#123;domain&#125;)&#123;        $&#123;domain&#125;Mapper.updateByPrimaryKey($&#123;domain&#125;);    &#125;    /**     * 删除     */    public void delete(String id)&#123;        $&#123;domain&#125;Mapper.deleteByPrimaryKey(id);    &#125;&#125;\n\n\n其次修改ServerGenerator代码，添加代码变量Domain\n\npackage com.course.generator.server;import com.course.generator.util.FreemarkerUtil;import freemarker.template.TemplateException;import java.io.IOException;import java.util.HashMap;import java.util.Map;public class ServerGenerator &#123;    static String toServicePath = &quot;server\\\\src\\\\main\\\\java\\\\com\\\\course\\\\server\\\\service\\\\&quot;;    public static void main(String[] args) throws IOException, TemplateException &#123;        String Domain = &quot;Section&quot;;        String domain = &quot;section&quot;;        Map&lt;String,Object&gt; map =new HashMap&lt;&gt;();        map.put(&quot;Domain&quot;,Domain);        map.put(&quot;domain&quot;,domain);        FreemarkerUtil.initConfig(&quot;service.ftl&quot;);        FreemarkerUtil.generator(toServicePath+Domain+&quot;Service.java&quot;,map);    &#125;&#125;\n\n\n最后改FreemarkerUtil代码，添加参数Map&lt;String,Object&gt; map和修改temp.process(map, bw);\n\n生成controller层代码，跟生成service一样\n6-3 dto层代码生成1.生成器开发：解决controller模板中的中文业务名称和模块名称问题\n\nstatic String MODULE = &quot;business&quot;;static String toControllerPath = MODULE+&quot;\\\\src\\\\main\\\\java\\\\com\\\\course\\\\&quot;+MODULE+&quot;\\\\controller\\\\admin\\\\&quot;;String tableNameCn = &quot;小节&quot;;String module = MODULE;map.put(&quot;tableNameCn&quot;,tableNameCn);map.put(&quot;module&quot;,module);\n\n\n就是添加了两个变量，再将模板ftl中的值换成变量的值\n\ndto层代码的生成：\n\ndto层的生成，需要知道表的所有字段，每个字段的类型需要映射成java类型，并且要把字段的变成小驼峰和大驼峰，比如course_id变成CourseId\n\nField类，用于存储每个字段的信息。流程：根据表名获取所有的字段信息，再将字段信息填充到Field类中，得到Field列表,之后将Field列表变量传入模板\n\n\npackage com.course.generator.util;public class Field &#123;    private String name; // 字段名：course_id    private String nameHump; // 字段名小驼峰：courseId    private String nameBigHump; // 字段名大驼峰：CourseId    private String nameCn; // 中文名：课程    private String type; // 字段类型：char(8)    private String javaType; // java类型：String    private String comment; // 注释：课程|ID    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getNameHump() &#123;        return nameHump;    &#125;    public void setNameHump(String nameHump) &#123;        this.nameHump = nameHump;    &#125;    public String getNameBigHump() &#123;        return nameBigHump;    &#125;    public void setNameBigHump(String nameBigHump) &#123;        this.nameBigHump = nameBigHump;    &#125;    public String getNameCn() &#123;        return nameCn;    &#125;    public void setNameCn(String nameCn) &#123;        this.nameCn = nameCn;    &#125;    public String getType() &#123;        return type;    &#125;    public void setType(String type) &#123;        this.type = type;    &#125;    public String getComment() &#123;        return comment;    &#125;    public void setComment(String comment) &#123;        this.comment = comment;    &#125;    public String getJavaType() &#123;        return javaType;    &#125;    public void setJavaType(String javaType) &#123;        this.javaType = javaType;    &#125;    @Override    public String toString() &#123;        final StringBuffer sb = new StringBuffer(&quot;Field&#123;&quot;);        sb.append(&quot;name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, nameHump=&#x27;&quot;).append(nameHump).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, nameBigHump=&#x27;&quot;).append(nameBigHump).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, nameCn=&#x27;&quot;).append(nameCn).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, type=&#x27;&quot;).append(type).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, javaType=&#x27;&quot;).append(javaType).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, comment=&#x27;&quot;).append(comment).append(&#x27;\\&#x27;&#x27;);        sb.append(&#x27;&#125;&#x27;);        return sb.toString();    &#125;&#125;\n\n\ntypeSet作用：整理出所有用到的Java类型，生成import语一种类型只需import一次，所以用set去重\n\nJsonFormat注解：将后端日期类型格式化，再返回给前端\n\n增加DbUtil.java\n\n\npackage com.course.generator.util;import java.sql.*;import java.util.ArrayList;import java.util.List;import java.util.regex.Matcher;import java.util.regex.Pattern;public class DbUtil &#123;    public static Connection getConnection() &#123;        Connection conn = null;        try &#123;            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);            String url = &quot;jdbc:mysql://localhost:3306/courseimooc&quot;;            String user = &quot;courseimooc&quot;;            String pass = &quot;666666&quot;;            conn = DriverManager.getConnection(url, user, pass);        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125;        return conn;    &#125;    /**     * 获得表注释     * @param tableName     * @return     * @throws Exception     */    public static String getTableComment(String tableName) throws Exception &#123;        Connection conn = getConnection();        Statement stmt = conn.createStatement();        ResultSet rs = stmt.executeQuery(&quot;select table_comment from information_schema.tables Where table_name = &#x27;&quot; + tableName + &quot;&#x27;&quot;);        String tableNameCH = &quot;&quot;;        if (rs != null) &#123;            while(rs.next()) &#123;                tableNameCH = rs.getString(&quot;table_comment&quot;);                break;            &#125;        &#125;        rs.close();        stmt.close();        conn.close();        System.out.println(&quot;表名：&quot; + tableNameCH);        return tableNameCH;    &#125;    /**     * 获得所有列信息     * @param tableName     * @return     * @throws Exception     */    public static List&lt;Field&gt; getColumnByTableName(String tableName) throws Exception &#123;        List&lt;Field&gt; fieldList = new ArrayList&lt;&gt;();        Connection conn = getConnection();        Statement stmt = conn.createStatement();        ResultSet rs = stmt.executeQuery(&quot;show full columns from `&quot; + tableName + &quot;`&quot;);        if (rs != null) &#123;            while(rs.next()) &#123;                String columnName = rs.getString(&quot;Field&quot;);                String type = rs.getString(&quot;Type&quot;);                String comment = rs.getString(&quot;Comment&quot;);                String nullAble = rs.getString(&quot;Null&quot;); //YES NO                Field field = new Field();                field.setName(columnName);                field.setNameHump(lineToHump(columnName));                field.setNameBigHump(lineToBigHump(columnName));                field.setType(type);                field.setJavaType(DbUtil.sqlTypeToJavaType(rs.getString(&quot;Type&quot;)));                field.setComment(comment);                if (comment.contains(&quot;|&quot;)) &#123;                    field.setNameCn(comment.substring(0, comment.indexOf(&quot;|&quot;)));                &#125; else &#123;                    field.setNameCn(comment);                &#125;                fieldList.add(field);            &#125;        &#125;        rs.close();        stmt.close();        conn.close();        System.out.println(&quot;列信息：&quot; + fieldList);        return fieldList;    &#125;    /**     * 下划线转小驼峰     */    public static String lineToHump(String str)&#123;        Pattern linePattern = Pattern.compile(&quot;_(\\\\w)&quot;);        str = str.toLowerCase();        Matcher matcher = linePattern.matcher(str);        StringBuffer sb = new StringBuffer();        while(matcher.find())&#123;            matcher.appendReplacement(sb, matcher.group(1).toUpperCase());        &#125;        matcher.appendTail(sb);        return sb.toString();    &#125;    /**     * 下划线转大驼峰     */    public static String lineToBigHump(String str)&#123;        String s = lineToHump(str);        return s.substring(0, 1).toUpperCase() + s.substring(1);    &#125;    /**     * 数据库类型转为Java类型     */    public static String sqlTypeToJavaType(String sqlType) &#123;        if (sqlType.toUpperCase().contains(&quot;varchar&quot;.toUpperCase())                || sqlType.toUpperCase().contains(&quot;char&quot;.toUpperCase())                || sqlType.toUpperCase().contains(&quot;text&quot;.toUpperCase())) &#123;            return &quot;String&quot;;        &#125; else if (sqlType.toUpperCase().contains(&quot;datetime&quot;.toUpperCase())) &#123;            return &quot;Date&quot;;        &#125; else if (sqlType.toUpperCase().contains(&quot;int&quot;.toUpperCase())) &#123;            return &quot;Integer&quot;;        &#125; else if (sqlType.toUpperCase().contains(&quot;long&quot;.toUpperCase())) &#123;            return &quot;Long&quot;;        &#125; else if (sqlType.toUpperCase().contains(&quot;decimal&quot;.toUpperCase())) &#123;            return &quot;BigDecimal&quot;;        &#125; else &#123;            return &quot;String&quot;;        &#125;    &#125;&#125;\n\n\n记得导入数据库连接的依赖，然后使用在启动类\n\nList&lt;Field&gt; fieldList = null;try &#123;    fieldList = DbUtil.getColumnByTableName(domain);&#125; catch (Exception e) &#123;    e.printStackTrace();&#125;Set&lt;String&gt; typeSet = getJavaTypes(fieldList);map.put(&quot;fieldList&quot;,fieldList);map.put(&quot;typeSet&quot;,typeSet);//生成dtoFreemarkerUtil.initConfig(&quot;dto.ftl&quot;);FreemarkerUtil.generator(toDtoPath+Domain+&quot;Dto.java&quot;,map);    private static Set&lt;String&gt; getJavaTypes(List&lt;Field&gt; fieldList) &#123;        Set&lt;String&gt; set = new HashSet&lt;&gt;();        for (int i = 0; i &lt; fieldList.size(); i++) &#123;            Field field = fieldList.get(i);            set.add(field.getJavaType());        &#125;        return set;    &#125;  \n\n通用代码生成器和mybatis generator整合：\n\n首先增加依赖（根目录和generator）\n\n&lt;!-- 读xml --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.dom4j&lt;/groupId&gt;   &lt;artifactId&gt;dom4j&lt;/artifactId&gt;   &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;\n\n\n在启动类增加代码\n\nstatic String generatorConfigPath = &quot;server\\\\src\\\\main\\\\resources\\\\generator\\\\generatorConfig.xml&quot;;    // 只生成配置文件中的第一个table节点    File file = new File(generatorConfigPath);    SAXReader reader=new SAXReader();    //读取xml文件到Document中    Document doc= null;    try &#123;        doc = reader.read(file);    &#125; catch (DocumentException e) &#123;        e.printStackTrace();    &#125;    //获取xml文件的根节点    Element rootElement=doc.getRootElement();    //读取context节点    Element contextElement = rootElement.element(&quot;context&quot;);    //定义一个Element用于遍历    Element tableElement;    //取第一个“table”的节点    tableElement=contextElement.elementIterator(&quot;table&quot;).next();    String Domain = tableElement.attributeValue(&quot;domainObjectName&quot;);    String tableName = tableElement.attributeValue(&quot;tableName&quot;);    String tableNameCn = null;    try &#123;        tableNameCn = DbUtil.getTableComment(tableName);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;    String domain = Domain.substring(0, 1).toLowerCase() + Domain.substring(1);    System.out.println(&quot;表：&quot;+tableElement.attributeValue(&quot;tableName&quot;));    System.out.println(&quot;Domain：&quot;+tableElement.attributeValue(&quot;domainObjectName&quot;));    List&lt;Field&gt; fieldList  = null;    try &#123;        fieldList = DbUtil.getColumnByTableName(tableName);    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125;    Set&lt;String&gt; typeSet = getJavaTypes(fieldList);\n\n6-4 前端vue界面代码生成vue cli多环境处理：自定义多环境变量必须以VUE_APP开头；NODE_ENV用来表示生产的环境\n\n在admin下增加两个文件分别是.env.dev和.env.prod\n\nNODE_ENV=developmentVUE_APP_SERVER=http://192.168.0.105:9000////////////////////////////////////////////NODE_ENV=developmentVUE_APP_SERVER=http://server.imooc.com\n\n\n最后将地址改为变量VUE_APP_SERVER\n\n新建VueGenerator用于生成vue页面代码\n1.生成器开发：增加生成vue界面代码。2.小节管理增删改查功能测试成功\n\n\n新建vue.ftl，代码从chapter.vue复制过来。注意：这里的粘贴应该右键-选择不带格式化的粘贴。一样改变量\n\n&lt;template&gt;  &lt;div&gt;    &lt;p&gt;      &lt;button v-on:click=&quot;add()&quot; class=&quot;btn btn-white btn-default btn-round&quot;&gt;        &lt;i class=&quot;ace-icon fa fa-edit red2&quot;&gt;&lt;/i&gt;        新增      &lt;/button&gt;    &amp;nbsp;      &lt;button v-on:click=&quot;list()&quot; class=&quot;btn btn-white btn-default btn-round&quot;&gt;        &lt;i class=&quot;ace-icon fa fa-refresh red2&quot;&gt;&lt;/i&gt;        刷新      &lt;/button&gt;    &lt;/p&gt;    &lt;pagination ref=&quot;pagination&quot; v-bind:list=&quot;list&quot; v-bind:itemCount=&quot;8&quot;&gt;&lt;/pagination&gt;      &lt;table id=&quot;simple-table&quot; class=&quot;table  table-bordered table-hover&quot;&gt;        &lt;thead&gt;        &lt;tr&gt;&lt;#list fieldList as field&gt;            &lt;th&gt;$&#123;field.nameCn&#125;&lt;/th&gt;&lt;/#list&gt;            &lt;th&gt;操作&lt;/th&gt;        &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;        &lt;tr v-for=&quot;$&#123;domain&#125; in $&#123;domain&#125;s&quot;&gt;          &lt;#list fieldList as field&gt;            &lt;td&gt;&#123;&#123;$&#123;domain&#125;.$&#123;field.nameHump&#125;&#125;&#125;&lt;/td&gt;          &lt;/#list&gt;          &lt;td&gt;            &lt;div class=&quot;hidden-sm hidden-xs btn-group&quot;&gt;              &lt;button v-on:click=&quot;edit($&#123;domain&#125;)&quot; class=&quot;btn btn-xs btn-info&quot;&gt;                &lt;i class=&quot;ace-icon fa fa-pencil bigger-120&quot;&gt;&lt;/i&gt;              &lt;/button&gt;              &lt;button v-on:click=&quot;del($&#123;domain&#125;.id)&quot; class=&quot;btn btn-xs btn-danger&quot;&gt;                &lt;i class=&quot;ace-icon fa fa-trash-o bigger-120&quot;&gt;&lt;/i&gt;              &lt;/button&gt;            &lt;/div&gt;            &lt;div class=&quot;hidden-md hidden-lg&quot;&gt;              &lt;div class=&quot;inline pos-rel&quot;&gt;                &lt;button class=&quot;btn btn-minier btn-primary dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; data-position=&quot;auto&quot;&gt;                  &lt;i class=&quot;ace-icon fa fa-cog icon-only bigger-110&quot;&gt;&lt;/i&gt;                &lt;/button&gt;                &lt;ul class=&quot;dropdown-menu dropdown-only-icon dropdown-yellow dropdown-menu-right dropdown-caret dropdown-close&quot;&gt;                  &lt;li&gt;                    &lt;a href=&quot;#&quot; class=&quot;tooltip-info&quot; data-rel=&quot;tooltip&quot; title=&quot;View&quot;&gt;                                                         &lt;span class=&quot;blue&quot;&gt;                                                            &lt;i class=&quot;ace-icon fa fa-search-plus bigger-120&quot;&gt;&lt;/i&gt;                                                         &lt;/span&gt;                    &lt;/a&gt;                  &lt;/li&gt;                  &lt;li&gt;                    &lt;a href=&quot;#&quot; class=&quot;tooltip-success&quot; data-rel=&quot;tooltip&quot; title=&quot;Edit&quot;&gt;                                                         &lt;span class=&quot;green&quot;&gt;                                                            &lt;i class=&quot;ace-icon fa fa-pencil-square-o bigger-120&quot;&gt;&lt;/i&gt;                                                         &lt;/span&gt;                    &lt;/a&gt;                  &lt;/li&gt;                  &lt;li&gt;                    &lt;a href=&quot;#&quot; class=&quot;tooltip-error&quot; data-rel=&quot;tooltip&quot; title=&quot;Delete&quot;&gt;                                                         &lt;span class=&quot;red&quot;&gt;                                                            &lt;i class=&quot;ace-icon fa fa-trash-o bigger-120&quot;&gt;&lt;/i&gt;                                                         &lt;/span&gt;                    &lt;/a&gt;                  &lt;/li&gt;                &lt;/ul&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/td&gt;        &lt;/tr&gt;        &lt;/tbody&gt;      &lt;/table&gt;    &lt;div id=&quot;form-modal&quot; class=&quot;modal fade&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot;&gt;      &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;        &lt;div class=&quot;modal-content&quot;&gt;          &lt;div class=&quot;modal-header&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;            &lt;h4 class=&quot;modal-title&quot;&gt;表单&lt;/h4&gt;          &lt;/div&gt;          &lt;div class=&quot;modal-body&quot;&gt;            &lt;form class=&quot;form-horizontal&quot;&gt;              &lt;#list fieldList as field&gt;                &lt;div class=&quot;form-group&quot;&gt;                  &lt;label  class=&quot;col-sm-2 control-label&quot;&gt;$&#123;field.nameCn&#125;&lt;/label&gt;                  &lt;div class=&quot;col-sm-10&quot;&gt;                    &lt;input v-model=&quot;$&#123;domain&#125;.$&#123;field.nameHump&#125;&quot; class=&quot;form-control&quot;  &gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/#list&gt;            &lt;/form&gt;          &lt;/div&gt;          &lt;div class=&quot;modal-footer&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;取消&lt;/button&gt;            &lt;button v-on:click=&quot;save()&quot; type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;保存&lt;/button&gt;          &lt;/div&gt;        &lt;/div&gt;&lt;!-- /.modal-content --&gt;      &lt;/div&gt;&lt;!-- /.modal-dialog --&gt;    &lt;/div&gt;&lt;!-- /.modal --&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Pagination from &quot;../../components/pagination&quot;;export default &#123;  components: &#123;Pagination&#125;,  name: &#x27;$&#123;domain&#125;&#x27;,  data: function () &#123;    return &#123;      $&#123;domain&#125;: &#123;&#125;,      $&#123;domain&#125;s: []    &#125;  &#125;,  mounted: function () &#123;    let _this = this;    _this.$refs.pagination.size = 5;    _this.list(1);  &#125;,  methods: &#123;    add() &#123;      let _this = this;      _this.$&#123;domain&#125; = &#123;&#125;;      $(&quot;#form-modal&quot;).modal(&quot;show&quot;);    &#125;,    edit($&#123;domain&#125;) &#123;      let _this = this;      _this.$&#123;domain&#125; = $.extend(&#123;&#125;, $&#123;domain&#125;);      $(&quot;#form-modal&quot;).modal(&quot;show&quot;);    &#125;,    /**     * 列表查询     */    list(page) &#123;      let _this = this;      Loading.show();      _this.$ajax.post(process.env.VUE_APP_SERVER +&#x27;/$&#123;module&#125;/admin/$&#123;domain&#125;/list&#x27;, &#123;        page: page,        size: _this.$refs.pagination.size,      &#125;).then((respond) =&gt; &#123;        Loading.hide();        let resp = respond.data;        _this.$&#123;domain&#125;s = resp.content.list;        _this.$refs.pagination.render(page, resp.content.total);      &#125;)    &#125;,    /**     * 点击保存     */    save(page) &#123;      let _this = this;      // 保存校验      Loading.show();      _this.$ajax.post(process.env.VUE_APP_SERVER +&#x27;/$&#123;module&#125;/admin/$&#123;domain&#125;/save&#x27;, _this.$&#123;domain&#125;).then((respond) =&gt; &#123;        Loading.hide();        let resp = respond.data;        if (resp.success) &#123;          $(&quot;#form-modal&quot;).modal(&quot;hide&quot;);          _this.list(1);          Toast.success(&quot;保存成功&quot;);        &#125;else&#123;          Toast.warning(resp.message);        &#125;      &#125;)    &#125;,    /**     * 点击删除     */    del(id) &#123;      let _this = this;      Confirm.show(&quot;删除$&#123;tableNameCn&#125;后不可恢复!&quot;,function ()&#123;        Loading.show();        _this.$ajax.delete(process.env.VUE_APP_SERVER +&#x27;/$&#123;module&#125;/admin/$&#123;domain&#125;/delete/&#x27; + id).then((respond) =&gt; &#123;          Loading.hide();          let resp = respond.data;          if (resp.success) &#123;            _this.list(1);            Toast.success(&quot;删除成功&quot;);          &#125;        &#125;)      &#125;);    &#125;  &#125;&#125;&lt;/script&gt;\n\n\n其次创建VueGenerator启动类\n\npackage com.course.generator.vue;import com.course.generator.util.DbUtil;import com.course.generator.util.Field;import com.course.generator.util.FreemarkerUtil;import freemarker.template.TemplateException;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.io.File;import java.io.IOException;import java.util.*;public class VueGenerator &#123;    static String MODULE = &quot;business&quot;;    static String toVuePath = &quot;admin\\\\src\\\\views\\\\admin\\\\&quot;;    static String generatorConfigPath = &quot;server\\\\src\\\\main\\\\resources\\\\generator\\\\generatorConfig.xml&quot;;    public static void main(String[] args) throws IOException, TemplateException &#123;        String module = MODULE;        // 只生成配置文件中的第一个table节点        File file = new File(generatorConfigPath);        SAXReader reader=new SAXReader();        //读取xml文件到Document中        Document doc= null;        try &#123;            doc = reader.read(file);        &#125; catch (DocumentException e) &#123;            e.printStackTrace();        &#125;        //获取xml文件的根节点        Element rootElement=doc.getRootElement();        //读取context节点        Element contextElement = rootElement.element(&quot;context&quot;);        //定义一个Element用于遍历        Element tableElement;        //取第一个“table”的节点        tableElement=contextElement.elementIterator(&quot;table&quot;).next();        String Domain = tableElement.attributeValue(&quot;domainObjectName&quot;);        String tableName = tableElement.attributeValue(&quot;tableName&quot;);        String tableNameCn = null;        try &#123;            tableNameCn = DbUtil.getTableComment(tableName);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        String domain = Domain.substring(0, 1).toLowerCase() + Domain.substring(1);        System.out.println(&quot;表：&quot;+tableElement.attributeValue(&quot;tableName&quot;));        System.out.println(&quot;Domain：&quot;+tableElement.attributeValue(&quot;domainObjectName&quot;));        List&lt;Field&gt; fieldList  = null;        try &#123;            fieldList = DbUtil.getColumnByTableName(tableName);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        Set&lt;String&gt; typeSet = getJavaTypes(fieldList);        Map&lt;String,Object&gt; map =new HashMap&lt;&gt;();        map.put(&quot;Domain&quot;,Domain);        map.put(&quot;domain&quot;,domain);        map.put(&quot;tableNameCn&quot;,tableNameCn);        map.put(&quot;module&quot;,module);        map.put(&quot;fieldList&quot;,fieldList);        map.put(&quot;typeSet&quot;,typeSet);        //生成dto        FreemarkerUtil.initConfig(&quot;vue.ftl&quot;);        FreemarkerUtil.generator(toVuePath+domain+&quot;.vue&quot;,map);       &#125;    /**     * 获取所有的Java类型，使用Set去重     */    private static Set&lt;String&gt; getJavaTypes(List&lt;Field&gt; fieldList) &#123;        Set&lt;String&gt; set = new HashSet&lt;&gt;();        for (int i = 0; i &lt; fieldList.size(); i++) &#123;            Field field = fieldList.get(i);            set.add(field.getJavaType());        &#125;        return set;    &#125;&#125;\n\n\n然后在admin.vue增加\n\n&lt;li class=&quot;active&quot; id=&quot;business-section-sidebar&quot;&gt;  &lt;router-link to=&quot;/business/section&quot;&gt;    &lt;i class=&quot;menu-icon fa fa-caret-right&quot;&gt;&lt;/i&gt;    小节管理  &lt;/router-link&gt;  &lt;b class=&quot;arrow&quot;&gt;&lt;/b&gt;&lt;/li&gt;\n\n\n添加路由\n\n,&#123;    path: &quot;business/section&quot;,    name:&quot;business/section&quot;,    component: Section,&#125;\n\n6-5 字段校验和通用字段的处理前后端模板增加字段校验\n1.生成器开发，前后端模板增加字段校验\n\n\n在Field添加两个变量\n\nprivate Boolean nullAble;//是否可为空private Integer length;//字符串长度/////////////////////////////////public Boolean getNullAble() &#123;    return nullAble;&#125;public void setNullAble(Boolean nullAble) &#123;    this.nullAble = nullAble;&#125;public Integer getLength() &#123;    return length;&#125;public void setLength(Integer length) &#123;    this.length = length;&#125;////////////////////////////////////////////////////sb.append(&quot;, nullAble=&quot;).append(nullAble);sb.append(&quot;, length=&quot;).append(length);\n\n\n其次在DbUtil中增加：\n\n约定：当length&gt;0时，表示需要对lenth做校验，当length&#x3D;0时，表示不需要校验\n\n疑问：char类型为什么不需要效验长度？\n\n解答：char类型一般用于固定长度的字段，常见的有id字段和枚举字段，id字段不需要校验，枚举字段界面一般会有下拉框，不是手输的，不需要校验。\n\n\nString nullAble = rs.getString(&quot;Null&quot;); //YES NOfield.setNullAble(&quot;YES&quot;.equals(nullAble));if(type.toUpperCase().contains(&quot;varchar&quot;.toUpperCase()))&#123;    String lengthStr = type.substring(type.indexOf(&quot;(&quot;)+1,type.length()-1);    field.setLength(Integer.valueOf(lengthStr));&#125;else&#123;    field.setLength(0);&#125;\n\n\n增加controller.ftl的保存校验\n\n&lt;#list fieldList as field&gt;&lt;#if !field.nullAble&gt;    ValidatorUtil.require($&#123;domain&#125;Dto.get$&#123;field.nameBigHump&#125;(), &quot;$&#123;field.nameCn&#125;&quot;);&lt;/#if&gt;&lt;#if (field.length &gt; 0)&gt;    ValidatorUtil.length($&#123;domain&#125;Dto.get$&#123;field.nameBigHump&#125;(), &quot;$&#123;field.nameCn&#125;&quot;, 1, $&#123;field.length&#125;);&lt;/#if&gt;&lt;/#list&gt;\n\n\n增加前端vue.ftl校验\n\n// 保存校验if (1 != 1 //是为了第一个请求或者长度没有||&lt;#list fieldList as field&gt;&lt;#if !field.nullAble&gt;|| !Validator.require(_this.$&#123;domain&#125;.$&#123;field.nameHump&#125;, &quot;$&#123;field.nameCn&#125;&quot;)&lt;/#if&gt;&lt;#if (field.length &gt; 0)&gt;|| !Validator.length(_this.$&#123;domain&#125;.$&#123;field.nameHump&#125;, &quot;$&#123;field.nameCn&#125;&quot;, 1, $&#123;field.length&#125;)&lt;/#if&gt;&lt;/#list&gt;) &#123;  return;&#125;\n\n\n对ValidatorUtil的js和后端的java分别增加\n\nif(Tool.isEmpty(value))&#123;    return true;&#125;//////////////////////////////////if(StringUtils.isEmpty(str))&#123;            return;        &#125;\n\n  cdn.bootcss.com偶尔会出现404，导致jquery.blockUI.min.js没下载下来。原因可能是cdn不稳定，也可能是本地网络不稳定.将jquery.blockUI.min.js复制到本地，不使用cdn\n/** jQuery BlockUI; v20141123* http://jquery.malsup.com/block/* Copyright (c) 2014 M. Alsup; Dual licensed: MIT/GPL*/(function()&#123;&quot;use strict&quot;;function e(e)&#123;function o(o,i)&#123;var s,h,k=o==window,v=i&amp;&amp;void 0!==i.message?i.message:void 0;if(i=e.extend(&#123;&#125;,e.blockUI.defaults,i||&#123;&#125;),!i.ignoreIfBlocked||!e(o).data(&quot;blockUI.isBlocked&quot;))&#123;if(i.overlayCSS=e.extend(&#123;&#125;,e.blockUI.defaults.overlayCSS,i.overlayCSS||&#123;&#125;),s=e.extend(&#123;&#125;,e.blockUI.defaults.css,i.css||&#123;&#125;),i.onOverlayClick&amp;&amp;(i.overlayCSS.cursor=&quot;pointer&quot;),h=e.extend(&#123;&#125;,e.blockUI.defaults.themedCSS,i.themedCSS||&#123;&#125;),v=void 0===v?i.message:v,k&amp;&amp;b&amp;&amp;t(window,&#123;fadeOut:0&#125;),v&amp;&amp;&quot;string&quot;!=typeof v&amp;&amp;(v.parentNode||v.jquery))&#123;var y=v.jquery?v[0]:v,m=&#123;&#125;;e(o).data(&quot;blockUI.history&quot;,m),m.el=y,m.parent=y.parentNode,m.display=y.style.display,m.position=y.style.position,m.parent&amp;&amp;m.parent.removeChild(y)&#125;e(o).data(&quot;blockUI.onUnblock&quot;,i.onUnblock);var g,I,w,U,x=i.baseZ;g=r||i.forceIframe?e(&#x27;&lt;iframe class=&quot;blockUI&quot; style=&quot;z-index:&#x27;+x++ +&#x27;;display:none;border:none;margin:0;padding:0;position:absolute;width:100%;height:100%;top:0;left:0&quot; src=&quot;&#x27;+i.iframeSrc+&#x27;&quot;&gt;&lt;/iframe&gt;&#x27;):e(&#x27;&lt;div class=&quot;blockUI&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt;&#x27;),I=i.theme?e(&#x27;&lt;div class=&quot;blockUI blockOverlay ui-widget-overlay&quot; style=&quot;z-index:&#x27;+x++ +&#x27;;display:none&quot;&gt;&lt;/div&gt;&#x27;):e(&#x27;&lt;div class=&quot;blockUI blockOverlay&quot; style=&quot;z-index:&#x27;+x++ +&#x27;;display:none;border:none;margin:0;padding:0;width:100%;height:100%;top:0;left:0&quot;&gt;&lt;/div&gt;&#x27;),i.theme&amp;&amp;k?(U=&#x27;&lt;div class=&quot;blockUI &#x27;+i.blockMsgClass+&#x27; blockPage ui-dialog ui-widget ui-corner-all&quot; style=&quot;z-index:&#x27;+(x+10)+&#x27;;display:none;position:fixed&quot;&gt;&#x27;,i.title&amp;&amp;(U+=&#x27;&lt;div class=&quot;ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle&quot;&gt;&#x27;+(i.title||&quot;&amp;nbsp;&quot;)+&quot;&lt;/div&gt;&quot;),U+=&#x27;&lt;div class=&quot;ui-widget-content ui-dialog-content&quot;&gt;&lt;/div&gt;&#x27;,U+=&quot;&lt;/div&gt;&quot;):i.theme?(U=&#x27;&lt;div class=&quot;blockUI &#x27;+i.blockMsgClass+&#x27; blockElement ui-dialog ui-widget ui-corner-all&quot; style=&quot;z-index:&#x27;+(x+10)+&#x27;;display:none;position:absolute&quot;&gt;&#x27;,i.title&amp;&amp;(U+=&#x27;&lt;div class=&quot;ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle&quot;&gt;&#x27;+(i.title||&quot;&amp;nbsp;&quot;)+&quot;&lt;/div&gt;&quot;),U+=&#x27;&lt;div class=&quot;ui-widget-content ui-dialog-content&quot;&gt;&lt;/div&gt;&#x27;,U+=&quot;&lt;/div&gt;&quot;):U=k?&#x27;&lt;div class=&quot;blockUI &#x27;+i.blockMsgClass+&#x27; blockPage&quot; style=&quot;z-index:&#x27;+(x+10)+&#x27;;display:none;position:fixed&quot;&gt;&lt;/div&gt;&#x27;:&#x27;&lt;div class=&quot;blockUI &#x27;+i.blockMsgClass+&#x27; blockElement&quot; style=&quot;z-index:&#x27;+(x+10)+&#x27;;display:none;position:absolute&quot;&gt;&lt;/div&gt;&#x27;,w=e(U),v&amp;&amp;(i.theme?(w.css(h),w.addClass(&quot;ui-widget-content&quot;)):w.css(s)),i.theme||I.css(i.overlayCSS),I.css(&quot;position&quot;,k?&quot;fixed&quot;:&quot;absolute&quot;),(r||i.forceIframe)&amp;&amp;g.css(&quot;opacity&quot;,0);var C=[g,I,w],S=k?e(&quot;body&quot;):e(o);e.each(C,function()&#123;this.appendTo(S)&#125;),i.theme&amp;&amp;i.draggable&amp;&amp;e.fn.draggable&amp;&amp;w.draggable(&#123;handle:&quot;.ui-dialog-titlebar&quot;,cancel:&quot;li&quot;&#125;);var O=f&amp;&amp;(!e.support.boxModel||e(&quot;object,embed&quot;,k?null:o).length&gt;0);if(u||O)&#123;if(k&amp;&amp;i.allowBodyStretch&amp;&amp;e.support.boxModel&amp;&amp;e(&quot;html,body&quot;).css(&quot;height&quot;,&quot;100%&quot;),(u||!e.support.boxModel)&amp;&amp;!k)var E=d(o,&quot;borderTopWidth&quot;),T=d(o,&quot;borderLeftWidth&quot;),M=E?&quot;(0 - &quot;+E+&quot;)&quot;:0,B=T?&quot;(0 - &quot;+T+&quot;)&quot;:0;e.each(C,function(e,o)&#123;var t=o[0].style;if(t.position=&quot;absolute&quot;,2&gt;e)k?t.setExpression(&quot;height&quot;,&quot;Math.max(document.body.scrollHeight, document.body.offsetHeight) - (jQuery.support.boxModel?0:&quot;+i.quirksmodeOffsetHack+&#x27;) + &quot;px&quot;&#x27;):t.setExpression(&quot;height&quot;,&#x27;this.parentNode.offsetHeight + &quot;px&quot;&#x27;),k?t.setExpression(&quot;width&quot;,&#x27;jQuery.support.boxModel &amp;&amp; document.documentElement.clientWidth || document.body.clientWidth + &quot;px&quot;&#x27;):t.setExpression(&quot;width&quot;,&#x27;this.parentNode.offsetWidth + &quot;px&quot;&#x27;),B&amp;&amp;t.setExpression(&quot;left&quot;,B),M&amp;&amp;t.setExpression(&quot;top&quot;,M);else if(i.centerY)k&amp;&amp;t.setExpression(&quot;top&quot;,&#x27;(document.documentElement.clientHeight || document.body.clientHeight) / 2 - (this.offsetHeight / 2) + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + &quot;px&quot;&#x27;),t.marginTop=0;else if(!i.centerY&amp;&amp;k)&#123;var n=i.css&amp;&amp;i.css.top?parseInt(i.css.top,10):0,s=&quot;((document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + &quot;+n+&#x27;) + &quot;px&quot;&#x27;;t.setExpression(&quot;top&quot;,s)&#125;&#125;)&#125;if(v&amp;&amp;(i.theme?w.find(&quot;.ui-widget-content&quot;).append(v):w.append(v),(v.jquery||v.nodeType)&amp;&amp;e(v).show()),(r||i.forceIframe)&amp;&amp;i.showOverlay&amp;&amp;g.show(),i.fadeIn)&#123;var j=i.onBlock?i.onBlock:c,H=i.showOverlay&amp;&amp;!v?j:c,z=v?j:c;i.showOverlay&amp;&amp;I._fadeIn(i.fadeIn,H),v&amp;&amp;w._fadeIn(i.fadeIn,z)&#125;else i.showOverlay&amp;&amp;I.show(),v&amp;&amp;w.show(),i.onBlock&amp;&amp;i.onBlock.bind(w)();if(n(1,o,i),k?(b=w[0],p=e(i.focusableElements,b),i.focusInput&amp;&amp;setTimeout(l,20)):a(w[0],i.centerX,i.centerY),i.timeout)&#123;var W=setTimeout(function()&#123;k?e.unblockUI(i):e(o).unblock(i)&#125;,i.timeout);e(o).data(&quot;blockUI.timeout&quot;,W)&#125;&#125;&#125;function t(o,t)&#123;var s,l=o==window,a=e(o),d=a.data(&quot;blockUI.history&quot;),c=a.data(&quot;blockUI.timeout&quot;);c&amp;&amp;(clearTimeout(c),a.removeData(&quot;blockUI.timeout&quot;)),t=e.extend(&#123;&#125;,e.blockUI.defaults,t||&#123;&#125;),n(0,o,t),null===t.onUnblock&amp;&amp;(t.onUnblock=a.data(&quot;blockUI.onUnblock&quot;),a.removeData(&quot;blockUI.onUnblock&quot;));var r;r=l?e(&quot;body&quot;).children().filter(&quot;.blockUI&quot;).add(&quot;body &gt; .blockUI&quot;):a.find(&quot;&gt;.blockUI&quot;),t.cursorReset&amp;&amp;(r.length&gt;1&amp;&amp;(r[1].style.cursor=t.cursorReset),r.length&gt;2&amp;&amp;(r[2].style.cursor=t.cursorReset)),l&amp;&amp;(b=p=null),t.fadeOut?(s=r.length,r.stop().fadeOut(t.fadeOut,function()&#123;0===--s&amp;&amp;i(r,d,t,o)&#125;)):i(r,d,t,o)&#125;function i(o,t,i,n)&#123;var s=e(n);if(!s.data(&quot;blockUI.isBlocked&quot;))&#123;o.each(function()&#123;this.parentNode&amp;&amp;this.parentNode.removeChild(this)&#125;),t&amp;&amp;t.el&amp;&amp;(t.el.style.display=t.display,t.el.style.position=t.position,t.el.style.cursor=&quot;default&quot;,t.parent&amp;&amp;t.parent.appendChild(t.el),s.removeData(&quot;blockUI.history&quot;)),s.data(&quot;blockUI.static&quot;)&amp;&amp;s.css(&quot;position&quot;,&quot;static&quot;),&quot;function&quot;==typeof i.onUnblock&amp;&amp;i.onUnblock(n,i);var l=e(document.body),a=l.width(),d=l[0].style.width;l.width(a-1).width(a),l[0].style.width=d&#125;&#125;function n(o,t,i)&#123;var n=t==window,l=e(t);if((o||(!n||b)&amp;&amp;(n||l.data(&quot;blockUI.isBlocked&quot;)))&amp;&amp;(l.data(&quot;blockUI.isBlocked&quot;,o),n&amp;&amp;i.bindEvents&amp;&amp;(!o||i.showOverlay)))&#123;var a=&quot;mousedown mouseup keydown keypress keyup touchstart touchend touchmove&quot;;o?e(document).bind(a,i,s):e(document).unbind(a,s)&#125;&#125;function s(o)&#123;if(&quot;keydown&quot;===o.type&amp;&amp;o.keyCode&amp;&amp;9==o.keyCode&amp;&amp;b&amp;&amp;o.data.constrainTabKey)&#123;var t=p,i=!o.shiftKey&amp;&amp;o.target===t[t.length-1],n=o.shiftKey&amp;&amp;o.target===t[0];if(i||n)return setTimeout(function()&#123;l(n)&#125;,10),!1&#125;var s=o.data,a=e(o.target);return a.hasClass(&quot;blockOverlay&quot;)&amp;&amp;s.onOverlayClick&amp;&amp;s.onOverlayClick(o),a.parents(&quot;div.&quot;+s.blockMsgClass).length&gt;0?!0:0===a.parents().children().filter(&quot;div.blockUI&quot;).length&#125;function l(e)&#123;if(p)&#123;var o=p[e===!0?p.length-1:0];o&amp;&amp;o.focus()&#125;&#125;function a(e,o,t)&#123;var i=e.parentNode,n=e.style,s=(i.offsetWidth-e.offsetWidth)/2-d(i,&quot;borderLeftWidth&quot;),l=(i.offsetHeight-e.offsetHeight)/2-d(i,&quot;borderTopWidth&quot;);o&amp;&amp;(n.left=s&gt;0?s+&quot;px&quot;:&quot;0&quot;),t&amp;&amp;(n.top=l&gt;0?l+&quot;px&quot;:&quot;0&quot;)&#125;function d(o,t)&#123;return parseInt(e.css(o,t),10)||0&#125;e.fn._fadeIn=e.fn.fadeIn;var c=e.noop||function()&#123;&#125;,r=/MSIE/.test(navigator.userAgent),u=/MSIE 6.0/.test(navigator.userAgent)&amp;&amp;!/MSIE 8.0/.test(navigator.userAgent);document.documentMode||0;var f=e.isFunction(document.createElement(&quot;div&quot;).style.setExpression);e.blockUI=function(e)&#123;o(window,e)&#125;,e.unblockUI=function(e)&#123;t(window,e)&#125;,e.growlUI=function(o,t,i,n)&#123;var s=e(&#x27;&lt;div class=&quot;growlUI&quot;&gt;&lt;/div&gt;&#x27;);o&amp;&amp;s.append(&quot;&lt;h1&gt;&quot;+o+&quot;&lt;/h1&gt;&quot;),t&amp;&amp;s.append(&quot;&lt;h2&gt;&quot;+t+&quot;&lt;/h2&gt;&quot;),void 0===i&amp;&amp;(i=3e3);var l=function(o)&#123;o=o||&#123;&#125;,e.blockUI(&#123;message:s,fadeIn:o.fadeIn!==void 0?o.fadeIn:700,fadeOut:o.fadeOut!==void 0?o.fadeOut:1e3,timeout:o.timeout!==void 0?o.timeout:i,centerY:!1,showOverlay:!1,onUnblock:n,css:e.blockUI.defaults.growlCSS&#125;)&#125;;l(),s.css(&quot;opacity&quot;),s.mouseover(function()&#123;l(&#123;fadeIn:0,timeout:3e4&#125;);var o=e(&quot;.blockMsg&quot;);o.stop(),o.fadeTo(300,1)&#125;).mouseout(function()&#123;e(&quot;.blockMsg&quot;).fadeOut(1e3)&#125;)&#125;,e.fn.block=function(t)&#123;if(this[0]===window)return e.blockUI(t),this;var i=e.extend(&#123;&#125;,e.blockUI.defaults,t||&#123;&#125;);return this.each(function()&#123;var o=e(this);i.ignoreIfBlocked&amp;&amp;o.data(&quot;blockUI.isBlocked&quot;)||o.unblock(&#123;fadeOut:0&#125;)&#125;),this.each(function()&#123;&quot;static&quot;==e.css(this,&quot;position&quot;)&amp;&amp;(this.style.position=&quot;relative&quot;,e(this).data(&quot;blockUI.static&quot;,!0)),this.style.zoom=1,o(this,t)&#125;)&#125;,e.fn.unblock=function(o)&#123;return this[0]===window?(e.unblockUI(o),this):this.each(function()&#123;t(this,o)&#125;)&#125;,e.blockUI.version=2.7,e.blockUI.defaults=&#123;message:&quot;&lt;h1&gt;Please wait...&lt;/h1&gt;&quot;,title:null,draggable:!0,theme:!1,css:&#123;padding:0,margin:0,width:&quot;30%&quot;,top:&quot;40%&quot;,left:&quot;35%&quot;,textAlign:&quot;center&quot;,color:&quot;#000&quot;,border:&quot;3px solid #aaa&quot;,backgroundColor:&quot;#fff&quot;,cursor:&quot;wait&quot;&#125;,themedCSS:&#123;width:&quot;30%&quot;,top:&quot;40%&quot;,left:&quot;35%&quot;&#125;,overlayCSS:&#123;backgroundColor:&quot;#000&quot;,opacity:.6,cursor:&quot;wait&quot;&#125;,cursorReset:&quot;default&quot;,growlCSS:&#123;width:&quot;350px&quot;,top:&quot;10px&quot;,left:&quot;&quot;,right:&quot;10px&quot;,border:&quot;none&quot;,padding:&quot;5px&quot;,opacity:.6,cursor:&quot;default&quot;,color:&quot;#fff&quot;,backgroundColor:&quot;#000&quot;,&quot;-webkit-border-radius&quot;:&quot;10px&quot;,&quot;-moz-border-radius&quot;:&quot;10px&quot;,&quot;border-radius&quot;:&quot;10px&quot;&#125;,iframeSrc:/^https/i.test(window.location.href||&quot;&quot;)?&quot;javascript:false&quot;:&quot;about:blank&quot;,forceIframe:!1,baseZ:1e3,centerX:!0,centerY:!0,allowBodyStretch:!0,bindEvents:!0,constrainTabKey:!0,fadeIn:200,fadeOut:400,timeout:0,showOverlay:!0,focusInput:!0,focusableElements:&quot;:input:enabled:visible&quot;,onBlock:null,onUnblock:null,onOverlayClick:null,quirksmodeOffsetHack:4,blockMsgClass:&quot;blockMsg&quot;,ignoreIfBlocked:!1&#125;;var b=null,p=[]&#125;&quot;function&quot;==typeof define&amp;&amp;define.amd&amp;&amp;define.amd.jQuery?define([&quot;jquery&quot;],e):e(jQuery)&#125;)();\n\n通用字段处理：1.生成器开发，通用字段处理，id，createdAt，updateAt，sort\n\n对controller.ftl保存校验做修改，并不是所有字段都需要做校验\n\n//保存校验&lt;#list fieldList as field&gt;&lt;#if field.name!=&quot;id&quot; &amp;&amp; field.nameHump!=&quot;createdAt&quot;&amp;&amp; field.nameHump!=&quot;updatedAt&quot; &amp;&amp; field.nameHump!=&quot;sort&quot;&gt;&lt;#if !field.nullAble&gt;    ValidatorUtil.require($&#123;domain&#125;Dto.get$&#123;field.nameBigHump&#125;(), &quot;$&#123;field.nameCn&#125;&quot;);&lt;/#if&gt;&lt;#if (field.length &gt; 0)&gt;    ValidatorUtil.length($&#123;domain&#125;Dto.get$&#123;field.nameBigHump&#125;(), &quot;$&#123;field.nameCn&#125;&quot;, 1, $&#123;field.length&#125;);&lt;/#if&gt; &lt;/#if&gt;&lt;/#list&gt;\n\n\n对service.ftl进行修改\n\n//导入部分&lt;#list typeSet as type&gt;    &lt;#if type==&#x27;Date&#x27;&gt;        import java.util.Date;    &lt;/#if&gt;&lt;/#list&gt;//列表查询&lt;#list fieldList as field&gt;    &lt;#if field.nameHump==&#x27;sort&#x27;&gt;    $&#123;domain&#125;Example.setOrderByClause(&quot;sort asc&quot;);    &lt;/#if&gt;&lt;/#list&gt;//插入 &lt;#list typeSet as type&gt;            &lt;#if type==&#x27;Date&#x27;&gt;        Date now = new Date();            &lt;/#if&gt;        &lt;/#list&gt;&lt;#list fieldList as field&gt;    &lt;#if field.nameHump==&#x27;createdAt&#x27;&gt;   \t\t $&#123;domain&#125;.setCreatedAt(now);    &lt;/#if&gt;    &lt;#if field.nameHump==&#x27;updatedAt&#x27;&gt;   \t\t $&#123;domain&#125;.setUpdatedAt(now);    &lt;/#if&gt;&lt;/#list&gt;//更新 &lt;#list fieldList as field&gt; \t&lt;#if field.nameHump==&#x27;updatedAt&#x27;&gt;   \t\t $&#123;domain&#125;.setUpdatedAt(new Date());     &lt;/#if&gt; &lt;/#list&gt;        \n\n\nvue.ftl进行修改：去除创建时间和更新时间的显示\n\n&lt;tr&gt;&lt;#list fieldList as field&gt;    &lt;#if field.nameHump!=&quot;createdAt&quot; &amp;&amp; field.nameHump!=&quot;updatedAt&quot;&gt;//就增加这一行    &lt;th&gt;$&#123;field.nameCn&#125;&lt;/th&gt;&lt;/#if&gt;&lt;/#list&gt;    &lt;th&gt;操作&lt;/th&gt;&lt;/tr&gt;//表单 &lt;#list fieldList as field&gt;       &lt;#if field.name!=&quot;id&quot; &amp;&amp; field.nameHump!=&quot;createdAt&quot; &amp;&amp; field.nameHump!=&quot;updatedAt&quot;&gt;//就增加这一行                &lt;div class=&quot;form-group&quot;&gt;                  &lt;label  class=&quot;col-sm-2 control-label&quot;&gt;$&#123;field.nameCn&#125;&lt;/label&gt;                  &lt;div class=&quot;col-sm-10&quot;&gt;                    &lt;input v-model=&quot;$&#123;domain&#125;.$&#123;field.nameHump&#125;&quot; class=&quot;form-control&quot;  &gt;                  &lt;/div&gt;                &lt;/div&gt;       &lt;/#if&gt;   &lt;/#list&gt; // 保存校验跟后端一样      if (1 != 1      &lt;#list fieldList as field&gt;          &lt;#if field.name!=&quot;id&quot; &amp;&amp; field.nameHump!=&quot;createdAt&quot; &amp;&amp; field.nameHump!=&quot;updatedAt&quot; &amp;&amp; field.nameHump!=&quot;sort&quot;&gt;          &lt;#if !field.nullAble&gt;      || !Validator.require(_this.$&#123;domain&#125;.$&#123;field.nameHump&#125;, &quot;$&#123;field.nameCn&#125;&quot;)      &lt;/#if&gt;      &lt;#if (field.length &gt; 0)&gt;      || !Validator.length(_this.$&#123;domain&#125;.$&#123;field.nameHump&#125;, &quot;$&#123;field.nameCn&#125;&quot;, 1, $&#123;field.length&#125;)      &lt;/#if&gt;      &lt;/#if&gt;      &lt;/#list&gt;\n\n\n实际开发中，是先写好SectionService的代码，再根据代码修改模板，测试生成的代码和手写的代码一致。\n\ncontroller.fi模板改动了，但SectionController之前已经手动把id的校验删除并提交了，所以本次生成的代码没有变动\n\n\n6-6 前端枚举代码的生成前端下拉框和列表枚举的设计：\n1.枚举字段，表格显示中文，表单显示下拉菜单2.vue增加过滤器\n\n\n给收费增加一个下拉框，将收费的输入改成这个\n\n&lt;select v-model=&quot;section.charge&quot; class=&quot;form-control&quot;  &gt;  &lt;option v-for=&quot;o in CHARGE&quot; v-bind:value=&quot;o.key&quot;&gt;&#123;&#123;o.value&#125;&#125;&lt;/option&gt;&lt;/select&gt;CHARGE:[&#123;key:&quot;C&quot;,value:&quot;收费&quot;&#125;,&#123;key:&quot;F&quot;,value:&quot;免费&quot;&#125;],//在data里面写死的\n\n\n修改下页面收费显示文字的问题：\n\n首先增加一个过滤器，在admin下src创建filter目录创建filter.js\n\n\n/** * 数组过滤器 例如：&#123;&#123;SECTION_CHARGE | option..KV(section.charge)&#125;&#125; * @param list 例如：&#123;&#123;key:&quot;C&quot;, value:&quot;收费&quot;&#125;,&#123;key:&quot;F&quot;, value:&quot;免费&quot;&#125;&#125; * @param key 例如：C * @returns &#123;string&#125; 例如：收费 */let option..KV = (list, key) =&gt;  &#123;    if (!list || !key) &#123;        return &quot;&quot;;    &#125; else &#123;        let result = &quot;&quot;;        for(let i = 0;i&lt;list.length;i++)&#123;            if (key === list[i][&quot;key&quot;]) &#123;                result = list[i][&quot;value&quot;];            &#125;        &#125;        return result;    &#125;&#125;;export default &#123;    option..KV,&#125;\n\n\n然后再main.js增加，这样就把filter变成vue的过滤器了\n\nimport filter from &#x27;./filter/filter&#x27;//全局过滤器Object.keys(filter).forEach(key =&gt;&#123;  Vue.filter(key,filter[key])&#125;);\n\n\n过滤器有了，使用再section.vue\n\n&lt;td&gt;&#123;&#123;section.charge&#125;&#125;&lt;/td&gt;//将这行改成&lt;td&gt;这里是两个大括号将他们括起来CHARGE|option..KV(section.charge)&lt;/td&gt;\n\n对于下拉框的列表值，一般会提取成全局的变量，方便多个页面使用：\n//首先再js创建enums.jsCHARGE = [&#123;key:&quot;C&quot;,value:&quot;收费&quot;&#125;,&#123;key:&quot;F&quot;,value:&quot;免费&quot;&#125;];//其次再index引用&lt;!--  枚举类  --&gt;&lt;script src=&quot;&lt;%= BASE_URL %&gt;static/js/enums.js&quot;&gt;&lt;/script&gt;//最后再vue使用 CHARGE: CHARGE,&lt;td&gt;这是两个大括号包的CHARGE|option..KV(section.charge)&lt;/td&gt;\n\n新增EnumGenerator用于生成前端枚举：\n1.增加了枚举生成器2.option..KV过滤器从list改成object\n\n\n问题：前端的枚举缺少枚举类型的信息，后续我们会碰到直接再前端用枚举值，我们的写法是直接SECTION_CHARGE.CHARGE.key，而不是写“C”。我们进行下列修改,注意表单的下拉框也要改成SECTION_CHARGE\n\n//首先修改enums.jsSECTION_CHARGE = &#123;CHARGE:&#123;key:&quot;C&quot;,value:&quot;收费&quot;&#125;,FREE:&#123;key:&quot;F&quot;,value:&quot;免费&quot;&#125;&#125;;//其次对filter.js/** * 数组过滤器 例如：两个大括号包住SECTION_CHARGE | option..KV(section.charge) * @param object 例如：&#123;CHARGE:&#123;key:&quot;C&quot;, value:&quot;收费&quot;&#125;,FREE:&#123;key:&quot;F&quot;, value:&quot;免费&quot;&#125;&#125; * @param key 例如：C * @returns &#123;string&#125; 例如：收费 */let option..KV = (object, key) =&gt;  &#123;    if (!object || !key) &#123;        return &quot;&quot;;    &#125; else &#123;        let result = &quot;&quot;;        for(let enums in object)&#123;            if (key === object[enums][&quot;key&quot;]) &#123;                result = object[enums][&quot;value&quot;];            &#125;        &#125;        return result;    &#125;&#125;;export default &#123;    option..KV,&#125;//最后再vue使用SECTION_CHARGE: SECTION_CHARGE,&lt;td&gt;两个大括号包住SECTION_CHARGE|option..KV(section.charge)&lt;/td&gt;\n\n\n通过后端的枚举，来生成枚举代码生成器，首先再server下建立软件包enums，然后放入两个文件，分别是SectionChargeEnum和YesNoEnum\n\npackage com.course.server.enums;public enum SectionChargeEnum &#123;    CHARGE(&quot;C&quot;, &quot;收费&quot;),    FREE(&quot;F&quot;, &quot;免费&quot;);    private String code;    private String desc;    SectionChargeEnum(String code, String desc) &#123;        this.code = code;        this.desc = desc;    &#125;    public String getCode() &#123;        return code;    &#125;    public void setCode(String code) &#123;        this.code = code;    &#125;    public void setDesc(String desc) &#123;        this.desc = desc;    &#125;    public String getDesc() &#123;        return desc;    &#125;&#125;\n\npackage com.course.server.enums;public enum YesNoEnum &#123;    YES(&quot;1&quot;, &quot;是&quot;),    NO(&quot;0&quot;, &quot;否&quot;);    private String code;    private String desc;    YesNoEnum(String code, String desc) &#123;        this.code = code;        this.desc = desc;    &#125;    public String getCode() &#123;        return code;    &#125;    public void setCode(String code) &#123;        this.code = code;    &#125;    public void setDesc(String desc) &#123;        this.desc = desc;    &#125;    public String getDesc() &#123;        return desc;    &#125;&#125;\n\n\n记得再sectionservice中增加\n\n/** * 插入 */private void insert(Section section)&#123;            Date now = new Date();            section.setCreatedAt(now);            section.setUpdatedAt(now);    section.setId(UuidUtil.getShortUuid());    section.setCharge(SectionChargeEnum.CHARGE.getCode());//这一行    sectionMapper.insert(section);&#125;\n\n\n最后写枚举生成器EnumGenerator\n\npackage com.course.generator.enums;import java.io.FileOutputStream;import java.io.OutputStreamWriter;import java.lang.reflect.Method;import java.util.regex.Matcher;import java.util.regex.Pattern;public class EnumGenerator &#123;    static String path = &quot;admin\\\\public\\\\static\\\\js\\\\enums.js&quot;;    public static void main(String[] args) &#123;        StringBuffer bufferObject = new StringBuffer();        StringBuffer bufferArray = new StringBuffer();        long begin = System.currentTimeMillis();        try &#123;            toJson(SectionChargeEnum.class, bufferObject, bufferArray);            toJson(YesNoEnum.class, bufferObject, bufferArray);            StringBuffer buffer = bufferObject.append(&quot;\\r\\n&quot;).append(bufferArray);            writeJs(buffer);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        long end = System.currentTimeMillis();        System.out.println(&quot;执行耗时:&quot; + (end - begin) + &quot; 毫秒&quot;);    &#125;    private static void toJson(Class clazz, StringBuffer bufferObject, StringBuffer bufferArray) throws Exception &#123;        String key = toUnderline(clazz.getSimpleName());        toJson(clazz, key, bufferObject, bufferArray);    &#125;    private static void toJson(Class clazz, String key, StringBuffer bufferObject, StringBuffer bufferArray) throws Exception &#123;        Object[] objects = clazz.getEnumConstants();        Method name = clazz.getMethod(&quot;name&quot;);        Method getDesc = clazz.getMethod(&quot;getDesc&quot;);        Method getCode = clazz.getMethod(&quot;getCode&quot;);        // 生成对象        bufferObject.append(key).append(&quot;=&#123;&quot;);        for (int i = 0; i &lt; objects.length; i++) &#123;            Object obj = objects[i];            if (getCode == null) &#123;                bufferObject.append(name.invoke(obj)).append(&quot;:&#123;key:\\&quot;&quot;).append(name.invoke(obj)).append(&quot;\\&quot;, value:\\&quot;&quot;).append(getDesc.invoke(obj)).append(&quot;\\&quot;&#125;&quot;);            &#125; else &#123;                bufferObject.append(name.invoke(obj)).append(&quot;:&#123;key:\\&quot;&quot;).append(getCode.invoke(obj)).append(&quot;\\&quot;, value:\\&quot;&quot;).append(getDesc.invoke(obj)).append(&quot;\\&quot;&#125;&quot;);            &#125;            if (i &lt; objects.length - 1) &#123;                bufferObject.append(&quot;,&quot;);            &#125;        &#125;        bufferObject.append(&quot;&#125;;\\r\\n&quot;);        // 生成数组        bufferArray.append(key).append(&quot;_ARRAY=[&quot;);        for (int i = 0; i &lt; objects.length; i++) &#123;            Object obj = objects[i];            if (getCode == null) &#123;                bufferArray.append(&quot;&#123;key:\\&quot;&quot;).append(name.invoke(obj)).append(&quot;\\&quot;, value:\\&quot;&quot;).append(getDesc.invoke(obj)).append(&quot;\\&quot;&#125;&quot;);            &#125; else &#123;                bufferArray.append(&quot;&#123;key:\\&quot;&quot;).append(getCode.invoke(obj)).append(&quot;\\&quot;, value:\\&quot;&quot;).append(getDesc.invoke(obj)).append(&quot;\\&quot;&#125;&quot;);            &#125;            if (i &lt; objects.length - 1) &#123;                bufferArray.append(&quot;,&quot;);            &#125;        &#125;        bufferArray.append(&quot;];\\r\\n&quot;);    &#125;    /**     * 写文件     * @param stringBuffer     */    public static void writeJs(StringBuffer stringBuffer) &#123;        FileOutputStream out = null;        try &#123;            out = new FileOutputStream(path);            OutputStreamWriter osw = new OutputStreamWriter(out, &quot;UTF-8&quot;);            System.out.println(path);            osw.write(stringBuffer.toString());            osw.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        finally &#123;            try &#123;                out.close();            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    /**     * 功能：驼峰转大写下划线，并去掉_ENUM     * 如：SectionChargeEnum 变成 SECTION_CHARGE     * @param str     * @return     */    public static String toUnderline(String str) &#123;        String result = underline(str).toString();        return result.substring(1, result.length()).toUpperCase().replace(&quot;_ENUM&quot;, &quot;&quot;);    &#125;    /**     * 驼峰转下划线，第一位是下划线     * 如：SectionChargeEnum 变成 _section_charge_enum     * @param str     * @return     */    private static StringBuffer underline(String str) &#123;        Pattern pattern = Pattern.compile(&quot;[A-Z]&quot;);        Matcher matcher = pattern.matcher(str);        StringBuffer sb = new StringBuffer(str);        if(matcher.find()) &#123;            sb = new StringBuffer();            matcher.appendReplacement(sb,&quot;_&quot;+matcher.group(0).toLowerCase());            matcher.appendTail(sb);        &#125;else &#123;            return sb;        &#125;        return underline(sb.toString());    &#125;&#125;\n\n\n原理：通过反射，得到枚举类的枚举类型、code、desc，然后通过字符串拼接的方式，得到最终完整的json字符串，再通过写文件的方式直接写入enums.js。\n\n记得添加依赖，才能引入包\n\n\n&lt;dependency&gt;    &lt;groupId&gt;com.course&lt;/groupId&gt;    &lt;artifactId&gt;server&lt;/artifactId&gt;&lt;/dependency&gt;\n\n  解决这个问题 [Vue warn]: Do not use built-in or reserved HTML elements as component id: section\n  将export default &#123;\n  components: &#123;Pagination&#125;,\n  name: &#39;business-section&#39;,//将section变成了business-section\n\n6-7 生成器综合示例课程管理功能开发：\n\n日期字段都是用datetime(3)，精确到毫秒。界面显示可以只到秒，但是落库要精确\n\n首先生成数据库，all.sql\n\n\n# 课程DROP TABLE IF EXISTS `course`;create table `course`(    `id`         CHAR(8)     NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;ID&#x27;,    `name`      VARCHAR(50) NOT NULL COMMENT &#x27;名称&#x27;,    `summary`  VARCHAR(2000) COMMENT &#x27;概述&#x27;,    `time`       INT default 0 COMMENT &#x27;时长|单位秒&#x27;,    `price`     decimal(8,2)  default 0.00 comment &#x27;价格(元)&#x27;,    `image`  VARCHAR(100) COMMENT &#x27;封面&#x27;,    `level`     CHAR(1)  COMMENT &#x27;级别|ONE(&quot;1&quot;,&quot;初级&quot;),ONE(&quot;2&quot;,&quot;中级&quot;),ONE(&quot;3&quot;,&quot;高级&quot;)&#x27;,    `charge`     CHAR(1) COMMENT &#x27;收费|CHARGE(&quot;C&quot;,&quot;收费&quot;),FREE(&quot;F&quot;,&quot;免费&quot;)&#x27;,    `status`     CHAR(1) COMMENT &#x27;状态|PUBLISH(&quot;P&quot;,&quot;发布&quot;),DRAFT(&quot;D&quot;,&quot;草稿&quot;)&#x27;,    `enroll`    integer default 0 comment &#x27;报名数&#x27;,    `sort`       INT COMMENT &#x27;顺序&#x27;,    `created_at` DATETIME(3) COMMENT &#x27;创建时间&#x27;,    `updated_at` DATETIME(3) COMMENT &#x27;修改时间&#x27;,    PRIMARY KEY (`id`)   )engine =innodb default charset=utf8mb4 comment=&#x27;课程&#x27;;INSERT INTO `course`(id,name,summary,time,price,image,level,charge,status,enroll,sort,created_at,updated_at)VALUES(&#x27;00000001&#x27;,&#x27;测试课程01&#x27;,&#x27;这时一门测试课程&#x27;,7200,19.9,&#x27;&#x27;,0,&#x27;C&#x27;,&#x27;D&#x27;,100,0,now(),now());\n\n\n其次在generatorConfiguration\n\n&lt;table tableName=&quot;course&quot; domainObjectName=&quot;Course&quot;/&gt;\n\n\n然后mybatis-generator，后端，前端代码生成器\n\n其次在admin增加管理\n\n\n&lt;li class=&quot;active&quot; id=&quot;business-course-sidebar&quot;&gt;  &lt;router-link to=&quot;/business/course&quot;&gt;    &lt;i class=&quot;menu-icon fa fa-caret-right&quot;&gt;&lt;/i&gt;    课程管理  &lt;/router-link&gt;  &lt;b class=&quot;arrow&quot;&gt;&lt;/b&gt;&lt;/li&gt;\n\n\n在路由router.js\n\n&#123;    path: &quot;business/course&quot;,    name:&quot;business/course&quot;,    component: Course,&#125;,\n\n\n在vue.ftl和controller。ftl都在长度后加?c这样会将数字2.000变为2000\n\n|| !Validator.length(_this.$&#123;domain&#125;.$&#123;field.nameHump&#125;, &quot;$&#123;field.nameCn&#125;&quot;, 1, $&#123;field.length?c&#125;)\n\n\n为其生成三个枚举分别是CourseChargeEnum，CourseLevelEnum，CourseStatusEnum\n\npackage com.course.server.enums;public enum CourseChargeEnum &#123;    CHARGE(&quot;C&quot;, &quot;收费&quot;),    FREE(&quot;F&quot;, &quot;免费&quot;);    private String code;    private String desc;    CourseChargeEnum(String code, String desc) &#123;        this.code = code;        this.desc = desc;    &#125;    public String getCode() &#123;        return code;    &#125;    public void setCode(String code) &#123;        this.code = code;    &#125;    public void setDesc(String desc) &#123;        this.desc = desc;    &#125;    public String getDesc() &#123;        return desc;    &#125;&#125;\n\npackage com.course.server.enums;public enum CourseLevelEnum &#123;    ONE(&quot;1&quot;, &quot;初级&quot;),    TWO(&quot;2&quot;, &quot;中级&quot;),    THREE(&quot;3&quot;, &quot;高级&quot;);    private String code;    private String desc;    CourseLevelEnum(String code, String desc) &#123;        this.code = code;        this.desc = desc;    &#125;    public String getCode() &#123;        return code;    &#125;    public void setCode(String code) &#123;        this.code = code;    &#125;    public void setDesc(String desc) &#123;        this.desc = desc;    &#125;    public String getDesc() &#123;        return desc;    &#125;&#125;\n\npackage com.course.server.enums;public enum CourseStatusEnum &#123;    PUBLISH(&quot;P&quot;, &quot;发布&quot;),    DRAFT(&quot;D&quot;, &quot;草稿&quot;);    private String code;    private String desc;    CourseStatusEnum(String code, String desc) &#123;        this.code = code;        this.desc = desc;    &#125;    public String getCode() &#123;        return code;    &#125;    public void setCode(String code) &#123;        this.code = code;    &#125;    public void setDesc(String desc) &#123;        this.desc = desc;    &#125;    public String getDesc() &#123;        return desc;    &#125;&#125;\n\n\n然后再EnumGenerator增加\n\ntoJson(CourseLevelEnum.class, bufferObject, bufferArray);toJson(CourseChargeEnum.class, bufferObject, bufferArray);toJson(CourseStatusEnum.class, bufferObject, bufferArray);\n\n\n然后再course.vue增加\n\ndata: function () &#123;  return &#123;    course: &#123;&#125;,    courses: [],    COURSE_LEVEL:COURSE_LEVEL,    COURSE_CHARGE:COURSE_CHARGE,    COURSE_STATUS:COURSE_STATUS,  &#125;&#125;,////////////////////////////////////////////////////////   &lt;td&gt;&#123;&#123;COURSE_LEVEL|option..KV(course.level)&#125;&#125;&lt;/td&gt;   &lt;td&gt;&#123;&#123;COURSE_CHARGE|option..KV(course.charge)&#125;&#125;&lt;/td&gt;   &lt;td&gt;&#123;&#123;COURSE_STATUS|option..KV(course.status)&#125;&#125;&lt;/td&gt;/////////////////////////////////////////////////////////&lt;select v-model=&quot;course.level&quot; class=&quot;form-control&quot;  &gt;    &lt;option v-for=&quot;o in COURSE_LEVEL&quot; v-bind:value=&quot;o.key&quot;&gt;&#123;&#123;o.value&#125;&#125;&lt;/option&gt;   &lt;/select&gt;&lt;select v-model=&quot;course.charge&quot; class=&quot;form-control&quot;  &gt;   &lt;option v-for=&quot;o in COURSE_CHARGE&quot; v-bind:value=&quot;o.key&quot;&gt;&#123;&#123;o.value&#125;&#125;&lt;/option&gt;   &lt;/select&gt;&lt;select v-model=&quot;course.status&quot; class=&quot;form-control&quot;  &gt;   &lt;option v-for=&quot;o in COURSE_STATUS&quot; v-bind:value=&quot;o.key&quot;&gt;&#123;&#123;o.value&#125;&#125;&lt;/option&gt; &lt;/select&gt;\n\n6-8 生成器升级作业生成器升级作业：将枚举类型的字段加入到代码生成器里面\n\n首先再all.sql进行修改，约定：枚举类型字段，增加“枚举”中文，并且将对应的枚举类写在[]中\n\n`level`     CHAR(1)  COMMENT &#x27;级别|枚举[CourseLevelEnum]:ONE(&quot;1&quot;,&quot;初级&quot;),ONE(&quot;2&quot;,&quot;中级&quot;),ONE(&quot;3&quot;,&quot;高级&quot;)&#x27;,`charge`     CHAR(1) COMMENT &#x27;收费|枚举[CourseChargeEnum]:CHARGE(&quot;C&quot;,&quot;收费&quot;),FREE(&quot;F&quot;,&quot;免费&quot;)&#x27;,`status`     CHAR(1) COMMENT &#x27;状态|枚举[CourseStatusEnum]:PUBLISH(&quot;P&quot;,&quot;发布&quot;),DRAFT(&quot;D&quot;,&quot;草稿&quot;)&#x27;,\n\n\n其次再field.java增加两个字段\n\npackage com.course.generator.util;public class Field &#123;    private Boolean enums; // 是否是枚举    private String enumsConst; // 枚举常量 COURSE_LEVEL        public Boolean getEnums() &#123;        return enums;    &#125;    public void setEnums(Boolean enums) &#123;        this.enums = enums;    &#125;    public String getEnumsConst() &#123;        return enumsConst;    &#125;    public void setEnumsConst(String enumsConst) &#123;        this.enumsConst = enumsConst;    &#125;    @Override    public String toString() &#123;        sb.append(&quot;, enums=&quot;).append(enums);        sb.append(&quot;, enumsConst=&#x27;&quot;).append(enumsConst).append(&#x27;\\&#x27;&#x27;);    &#125;&#125;\n\n\n然后再DbUtil.java增加\n\nif (comment.contains(&quot;枚举&quot;)) &#123;    field.setEnums(true);    // 以课程等级为例：从注释中的“枚举[CourseLevelEnum]”，得到COURSE_LEVEL    int start = comment.indexOf(&quot;[&quot;);    int end = comment.indexOf(&quot;]&quot;);    String enumsName = comment.substring(start + 1, end);    String enumsConst = EnumGenerator.toUnderline(enumsName);    field.setEnumsConst(enumsConst);&#125; else &#123;    field.setEnums(false);&#125;\n\n\n最后对vue.ftl增加枚举判断\n\n&lt;#list fieldList as field&gt;  &lt;#if field.nameHump!=&quot;createdAt&quot;&amp;&amp; field.nameHump!=&quot;updatedAt&quot; &gt;    &lt;#if field.enums&gt;    &lt;td&gt;&#123;&#123;$&#123;field.enumsConst&#125;|option..KV($&#123;domain&#125;.$&#123;field.nameHump&#125;)&#125;&#125;&lt;/td&gt;    &lt;#else&gt;  &lt;td&gt;&#123;&#123;$&#123;domain&#125;.$&#123;field.nameHump&#125;&#125;&#125;&lt;/td&gt;  &lt;/#if&gt;&lt;/#if&gt;\n\n//表单也得改，进行判断&lt;#list fieldList as field&gt;  &lt;#if field.name!=&quot;id&quot; &amp;&amp; field.nameHump!=&quot;createdAt&quot; &amp;&amp; field.nameHump!=&quot;updatedAt&quot;&gt;    &lt;#if field.enums&gt;&lt;div class=&quot;form-group&quot;&gt;  &lt;label class=&quot;col-sm-2 control-label&quot;&gt;$&#123;field.nameCn&#125;&lt;/label&gt;  &lt;div class=&quot;col-sm-10&quot;&gt;    &lt;select v-model=&quot;$&#123;domain&#125;.$&#123;field.nameHump&#125;&quot; class=&quot;form-control&quot;&gt;      &lt;option v-for=&quot;o in $&#123;field.enumsConst&#125;&quot; v-bind:value=&quot;o.key&quot;&gt;&#123;&#123;o.value&#125;&#125;&lt;/option&gt;    &lt;/select&gt;  &lt;/div&gt;&lt;/div&gt;    &lt;#else&gt;&lt;div class=&quot;form-group&quot;&gt;  &lt;label class=&quot;col-sm-2 control-label&quot;&gt;$&#123;field.nameCn&#125;&lt;/label&gt;  &lt;div class=&quot;col-sm-10&quot;&gt;    &lt;input v-model=&quot;$&#123;domain&#125;.$&#123;field.nameHump&#125;&quot; class=&quot;form-control&quot;&gt;  &lt;/div&gt;&lt;/div&gt;    &lt;/#if&gt;  &lt;/#if&gt;&lt;/#list&gt;\n\n//data这也得增加data: function () &#123;  return &#123;    $&#123;domain&#125;: &#123;&#125;,    $&#123;domain&#125;s: [],    &lt;#list fieldList as field&gt;     &lt;#if field.enums&gt;    $&#123;field.enumsConst&#125;: $&#123;field.enumsConst&#125;,     &lt;/#if&gt;    &lt;/#list&gt;  &#125;&#125;,\n\n","tags":["完整项目"]},{"title":"完整项目之Spring Cloud + Vue 前后端分离2-2","url":"/2022/02/15/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E4%B9%8BSpring%20Cloud%20+%20Vue%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%202-2/","content":"第7章 核心业务功能开发7-1 课程管理功能开发-课程大章小节关联本章将演示核心业务功能开发，包括课程、章、节、分类的管理功能，学习前端页面跳转及参数传递，Vue过滤器，前端树形展示插件zTree，富文本框的使用，Spring事务，通用排序功能解决方案等。\n\n课程管理页面美化：1.课程管理页面美化\n\nscoped：style下的样式只应用于当前组件，防止互相污染\n\n只是修改前端，然后将table标签注释\n\n\n&lt;div class=&quot;row&quot;&gt;  &lt;div v-for=&quot;course in courses&quot; class=&quot;col-md-4&quot;&gt;    &lt;div class=&quot;thumbnail search-thumbnail&quot;&gt;      &lt;img v-show=&quot;!course.image&quot; class=&quot;media-object&quot; src=&quot;/static/image/demo-course.jpg&quot; /&gt;      &lt;img v-show=&quot;course.image&quot; class=&quot;media-object&quot; v-bind:src=&quot;course.image&quot; /&gt;      &lt;div class=&quot;caption&quot;&gt;        &lt;div class=&quot;clearfix&quot;&gt;          &lt;span class=&quot;pull-right label label-primary info-label&quot;&gt;&#123;&#123;COURSE_LEVEL|option..KV(course.level)&#125;&#125;&lt;/span&gt;          &lt;span class=&quot;pull-right label label-primary info-label&quot;&gt;&#123;&#123;COURSE_CHARGE|option..KV(course.charge)&#125;&#125;&lt;/span&gt;          &lt;span class=&quot;pull-right label label-primary info-label&quot;&gt;&#123;&#123;COURSE_STATUS|option..KV(course.status)&#125;&#125;&lt;/span&gt;        &lt;/div&gt;        &lt;h3 class=&quot;search-title&quot;&gt;          &lt;a href=&quot;#&quot; class=&quot;blue&quot;&gt;&#123;&#123; course.name&#125;&#125;&lt;/a&gt;        &lt;/h3&gt;        &lt;p&gt;          &lt;span class=&quot;blue bolder bigger-150&quot;&gt;&#123;&#123;course.price&#125;&#125;&amp;nbsp;&lt;i class=&quot;fa fa-rmb&quot;&gt;&lt;/i&gt;&lt;/span&gt;&amp;nbsp;        &lt;/p&gt;        &lt;p&gt;&#123;&#123; course.summary&#125;&#125;&lt;/p&gt;        &lt;p&gt;          &lt;span class=&quot;badge badge-info&quot;&gt;&#123;&#123;course.id&#125;&#125;&lt;/span&gt;          &lt;span class=&quot;badge badge-info&quot;&gt;排序：&#123;&#123;course.sort&#125;&#125;&lt;/span&gt;          &lt;span class=&quot;badge badge-info&quot;&gt;时长：&#123;&#123;course.time&#125;&#125;&lt;/span&gt;        &lt;/p&gt;        &lt;p&gt;          &lt;button v-on:click=&quot;edit(course)&quot; class=&quot;btn btn-white btn-xs btn-info btn-round&quot;&gt;            编辑          &lt;/button&gt;&amp;nbsp;          &lt;button v-on:click=&quot;del(course.id)&quot; class=&quot;btn btn-white btn-xs btn-warning btn-round&quot;&gt;            删除          &lt;/button&gt;        &lt;/p&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;/div&gt;&lt;style scoped&gt;  .caption h3&#123;    font-size: 20px;  &#125;&lt;/style&gt;\n\n课程管理和大章管理互相跳转\n\n完成功能：在课程列表中增加“大章”按钮，点击会跳转到大章页面，并且筛选出当前课程下所有的大章。大章页面增加显示课程名称，并且有可以返回课程管理页面。\n\nsessionStorage是会话缓存，浏览器窗口关闭，缓存就没了。localStorage是本地缓存，浏览器关闭后，下次再打开还能读到。sessionStorage和localStorage只能操作字符串，但是我们经常要放对象数据，所以封装一下。\n\n\nSessionStorage = &#123;    get: function (key) &#123;        let v = sessionStorage.getItem(key);        if (v &amp;&amp; typeof(v) !== &quot;undefined&quot; &amp;&amp; v !== &quot;undefined&quot;) &#123;            return JSON.parse(v);        &#125;    &#125;,    set: function (key, data) &#123;        sessionStorage.setItem(key, JSON.stringify(data));    &#125;,    remove: function (key) &#123;        sessionStorage.removeItem(key);    &#125;,    clearAll: function () &#123;        sessionStorage.clear();    &#125;&#125;;\n\nLocalStorage = &#123;    get: function (key) &#123;        let v = localStorage.getItem(key);        if (v &amp;&amp; typeof(v) !== &quot;undefined&quot; &amp;&amp; v !== &quot;undefined&quot;) &#123;            return JSON.parse(v);        &#125;    &#125;,    set: function (key, data) &#123;        localStorage.setItem(key, JSON.stringify(data));    &#125;,    remove: function (key) &#123;        localStorage.removeItem(key);    &#125;,    clearAll: function () &#123;        localStorage.clear();    &#125;&#125;;\n\n\n首先再index.html增加引用\n\n&lt;!--  h5缓存  --&gt;&lt;script src=&quot;&lt;%= BASE_URL %&gt;static/js/session-storage.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&lt;%= BASE_URL %&gt;static/js/local-storage.js&quot;&gt;&lt;/script&gt;\n\n\n然后再course.vue增加一个大章按钮进行跳转\n\n&lt;button v-on:click=&quot;toChapter(course)&quot; class=&quot;btn btn-white btn-xs btn-info btn-round&quot;&gt;        大章&lt;/button&gt;&amp;nbsp;//增加toChapter方法toChapter(course) &#123;      let _this = this;      SessionStorage.set(&quot;course&quot;,course);      _this.$router.push(&quot;/business/chapter&quot;);   &#125;,    \n\n\n组件（页面）间传输数据可以用h5原生的localStorage或sessionStorage；也可以用js全局变量，也可以用vuex store。但是后两者会在页面刷新时丢失数据，所以推荐使用h5原生的。\n\n接下来再chapter.vue的mounted里将SessionStorage的缓存取出来\n\n\n data: function () &#123;    return &#123;      chapter: &#123;&#125;,      chapters: [],      course:&#123;&#125;,//一定要加    &#125;mounted: function () &#123;  let _this = this;  _this.$refs.pagination.size = 5;  let course = SessionStorage.get(&quot;course&quot;)||&#123;&#125;;  if (Tool.isEmpty(course))&#123;    _this.$router.push(&quot;/welcome&quot;);  &#125;  _this.course =course;  _this.list(1);&#125;,\n\n\n简单的跳转可以用router-link，如过有其他操作，可以写个click方法。比如前面完成的，从课程跳到大章，需要先缓存课程信息，所以写click方法\n\n&lt;h3&gt;&#123;&#123;course.name&#125;&#125;&lt;/h3&gt;/////////////////////////////////////////////////////////  &lt;router-link to=&quot;/business/course&quot; class=&quot;btn btn-white btn-default btn-round&quot;&gt;    &lt;i class=&quot;ace-icon fa fa-arrow-left red2&quot;&gt;&lt;/i&gt;    返回课程  &lt;/router-link&gt;\n\n大章管理保存和查询功能关联courseId\n\n改下chapter，将表单的courseID改成这个\n\n&lt;div class=&quot;form-group&quot;&gt;                &lt;label  class=&quot;col-sm-2 control-label&quot;&gt;课程&lt;/label&gt;                &lt;div class=&quot;col-sm-10&quot;&gt;                  &lt;P class=&quot;form-control-static&quot;&gt;&#123;&#123;course.name&#125;&#125;&lt;/P&gt;                &lt;/div&gt;              &lt;/div&gt;//////////////////////////// save的保存校验      if (!Validator.require(_this.chapter.name, &quot;名称&quot;)          || !Validator.length(_this.chapter.courseId, &quot;课程ID&quot;, 1, 8)) &#123;        return;      &#125;      _this.chapter.courseId =_this.course.id;////////////////////////////////////////////////list(page) &#123;      let _this = this;      Loading.show();      _this.$ajax.post(process.env.VUE_APP_SERVER +&#x27;/business/admin/chapter/list&#x27;, &#123;        page: page,        size: _this.$refs.pagination.size,        courseId:_this.course.id//根据传进来的课程ID来筛选所有的章\n\n\n首先再server的dto增加ChapterPageDto\n\npackage com.course.server.dto;public class ChapterPageDto extends PageDto&#123;    private String courseId;    public String getCourseId() &#123;        return courseId;    &#125;    public void setCourseId(String courseId) &#123;        this.courseId = courseId;    &#125;    @Override    public String toString() &#123;        final StringBuffer sb = new StringBuffer(&quot;ChapterPageDto&#123;&quot;);        sb.append(&quot;courseId=&#x27;&quot;).append(courseId).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, page=&quot;).append(page);        sb.append(&quot;, size=&quot;).append(size);        sb.append(&quot;, total=&quot;).append(total);        sb.append(&quot;, list=&quot;).append(list);        sb.append(&#x27;&#125;&#x27;);        return sb.toString();    &#125;&#125;\n\n\n接着转到chaptercontroller\n\n/** * 列表查询 */@PostMapping(&quot;/list&quot;)public ResponseDto list(@RequestBody ChapterPageDto chapterPageDto)&#123;    ResponseDto responseDto = new ResponseDto();    ValidatorUtil.require(chapterPageDto.getCourseId(), &quot;课程ID&quot;);    chapterService.list(chapterPageDto);    responseDto.setContent(chapterPageDto);    return responseDto;&#125;\n\n\n然后ChapterService\n\n/** * 列表查询 */public void list(ChapterPageDto chapterPageDto) &#123;    PageHelper.startPage(chapterPageDto.getPage(), chapterPageDto.getSize());    ChapterExample chapterExample = new ChapterExample();    ChapterExample.Criteria criteria = chapterExample.createCriteria();    if (!StringUtils.isEmpty(chapterPageDto.getCourseId())) &#123;        criteria.andCourseIdEqualTo(chapterPageDto.getCourseId());    &#125;    List&lt;Chapter&gt; chapterList = chapterMapper.selectByExample(chapterExample);    PageInfo&lt;Chapter&gt; pageInfo = new PageInfo&lt;&gt;(chapterList);    chapterPageDto.setTotal(pageInfo.getTotal());    List&lt;ChapterDto&gt; chapterDtoList = CopyUtil.copyList(chapterList, ChapterDto.class);    chapterPageDto.setList(chapterDtoList);&#125;\n\n\n经验分享：service层的查询条件写的松一点，灵活一点。service层可能被多个controller调用，也可能被其他service调用，每个调用的查询条件可能不一样\n\n大章管理和小节管理互相跳转：小节管理保存和查询功能关联courseId，chapterId\n\n对chapter做修改\n\n&lt;h4 class=&quot;lighter&quot;&gt;  &lt;i class=&quot;ace-icon fa fa-hand-o-right icon-animated-hand-pointer blue&quot;&gt;&lt;/i&gt;  &lt;router-link to=&quot;/business/course&quot; class=&quot;pink&quot;&gt; &#123;&#123;course.name&#125;&#125; &lt;/router-link&gt;&lt;/h4&gt;&lt;hr&gt;////////////////////////////////////////&lt;div class=&quot;hidden-sm hidden-xs btn-group&quot;&gt;    &lt;button v-on:click=&quot;toSection(chapter)&quot; class=&quot;btn btn-white btn-xs btn-info btn-round&quot;&gt;        小节    &lt;/button&gt;&amp;nbsp;    &lt;button v-on:click=&quot;edit(chapter)&quot; class=&quot;btn btn-white btn-xs btn-info btn-round&quot;&gt;        编辑    &lt;/button&gt;&amp;nbsp;    &lt;button v-on:click=&quot;del(chapter.id)&quot; class=&quot;btn btn-white btn-xs btn-warning btn-round&quot;&gt;        删除    &lt;/button&gt;&lt;/div&gt;/////////////////////////////////////////////toSection(chapter) &#123;      let _this = this;      SessionStorage.set(&quot;chapter&quot;, chapter);      _this.$router.push(&quot;/business/section&quot;);    &#125;\n\n\n然后对section\n\n&lt;h4 class=&quot;lighter&quot;&gt;  &lt;i class=&quot;ace-icon fa fa-hand-o-right icon-animated-hand-pointer blue&quot;&gt;&lt;/i&gt;  &lt;router-link to=&quot;/business/course&quot; class=&quot;pink&quot;&gt; &#123;&#123;course.name&#125;&#125; &lt;/router-link&gt;：  &lt;i class=&quot;ace-icon fa fa-hand-o-right icon-animated-hand-pointer blue&quot;&gt;&lt;/i&gt;  &lt;router-link to=&quot;/business/chapter&quot; class=&quot;pink&quot;&gt; &#123;&#123;chapter.name&#125;&#125; &lt;/router-link&gt;&lt;/h4&gt;&lt;hr&gt;///////////////////////////////////表单&lt;div class=&quot;form-group&quot;&gt;    &lt;label  class=&quot;col-sm-2 control-label&quot;&gt;课程&lt;/label&gt;    &lt;div class=&quot;col-sm-10&quot;&gt;        &lt;p class=&quot;form-control-static&quot;&gt;&#123;&#123;course.name&#125;&#125;&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;form-group&quot;&gt;    &lt;label  class=&quot;col-sm-2 control-label&quot;&gt;大章&lt;/label&gt;    &lt;div class=&quot;col-sm-10&quot;&gt;        &lt;p class=&quot;form-control-static&quot;&gt;&#123;&#123;chapter.name&#125;&#125;&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;//////////////////////////////////////////// data: function () &#123;    return &#123;      section: &#123;&#125;,      sections: [],      SECTION_CHARGE: SECTION_CHARGE,      course:&#123;&#125;,//这      chapter:&#123;&#125;,//这    &#125;  &#125;,  mounted: function () &#123;    let _this = this;    _this.$refs.pagination.size = 5;    let course = SessionStorage.get(&quot;course&quot;) || &#123;&#125;;    let chapter = SessionStorage.get(&quot;chapter&quot;) || &#123;&#125;;       if (Tool.isEmpty(course) || Tool.isEmpty(chapter)) &#123;      _this.$router.push(&quot;/welcome&quot;);    &#125;    _this.course = course;    _this.chapter = chapter;    _this.list(1);  &#125;,//////////////////////////////////////////////////列表查询两个参数courseId: _this.course.id,chapterId: _this.chapter.id////////////////////////////////////////////////////保存给两个赋值_this.section.courseId = _this.course.id;_this.section.chapterId = _this.chapter.id;\n\n\n增加SectionPageDto\n\npackage com.course.server.dto;public class SectionPageDto extends PageDto &#123;    private String courseId;    private String chapterId;    public String getCourseId() &#123;        return courseId;    &#125;    public void setCourseId(String courseId) &#123;        this.courseId = courseId;    &#125;    public String getChapterId() &#123;        return chapterId;    &#125;    public void setChapterId(String chapterId) &#123;        this.chapterId = chapterId;    &#125;    @Override    public String toString() &#123;        final StringBuffer sb = new StringBuffer(&quot;SectionPageDto&#123;&quot;);        sb.append(&quot;courseId=&#x27;&quot;).append(courseId).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, chapterId=&#x27;&quot;).append(chapterId).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, page=&quot;).append(page);        sb.append(&quot;, size=&quot;).append(size);        sb.append(&quot;, total=&quot;).append(total);        sb.append(&quot;, list=&quot;).append(list);        sb.append(&#x27;&#125;&#x27;);        return sb.toString();    &#125;&#125;\n\n\n然后对SectionController修改\n\n/*** 列表查询*/@PostMapping(&quot;/list&quot;)public ResponseDto list(@RequestBody SectionPageDto sectionPageDto)&#123;    ResponseDto responseDto = new ResponseDto();    ValidatorUtil.require(sectionPageDto.getCourseId(), &quot;课程ID&quot;);    ValidatorUtil.require(sectionPageDto.getChapterId(), &quot;大章ID&quot;);    sectionService.list(sectionPageDto);    responseDto.setContent(sectionPageDto);    return responseDto;&#125;\n\n\n最后对SectionService，criteria相当于写where语句\n\n/** * 列表查询 */public void list(SectionPageDto sectionPageDto)&#123;    PageHelper.startPage(sectionPageDto.getPage(),sectionPageDto.getSize());    SectionExample sectionExample = new SectionExample();    SectionExample.Criteria criteria = sectionExample.createCriteria();    if (!StringUtils.isEmpty(sectionPageDto.getCourseId())) &#123;        criteria.andCourseIdEqualTo(sectionPageDto.getCourseId());    &#125;    if (!StringUtils.isEmpty(sectionPageDto.getChapterId())) &#123;        criteria.andChapterIdEqualTo(sectionPageDto.getChapterId());    &#125;    sectionExample.setOrderByClause(&quot;sort asc&quot;);    List&lt;Section&gt; sectionList = sectionMapper.selectByExample(sectionExample);    PageInfo&lt;Section&gt; pageInfo =new PageInfo&lt;&gt;(sectionList);    sectionPageDto.setTotal(pageInfo.getTotal());    ArrayList&lt;SectionDto&gt; sectionDtoArrayList = new ArrayList&lt;SectionDto&gt;();    for (int i = 0, l=sectionList.size(); i &lt;l ; i++) &#123;        Section section = sectionList.get(i);        SectionDto sectionDto = new SectionDto();        BeanUtils.copyProperties(section,sectionDto);        sectionDtoArrayList.add(sectionDto);    &#125;    sectionPageDto.setList(sectionDtoArrayList);&#125;\n\n7-2 课程时长的保存和显示保存节时，更新课程总时长\n1.保存节时，更新课程总时长2.增加自定义mapper\n\n\n自定义的xml要和自动生成的xml分开，所以再server的mapper中都增加两个文件夹my一个存入MyCourseMapper.java，一个MyCourseMapper.xml\n\npackage com.course.server.mapper.my;import org.apache.ibatis.annotations.Param;public interface MyCourseMapper &#123;    int updateTime(@Param(&quot;courseId&quot;) String courseId);&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.course.server.mapper.my.MyCourseMapper&quot; &gt;    &lt;update id=&quot;updateTime&quot;&gt;        update course c set `time` = (select sum(`time`) from `section` where course_id = #&#123;courseId&#125;)        where c.id = #&#123;courseId&#125;    &lt;/update&gt;&lt;/mapper&gt;\n\n\n代码规范提示SectionService不要直接调用course的mapper，而是调用平级的CourseService。这时就需要将MyCourseMapper在CourseService封装一下\n\nprivate static final Logger LOG = LoggerFactory.getLogger(CourseService.class);@Resourceprivate MyCourseMapper myCourseMapper;/*** 更新课程时长* @param courseId* @return*/public void updateTime(String courseId) &#123;\tLOG.info(&quot;更新课程时长：&#123;&#125;&quot;, courseId);\tmyCourseMapper.updateTime(courseId);&#125;\n\n\n在SectionService使用\n\n@Resourceprivate CourseService courseService;在保存中添加courseService.updateTime(sectionDto.getCourseId());\n\n\n因为我们在mapper下新增个文件夹所以application.properties也要改\n\nmybatis.mapper-locations=classpath:/mapper/**/*.xml\n\n增加事务处理：\n\n一次操作会更新或修改多张表，一般为了保证数据一致，需要增加事务处理\n\n在server的config增加TransactionManagementConfig\n\n\npackage com.course.server.config;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;@EnableTransactionManagement@Configurationpublic class TransactionManagementConfig &#123;   &#125;\n\n\n使用时只需要在你想使用的方法上加@Transactional\n\n数据保存进数据库了，说明事务没有回滚，事务不起作用\n\n自定义异常一般可以选择继承RuntimeException。\n\n同一个类的内部方法互相调用，methodA调用methodB，methodB事务不起作用。Spring的事务处理是利用AOP生成动态代理类，内部方法调用时不经过代理类，所以事务不生效\n\n\n增加时长格式化filter：\n1.增加时长格式化filter format..Second\n\n\n在filter增加\n\n/** * 时长格式化 * @param value 例如：36000 * @returns &#123;string&#125; 例如：10:00:00 */let format..Second = (value) =&gt; &#123;    value = value || 0;    let second = parseInt(value, 10); // 秒    let minute = 0; // 分    let hour = 0; // 小时    if (second &gt;= 60) &#123;        // 当大于60秒时，才需要做转换        minute = Math.floor(second / 60);        second = Math.floor(second % 60);        if (minute &gt;= 60) &#123;            hour = Math.floor(minute / 60);            minute = Math.floor(minute % 60);        &#125;    &#125; else &#123;        // 小于60秒时，直接显示，不需要处理    &#125;    let result = &quot;&quot; + PrefixInteger(second, 2) + &quot;&quot;;    // 拼上分钟    result = &quot;&quot; + PrefixInteger(minute, 2) + &quot;:&quot; + result;    // 拼上小时    result = &quot;&quot; + PrefixInteger(hour, 2) + &quot;:&quot; + result;    return result;&#125;;/** * 格式化指定长度，前面补0 */function PrefixInteger(num, length) &#123;    return (Array(length).join(&#x27;0&#x27;) + num).slice(-length);&#125;export default &#123;    option..KV,    format..Second&#125;\n\n\n使用的时候直接在时间后加过滤器\n\n&lt;td&gt;两个大括号包住section.time | format..Second&lt;/td&gt;\n\n7-3 分类管理功能的开发分类表设计和基本代码生成：\n\n首先设计数据库\n\n# 分类DROP TABLE IF EXISTS `category`;create table `category`(    `id`         CHAR(8)     NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;id&#x27;,    `parent`         CHAR(8)     NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;父id&#x27;,    `name`      VARCHAR(50) NOT NULL COMMENT &#x27;名称&#x27;,    `sort`       INT COMMENT &#x27;顺序&#x27;,    PRIMARY KEY (`id`)   )engine =innodb default charset=utf8mb4 comment=&#x27;分类&#x27;;insert into `category` (id,parent,name,sort) values (&#x27;00000100&#x27;,&#x27;00000000&#x27;,&#x27;前端技术&#x27;,100);insert into `category` (id,parent,name,sort) values (&#x27;00000101&#x27;,&#x27;00000100&#x27;,&#x27;html/css&#x27;,101);insert into `category` (id,parent,name,sort) values (&#x27;00000102&#x27;,&#x27;00000100&#x27;,&#x27;javascript&#x27;,102);insert into `category` (id,parent,name,sort) values (&#x27;00000103&#x27;,&#x27;00000100&#x27;,&#x27;vue.js&#x27;,103);insert into `category` (id,parent,name,sort) values (&#x27;00000104&#x27;,&#x27;00000100&#x27;,&#x27;react.js&#x27;,104);insert into `category` (id,parent,name,sort) values (&#x27;00000105&#x27;,&#x27;00000100&#x27;,&#x27;angular&#x27;,105);insert into `category` (id,parent,name,sort) values (&#x27;00000106&#x27;,&#x27;00000100&#x27;,&#x27;node.js&#x27;,106);insert into `category` (id,parent,name,sort) values (&#x27;00000107&#x27;,&#x27;00000100&#x27;,&#x27;jquery&#x27;,107);insert into `category` (id,parent,name,sort) values (&#x27;00000108&#x27;,&#x27;00000100&#x27;,&#x27;小程序&#x27;,108);insert into `category` (id,parent,name,sort) values (&#x27;00000200&#x27;,&#x27;00000000&#x27;,&#x27;后端技术&#x27;,200);insert into `category` (id,parent,name,sort) values (&#x27;00000201&#x27;,&#x27;00000200&#x27;,&#x27;java&#x27;,201);insert into `category` (id,parent,name,sort) values (&#x27;00000202&#x27;,&#x27;00000200&#x27;,&#x27;springboot&#x27;,202);insert into `category` (id,parent,name,sort) values (&#x27;00000203&#x27;,&#x27;00000200&#x27;,&#x27;spring cloud&#x27;,203);insert into `category` (id,parent,name,sort) values (&#x27;00000204&#x27;,&#x27;00000200&#x27;,&#x27;ssm&#x27;,204);insert into `category` (id,parent,name,sort) values (&#x27;00000205&#x27;,&#x27;00000200&#x27;,&#x27;python&#x27;,205);insert into `category` (id,parent,name,sort) values (&#x27;00000206&#x27;,&#x27;00000200&#x27;,&#x27;爬虫&#x27;,206);insert into `category` (id,parent,name,sort) values (&#x27;00000300&#x27;,&#x27;00000000&#x27;,&#x27;移动开发&#x27;,300);insert into `category` (id,parent,name,sort) values (&#x27;00000301&#x27;,&#x27;00000000&#x27;,&#x27;android&#x27;,301);insert into `category` (id,parent,name,sort) values (&#x27;00000302&#x27;,&#x27;00000000&#x27;,&#x27;ios&#x27;,302);insert into `category` (id,parent,name,sort) values (&#x27;00000303&#x27;,&#x27;00000000&#x27;,&#x27;react native&#x27;,303);insert into `category` (id,parent,name,sort) values (&#x27;00000304&#x27;,&#x27;00000000&#x27;,&#x27;ionic&#x27;,304);insert into `category` (id,parent,name,sort) values (&#x27;00000400&#x27;,&#x27;00000000&#x27;,&#x27;前沿技术&#x27;,400);insert into `category` (id,parent,name,sort) values (&#x27;00000401&#x27;,&#x27;00000000&#x27;,&#x27;微服务&#x27;,401);insert into `category` (id,parent,name,sort) values (&#x27;00000402&#x27;,&#x27;00000000&#x27;,&#x27;区块链&#x27;,402);insert into `category` (id,parent,name,sort) values (&#x27;00000403&#x27;,&#x27;00000000&#x27;,&#x27;机器学习&#x27;,403);insert into `category` (id,parent,name,sort) values (&#x27;00000404&#x27;,&#x27;00000000&#x27;,&#x27;深度学习&#x27;,404);insert into `category` (id,parent,name,sort) values (&#x27;00000405&#x27;,&#x27;00000000&#x27;,&#x27;数据分析&amp;挖掘&#x27;,405);insert into `category` (id,parent,name,sort) values (&#x27;00000500&#x27;,&#x27;00000000&#x27;,&#x27;云计算&amp;大数据&#x27;,500);insert into `category` (id,parent,name,sort) values (&#x27;00000501&#x27;,&#x27;00000000&#x27;,&#x27;大数据&#x27;,501);insert into `category` (id,parent,name,sort) values (&#x27;00000502&#x27;,&#x27;00000000&#x27;,&#x27;hadoop&#x27;,502);\n\n\n接下来mybatis-generator、前端后端生成器生成下，然后改下admin增加分类管理，然后路由增加下。\n\n分类的二级列表查询与显示：\n\n做成两个表格，左边一个表格是一级分类，右边是二级分类。点击一级分类时显示二级分类。\n\n首先在CategoryService中添加\n\n\n/*** 列表查询*/    public List&lt;CategoryDto&gt; all( ) &#123;        CategoryExample categoryExample = new CategoryExample();        categoryExample.setOrderByClause(&quot;sort asc&quot;);        List&lt;Category&gt; categoryList = categoryMapper.selectByExample(categoryExample);        List&lt;CategoryDto&gt; categoryDtoList = CopyUtil.copyList(categoryList, CategoryDto.class);        return categoryDtoList;    &#125;\n\n\n接着在CategoryController增加\n\n/*** 列表查询*/@PostMapping(&quot;/all&quot;)public ResponseDto all()&#123;    ResponseDto responseDto = new ResponseDto();    List&lt;CategoryDto&gt; categoryDtoList = categoryService.all();    responseDto.setContent(categoryDtoList);    return responseDto;&#125;\n\n\n然后再category.vue将分页全都删了，增加\n\nexport default &#123;  name: &#x27;business-category&#x27;,  data: function () &#123;    return &#123;      category: &#123;&#125;,      categorys: [],      level1: [],      level2: [],    &#125;  &#125;,  mounted: function () &#123;    let _this = this;    _this.all();  &#125;,  /////////////////////////////////////////////修改list   /**     * 列表查询     */    all() &#123;      let _this = this;      Loading.show();      _this.$ajax.post(process.env.VUE_APP_SERVER +&#x27;/business/admin/category/all&#x27;).then((respond) =&gt; &#123;        Loading.hide();        let resp = respond.data;        _this.categorys = resp.content;        //将所有记录格式化成树形结构        for (let i = 0; i &lt; _this.categorys.length; i++) &#123;          let c =_this.categorys[i];          if(c.parent === &#x27;00000000&#x27;)&#123;            _this.level1.push(c);            for (let j = 0; j &lt; _this.categorys.length; j++) &#123;              let child =_this.categorys[j];              if(child.parent === c.id)&#123;                if(Tool.isEmpty(c.children))&#123;                  c.children = [];                &#125;                c.children.push(child);              &#125;            &#125;          &#125;        &#125;      &#125;)    &#125;,\n\n\nlevel1的数据增加childern属性，用于存放它所有的二级分类\n\n\n\n左边一个表格是一级分类，右边是二级分类：简单来说就是再 中加了两个table。\n\n\n&lt;div class=&quot;row&quot;&gt;  &lt;div class=&quot;col-md-6&quot;&gt;    &lt;p&gt;      &lt;button v-on:click=&quot;add()&quot; class=&quot;btn btn-white btn-default btn-round&quot;&gt;        &lt;i class=&quot;ace-icon fa fa-edit red2&quot;&gt;&lt;/i&gt;        新增      &lt;/button&gt;      &amp;nbsp;      &lt;button v-on:click=&quot;all()&quot; class=&quot;btn btn-white btn-default btn-round&quot;&gt;        &lt;i class=&quot;ace-icon fa fa-refresh red2&quot;&gt;&lt;/i&gt;        刷新      &lt;/button&gt;    &lt;/p&gt;    &lt;table id=&quot;level1-table&quot; class=&quot;table  table-bordered table-hover&quot;&gt;      &lt;thead&gt;      &lt;tr&gt;        &lt;th&gt;id&lt;/th&gt;        &lt;th&gt;名称&lt;/th&gt;        &lt;th&gt;顺序&lt;/th&gt;        &lt;th&gt;操作&lt;/th&gt;      &lt;/tr&gt;      &lt;/thead&gt;      &lt;tbody&gt;      &lt;tr v-for=&quot;category in level1&quot; v-on:click=&quot;onClickLevel1(category)&quot;&gt;        &lt;td&gt;&#123;&#123;category.id&#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123;category.name&#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123;category.sort&#125;&#125;&lt;/td&gt;        &lt;td&gt;          &lt;div class=&quot;hidden-sm hidden-xs btn-group&quot;&gt;            &lt;button v-on:click=&quot;edit(category)&quot; class=&quot;btn btn-xs btn-info&quot;&gt;              &lt;i class=&quot;ace-icon fa fa-pencil bigger-120&quot;&gt;&lt;/i&gt;            &lt;/button&gt;            &lt;button v-on:click=&quot;del(category.id)&quot; class=&quot;btn btn-xs btn-danger&quot;&gt;              &lt;i class=&quot;ace-icon fa fa-trash-o bigger-120&quot;&gt;&lt;/i&gt;            &lt;/button&gt;          &lt;/div&gt;          &lt;div class=&quot;hidden-md hidden-lg&quot;&gt;            &lt;div class=&quot;inline pos-rel&quot;&gt;              &lt;button class=&quot;btn btn-minier btn-primary dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; data-position=&quot;auto&quot;&gt;                &lt;i class=&quot;ace-icon fa fa-cog icon-only bigger-110&quot;&gt;&lt;/i&gt;              &lt;/button&gt;              &lt;ul class=&quot;dropdown-menu dropdown-only-icon dropdown-yellow dropdown-menu-right dropdown-caret dropdown-close&quot;&gt;                &lt;li&gt;                  &lt;a href=&quot;#&quot; class=&quot;tooltip-info&quot; data-rel=&quot;tooltip&quot; title=&quot;View&quot;&gt;               &lt;span class=&quot;blue&quot;&gt;                &lt;i class=&quot;ace-icon fa fa-search-plus bigger-120&quot;&gt;&lt;/i&gt;               &lt;/span&gt;                  &lt;/a&gt;                &lt;/li&gt;                &lt;li&gt;                  &lt;a href=&quot;#&quot; class=&quot;tooltip-success&quot; data-rel=&quot;tooltip&quot; title=&quot;Edit&quot;&gt;               &lt;span class=&quot;green&quot;&gt;                &lt;i class=&quot;ace-icon fa fa-pencil-square-o bigger-120&quot;&gt;&lt;/i&gt;               &lt;/span&gt;                  &lt;/a&gt;                &lt;/li&gt;                &lt;li&gt;                  &lt;a href=&quot;#&quot; class=&quot;tooltip-error&quot; data-rel=&quot;tooltip&quot; title=&quot;Delete&quot;&gt;               &lt;span class=&quot;red&quot;&gt;                &lt;i class=&quot;ace-icon fa fa-trash-o bigger-120&quot;&gt;&lt;/i&gt;               &lt;/span&gt;                  &lt;/a&gt;                &lt;/li&gt;              &lt;/ul&gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/td&gt;      &lt;/tr&gt;      &lt;/tbody&gt;    &lt;/table&gt;  &lt;/div&gt;  &lt;div class=&quot;col-md-6&quot;&gt;    &lt;p&gt;      &lt;button v-on:click=&quot;add()&quot; class=&quot;btn btn-white btn-default btn-round&quot;&gt;        &lt;i class=&quot;ace-icon fa fa-edit red2&quot;&gt;&lt;/i&gt;        新增      &lt;/button&gt;      &amp;nbsp;      &lt;button v-on:click=&quot;all()&quot; class=&quot;btn btn-white btn-default btn-round&quot;&gt;        &lt;i class=&quot;ace-icon fa fa-refresh red2&quot;&gt;&lt;/i&gt;        刷新      &lt;/button&gt;    &lt;/p&gt;    &lt;table id=&quot;level2-table&quot; class=&quot;table  table-bordered table-hover&quot;&gt;      &lt;thead&gt;      &lt;tr&gt;        &lt;th&gt;id&lt;/th&gt;        &lt;th&gt;名称&lt;/th&gt;        &lt;th&gt;顺序&lt;/th&gt;        &lt;th&gt;操作&lt;/th&gt;      &lt;/tr&gt;      &lt;/thead&gt;      &lt;tbody&gt;      &lt;tr v-for=&quot;category in level2&quot; &gt;        &lt;td&gt;&#123;&#123;category.id&#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123;category.name&#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123;category.sort&#125;&#125;&lt;/td&gt;        &lt;td&gt;          &lt;div class=&quot;hidden-sm hidden-xs btn-group&quot;&gt;            &lt;button v-on:click=&quot;edit(category)&quot; class=&quot;btn btn-xs btn-info&quot;&gt;              &lt;i class=&quot;ace-icon fa fa-pencil bigger-120&quot;&gt;&lt;/i&gt;            &lt;/button&gt;            &lt;button v-on:click=&quot;del(category.id)&quot; class=&quot;btn btn-xs btn-danger&quot;&gt;              &lt;i class=&quot;ace-icon fa fa-trash-o bigger-120&quot;&gt;&lt;/i&gt;            &lt;/button&gt;          &lt;/div&gt;          &lt;div class=&quot;hidden-md hidden-lg&quot;&gt;            &lt;div class=&quot;inline pos-rel&quot;&gt;              &lt;button class=&quot;btn btn-minier btn-primary dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; data-position=&quot;auto&quot;&gt;                &lt;i class=&quot;ace-icon fa fa-cog icon-only bigger-110&quot;&gt;&lt;/i&gt;              &lt;/button&gt;              &lt;ul class=&quot;dropdown-menu dropdown-only-icon dropdown-yellow dropdown-menu-right dropdown-caret dropdown-close&quot;&gt;                &lt;li&gt;                  &lt;a href=&quot;#&quot; class=&quot;tooltip-info&quot; data-rel=&quot;tooltip&quot; title=&quot;View&quot;&gt;               &lt;span class=&quot;blue&quot;&gt;                &lt;i class=&quot;ace-icon fa fa-search-plus bigger-120&quot;&gt;&lt;/i&gt;               &lt;/span&gt;                  &lt;/a&gt;                &lt;/li&gt;                &lt;li&gt;                  &lt;a href=&quot;#&quot; class=&quot;tooltip-success&quot; data-rel=&quot;tooltip&quot; title=&quot;Edit&quot;&gt;               &lt;span class=&quot;green&quot;&gt;                &lt;i class=&quot;ace-icon fa fa-pencil-square-o bigger-120&quot;&gt;&lt;/i&gt;               &lt;/span&gt;                  &lt;/a&gt;                &lt;/li&gt;                &lt;li&gt;                  &lt;a href=&quot;#&quot; class=&quot;tooltip-error&quot; data-rel=&quot;tooltip&quot; title=&quot;Delete&quot;&gt;               &lt;span class=&quot;red&quot;&gt;                &lt;i class=&quot;ace-icon fa fa-trash-o bigger-120&quot;&gt;&lt;/i&gt;               &lt;/span&gt;                  &lt;/a&gt;                &lt;/li&gt;              &lt;/ul&gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/td&gt;      &lt;/tr&gt;      &lt;/tbody&gt;    &lt;/table&gt;  &lt;/div&gt;&lt;/div&gt;\n\n\n为左边表增加点击事件，点击右边就显示子表\n\nonClickLevel1(category)&#123;  let _this =this;  _this.level2 =category.children;&#125;\n\n\n出现问题一：点击刷新的时候，会重复增加，主要是因为all事件每次都会将level1push\n\n解决只需要再每次格式化前将level1清空即增加_this.level1 &#x3D;[];\n\n问题二：点击左边的，出来右边时，我们需要增加一个激活效果\n\n动态class：使用v-bind:class&#x3D;json表达式，key就是样式，value是boolean，为true时，表示key的样式生效。可以和原生的class并存\n\n\n///////////////////////////////////////////////////////////////&lt;tr v-for=&quot;category in level1&quot; v-on:click=&quot;onClickLevel1(category)&quot; v-bind:class=&quot;&#123;&#x27;active&#x27;: category.id === active.id&#125;&quot;&gt;////////////////////////////////////////////////////data: function () &#123;    return &#123;      category: &#123;&#125;,      categorys: [],      level1: [],      level2: [],      active: &#123;&#125;,//增加    &#125;  &#125;,  /////////////////////////////////////////////////   onClickLevel1(category) &#123;        let _this = this;        _this.active = category;        _this.level2 = category.children;      &#125;    &#125;  &#125; /////////////////////////////////////////////&lt;style scoped&gt;  .active td &#123;    background-color: #d6e9c6 !important;  &#125;&lt;/style&gt;\n\n两级分类的新增修改删除：\n\n将两个新增标签改成新增一级，新增二级，对应的方法改为add1(),add2()，将父id改成父分类\n\n&lt;div class=&quot;form-group&quot;&gt;  &lt;label class=&quot;col-sm-2 control-label&quot;&gt;父分类&lt;/label&gt;  &lt;div class=&quot;col-sm-10&quot;&gt;    &lt;p  class=&quot;form-control-static&quot;&gt;&#123;&#123;active.name || &quot;无&quot;&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;//////////////////////////////////////////////////////////////////////////////////  /**     * 点击【新增一级】     */    add1() &#123;      let _this = this;      _this.active = &#123;&#125;;      _this.level2 = [];      _this.category = &#123;        parent:&quot;00000000&quot;      &#125;;      $(&quot;#form-modal&quot;).modal(&quot;show&quot;);    &#125;,    /**     * 点击【新增二级】     */    add2() &#123;      let _this = this;      if(Tool.isEmpty(_this.active))&#123;        Toast.warning(&quot;请先点击一级分类&quot;);        return;      &#125;      _this.category = &#123;        parent:_this.active.id      &#125;;      $(&quot;#form-modal&quot;).modal(&quot;show&quot;);    &#125;,\n\n\n修改CategoryService\n\n/** * 删除 */@Transactionalpublic void delete(String id)&#123;    deleteChildren(id);    categoryMapper.deleteByPrimaryKey(id);&#125;/** * 删除子分类 * @param id */public void deleteChildren(String id) &#123;    Category category = categoryMapper.selectByPrimaryKey(id);    if (&quot;00000000&quot;.equals(category.getParent())) &#123;        // 如果是一级分类，需要删除其下的二级分类        CategoryExample example = new CategoryExample();        example.createCriteria().andParentEqualTo(category.getId());        categoryMapper.deleteByExample(example);    &#125;&#125;\n\n\n问题：新增、编辑、删除二级分类时，没有马上刷新出来，会用到另一个小知识点\n\n处理：对一级或二级分类的增删改查，都会调用all()刷新数据，所以all()的后面触发一次表格行点击事件。\n\n\n_this.level2 =[];  //对当前一级分类中选中的表格触发一次点击事件，以刷新二级菜单栏  //注意：界面的渲染需要等vue绑定好变量后才做，所以延迟100ms  setTimeout(function ()&#123;    $(&quot;tr.active&quot;).trigger(&quot;click&quot;);  &#125;,100)&#125;)\n\n\n小技巧：当界面又用了jquery（特别是第三插件），当觉得代码没问题，但是效果又没出来，可以加一个小延迟看看。\n\n7-4 课程和分类关联保存和显示集成树型展示插件zTree：http://www.treejs.cn/v3/main.php#_zTreeInfo\n\n先弄成这个样式：\n\nzTree是jquery插件，用于展示树型结构数据。分类数据有两层结构，可用树形结构展示。\n\n首先再index中引入\n\n\n&lt;!--  zTree jquery树插件  --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= BASE_URL %&gt;zTree_v3/css/zTreeStyle/zTreeStyle.css&quot; type=&quot;text/css&quot;&gt;///////////////////////////////////&lt;!--  zTree jquery树插件  --&gt;&lt;script src=&quot;&lt;%= BASE_URL %&gt;zTree_v3-master/js/jquery.ztree.core.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&lt;%= BASE_URL %&gt;zTree_v3-master/js/jquery.ztree.excheck.min.js&quot;&gt;&lt;/script&gt;\n\n\n功能设计：新增课程的时候，同时选择这门课程属于哪些分类，并且一门课程可以属于多个分类。\n\n再course.vue表单下添加\n\n\n&lt;div class=&quot;form-group&quot;&gt;  &lt;label class=&quot;col-sm-2 control-label&quot;&gt;    分类  &lt;/label&gt;  &lt;div class=&quot;col-sm-10&quot;&gt;    &lt;ul id=&quot;tree&quot; class=&quot;ztree&quot;&gt;&lt;/ul&gt;  &lt;/div&gt;&lt;/div&gt;/////////////////////////////////初始化时   _this.initTree();////////////////////////////////////////    initTree()&#123;      let setting = &#123;        check: &#123;          enable: true        &#125;,        data: &#123;          simpleData: &#123;            enable: true          &#125;        &#125;      &#125;;      let zNodes =[        &#123; id:1, pId:0, name:&quot;随意勾选 1&quot;, open:true&#125;,        &#123; id:11, pId:1, name:&quot;随意勾选 1-1&quot;, open:true&#125;,        &#123; id:111, pId:11, name:&quot;随意勾选 1-1-1&quot;&#125;,        &#123; id:112, pId:11, name:&quot;随意勾选 1-1-2&quot;&#125;,        &#123; id:12, pId:1, name:&quot;随意勾选 1-2&quot;, open:true&#125;,        &#123; id:121, pId:12, name:&quot;随意勾选 1-2-1&quot;&#125;,        &#123; id:122, pId:12, name:&quot;随意勾选 1-2-2&quot;&#125;,        &#123; id:2, pId:0, name:&quot;随意勾选 2&quot;, checked:true, open:true&#125;,        &#123; id:21, pId:2, name:&quot;随意勾选 2-1&quot;&#125;,        &#123; id:22, pId:2, name:&quot;随意勾选 2-2&quot;, open:true&#125;,        &#123; id:221, pId:22, name:&quot;随意勾选 2-2-1&quot;, checked:true&#125;,        &#123; id:222, pId:22, name:&quot;随意勾选 2-2-2&quot;&#125;,        &#123; id:23, pId:2, name:&quot;随意勾选 2-3&quot;&#125;      ];      $.fn.zTree.init($(&quot;#tree&quot;), setting, zNodes);    &#125;\n\n将其改成这样：1.zTree数据改为分类所有记录\n\n首先将category中all方法复制修改到course中，然后初始值，接着将初始initTree更改初始allCategory，然后再allCategory中使用initTree（在第八行），接着将分支写入tree中，最后pId是zTree默认的父ID名称，而分类表是用parent，需要配置转换\n\n//首先将category中all方法复制修改到course中allCategory() &#123;  let _this = this;  Loading.show();  _this.$ajax.post(process.env.VUE_APP_SERVER +&#x27;/business/admin/category/all&#x27;).then((respond) =&gt; &#123;    Loading.hide();    let resp = respond.data;    _this.categorys = resp.content;    _this.initTree();//然后再allCategory中使用initTree  &#125;)&#125;,//然后初始值categorys: [],//接着将初始initTree更改初始allCategory _this.allCategory(); //将分支写入tree中let zNodes = _this.categorys;//pId是zTree默认的父ID名称，而分类表是用parent，需要配置转换 data: &#123;          simpleData: &#123;            idKey:&quot;id&quot;,            pIdKey:&quot;parent&quot;,            rootPId:&quot;00000000&quot;,            enable: true          &#125;        &#125;\n\n保存课程时，同时保存课程分类：\n1.保存课程时，同时保存课程分类2.增加课程分类关联表，一门课程可以属于多个分类\n\n\n首先创建sql语句\n\n#课程分类DROP TABLE IF EXISTS `course_category`;create table `course_category`(            `id` char(8) not null default &#x27;&#x27; comment &#x27;id&#x27;,            `course_id` char(8) comment &#x27;课程|course.id&#x27;,            `category_id` char(8) comment &#x27;分类|course.id&#x27;,             primary key (`id`))engine =innodb default charset=utf8mb4 comment=&#x27;课程分类&#x27;;\n\n\n接着就是代码生成器，不需要前端的，所以也不需要controller。\n\n在course.vue中进行代码的修改\n\n\n//在data中定义treetree: &#123;&#125;,//再保存中进行一些弹框提示let categorys = _this.tree.getCheckedNodes();if(Tool.isEmpty(categorys))&#123;  Toast.warning(&quot;请选择分类!&quot;);  return;&#125;_this.course.categorys =categorys;//将这个赋值到tree_this.tree = $.fn.zTree.init($(&quot;#tree&quot;), setting, zNodes);\n\n\n在courseDto中增加一个变量\n\nprivate List&lt;CategoryDto&gt; categorys;//属性名和前端传递的参数名一致，这样spring会自动映射参数\n\n\n在CourseService中save中增加\n\n@Resourceprivate CourseCategoryService courseCategoryService;   //批量保存课程分类courseCategoryService.saveBatch(courseDto.getId(),courseDto.getCategorys());\n\n\n在CourseCategoryService增加saveBatch方法\n\npublic void saveBatch(String courseId, List&lt;CategoryDto&gt; dtoList)&#123;    CourseCategoryExample example = new CourseCategoryExample();    example.createCriteria().andCourseIdEqualTo(courseId);    courseCategoryMapper.deleteByExample(example);    for (int i = 0,l = dtoList.size(); i &lt; l; i++) &#123;        CategoryDto categoryDto = dtoList.get(i);        CourseCategory courseCategory = new CourseCategory();        courseCategory.setId(UuidUtil.getShortUuid());        courseCategory.setCourseId(courseId);        courseCategory.setCategoryId(categoryDto.getId());        insert(courseCategory);    &#125;&#125;\n\n\n我们只需要保存分类的ID，所以数据传输可以选择id数组，也可以选择category数组\n\n也可以通过自定义的mapper写动态sql，将list传入mybatis，批量插入一批数据，只要一条insert语句。项目开发需要在开发效率和运行效率间找平衡。\n\n问题：保存课程时，调用saveBatch，那么课程新增时，还会批量插入数据，课程更新时，会再次批量插入数据，每次调用保存都会批量插入数据\n\n\n编辑课程时，加载课程分类树，并设置勾选：\n\n首先在CourseService增加一个事务，\n\n/** * 保存，id有值时更新，无值时新增 */@Transactional\n\n\n外层save增加了事务，saveBatch按理可以不加事务。但是由于本身也是多个sql操作，且以后可能被多个地方调用，为了防止外层save忘记加事务，所以在saveBatch加事务，以防外一。\n\n在CourseCategoryService中增加,其次在saveBatch也增加一个事务\n\n\n/**  * 根据某一课程，前清空课程分类，再保存课程分类  * @param courseId  * @param dtoList*/@Transactional///////////////////////////////////////////////public List&lt;CourseCategoryDto&gt; listByCourse(String courseId)&#123;    CourseCategoryExample example = new CourseCategoryExample();    example.createCriteria().andCourseIdEqualTo(courseId);    List&lt;CourseCategory&gt; courseCategoryList = courseCategoryMapper.selectByExample(example);    return CopyUtil.copyList(courseCategoryList,CourseCategoryDto.class);&#125;\n\n\n在coursecontroller中增加一个方法\n\n/*** 查找课程下所有分类*/@PostMapping (&quot;/list-category/&#123;courseId&#125;&quot;)public ResponseDto listCategory(@PathVariable(value = &quot;courseId&quot;)  String courseId)&#123;    ResponseDto responseDto = new ResponseDto();    List&lt;CourseCategoryDto&gt; dtoList = courseCategoryService.listByCourse(courseId);    responseDto.setContent(dtoList);    return responseDto;    &#125;\n\n\n最后在course.vue中增加\n\nadd() &#123;  _this.tree.checkAllNodes(false);&#125;,/////////////////edit(course) &#123;     _this.listCategory(course.id);&#125;,////////////////////// /**     * 查找课程下所有分类     * @param courseId     */    listCategory(courseId) &#123;      let _this = this;      Loading.show();      _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/business/admin/course/list-category/&#x27; + courseId).then((res)=&gt;&#123;        Loading.hide();        console.log(&quot;查找课程下所有分类结果：&quot;, res);        let response = res.data;        let categorys = response.content;        // 勾选查询到的分类        _this.tree.checkAllNodes(false);        for (let i = 0; i &lt; categorys.length; i++) &#123;          let node = _this.tree.getNodeByParam(&quot;id&quot;, categorys[i].categoryId);          _this.tree.checkNode(node, true);        &#125;      &#125;)    &#125;,\n\n7-5 课程内容功能开发课程内容表的设计与基本代码的生成：\n\nall.sql生成代码\n\n#课程内容DROP TABLE IF EXISTS `course_content`;create table `course_content`(            `id` char(8) not null default &#x27;&#x27; comment &#x27;课程id&#x27;,            `content` mediumtext not null  comment &#x27;课程内容&#x27;,             primary key (`id`))engine =innodb default charset=utf8mb4 comment=&#x27;课程内容&#x27;;\n\n\n课程表和课程内容表是1：1的关系，两张表都用同样的字段\n课程详情一般会有文字，图片，视频等，虽然不会把整张图片或者整个视频放到数据库，但是存的信息还是很多，所以用大字段。mediumtext比text类型长度更长。\n然后依旧mybatis和后端生成器生成代码。\n表里有大字段时，就会生成withBLOBs方法（在service中）\n\n完成课程内容管理功能：\n\n富文本编辑器，一个很重要的特性：所见即所得\n\n课程内容，只有读和写，没有列表查询，也没有删除\n\n新增课程的时候，course表有数据，course_content表没有数据。\n\n正常思路，先去select，看看有没有数据，再判断时insert还是update，这样会执行两个sql。其实可以直接更新，没有更新到再插入，只有第一次会更新不到，执行两次sql，后面都只需要一个sql\n\n首先在CourseService中插入\n\n\n @Resource private CourseContentMapper courseContentMapper;    /** * 查找课程内容 */public CourseContentDto findContent(String id)&#123;    CourseContent content = courseContentMapper.selectByPrimaryKey(id);    if(content == null)&#123;        return null;    &#125;    return CopyUtil.copy(content,CourseContentDto.class);&#125;/** * 保存课程内容，包含新增和修改 */public int saveContent(CourseContentDto contentDto)&#123;    CourseContent content = CopyUtil.copy(contentDto,CourseContent.class);    int i = courseContentMapper.updateByPrimaryKeyWithBLOBs(content);    if (i == 0)&#123;        i = courseContentMapper.insert(content);    &#125;    return i;&#125;\n\n\n其次在controller中将service中写的两个方法都暴露出去\n\n@GetMapping (&quot;/find-content/&#123;id&#125;&quot;)public ResponseDto findContent(@PathVariable  String id)&#123;    ResponseDto responseDto = new ResponseDto();    CourseContentDto contentDto = courseService.findContent(id);    responseDto.setContent(contentDto);    return responseDto;    &#125;@PostMapping(&quot;/save-content&quot;)public ResponseDto saveContent(@RequestBody CourseContentDto contentDto) &#123;    ResponseDto responseDto = new ResponseDto();    courseService.saveContent(contentDto);    return responseDto;&#125;\n\n\n接着在index中引入富文本的css和js\n\n!-- include summernote css/js --&gt;&lt;link href=&quot;https://cdn.jsdelivr.net/npm/summernote@0.8.18/dist/summernote.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/summernote@0.8.18/dist/summernote.min.js&quot;&gt;&lt;/script&gt;\n\n\n最後在course.vue中添加代碼\n\n&lt;button v-on:click=&quot;editContent(course)&quot; class=&quot;btn btn-white btn-xs btn-info btn-round&quot;&gt;  内容&lt;/button&gt;&amp;nbsp;&amp;nbsp;/////////////////////////////////////  &lt;div id=&quot;course-content-modal&quot; class=&quot;modal fade&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot;&gt;      &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;        &lt;div class=&quot;modal-content&quot;&gt;          &lt;div class=&quot;modal-header&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;            &lt;h4 class=&quot;modal-title&quot;&gt;内容编辑&lt;/h4&gt;          &lt;/div&gt;          &lt;div class=&quot;modal-body&quot;&gt;            &lt;form class=&quot;form-horizontal&quot;&gt;              &lt;div class=&quot;form-group&quot;&gt;                &lt;div class=&quot;col-lg-12&quot;&gt;                  &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/form&gt;          &lt;/div&gt;          &lt;div class=&quot;modal-footer&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;              &lt;i class=&quot;ace-icon fa fa-times&quot;&gt;&lt;/i&gt;              取消            &lt;/button&gt;            &lt;button v-on:click=&quot;saveContent()&quot; type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;              &lt;i class=&quot;ace-icon fa fa-plus blue&quot;&gt;&lt;/i&gt;              保存            &lt;/button&gt;          &lt;/div&gt;        &lt;/div&gt;&lt;!-- /.modal-content --&gt;      &lt;/div&gt;&lt;!-- /.modal-dialog --&gt;    &lt;/div&gt;&lt;!-- /.modal --&gt;/////////////////////////////////////////////// /**     * 打开内容编辑     */    editContent(course) &#123;      let _this = this;      let id = course.id;      _this.course =course;      $(&quot;#content&quot;).summernote(&#123;        focus: true,        height: 300      &#125;);      // 先清空历史文本      $(&quot;#content&quot;).summernote(&#x27;code&#x27;, &#x27;&#x27;);      Loading.show();      _this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/business/admin/course/find-content/&#x27; + id).then((response)=&gt;&#123;        Loading.hide();        let resp = response.data;        if (resp.success) &#123;          if (resp.content) &#123;            $(&quot;#content&quot;).summernote(&#x27;code&#x27;, resp.content.content);          &#125;        &#125; else &#123;          Toast.warning(resp.message);        &#125;      &#125;);    &#125;,       /**     * 保存内容     */    saveContent () &#123;      let _this = this;      let content = $(&quot;#content&quot;).summernote(&quot;code&quot;);      _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/business/admin/course/save-content&#x27;, &#123;        id: _this.course.id,        content: content      &#125;).then((response)=&gt;&#123;        Loading.hide();        let resp = response.data;        if (resp.success) &#123;          Toast.success(&quot;内容保存成功&quot;);        &#125; else &#123;          Toast.warning(resp.message);        &#125;      &#125;);    &#125;,\n\n利用setInterval完成自動保存功能：\n1.利用setInterval完成自动保存功能2.增加js日期格式化方法\n\n\nsetInterval，重复的定时任务；setTimeout，只执行一次的定时任务\n\n在editContent中增加。\n\n\n//自動保存功能let saveContentInterval = setInterval(function ()&#123;  _this.saveContent();&#125;,5000);//关闭内容框时，情况自动保存功能$(&#x27;course-content-modal&#x27;).on(&#x27;hidden.bs.modal&#x27;,function (e)&#123;  clearInterval(saveContentInterval);&#125;)\n\n\n\n这样写右上角总是出现下面这个框，所以做以下修改，在tool.js增加一个日期格式化方法\n\n/** * 时间格式化，date为空时取当前时间 */dateFormat: function (format, date) &#123;  let result;  if (!date) &#123;    date = new Date();  &#125;  const option = &#123;    &quot;y+&quot;: date.getFullYear().toString(),        // 年    &quot;M+&quot;: (date.getMonth() + 1).toString(),     // 月    &quot;d+&quot;: date.getDate().toString(),            // 日    &quot;h+&quot;: date.getHours().toString(),           // 时    &quot;m+&quot;: date.getMinutes().toString(),         // 分    &quot;s+&quot;: date.getSeconds().toString()          // 秒  &#125;;  for (let i in option) &#123;    result = new RegExp(&quot;(&quot; + i + &quot;)&quot;).exec(format);    if (result) &#123;      format = format.replace(result[1], (result[1].length == 1) ? (option[i]) : (option[i].padStart(result[1].length, &quot;0&quot;)))    &#125;  &#125;  return format;&#125;,\n\n\n然后在course.vue增加，在富文本内容上增加一个时间标签\n\n&lt;div class=&quot;form-group&quot;&gt;  &lt;div class=&quot;col-lg-12&quot;&gt;    &#123;&#123;saveContentLable&#125;&#125;  &lt;/div&gt;&lt;/div&gt;//定义变量saveContentLabel:&quot;&quot;,//在每次打开editContent每次都要情况历史文本 _this.saveContentLabel = &quot;&quot;;//在saveContent中加入if (resp.success) &#123;    let now = Tool.dateFormat(&quot;mm:ss&quot;);    _this.saveContentLabel = &quot;最后保存时间: &quot;+now;&#125;\t\t\n\n7-6 课程代码优化课程自定义排序：\n\n注意用法：小节的顺序是可以重复的，每一章里的小节都可以从1开始排序\n\n首先在course.vue中进行修改\n\n\n&lt;button v-on:click=&quot;openSortModal(course)&quot; class=&quot;btn btn-white btn-xs btn-info btn-round&quot;&gt;  排序&lt;/button&gt;&amp;nbsp;&amp;nbsp;////增加disabled &lt;div class=&quot;form-group&quot;&gt; \t&lt;label  class=&quot;col-sm-2 control-label&quot;&gt;顺序&lt;/label&gt; \t&lt;div class=&quot;col-sm-10&quot;&gt;\t\t &lt;input v-model=&quot;course.sort&quot; class=&quot;form-control&quot; disabled &gt; \t&lt;/div&gt; &lt;/div&gt;//增加模态框  &lt;div id=&quot;course-sort-modal&quot; class=&quot;modal fade&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot;&gt;      &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;        &lt;div class=&quot;modal-content&quot;&gt;          &lt;div class=&quot;modal-header&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;            &lt;h4 class=&quot;modal-title&quot;&gt;排序&lt;/h4&gt;          &lt;/div&gt;          &lt;div class=&quot;modal-body&quot;&gt;            &lt;form class=&quot;form-horizontal&quot;&gt;              &lt;div class=&quot;form-group&quot;&gt;                &lt;label class=&quot;control-label col-lg-3&quot;&gt;                  当前排序                &lt;/label&gt;                &lt;div class=&quot;col-lg-9&quot;&gt;                  &lt;input class=&quot;form-control&quot; v-model=&quot;sort.oldSort&quot; name=&quot;oldSort&quot; disabled&gt;                &lt;/div&gt;              &lt;/div&gt;              &lt;div class=&quot;form-group&quot;&gt;                &lt;label class=&quot;control-label col-lg-3&quot;&gt;                  新排序                &lt;/label&gt;                &lt;div class=&quot;col-lg-9&quot;&gt;                  &lt;input class=&quot;form-control&quot; v-model=&quot;sort.newSort&quot; name=&quot;newSort&quot;&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/form&gt;          &lt;/div&gt;          &lt;div class=&quot;modal-footer&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-white btn-default btn-round&quot; data-dismiss=&quot;modal&quot;&gt;              &lt;i class=&quot;ace-icon fa fa-times&quot;&gt;&lt;/i&gt;              取消            &lt;/button&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-white btn-info btn-round&quot; v-on:click=&quot;updateSort()&quot;&gt;              &lt;i class=&quot;ace-icon fa fa-plus blue&quot;&gt;&lt;/i&gt;              更新排序            &lt;/button&gt;          &lt;/div&gt;        &lt;/div&gt;&lt;!-- /.modal-content --&gt;      &lt;/div&gt;&lt;!-- /.modal-dialog --&gt;    &lt;/div&gt;&lt;!-- /.modal --&gt;//data增加变量 sort: &#123;        id: &quot;&quot;,        oldSort: 0,        newSort: 0      &#125;,//在添加方法增加_this.course = &#123;  sort: _this.$refs.pagination.total+1   &#125;;//增加两个方法    openSortModal(course) &#123;      let _this = this;      _this.sort = &#123;        id: course.id,        oldSort: course.sort,        newSort: course.sort      &#125;;      $(&quot;#course-sort-modal&quot;).modal(&quot;show&quot;);    &#125;,    /**     * 排序     */    updateSort() &#123;      let _this = this;      if (_this.sort.newSort === _this.sort.oldSort) &#123;        Toast.warning(&quot;排序没有变化&quot;);        return;      &#125;      Loading.show();      _this.$ajax.post(process.env.VUE_APP_SERVER + &quot;/business/admin/course/sort&quot;, _this.sort).then((res) =&gt; &#123;        let response = res.data;        if (response.success) &#123;          Toast.success(&quot;更新排序成功&quot;);          $(&quot;#course-sort-modal&quot;).modal(&quot;hide&quot;);          _this.list(1);        &#125; else &#123;          Toast.error(&quot;更新排序失败&quot;);        &#125;      &#125;);    &#125;,\n\n\n其次增加SortDto\n\npackage com.course.server.dto;public class SortDto &#123;    /**     * ID     */    private String id;    /**     * 当前排序     */    private int oldSort;    /**     * 新排序     */    private int newSort;    public String getId() &#123;        return id;    &#125;    public void setId(String id) &#123;        this.id = id;    &#125;    public int getNewSort() &#123;        return newSort;    &#125;    public void setNewSort(int newSort) &#123;        this.newSort = newSort;    &#125;    public int getOldSort() &#123;        return oldSort;    &#125;    public void setOldSort(int oldSort) &#123;        this.oldSort = oldSort;    &#125;    @Override    public String toString() &#123;        final StringBuffer sb = new StringBuffer(&quot;SortDto&#123;&quot;);        sb.append(&quot;id=&#x27;&quot;).append(id).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, oldSort=&quot;).append(oldSort);        sb.append(&quot;, newSort=&quot;).append(newSort);        sb.append(&#x27;&#125;&#x27;);        return sb.toString();    &#125;&#125;\n\n\n然后我们在coursecontroller添加\n\n@RequestMapping(value = &quot;/sort&quot;)public ResponseDto sort(@RequestBody SortDto sortDto) &#123;    LOG.info(&quot;更新排序&quot;);    ResponseDto responseDto = new ResponseDto();    courseService.sort(sortDto);    return responseDto;&#125;\n\n\n在CourseService中进行\n\n//批量保存课程分类courseCategoryService.saveBatch(course.getId(),courseDto.getCategorys());//这改了，之前是coursedto，新增课程的时候coursedto.id没有值,应该用course.id//增加方法/**     * 排序     * @param sortDto     */    @Transactional    public void sort(SortDto sortDto)&#123;        //修改当前记录的排序值        myCourseMapper.updateSort(sortDto);        //如果排序值变大        if (sortDto.getNewSort()&gt;sortDto.getOldSort())&#123;            myCourseMapper.moveSortsForward(sortDto);        &#125;        //如果排序值变小        if (sortDto.getNewSort()&lt;sortDto.getOldSort())&#123;            myCourseMapper.moveSortsBackward(sortDto);        &#125;    &#125;\n\n\n在MyCourseMapper创建CourseService调用的方法\n\nint updateSort(SortDto sortDto);int moveSortsForward(SortDto sortDto);int moveSortsBackward(SortDto sortDto);\n\n\n在MyCourseMapper.xml写对应接口\n\n&lt;update id=&quot;updateSort&quot; parameterType=&quot;com.course.server.dto.SortDto&quot;&gt;    update course set `sort`= #&#123;newSort&#125; where id = #&#123;id&#125;&lt;/update&gt;&lt;update id=&quot;moveSortsBackward&quot; parameterType=&quot;com.course.server.dto.SortDto&quot;&gt;    &lt;![CDATA[    update course set `sort`= (`sort`+1) where `sort` &gt;= #&#123;newSort&#125; and `sort` &lt;= #&#123;oldSort&#125; and id != #&#123;id&#125;    ]]&gt;&lt;/update&gt;&lt;update id=&quot;moveSortsForward&quot; parameterType=&quot;com.course.server.dto.SortDto&quot;&gt;    &lt;![CDATA[    update course set `sort`= (`sort`-1) where `sort` &lt;= #&#123;newSort&#125; and `sort` &gt;= #&#123;oldSort&#125; and id != #&#123;id&#125;    ]]&gt;&lt;/update&gt;\n\n菜单隐藏掉大章和小节：\n\n修改一：菜单栏不出现大章管理和小节管理\n\n首先admin中注释掉大章和小节管理\n\n\n&lt;!--   &lt;li class=&quot;active&quot; id=&quot;business-chapter-sidebar&quot;&gt;--&gt;&lt;!--                &lt;router-link to=&quot;/business/chapter&quot;&gt;--&gt;&lt;!--                  &lt;i class=&quot;menu-icon fa fa-caret-right&quot;&gt;&lt;/i&gt;--&gt;&lt;!--                  大章管理--&gt;&lt;!--                &lt;/router-link&gt;--&gt;&lt;!--                &lt;b class=&quot;arrow&quot;&gt;&lt;/b&gt;--&gt;&lt;!--              &lt;/li&gt;--&gt;&lt;!--              &lt;li class=&quot;active&quot; id=&quot;business-section-sidebar&quot;&gt;--&gt;&lt;!--                &lt;router-link to=&quot;/business/section&quot;&gt;--&gt;&lt;!--                  &lt;i class=&quot;menu-icon fa fa-caret-right&quot;&gt;&lt;/i&gt;--&gt;&lt;!--                  小节管理--&gt;&lt;!--                &lt;/router-link&gt;--&gt;&lt;!--                &lt;b class=&quot;arrow&quot;&gt;&lt;/b&gt;--&gt;&lt;!--              &lt;/li&gt;--&gt;\n\n\n修改2：页面进入大章管理和小节管理时，侧边栏的课程管理应该显示激活样式\n\n然后再chapter和section都加上激活样式\n\n\n//sidebar激活样式方法一this.$parent.activeSidebar(&quot;business-course-sidebar&quot;);\n\nsessionStorage的key改成常量：\n\nkey值不要直接写字符串，后面缓存用得越来越多；key名有可能冲突，这时要改key名的话所有set和get都要改。且不要用单一的单词，最好加一些前后缀。\n\n在SessionStorage.js中添加常量\n\n\nSESSION_KEY_COURSE = &quot;SESSION_KEY_COURSE&quot;; // 课程管理页面点击章管理时，保存课程信息SESSION_KEY_CHAPTER = &quot;SESSION_KEY_CHAPTER&quot;; // 章管理页面点击节管理时，保存章信息\n\n\n然后再course和chapter和section中都修改SessionStorage方法的key\n\n表格内文字上下居中：\n\n在static中创建css文件夹建立style.css文件，在index中引入css\n\n/*表格内容上下居中显示*/.table td&#123;    vertical-align: middle !important;&#125;\n\n7-7 讲师管理功能开发增加讲师管理功能：\n\n注意：菜单去掉了大章和小节，但是路由不能去\n\n简介要改成多行文本框textarea\n\nall.sql增加\n\n\n#讲师DROP TABLE IF EXISTS `teacher`;create table `teacher`(            `id` char(8) not null default &#x27;&#x27; comment &#x27;课程id&#x27;,            `name` varchar(50) not null comment &#x27;名称&#x27;,            `nickname` varchar(50)  comment &#x27;昵称&#x27;,            `image` varchar(100)  comment &#x27;头像&#x27;,            `position` varchar(50)  comment &#x27;职位&#x27;,            `motto` varchar(50)  comment &#x27;座右铭&#x27;,            `intro` varchar(500)  comment &#x27;简介&#x27;,             primary key (`id`))engine =innodb default charset=utf8mb4 comment=&#x27;讲师&#x27;;\n\n\n然后就是各种代码生成器，然后admin中和router中添加相应模块和路由。\n\n讲师管理布局优化：\n\n只需要改teacher.vue，table删了，加上这个。\n\n&lt;div class=&quot;row&quot;&gt;  &lt;div v-for=&quot;teacher in teachers&quot; class=&quot;col-md-3&quot;&gt;    &lt;div&gt;      &lt;span class=&quot;profile-picture&quot;&gt;        &lt;img v-show=&quot;!teacher.image&quot; class=&quot;editable img-responsive editable-click editable-empty&quot; src=&quot;/static/image/讲师头像/头像1.jpg&quot; v-bind:title=&quot;teacher.intro&quot;/&gt;        &lt;img v-show=&quot;teacher.image&quot; class=&quot;editable img-responsive editable-click editable-empty&quot; v-bind:src=&quot;teacher.image&quot; v-bind:title=&quot;teacher.intro&quot;/&gt;      &lt;/span&gt;      &lt;div class=&quot;space-4&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;width-85 label label-info label-xlg arrowed-in arrowed-in-right&quot;&gt;        &lt;div class=&quot;inline position-relative&quot;&gt;          &lt;a href=&quot;javascript:;&quot; class=&quot;user-title-label dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt;            &lt;i class=&quot;ace-icon fa fa-circle light-green&quot;&gt;&lt;/i&gt;            &amp;nbsp;            &lt;span class=&quot;white&quot;&gt;&#123;&#123;teacher.position&#125;&#125;&lt;/span&gt;          &lt;/a&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;space-6&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;text-center&quot;&gt;      &lt;a href=&quot;javascript:;&quot; class=&quot;text-info bigger-110&quot; v-bind:title=&quot;teacher.motto&quot;&gt;        &lt;i class=&quot;ace-icon fa fa-user&quot;&gt;&lt;/i&gt;        &#123;&#123;teacher.name&#125;&#125;【&#123;&#123;teacher.nickname&#125;&#125;】      &lt;/a&gt;    &lt;/div&gt;    &lt;div class=&quot;space-6&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;profile-social-links align-center&quot;&gt;      &lt;button v-on:click=&quot;edit(teacher)&quot; class=&quot;btn btn-xs btn-info&quot;&gt;        &lt;i class=&quot;ace-icon fa fa-pencil bigger-120&quot;&gt;&lt;/i&gt;      &lt;/button&gt;      &amp;nbsp;      &lt;button v-on:click=&quot;del(teacher.id)&quot; class=&quot;btn btn-xs btn-danger&quot;&gt;        &lt;i class=&quot;ace-icon fa fa-trash-o bigger-120&quot;&gt;&lt;/i&gt;      &lt;/button&gt;    &lt;/div&gt;    &lt;div class=&quot;hr hr16 dotted&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;//再把简介的input修改&lt;textarea v-model=&quot;teacher.intro&quot; class=&quot;form-control&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt;\n\n课程讲师的关联：\n\n一个分类可以有多门课程，一门课程也可以属于多个分类，所以他们是多对多的关系。多对多的关系，一般会设计个中间来维护关系\n\n一个讲师可以讲多门课程，一门课程只能有一个讲师，所以他们是一对多的关系。一对多的关系，可以把关系维护在“一那张表中\n\n旧表加字段，使用单独的sql：alter table，这样，上生产的时候也是执行这个sql\n\n\nalter table `course` add column (`teacher_id` char(8) comment  &#x27;讲师|teacher.id&#x27;);\n\n\n需要重新生成mybatis-generator。增加字段重新生成代码时，CourseMapper.java不会变化。\n\n要求：mybatis自动生成的四个文件不允许修改，这样才能做到重复生成\n\n但是courseDto要手动添加course.java中新增加的变量\n\n在course.vue中修改代码\n\n\n//在data中增加teachers: [],//页面打开始就加载所有讲师//在mounted中增加 _this.allTeacher();//增加方法allTeacher() &#123;  let _this = this;  Loading.show();  _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/business/admin/teacher/all&#x27;).then((respond) =&gt; &#123;    Loading.hide();    let resp = respond.data;    _this.teachers = resp.content;  &#125;)&#125;,\n\n\n在后端增加all方法，加载所有讲师信息。参照CategoryController的all来修改TeacherController。同样service也一样。\n\n/** * 列表查询 */@PostMapping(&quot;/all&quot;)public ResponseDto all()&#123;    ResponseDto responseDto = new ResponseDto();    List&lt;TeacherDto&gt; teacherDtoList = teacherService.all();    responseDto.setContent(teacherDtoList);    return responseDto;&#125;\n\n\n在课程表单中增加讲师选择框，在course.vue\n\n&lt;div class=&quot;form-group&quot;&gt;  &lt;label  class=&quot;col-sm-2 control-label&quot;&gt;讲师&lt;/label&gt;  &lt;div class=&quot;col-sm-10&quot;&gt;    &lt;select v-model=&quot;course.teacherId&quot; class=&quot;form-control&quot;  &gt;      &lt;option v-for=&quot;o in teachers&quot; v-bind:value=&quot;o.id&quot;&gt;&#123;&#123;o.name&#125;&#125;&lt;/option&gt;    &lt;/select&gt;  &lt;/div&gt;&lt;/div&gt;\n\n课程列表中显示讲师信息，课程名字字体自适应：\n\nv-for中，对循环的数组，可通过filter进行数据过滤\n\n&lt;div v-for=&quot;teacher in teachers.filter(t=&gt;&#123;return t.id===course.teacherId&#125;)&quot; class=&quot;profile-activity clearfix&quot;&gt;  &lt;div&gt;    &lt;img v-show=&quot;!teacher.image&quot; class=&quot;pull-left&quot; src=&quot;/ace/assets/images/avatars/avatar5.png&quot;&gt;    &lt;img v-show=&quot;teacher.image&quot; class=&quot;pull-left&quot; v-bind:src=&quot;teacher.image&quot;&gt;    &lt;a class=&quot;user&quot; href=&quot;#&quot;&gt; &#123;&#123;teacher.name&#125;&#125; &lt;/a&gt;    &lt;br&gt;    &#123;&#123;teacher.position&#125;&#125;  &lt;/div&gt;&lt;/div&gt;\n\n\n字体大小自适应，根据屏幕的分辩率显示不同大小的字体\n\n@media (max-width: 1199px) &#123;  .caption h3 &#123;    font-size: 16px;  &#125;&#125;\n\n\n前端开发小技巧：可以用浏览器的开发工具修改样式，调试好后，再把样式拷到代码里\n\n","tags":["完整项目"]},{"title":"完整项目之Spring Cloud + Vue 前后端分离3-1","url":"/2022/02/20/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E4%B9%8BSpring%20Cloud%20+%20Vue%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%203-1/","content":"第8章 文件上传功能开发本章将演示文件模块的开发，会使用SpringBoot + Vue完成文件上传功能，上传的图片支持实时预览显示。文件上传是系统操作中常见的功能，文件有大有小，不可避免带来带宽的问题，单独的文件模块很好的解决这个问题。\n\n8-1 完成基本的文件上传功能搭建文件模块-file：1.增加file模块用于文件上传和储存\n\n就是maven模块，增加启动文件，配置文件，路由转发。\n\nspringboot+vue文件上传功能：1.文件上传功能开发：springboot+vue基本的文件上传功能，上传讲师头像\n\ntype&#x3D;file，文件上传控件，将头像的input进行修改\n\n&lt;div class=&quot;form-group&quot;&gt;  &lt;label class=&quot;col-sm-2 control-label&quot;&gt;头像&lt;/label&gt;  &lt;div class=&quot;col-sm-10&quot;&gt;    &lt;input type = &quot;file&quot;  &gt;  &lt;/div&gt;&lt;/div&gt;\n\n\n触发文件上传动作方法一：增加一个新的按钮开始上传\n\n触发文件上传动作方法一：在文件上传组件上增加chang事件（选择这个）\n\n\n&lt;div class=&quot;form-group&quot;&gt;  &lt;label class=&quot;col-sm-2 control-label&quot;&gt;头像&lt;/label&gt;  &lt;div class=&quot;col-sm-10&quot;&gt;    &lt;input type = &quot;file&quot; v-on:change=&quot;uploadImage()&quot; id=&quot;file-upload-input&quot;&gt;  &lt;/div&gt;&lt;/div&gt;//添加方法uploadImage()&#123;      let _this =this;      let formData = new window.FormData();      //key：”file“必须和后端controller参数名一致      formData.append(&#x27;file&#x27;,document.querySelector(&#x27;#file-upload-input&#x27;).files[0]);      Loading.show();      _this.$ajax.post(process.env.VUE_APP_SERVER +&#x27;/file/admin/upload&#x27;,formData).then((respond) =&gt; &#123;        Loading.hide();        let resp = respond.data;      &#125;);    &#125;\n\n\n在file文件下创建controller.admin,创建文件UploadController\n\n@RequestMapping(&quot;/admin&quot;)@RestControllerpublic class UploadController &#123;   private static final Logger LOG = LoggerFactory.getLogger(UploadController.class);    @RequestMapping(&quot;/upload&quot;)     public ResponseDto upload(@RequestParam MultipartFile file) throws IOException &#123;         LOG.info(&quot;上传文件开始：&#123;&#125;&quot;,file);         LOG.info(file.getOriginalFilename());         LOG.info(String.valueOf(file.getSize()));         //保存文件到本地        String fileName =file.getOriginalFilename();        String key = UuidUtil.getShortUuid();        String fullPath = &quot;C:/Users/1/Desktop/方梓旭/course/admin/public/static/image/讲师头像/&quot;+key+&quot;-&quot;+fileName;        File dest = new File(fullPath);        file.transferTo(dest);        LOG.info(dest.getAbsolutePath());        ResponseDto responseDto = new ResponseDto();        return responseDto;    &#125;&#125;\n\n8-2 讲师头像的保存与显示文件访问配置：1.文件上传功能开发：增加springboot静态资源配置，配置文件访问路径\n\nSpringBoot静态资源配置，静态资源包含图片.Css、JS等\n\n测试路由转发到file模块是否生效，测试的时候要注意浏览器是有静态资源缓存的，可以用ctrl+f5强制刷新姿可铁用ohrome无痕浏览来测试，不会有缓存\n\n在file.config目录下创建SpringMvcConfig文件\n\n\npackage com.course.file.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class SpringMvcConfig implements WebMvcConfigurer &#123;    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        registry.addResourceHandler(&quot;/f/**&quot;).addResourceLocations(&quot;file:C:/Users/1/Desktop/方梓旭/course/admin/public/static/image/&quot; );    &#125;&#125;\n\n文件上传实时显示：\n1.文件上传功能开发：文件上传实时显示与保存\n\n\n在UploadController中将地址返回到前端\n\nresponseDto.setContent(&quot;http://192.168.0.105:9000/file/f/讲师头像/&quot;+key+&quot;-&quot;+fileName);\n\n\n在teacher前端的uploadImage方法中，取出来照片地址\n\nlet image =resp.content;console.log(&quot;头像地址:&quot;,image);_this.teacher.image = image;\n\n\nimg-responsive：bootstrap内置的样式，图片自适应\n\n在teacher.vue表单中头像input下增加\n\n\n&lt;div class=&quot;form-group&quot;&gt;  &lt;label class=&quot;col-sm-2 control-label&quot;&gt;头像&lt;/label&gt;  &lt;div class=&quot;col-sm-10&quot;&gt;    &lt;input type = &quot;file&quot; v-on:change=&quot;uploadImage()&quot; id=&quot;file-upload-input&quot;&gt;    &lt;img v-bind:src=&quot;teacher.image&quot; class=&quot;img-responsive&quot;&gt;  &lt;/div&gt;&lt;/div&gt;\n\n讲师头像显示优化：\n\n如果头像显示特别大class就应该使用\n\n&lt;img v-show=&quot;!teacher.image&quot; class=&quot;editable img-responsive editable-click editable-empty&quot; src=&quot;/static/image/讲师头像/头像1.jpg&quot; v-bind:title=&quot;teacher.intro&quot;/&gt;&lt;img v-show=&quot;teacher.image&quot; class=&quot;editable img-responsive editable-click editable-empty&quot; v-bind:src=&quot;teacher.image&quot; v-bind:title=&quot;teacher.intro&quot;/&gt;\n\n\n利用bootstrape栅格系统，一个div是12格，可以让图片只占4格的宽度\n\n&lt;div v-show=&quot;teacher.image&quot; class=&quot;row&quot;&gt;  &lt;div class=&quot;col-md-4&quot;&gt;    &lt;img v-bind:src=&quot;teacher.image&quot; class=&quot;img-responsive&quot;&gt;  &lt;/div&gt;&lt;/div&gt;\n\n\n接下来我们把图片地址进行修改，不写死。首先在application中增加\n\nfile.path=C:/Users/1/Desktop/方梓旭/course/admin/public/static/image/file.domain=http://192.168.0.105:9000/file/\n\n\n其次在UploadController，@Value，注入属性值\n\n@Value(&quot;$&#123;file.domain&#125;&quot;)private String FILE_DOMAIN;@Value(&quot;$&#123;file.path&#125;&quot;)private String FILE_PATH;//将地址替换 String fullPath = FILE_PATH+&quot;讲师头像/&quot;+key+&quot;-&quot;+fileName; responseDto.setContent(FILE_DOMAIN+&quot;/f/讲师头像/&quot;+key+&quot;-&quot;+fileName);     \n\n\n同样在SpringMvcConfig中也注入\n\n@Value(&quot;$&#123;file.path&#125;&quot;)private String FILE_PATH;registry.addResourceHandler(&quot;/f/**&quot;).addResourceLocations(&quot;file:&quot;+FILE_PATH );\n\n\nMaven多环境配置，将开发环境和生产环境配置成不同的值\n\n8-3 文件上传组件开发11.文件上传功能开发，使用单独的文件上传按钮\n\n\n优化点：用一个单独的按钮，来代替file控件，且操作的流程没有变化\n\n\n\n对teacher.vue进行修改，增加了button按钮，并将input隐藏，写selectImage方法\n\n&lt;div class=&quot;form-group&quot;&gt;  &lt;label class=&quot;col-sm-2 control-label&quot;&gt;头像&lt;/label&gt;  &lt;div class=&quot;col-sm-10&quot;&gt;    &lt;button type=&quot;button&quot; v-on:click=&quot;selectImage()&quot; class=&quot;btn btn-white btn-default btn-round&quot;&gt;      &lt;i class=&quot;ace-icon fa fa-upload&quot;&gt;&lt;/i&gt;      上传头像    &lt;/button&gt;    &lt;input class=&quot;hidden&quot; type = &quot;file&quot; v-on:change=&quot;uploadImage()&quot; id=&quot;file-upload-input&quot;&gt;    &lt;div v-show=&quot;teacher.image&quot; class=&quot;row&quot;&gt;      &lt;div class=&quot;col-md-4&quot;&gt;        &lt;img v-bind:src=&quot;teacher.image&quot; class=&quot;img-responsive&quot;&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;//selectImage方法  selectImage()&#123;      $(&quot;#file-upload-input&quot;).trigger(&quot;click&quot;);    &#125;\n\n\n增加上传文件类型判断：1.文件上传功能开发，增加上传文件类型的判断\n图片显示不出来我又把SpringMvcConfig改了回去\n\n优化：使用vue的$refs来获取组件\n\n//在头像那加ref&lt;input class=&quot;hidden&quot; type = &quot;file&quot; ref=&quot;file&quot; v-on:change=&quot;uploadImage()&quot; id=&quot;file-upload-input&quot;&gt;//在uploadImage中增加let file = _this.$refs.file.files[0];      //判断文件格式      let suffixs = [&quot;jpg&quot;,&quot;png&quot;,&quot;jpeg&quot;];      let fileName = file.name;      let suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)+1,fileName.length).toLowerCase();      let validateSuffix = false;      for (let i = 0; i &lt; suffixs.length; i++) &#123;        if(suffixs[i].toLowerCase() === suffix)&#123;          validateSuffix = true;          break;        &#125;      &#125;      if(!validateSuffix)&#123;        Toast.warning(&quot;文件格式不对！只支持上传：&quot;+suffixs.join(&quot;,&quot;));        return;      &#125;      //key：”file“必须和后端controller参数名一致      formData.append(&#x27;file&#x27;,file);\n\n制作文件上传公共组件1：\n\n一个项目中，很多地方都会用到文件上传功能，所以有必要把文件上传做成通用组件，这样以后也可以把文件组件直接拷贝到其他项目直接引用\n\nprops，用于父子组件传递数据，可以理解成组件可配置的属性\n\n创建了file.vue组件\n\n\n&lt;template&gt;  &lt;div&gt;    &lt;button type=&quot;button&quot; v-on:click=&quot;selectFile()&quot; class=&quot;btn btn-white btn-default btn-round&quot;&gt;      &lt;i class=&quot;ace-icon fa fa-upload&quot;&gt;&lt;/i&gt;      &#123;&#123;text&#125;&#125;    &lt;/button&gt;    &lt;input class=&quot;hidden&quot; type = &quot;file&quot; ref=&quot;file&quot; v-on:change=&quot;uploadFile()&quot; id=&quot;file-upload-input&quot;&gt;    &lt;div v-show=&quot;teacher.image&quot; class=&quot;row&quot;&gt;      &lt;div class=&quot;col-md-4&quot;&gt;        &lt;img v-bind:src=&quot;teacher.image&quot; class=&quot;img-responsive&quot;&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;pagination&#x27;,  props: &#123;    text:&#123;      default: &quot;上传文件&quot;    &#125;,    list: &#123;      type: Function,      default: null    &#125;,    itemCount: Number // 显示的页码数，比如总共有100页，只显示10页，其它用省略号表示  &#125;,  data: function () &#123;  &#125;,  methods: &#123;    uploadFile()&#123;      let _this =this;      let formData = new window.FormData();      let file = _this.$refs.file.files[0];      //判断文件格式      let suffixs = [&quot;jpg&quot;,&quot;png&quot;,&quot;jpeg&quot;];      let fileName = file.name;      let suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)+1,fileName.length).toLowerCase();      let validateSuffix = false;      for (let i = 0; i &lt; suffixs.length; i++) &#123;        if(suffixs[i].toLowerCase() === suffix)&#123;          validateSuffix = true;          break;        &#125;      &#125;      if(!validateSuffix)&#123;        Toast.warning(&quot;文件格式不对！只支持上传：&quot;+suffixs.join(&quot;,&quot;));        return;      &#125;      //key：”file“必须和后端controller参数名一致      formData.append(&#x27;file&#x27;,file);      Loading.show();      _this.$ajax.post(process.env.VUE_APP_SERVER +&#x27;/file/admin/upload&#x27;,formData).then((respond) =&gt; &#123;        Loading.hide();        let resp = respond.data;        let image =resp.content;        console.log(&quot;头像地址:&quot;,image);        _this.teacher.image = image;      &#125;);    &#125;,    selectFile()&#123;      $(&quot;#file-upload-input&quot;).trigger(&quot;click&quot;);    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.pagination &#123;  vertical-align: middle !important;  font-size: 16px;  margin-top: 0;  margin-bottom: 10px;&#125;.pagination button &#123;  margin-right: 5px;&#125;.btn-primary.active &#123;  background-color: #2f7bba !important;  border-color: #27689d !important;  color: white !important;  font-weight: 600;&#125;/*.pagination select &#123;*//*vertical-align: middle !important;*//*font-size: 16px;*//*margin-top: 0;*//*&#125;*/&lt;/style&gt;\n\n8-4 文件上传组件开发2制作文件上传公共组件1：\n1.文件上传功能开发：制作文件上传公共组件2.修复不能连续上传同一个文件的BUG\n\n\n对file进行修改\n\n&lt;template&gt;  &lt;div&gt;    &lt;button type=&quot;button&quot; v-on:click=&quot;selectFile()&quot; class=&quot;btn btn-white btn-default btn-round&quot;&gt;      &lt;i class=&quot;ace-icon fa fa-upload&quot;&gt;&lt;/i&gt;      &#123;&#123;text&#125;&#125;    &lt;/button&gt;    &lt;input class=&quot;hidden&quot; type=&quot;file&quot; ref=&quot;file&quot; v-on:change=&quot;uploadFile()&quot; v-bind:id=&quot;inputId+&#x27;-input&#x27;&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;file&#x27;,  props: &#123;    text: &#123;      default: &quot;上传文件&quot;    &#125;,    inputId: &#123;      default: &quot;file-upload&quot;    &#125;,    suffixs: &#123;      default: []    &#125;,    use: &#123;      default: &quot;&quot;    &#125;,    afterUpload: &#123;      type: Function,      default: null    &#125;,  &#125;,  data: function () &#123;    return &#123;    &#125;  &#125;,  methods: &#123;    uploadFile () &#123;      let _this = this;      let formData = new window.FormData();      let file = _this.$refs.file.files[0];      // 判断文件格式      let suffixs = _this.suffixs;      let fileName = file.name;      let suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;) + 1, fileName.length).toLowerCase();      let validateSuffix = false;      for (let i = 0; i &lt; suffixs.length; i++) &#123;        if (suffixs[i].toLowerCase() === suffix) &#123;          validateSuffix = true;          break;        &#125;      &#125;      if (!validateSuffix) &#123;        Toast.warning(&quot;文件格式不正确！只支持上传：&quot; + suffixs.join(&quot;,&quot;));        $(&quot;#&quot; + _this.inputId + &quot;-input&quot;).val(&quot;&quot;);//将控件里的值清空        return;      &#125;      // key：&quot;file&quot;必须和后端controller参数名一致      formData.append(&#x27;file&#x27;, file);      formData.append(&#x27;use&#x27;, _this.use);      Loading.show();      _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/file/admin/upload&#x27;, formData).then((response)=&gt;&#123;        Loading.hide();        let resp = response.data;        console.log(&quot;上传文件成功：&quot;, resp);        _this.afterUpload(resp);//回调函数        $(&quot;#&quot; + _this.inputId + &quot;-input&quot;).val(&quot;&quot;);//将控件里的值清空      &#125;);    &#125;,    selectFile () &#123;      let _this = this;      $(&quot;#&quot; + _this.inputId + &quot;-input&quot;).trigger(&quot;click&quot;);    &#125;  &#125;&#125;&lt;/script&gt;\n\n\n为组件增加上传成功后的回调函数，和组件不相关的业务代码应该由外部通过回调函数传进来。因为在file组件中没有teacher这个属性，所以需要在file中增加一个回调\n\n公共的代码放到组件里，变化的代码做成可配置的属性，由外部传入\n\n如果一个页面放了两个文件上传组件，会出现两个input的id重复，可以把id也做成可配置的。\n\n在teacher.vue中引用，file的可配置属性，然后再引入公共组件，最后设置回调函数\n\n\n&lt;file v-bind:input-id=&quot;&#x27;image-upload&#x27;&quot;          v-bind:text=&quot;&#x27;上传头像&#x27;&quot;          v-bind:suffixs=&quot;[&#x27;jpg&#x27;, &#x27;jpeg&#x27;, &#x27;png&#x27;]&quot;          v-bind:after-upload=&quot;afterUpload&quot;&gt;&lt;/file&gt;//引入公共组件import File from &quot;../../components/file&quot;;export default &#123;  components: &#123;Pagination,File&#125;,  &#125;//设置回调函数 afterUpload(resp)&#123;      let _this=this;      let image =resp.content;      _this.teacher.image = image;    &#125;\n\n\nBUG：连续选择同一个文件的时候，第二次会没反应，这时就要增加  $(“#” + _this.inputId + “-input”).val(“”);（上面file标注了）\n\n8-5 增加文件管理功能1文件表设计与基本代码生成：\n\n首先在all.sql中写\n\n#文件drop table if exists `file`;create table `file`(            `id` char(8) not null default &#x27;&#x27; comment &#x27;id&#x27;,            `path` varchar(100)  not null comment &#x27;相对路径&#x27;,            `name` varchar(100)  comment &#x27;文件名&#x27;,            `suffix` varchar(10)  comment &#x27;后缀&#x27;,            `size` int  comment &#x27;大小|字节B&#x27;,            `use` char(1)  comment &#x27;用途|枚举[FileUseEnum]:COURSE(&quot;C&quot;,&quot;讲师&quot;),TEACHER(&quot;T&quot;,&quot;课程&quot;)&#x27;,            `created_at` datetime(3) comment &#x27;创建时间&#x27;,            `updated_at` datetime(3) comment &#x27;修改时间&#x27;,             primary key (`id`),             unique key `path_unique`(`path`))engine =innodb default charset=utf8mb4 comment=&#x27;文件&#x27;;\n\n\n对于sql关键字就要在生成器中添加\n\n&lt;!--        会对关键字的表、 字段，增加反引号 (Shift+~)--&gt;        &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;true&quot;/&gt;\n\n\n对这个代码mybatis-generator，后端，前端，枚举。\n\n在对ServerGenerator和VueGenerator修改时，都要修改这个值\n\n\nstatic String MODULE = &quot;file&quot;;\n\n\n然后在server.enums创建FileUseEnum\n\npackage com.course.server.enums;public enum FileUseEnum &#123;    COURSE(&quot;C&quot;, &quot;课程&quot;),    TEACHER(&quot;T&quot;, &quot;讲师&quot;);    private String code;    private String desc;    FileUseEnum(String code, String desc) &#123;        this.code = code;        this.desc = desc;    &#125;    public String getCode() &#123;        return code;    &#125;    public void setCode(String code) &#123;        this.code = code;    &#125;    public void setDesc(String desc) &#123;        this.desc = desc;    &#125;    public String getDesc() &#123;        return desc;    &#125;    public static FileUseEnum getByCode(String code)&#123;        for(FileUseEnum e: FileUseEnum.values())&#123;            if(code.equals(e.getCode()))&#123;                return e;            &#125;        &#125;        return  null;    &#125;&#125;\n\n\n然后再EnumGenerator加入\n\ntoJson(FileUseEnum.class, bufferObject, bufferArray);\n\n\n接下来对admin进行修改\n\n&lt;li class=&quot;active open&quot;&gt;  &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot;&gt;    &lt;i class=&quot;menu-icon fa fa-list&quot;&gt;&lt;/i&gt;    &lt;span class=&quot;menu-text&quot;&gt; 文件管理 &lt;/span&gt;    &lt;b class=&quot;arrow fa fa-angle-down&quot;&gt;&lt;/b&gt;  &lt;/a&gt;  &lt;b class=&quot;arrow&quot;&gt;&lt;/b&gt;  &lt;ul class=&quot;submenu&quot;&gt;    &lt;li class=&quot;active&quot; id=&quot;file-file-sidebar&quot;&gt;      &lt;router-link to=&quot;/file/file&quot;&gt;        &lt;i class=&quot;menu-icon fa fa-caret-right&quot;&gt;&lt;/i&gt;        分类管理      &lt;/router-link&gt;      &lt;b class=&quot;arrow&quot;&gt;&lt;/b&gt;    &lt;/li&gt;  &lt;/ul&gt;&lt;/li&gt;\n\n\n然后是router.js\n\nimport File from &quot;./views/admin/file.vue&quot;,&#123;    path: &quot;file/file&quot;,    name:&quot;file/file&quot;,    component: File,&#125;\n\n上传文件时保存文件记录：1.文件上传功能开发：上传文件时保存文件记录\n\n统一文件名为8位uuid+文件后缓。下一章，我们还会对进一步规范文件名。\n\n文件记录不允许编辑和删除，但是可以做一些统计功能，比如文件大小统计，文件类型统计，也可增加文件审核功能，对不合规的图片、视频做处理\n\n先把application中，地址加一个f&#x2F;，好看\n\n\nfile.domain=http://192.168.0.105:9000/file/f/\n\n\n然后修改UploadController\n\n//注入@Resourceprivate FileService fileService;//取后缀String suffix =fileName.substring(fileName.lastIndexOf(&quot;.&quot;)+1).toLowerCase();String path = &quot;teacher/&quot;+key+&quot;.&quot;+suffix;String fullPath = FILE_PATH+path;//记录LOG.info(&quot;保存文件记录开始&quot;);FileDto fileDto = new FileDto();fileDto.setPath(path);fileDto.setName(fileName);fileDto.setSize(Math.toIntExact(file.getSize()));fileDto.setSuffix(suffix);fileDto.setUse(&quot;&quot;);fileService.save(fileDto);//地址也得相应修改       responseDto.setContent(FILE_DOMAIN+path);\n\n8-6 增加文件管理功能21.文件上传功能开发：去掉文件管理的新增、修改，删除功能\n\n\n就是该删删\n\n文件上传功能开发：增加文件大小格式化过滤器\n\n小技巧：不用算出最终的数值大小，直接写表达式，让程序来计算，这种写法方便维护和修改，比如我写个5242880，看不出来是多少但是写5 * 1024 * 1024，一看就是5M。\n\n再filter.js中设置格式化方法\n\n\n/** * 格式化文件大小 * @param value * @returns &#123;string&#125; */let formatFileSize = (value) =&gt; &#123;    value = value || 0;    let result;    if (value &gt; 100 * 1024) &#123;        result = Math.round((value / 1024 / 1024) * 100) / 100 + &quot;MB&quot;;    &#125; else &#123;        result = Math.round((value / 1024) * 100) / 100 + &quot;KB&quot;;    &#125;    return result;&#125;;//将其抛出export default &#123;    formatFileSize&#125;\n\n\n在filter.vue中使用只需要这样\n\n&lt;td&gt;&#123;&#123;file.size|formatFileSize&#125;&#125;&lt;/td&gt;\n\n文件按用途分类保存：\n\n首先在FileUseEnum中创建一个方法\n\n//通过code得到完整的枚举public static FileUseEnum getByCode(String code)&#123;    for(FileUseEnum e: FileUseEnum.values())&#123;        if(code.equals(e.getCode()))&#123;            return e;        &#125;    &#125;    return  null;&#125;\n\n\n然后再filevue（这个是哪个通用组件）\n\n//增加一个可改变的属性props: &#123;  use: &#123;    default: &quot;&quot;  &#125;, &#125; //提交表单时将use也提交出去 formData.append(&#x27;use&#x27;, _this.use);\n\n\n再teacher.vue中使用，生成的枚举\n\ndata: function () &#123;  return &#123;    teacher: &#123;&#125;,    teachers: [],    FILE_USE:FILE_USE//将枚举js全局变量定义组件变量，再html中使用的时组件变量  &#125;&#125;,//再上传file标签那使用v-bind:use=&quot;FILE_USE.TEACHER.key&quot;\n\n\n最后在UploadController中\n\n//将use传进来public ResponseDto upload(@RequestParam MultipartFile file,String use) throws IOException &#123;    //保存文件到本地，通过use获取枚举类型 FileUseEnum useEnum =FileUseEnum.getByCode(use);      //如果文件夹不存在，创建文件夹 String dir = useEnum.name().toLowerCase(); File fullDir = new File(FILE_PATH+dir); if(!fullDir.exists())&#123; \tfullDir.mkdir();  &#125; String path = dir+File.separator+key+&quot;.&quot;+suffix;   //将use设置进去fileDto.setUse(use);\n\n8-7 文件上传组件的使用文件上传成功后返回值处理：1，文件上传功能开发：文件上传成功后返回值的处理\n\n要将全路径返回回去，首先在UploadController中重新设置下全路径，再将其设置到内容里\n\nfileDto.setPath(FILE_DOMAIN+path);responseDto.setContent(fileDto);\n\n\n与此同时teacher.vue也要改afterUpload方法中content后加一个.path\n\nafterUpload(resp)&#123;  let _this=this;  let image =resp.content.path;  _this.teacher.image = image;&#125;\n\n课程管理和小节管理使用文件组件：1.文件上传功能开发：课程管理和小节管理使用文件组件\n\n我们先修改course的封面：\n\n//修改封面部分&lt;div class=&quot;form-group&quot;&gt;  &lt;label  class=&quot;col-sm-2 control-label&quot;&gt;封面&lt;/label&gt;  &lt;div class=&quot;col-sm-10&quot;&gt;    &lt;file v-bind:input-id=&quot;&#x27;image-upload&#x27;&quot;          v-bind:text=&quot;&#x27;上传封面&#x27;&quot;          v-bind:suffixs=&quot;[&#x27;jpg&#x27;, &#x27;jpeg&#x27;, &#x27;png&#x27;]&quot;          v-bind:use=&quot;FILE_USE.COURSE.key&quot;          v-bind:after-upload=&quot;afterUpload&quot;&gt;&lt;/file&gt;    &lt;div v-show=&quot;course.image&quot; class=&quot;row&quot;&gt;      &lt;div class=&quot;col-md-4&quot;&gt;        &lt;img v-bind:src=&quot;course.image&quot; class=&quot;img-responsive&quot;&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;//引入Fileimport File from &quot;../../components/file&quot;;export default &#123;   components: &#123;Pagination,File&#125;,  &#125;//data中引入全局变量FILE_USE:FILE_USE,//引入方法afterUpload(resp)&#123;    let _this=this;    let image =resp.content.path;    _this.course.image = image;&#125;\n\n\n接下来我们改小节的视频上传部分：\n\n//修改视频部分&lt;div class=&quot;form-group&quot;&gt;  &lt;label  class=&quot;col-sm-2 control-label&quot;&gt;视频&lt;/label&gt;  &lt;div class=&quot;col-sm-10&quot;&gt;    &lt;file v-bind:input-id=&quot;&#x27;video-upload&#x27;&quot;          v-bind:text=&quot;&#x27;上传视频&#x27;&quot;          v-bind:suffixs=&quot;[&#x27;mp4&#x27;]&quot;          v-bind:use=&quot;FILE_USE.COURSE.key&quot;          v-bind:after-upload=&quot;afterUpload&quot;&gt;&lt;/file&gt;    &lt;div v-show=&quot;section.video&quot; class=&quot;row&quot;&gt;      &lt;div class=&quot;col-md-9&quot;&gt;        &lt;video v-bind:src=&quot;section.video&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;//引入Fileimport File from &quot;../../components/file&quot;;export default &#123;  components: &#123;Pagination,File&#125;,  &#125;//data中引入变量FILE_USE:FILE_USE,//引入方法 afterUpload(resp)&#123;      let _this=this;      let video =resp.content.path;      _this.section.video = video;    &#125;\n\n\nmax-file-size：单个文件的大小；max-request-size：请求的大小，比如一次请求可以上传多个文件，这时两个值就不一样了。\n\n修改File的application\n\n\nspring.servlet.multipart.max-file-size=100MBspring.servlet.multipart.max-request-size=100MB\n\n自动获取视频时长：1.文件上传功能开发：自动获取视频时长\n\n修改section.vue\n\n//给video标签加一个id&lt;div class=&quot;col-md-9&quot;&gt;  &lt;video v-bind:src=&quot;section.video&quot; id=&quot;video&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;&lt;/div&gt;//  afterUpload中使用getTime方法afterUpload(resp)&#123;      _this.getTime();    &#125;,//加一个获取时长方法    /**     * 获取时长     */    getTime()&#123;      let _this=this;      let ele =document.getElementById(&quot;video&quot;);      _this.section.time =parseInt(ele.duration,10);    &#125;\n\n8-8 作业讲解：课程内容中增加文件管理1.文件上传功能开发：增加误程内容文件管理，用于富文本框中插入图片或视2.修复course，section，teacher页面中关于文件组件中inputId的赋值3，修复file组件中selectFile，id的值改为变量\n\n\n首先在all.sql中写入\n\n#课程内容文件drop table if exists `course_content_file`;create table `course_content_file`(                       `id` char(8) not null default &#x27;&#x27; comment &#x27;id&#x27;,                       `course_id` char(8) not null  comment &#x27;课程id&#x27;,                       `url` varchar(100)  comment &#x27;地址&#x27;,                       `name` varchar(100)  comment &#x27;文件名&#x27;,                       `size` int  comment &#x27;大小|字节B&#x27;,                       primary key (`id`))engine =innodb default charset=utf8mb4 comment=&#x27;课程内容文件&#x27;;\n\n\n只需要生成持久层和服务端的代码，不需要生成界面，记得改后端生成器ServerGenerator的模块名\n\nstatic String MODULE = &quot;business&quot;;\n\n\n对生成的CourseContentFileService进行一些改动\n\n/*** 列表查询*/    public List&lt;CourseContentFileDto&gt; list(String courseId) &#123;        CourseContentFileExample example = new CourseContentFileExample();        CourseContentFileExample.Criteria criteria =example.createCriteria();        criteria.andCourseIdEqualTo(courseId);        List&lt;CourseContentFile&gt; fileList = courseContentFileMapper.selectByExample(example);        return CopyUtil.copyList(fileList,CourseContentFileDto.class);    &#125;\n\n\nCourseContentFileController也做修改\n\n//习惯用哪个就写成哪个@RequestMapping(&quot;/admin/course-content-file&quot;)/*** 列表查询*/@GetMapping(&quot;/list/&#123;courseId&#125;&quot;)public ResponseDto list(@PathVariable String courseId)&#123;    ResponseDto responseDto = new ResponseDto();    List&lt;CourseContentFileDto&gt; fileDtoList = courseContentFileService.list(courseId);    responseDto.setContent(fileDtoList);    return responseDto;&#125;\n\n\n首先修改course.vue\n\n//增加模态框&lt;file v-bind:input-id=&quot;&#x27;content--upload&#x27;&quot;      v-bind:text=&quot;&#x27;上传文件&#x27;&quot;      v-bind:suffixs=&quot;[&#x27;jpg&#x27;, &#x27;jpeg&#x27;, &#x27;png&#x27;]&quot;      v-bind:use=&quot;FILE_USE.COURSE.key&quot;      v-bind:after-upload=&quot;afterUploadContentFile&quot;&gt;&lt;/file&gt;&lt;br&gt;&lt;table id=&quot;file-table&quot; class=&quot;table  table-bordered table-hover&quot;&gt;  &lt;thead&gt;  &lt;tr&gt;    &lt;th&gt;名称&lt;/th&gt;    &lt;th&gt;地址&lt;/th&gt;    &lt;th&gt;大小&lt;/th&gt;    &lt;th&gt;操作&lt;/th&gt;  &lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;  &lt;tr v-for=&quot;(f,i) in files&quot; v-bind:key=&quot;f.id&quot;&gt;    &lt;td&gt;&#123;&#123;f.name&#125;&#125;&lt;/td&gt;    &lt;td&gt;&#123;&#123;f.url&#125;&#125;&lt;/td&gt;    &lt;td&gt;&#123;&#123;f.size|formatFileSize&#125;&#125;&lt;/td&gt;    &lt;td&gt;        &lt;button v-on:click=&quot;delFile(f)&quot; class=&quot;btn btn-white btn-xs btn-warning&quot;&gt;          &lt;i class=&quot;ace-icon fa fa-times red2&quot;&gt;&lt;/i&gt;          删除        &lt;/button&gt;    &lt;/td&gt;  &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;//在data中增加变量files: [],//在editContent方法中增加，加载内容文件列表_this.listContentFiles();//添加相应方法 /**     * 加载文件列表     */    listContentFiles()&#123;      let _this =this;      _this.$ajax.get(process.env.VUE_APP_SERVER +&#x27;/business/admin/course-content-file/list&#x27;+_this.course.id).then((respond)=&gt;&#123;        let resp = respond.data;        if(resp.success)&#123;          _this.file = resp.content;        &#125;      &#125;);    &#125;,    /**     * 上传内容文件后，保存内容文件记录，流程：先使用文件上传组件，上传文件，并保存file表记录，前端拿到上传结果后，再调一次服务端，保存course_content_file表记录。     */    afterUploadContentFile(response) &#123;      let _this = this;      console.log(&quot;开始保存文件记录&quot;);      let file = response.content;      file.courseId = _this.course.id;      file.url = file.path;      _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/business/admin/course-content-file/save&#x27;, file).then((response)=&gt;&#123;        let resp = response.data;        if (resp.success) &#123;          Toast.success(&quot;上传文件成功&quot;);          _this.files.push(resp.content);        &#125;      &#125;);    &#125;,    /**     * 删除内容文件，这里的删除只是删除course-content-file表的记录，并没有删除真正的文件，也没有删除fie表的记录，看起来会导致脏数据，下一章我们会解决这个问题     */    delFile(f) &#123;      let _this = this;      Confirm.show(&quot;删除课程后不可恢复，确认删除？&quot;, function () &#123;        _this.$ajax.delete(process.env.VUE_APP_SERVER + &#x27;/business/admin/course-content-file/delete/&#x27; + f.id).then((response)=&gt;&#123;          let resp = response.data;          if (resp.success) &#123;            Toast.success(&quot;删除文件成功&quot;);            Tool.removeObj(_this.files, f);          &#125;        &#125;);      &#125;);    &#125;,\n\n\n在Tool.js中添加removeObj方法\n\n/** * 移除对象数组中的对象 * @param array * @param obj * @returns &#123;number&#125; */removeObj: function (array, obj) &#123;    let index = -1;    for (let i = 0; i &lt; array.length; i++) &#123;        if (array[i] === obj) &#123;            array.splice(i, 1);//splice(）方法向/从数组中添加/删除项目，然后返回被删除的项目。注释：该方法会改变原始数组。            index = i;            break;        &#125;    &#125;    return index;&#125;,\n\n  1.文件上传功能开发：将文件内容权态柜做成单独的页面，代码更容易维护，内容编辑更方便\n\n\n增加一个content页面\n\n&lt;template&gt;  &lt;div&gt;    &lt;h4 class=&quot;lighter&quot;&gt;      &lt;i class=&quot;ace-icon fa fa-hand-o-right icon-animated-hand-pointer blue&quot;&gt;&lt;/i&gt;      &lt;router-link to=&quot;/business/course&quot; class=&quot;pink&quot;&gt; &#123;&#123;course.name&#125;&#125; &lt;/router-link&gt;    &lt;/h4&gt;    &lt;hr&gt;    &lt;file v-bind:input-id=&quot;&#x27;content-file-upload&#x27;&quot;          v-bind:text=&quot;&#x27;上传文件&#x27;&quot;          v-bind:suffixs=&quot;[&#x27;jpg&#x27;, &#x27;jpeg&#x27;, &#x27;png&#x27;, &#x27;mp4&#x27;]&quot;          v-bind:use=&quot;FILE_USE.COURSE.key&quot;          v-bind:after-upload=&quot;afterUploadContentFile&quot;&gt;&lt;/file&gt;    &lt;br&gt;    &lt;table id=&quot;file-table&quot; class=&quot;table  table-bordered table-hover&quot;&gt;      &lt;thead&gt;      &lt;tr&gt;        &lt;th&gt;名称&lt;/th&gt;        &lt;th&gt;地址&lt;/th&gt;        &lt;th&gt;大小&lt;/th&gt;        &lt;th&gt;操作&lt;/th&gt;      &lt;/tr&gt;      &lt;/thead&gt;      &lt;tbody&gt;      &lt;tr v-for=&quot;(f, i) in files&quot; v-bind:key=&quot;f.id&quot;&gt;        &lt;td&gt;&#123;&#123;f.name&#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123;f.url&#125;&#125;&lt;/td&gt;        &lt;td&gt;&#123;&#123;f.size | formatFileSize&#125;&#125;&lt;/td&gt;        &lt;td&gt;          &lt;button v-on:click=&quot;delFile(f)&quot; class=&quot;btn btn-white btn-xs btn-warning btn-round&quot;&gt;            &lt;i class=&quot;ace-icon fa fa-times red2&quot;&gt;&lt;/i&gt;            删除          &lt;/button&gt;        &lt;/td&gt;      &lt;/tr&gt;      &lt;/tbody&gt;    &lt;/table&gt;    &lt;form class=&quot;form-horizontal&quot;&gt;      &lt;div class=&quot;form-group&quot;&gt;        &lt;div class=&quot;col-lg-12&quot;&gt;          &#123;&#123;saveContentLabel&#125;&#125;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;form-group&quot;&gt;        &lt;div class=&quot;col-lg-12&quot;&gt;          &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;form-group&quot;&gt;        &lt;div class=&quot;col-lg-12&quot;&gt;          &#123;&#123;saveContentLabel&#125;&#125;        &lt;/div&gt;      &lt;/div&gt;    &lt;/form&gt;    &lt;p&gt;      &lt;button type=&quot;button&quot; class=&quot;btn btn-white btn-info btn-round&quot; v-on:click=&quot;saveContent()&quot;&gt;        &lt;i class=&quot;ace-icon fa fa-plus blue&quot;&gt;&lt;/i&gt;        保存      &lt;/button&gt;&amp;nbsp;      &lt;router-link to=&quot;/business/course&quot; type=&quot;button&quot; class=&quot;btn btn-white btn-default btn-round&quot; data-dismiss=&quot;modal&quot;&gt;        &lt;i class=&quot;ace-icon fa fa-times&quot;&gt;&lt;/i&gt;        返回课程      &lt;/router-link&gt;    &lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import File from &quot;../../components/file&quot;;export default &#123;  components: &#123;File&#125;,  name: &quot;business-course-content&quot;,  data: function() &#123;    return &#123;      course: &#123;&#125;,      FILE_USE: FILE_USE,      saveContentLabel: &quot;&quot;,      files: [],      saveContentInterval: &#123;&#125;,    &#125;  &#125;,  mounted: function() &#123;    let _this = this;    let course = SessionStorage.get(SESSION_KEY_COURSE) || &#123;&#125;;    if (Tool.isEmpty(course)) &#123;      _this.$router.push(&quot;/welcome&quot;);    &#125;    _this.course = course;    _this.init();    // sidebar激活样式方法一    this.$parent.activeSidebar(&quot;business-course-sidebar&quot;);  &#125;,  destroyed: function() &#123;    let _this = this;    console.log(&quot;组件销毁&quot;);    clearInterval(_this.saveContentInterval);  &#125;,  methods: &#123;    /**     * 打开内容编辑框     */    init() &#123;      let _this = this;      let course = _this.course;      let id = course.id;      $(&quot;#content&quot;).summernote(&#123;        focus: true,        height: 300      &#125;);      // 先清空历史文本      $(&quot;#content&quot;).summernote(&#x27;code&#x27;, &#x27;&#x27;);      _this.saveContentLabel = &quot;&quot;;      // 加载内容文件列表      _this.listContentFiles();      Loading.show();      _this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/business/admin/course/find-content/&#x27; + id).then((response)=&gt;&#123;        Loading.hide();        let resp = response.data;        if (resp.success) &#123;          if (resp.content) &#123;            $(&quot;#content&quot;).summernote(&#x27;code&#x27;, resp.content.content);          &#125;          // 定时自动保存          _this.saveContentInterval = setInterval(function() &#123;            _this.saveContent();          &#125;, 5000);        &#125; else &#123;          Toast.warning(resp.message);        &#125;      &#125;);    &#125;,    /**     * 保存内容     */    saveContent () &#123;      let _this = this;      let content = $(&quot;#content&quot;).summernote(&quot;code&quot;);      _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/business/admin/course/save-content&#x27;, &#123;        id: _this.course.id,        content: content      &#125;).then((response)=&gt;&#123;        Loading.hide();        let resp = response.data;        if (resp.success) &#123;          // Toast.success(&quot;内容保存成功&quot;);          // let now = Tool.dateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);          let now = Tool.dateFormat(&quot;mm:ss&quot;);          _this.saveContentLabel = &quot;最后保存时间：&quot; + now;        &#125; else &#123;          Toast.warning(resp.message);        &#125;      &#125;);    &#125;,    /**     * 加载内容文件列表     */    listContentFiles() &#123;      let _this = this;      _this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/business/admin/course-content-file/list/&#x27; + _this.course.id).then((response)=&gt;&#123;        let resp = response.data;        if (resp.success) &#123;          _this.files = resp.content;        &#125;      &#125;);    &#125;,    /**     * 上传内容文件后，保存内容文件记录     */    afterUploadContentFile(response) &#123;      let _this = this;      console.log(&quot;开始保存文件记录&quot;);      let file = response.content;      file.courseId = _this.course.id;      file.url = file.path;      _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/business/admin/course-content-file/save&#x27;, file).then((response)=&gt;&#123;        let resp = response.data;        if (resp.success) &#123;          Toast.success(&quot;上传文件成功&quot;);          _this.files.push(resp.content);        &#125;      &#125;);    &#125;,    /**     * 删除内容文件     */    delFile(f) &#123;      let _this = this;      Confirm.show(&quot;删除课程后不可恢复，确认删除？&quot;, function () &#123;        _this.$ajax.delete(process.env.VUE_APP_SERVER + &#x27;/business/admin/course-content-file/delete/&#x27; + f.id).then((response)=&gt;&#123;          let resp = response.data;          if (resp.success) &#123;            Toast.success(&quot;删除文件成功&quot;);            Tool.removeObj(_this.files, f);          &#125;        &#125;);      &#125;);    &#125;,  &#125;&#125;&lt;/script&gt;\n\n\n原来是逻辑是打开模态框时，开始定时任务，关闭模态框时，清除定时任务。现在要改为打开页面组件初始化时（mounted），开始定时任务，页面组件销毁时（destroyed），清除定时任务。\n\n修改course.vue\n\n\n&lt;button v-on:click=&quot;toContent(course)&quot; class=&quot;btn btn-white btn-xs btn-info btn-round&quot;&gt;  内容&lt;/button&gt;&amp;nbsp;&amp;nbsp;//增加toContent方法\t/**     * 点击内容     * @param course     */    toContent(course) &#123;      let _this = this;      SessionStorage.set(SESSION_KEY_COURSE, course);      _this.$router.push(&quot;/business/content&quot;);    &#125;,\n\n\n增加路由router.js\n\nimport Content from &quot;./views/admin/content.vue&quot;&#123;    path: &quot;business/content&quot;,    name:&quot;business/content&quot;,    component: Content,&#125;,\n\n","tags":["完整项目"]},{"title":"完整项目之Spring Cloud + Vue 前后端分离3-2","url":"/2022/02/25/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E4%B9%8BSpring%20Cloud%20+%20Vue%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%203-2/","content":"第9章 大文件断点续与极速秒传本章将在上一章的基础上增加大文件断点续传功能。作为一个视频网站，一个文件从几十M到上G，上传一个大文件受网络影响很大，一次上传成功的几率很小，为此我们会在本章完善文件上传功能，支持断点续传并且上传文件时，检查文件是否上传过实现极速秒传。…\n\n9-1 分片传输的试探分片上传：1.大文件断原续传与极速秒传：增加big-fi1e组件，分片传输测试成功\n\n极速秒传听起来很高深，原理其实很简单，就是开始上传前，先检查一下文件是否上传过了，如果已上传过，直接弹出提示，极速秒传成功。\n\n一个文件有10M，每个分片定义为1M，那这个文件就会被分为10片进行传输\n\n首先创建一个组件big-file就是把file复制过去修改下\n\n\n//修改姓名和文本name: &#x27;big-file&#x27;,  props: &#123;    text: &#123;      default: &quot;上传大文件&quot;    &#125;,  &#125;//在uploadFile中增加文件分片let shardSize=20 * 1024 * 1024;//以20MB为一个分片let shardIndex = 0;//分片索引let start = shardIndex * shardSize;//当前分片起始位置let end = Math.min(file.size,start+shardSize);//当前分片结束位置let fileShard = file.slice(start,end);//从文件中截取当前的分片数据// key：&quot;file&quot;必须和后端controller参数名一致formData.append(&#x27;file&#x27;, fileShard);\n\n\nfile.slice（），对文件进行截取\n\n在section中引入big-file，并将file组件改为big-file\n\n\nimport BigFile from &quot;../../components/big-file&quot;;export default &#123;  components: &#123;Pagination,BigFile&#125;,\n\n分片合并：1.大文件断点续传与极速秒传：分片合并测试成功\n\n在UploadController中增加方法\n\n@GetMapping(&quot;merge&quot;)public ResponseDto merge() throws Exception &#123;    File newFile = new File(FILE_PATH + &quot;/course/test123.mp4&quot;);    FileOutputStream outputStream = new FileOutputStream(newFile, true);//文件追加写入    FileInputStream fileInputStream = null;//分片文件    byte[] byt = new byte[10 * 1024 * 1024];    int len;    try &#123;        //读取第一个分片        fileInputStream = new FileInputStream(new File(FILE_PATH + &quot;/course/G8Yfj2Ij.blob&quot;));        while ((len = fileInputStream.read(byt)) != -1) &#123;            outputStream.write(byt, 0, len);        &#125;        //读第二个分片        fileInputStream = new FileInputStream(new File(FILE_PATH + &quot;/course/NUTxyaDe.blob&quot;));        while ((len = fileInputStream.read(byt)) != -1) &#123;            outputStream.write(byt, 0, len);        &#125;    &#125;catch (IOException e)&#123;        LOG.error(&quot;分片异常&quot;,e);    &#125;finally &#123;        try &#123;            if(fileInputStream!=null)&#123;                fileInputStream.close();            &#125;            outputStream.close();            LOG.info(&quot;IO流关闭&quot;);        &#125;catch (Exception e)&#123;            LOG.error(&quot;IO流关闭&quot;,e);        &#125;    &#125;    ResponseDto responseDto = new ResponseDto();    return  responseDto;&#125;\n\n9-2 分片上传功能开发1文件分片管理的模型设计：\n1.大文件断点续传与极速秒传：文件表增加分片相关字段\n\n\n在all.sql的“文件”中增加，然后mybatis-generator\n\nalter table `file` add column (`Shard_index` int comment &#x27;已上传分片&#x27;);alter table `file` add column (`Shard_size` int comment &#x27;分片大小|B&#x27;);alter table `file` add column (`Shard_total` int comment &#x27;分片总数&#x27;);alter table `file` add column (`key` varchar(32) comment &#x27;文件标识&#x27;);alter table `file` add unique key key_unique(`key`);\n\n分片数据传输：\n\n经验分享：对于对于一些不涉及安全性的数据，可以交由前端来计算，这样可以减轻服务端的压力\n\n我们将File中生成的变量复制到filedto中然后生成get和set和tostring方法\n\n然后我们对前端big-file组件做修改：\n\n\nlet size = file.size;let shardTotal = Math.ceil(size/shardSize);//总片数// key：&quot;file&quot;必须和后端controller参数名一致formData.append(&#x27;shard&#x27;, fileShard);formData.append(&#x27;shardIndex&#x27;, shardIndex);formData.append(&#x27;shardSize&#x27;, shardSize);formData.append(&#x27;shardTotal&#x27;, shardTotal);//提交表单时将use也提交出去formData.append(&#x27;use&#x27;, _this.use);formData.append(&#x27;name&#x27;, file.name);formData.append(&#x27;suffix&#x27;, suffix);formData.append(&#x27;size&#x27;, size);\n\n\n其次对服务端UploadController做修改：\n\n//对传入参数进行增加public ResponseDto upload(@RequestParam MultipartFile shard,                                            String use,                                            String name,                                            String suffix,                                            Integer size,                                            Integer shardIndex,                                            Integer shardSize,                                            Integer shardTotal) throws IOException &#123;//将file改为shardshard.transferTo(dest);//将里面参数进行修改fileDto.setName(name);fileDto.setSize(size);//再将新增参数设置进去fileDto.setShardIndex(shardIndex);fileDto.setSize(shardSize);fileDto.setShardTotal(shardTotal);fileDto.setKey(key);\n\n文件标识的设计：1.大文件断点续传与极速秒传：使用文件生成md5签名，作为文件标识\n\n数据库设计上传第一个分片时，插入一条记录，上传之后的分片都是更新记录，只需更新shard_index字段，当然也包括updated_at\n\n数据库设计：shard_index和shard_total的值相等时表示所有分片都已上传完成\n\n数据库设计：不管上传第几个分片，传输的key值是一样的，key跟文件相关，跟分片无关\n\nMD5信息摘要算法，常用于密码加密传输与存储，会生成128位二制数，每4个二进制可以转成1个16进制数字，结果是32个16进制数字\n\n26个大写字字母+26个小写字母+10个阿拉伯数字，共62个字符，可以表达62进制数字。\n\n首先我们增加md5.js文件\n\n\nvar KEY = &quot;!@#QWERT&quot;;/* * Configurable variables. You may need to tweak these to be compatible with * the server-side, but the defaults work in most cases. */var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      *//* * These are the functions you&#x27;ll usually want to call * They take string arguments and return either hex or base-64 encoded strings */function hex_md5(s)&#123; return binl2hex(core_md5(str2binl(s), s.length * chrsz));&#125;function b64_md5(s)&#123; return binl2b64(core_md5(str2binl(s), s.length * chrsz));&#125;function str_md5(s)&#123; return binl2str(core_md5(str2binl(s), s.length * chrsz));&#125;function hex_hmac_md5(key, data) &#123; return binl2hex(core_hmac_md5(key, data)); &#125;function b64_hmac_md5(key, data) &#123; return binl2b64(core_hmac_md5(key, data)); &#125;function str_hmac_md5(key, data) &#123; return binl2str(core_hmac_md5(key, data)); &#125;/* * Perform a simple self-test to see if the VM is working */function md5_vm_test()&#123;  return hex_md5(&quot;abc&quot;) == &quot;900150983cd24fb0d6963f7d28e17f72&quot;;&#125;/* * Calculate the MD5 of an array of little-endian words, and a bit length */function core_md5(x, len)&#123;  /* append padding */  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; ((len) % 32);  x[(((len + 64) &gt;&gt;&gt; 9) &lt;&lt; 4) + 14] = len;  var a =  1732584193;  var b = -271733879;  var c = -1732584194;  var d =  271733878;  for(var i = 0; i &lt; x.length; i += 16)  &#123;    var olda = a;    var oldb = b;    var oldc = c;    var oldd = d;    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);    a = safe_add(a, olda);    b = safe_add(b, oldb);    c = safe_add(c, oldc);    d = safe_add(d, oldd);  &#125;  return Array(a, b, c, d);&#125;/* * These functions implement the four basic operations the algorithm uses. */function md5_cmn(q, a, b, x, s, t)&#123;  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);&#125;function md5_ff(a, b, c, d, x, s, t)&#123;  return md5_cmn((b &amp; c) | ((~b) &amp; d), a, b, x, s, t);&#125;function md5_gg(a, b, c, d, x, s, t)&#123;  return md5_cmn((b &amp; d) | (c &amp; (~d)), a, b, x, s, t);&#125;function md5_hh(a, b, c, d, x, s, t)&#123;  return md5_cmn(b ^ c ^ d, a, b, x, s, t);&#125;function md5_ii(a, b, c, d, x, s, t)&#123;  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);&#125;/* * Calculate the HMAC-MD5, of a key and some data */function core_hmac_md5(key, data)&#123;  var bkey = str2binl(key);  if(bkey.length &gt; 16) bkey = core_md5(bkey, key.length * chrsz);  var ipad = Array(16), opad = Array(16);  for(var i = 0; i &lt; 16; i++)  &#123;    ipad[i] = bkey[i] ^ 0x36363636;    opad[i] = bkey[i] ^ 0x5C5C5C5C;  &#125;  var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);  return core_md5(opad.concat(hash), 512 + 128);&#125;/* * Add integers, wrapping at 2^32. This uses 16-bit operations internally * to work around bugs in some JS interpreters. */function safe_add(x, y)&#123;  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);&#125;/* * Bitwise rotate a 32-bit number to the left. */function bit_rol(num, cnt)&#123;  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));&#125;/* * Convert a string to an array of little-endian words * If chrsz is ASCII, characters &gt;255 have their hi-byte silently ignored. */function str2binl(str)&#123;  var bin = Array();  var mask = (1 &lt;&lt; chrsz) - 1;  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (i%32);  return bin;&#125;/* * Convert an array of little-endian words to a string */function binl2str(bin)&#123;  var str = &quot;&quot;;  var mask = (1 &lt;&lt; chrsz) - 1;  for(var i = 0; i &lt; bin.length * 32; i += chrsz)    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (i % 32)) &amp; mask);  return str;&#125;/* * Convert an array of little-endian words to a hex string. */function binl2hex(binarray)&#123;  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;  var str = &quot;&quot;;  for(var i = 0; i &lt; binarray.length * 4; i++)  &#123;    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((i%4)*8+4)) &amp; 0xF) +           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((i%4)*8  )) &amp; 0xF);  &#125;  return str;&#125;/* * Convert an array of little-endian words to a base-64 string */function binl2b64(binarray)&#123;  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;  var str = &quot;&quot;;  for(var i = 0; i &lt; binarray.length * 4; i += 3)  &#123;    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * ( i   %4)) &amp; 0xFF) &lt;&lt; 16)                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * ((i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * ((i+2)%4)) &amp; 0xFF);    for(var j = 0; j &lt; 4; j++)    &#123;      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);    &#125;  &#125;  return str;&#125;\n\n\n然后我们在index中引用\n\n&lt;!--  md5工具类--&gt;&lt;script src=&quot;&lt;%= BASE_URL %&gt;static/js/md5.js&quot;&gt;&lt;/script&gt;\n\n\n然后再big-file中就可以使用了，再uploadFile中增加\n\n//生成文件标识，标识多次上传的是不是同一文件let key = hex_md5(file);let key10 = parseInt(key,16);let key62 = Tool._10to62(key10);console.log(key,key10,key62)//表单增加keyformData.append(&#x27;key&#x27;, key62);\n\n\n对于Tool._10to62方法，我们在tool中增加\n\n/** * 10进制转62进制 * @param number * @returns &#123;string&#125; * @private */_10to62: function (number) &#123;    let chars = &#x27;0123456789abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&#x27;;    let radix = chars.length;    let arr = [];    do &#123;        let mod = number % radix;        number = (number - mod) / radix;        arr.unshift(chars[mod]);    &#125; while (number);    return arr.join(&#x27;&#x27;);&#125;,\n\n\n在UploadController增加String key参数，将自定义参数key删了\n\n大文件断点续传与极速秒传：根据文件标识来新增或修改文件记录，修改分片索引从1开始\n\n实际使用场景中，一个文件太大，当第一次上传一半，失败了。第二次再上传时，有可能隔了一天或更久\n\n我们对FileService进行修改\n\n\n//增加方法public File selectByKet(String key)&#123;    FileExample example = new FileExample();    example.createCriteria().andKeyEqualTo(key);    List&lt;File&gt; fileList = fileMapper.selectByExample(example);    if(CollectionUtils.isEmpty(fileList))&#123;        return null;    &#125;else&#123;        return fileList.get(0);    &#125;&#125;//使用方法public void save(FileDto fileDto)&#123;        File file = CopyUtil.copy(fileDto, File.class);        File fileDb = selectByKet(fileDto.getKey());        if(fileDb == null)&#123;            this.insert(file);        &#125;else&#123;            fileDb.setShardIndex(fileDb.getShardIndex());            this.update(fileDb);        &#125;    &#125;\n\n\nbig-file中也进行修改，1标识第一个分片\n\nlet shardIndex = 1;//分片索引 1标识第一个分片let start = (shardIndex-1) * shardSize;//当前分片起始位置\n\n9-3 分片上传功能开发2分片数据格式转换，统一系统前后端数据交互传参：1.大文件断点续传与极速秒传：分片数据改成base64进行传输，后端统一用RequestBody接收数据\n\n将file类型转换成String有一个方法就是base64\n\n首先在big-file中的uploadFile方法增加\n\n\nlet fileReader = new FileReader();  fileReader.onload = function (e)&#123;//当读分片数据时就会触发onload事件监听    let base64 = e.target.result;    let param = &#123;//就可以将上面append那些注释掉了      &#x27;shard&#x27;:base64,      &#x27;shardIndex&#x27;: shardIndex,      &#x27;shardSize&#x27;: shardSize,      &#x27;shardTotal&#x27;: shardTotal,      &#x27;use&#x27;: _this.use,      &#x27;name&#x27;: file.name,      &#x27;suffix&#x27;: suffix,      &#x27;size&#x27;: size,      &#x27;key&#x27;: key62    &#125;;    Loading.show();    _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/file/admin/upload&#x27;, param).then((response)=&gt;&#123;      Loading.hide();      let resp = response.data;      console.log(&quot;上传文件成功：&quot;, resp);      _this.afterUpload(resp);      $(&quot;#&quot; + _this.inputId + &quot;-input&quot;).val(&quot;&quot;);    &#125;);  &#125;;  fileReader.readAsDataURL(fileShard);//这个方法去读分片数据&#125;,\n\n\n这时我们就可以在UploadController中将参数改了\n\npublic ResponseDto upload(@RequestBody FileDto fileDto) //删除一些东西//FileDto fileDto = new FileDto();fileDto.setPath(path);//fileDto.setName(name);//fileDto.setSize(size);//fileDto.setSuffix(suffix);//fileDto.setUse(use);//fileDto.setShardIndex(shardIndex);//fileDto.setSize(shardSize);//.setShardTotal(shardTotal);//fileDto.setKey(key);\n\n\n记得在FileDto中增加，生成方法和tostring\n\n/** *base64 */private  String shard;\n\n\n这时有四个变量没有定义我们将他们定义成本地变量\n\nString use = fileDto.getUse();String key = fileDto.getKey();String suffix = fileDto.getSuffix();String shardBase64 = fileDto.getShard();\n\n\n这时我还有一处报错，因为现在的shard是String类型，我们还要把string类型转成MultipartFile，所以我们将shard名改为shardBase64，不使用同一名称。\n\n我们在util增加Base64ToMultipartFile类\n\n\npackage com.course.server.util;import org.springframework.web.multipart.MultipartFile;import sun.misc.BASE64Decoder;import java.io.*;public class Base64ToMultipartFile implements MultipartFile &#123;    private final byte[] imgContent;    private final String header;    public Base64ToMultipartFile(byte[] imgContent, String header) &#123;        this.imgContent = imgContent;        this.header = header.split(&quot;;&quot;)[0];    &#125;    @Override    public String getName() &#123;        // TODO - implementation depends on your requirements        return System.currentTimeMillis() + Math.random() + &quot;.&quot; + header.split(&quot;/&quot;)[1];    &#125;    @Override    public String getOriginalFilename() &#123;        // TODO - implementation depends on your requirements        return System.currentTimeMillis() + (int) Math.random() * 10000 + &quot;.&quot; + header.split(&quot;/&quot;)[1];    &#125;    @Override    public String getContentType() &#123;        // TODO - implementation depends on your requirements        return header.split(&quot;:&quot;)[1];    &#125;    @Override    public boolean isEmpty() &#123;        return imgContent == null || imgContent.length == 0;    &#125;    @Override    public long getSize() &#123;        return imgContent.length;    &#125;    @Override    public byte[] getBytes() throws IOException &#123;        return imgContent;    &#125;    @Override    public InputStream getInputStream() throws IOException &#123;        return new ByteArrayInputStream(imgContent);    &#125;    @Override    public void transferTo(File dest) throws IOException, IllegalStateException &#123;        new FileOutputStream(dest).write(imgContent);    &#125;    public static MultipartFile base64ToMultipart(String base64) &#123;        try &#123;            String[] baseStrs = base64.split(&quot;,&quot;);            BASE64Decoder decoder = new BASE64Decoder();            byte[] b = new byte[0];            b = decoder.decodeBuffer(baseStrs[1]);            for(int i = 0; i &lt; b.length; ++i) &#123;                if (b[i] &lt; 0) &#123;                    b[i] += 256;                &#125;            &#125;            return new Base64ToMultipartFile(b, baseStrs[0]);        &#125; catch (IOException e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;&#125;\n\n\n最后我们在UploadController使用\n\nMultipartFile shard = Base64ToMultipartFile.base64ToMultipart(shardBase64);\n\n\nbase64格式：文件说明+“+文件内容\n\n将文件转成base64进行传输，优势是变成了常见的字符串类型，劣势是传输的数据会变大\n\n\n设置分片文件名:\n\n小提示：当字符串拼接个数大多时，不要使用+，而是使用StringBuffer\n\n//String path = dir + File.separator + key + &quot;.&quot; + suffix+ &quot;.&quot; +fileDto.getShardIndex();String path = new StringBuffer(dir)        .append(File.separator)        .append(key)        .append(&quot;.&quot;)        .append(suffix)        .append(&quot;.&quot;)        .append(fileDto.getShardIndex()).toString();\n\n支持连续上传多个分片:\n\n在上传结束时，做个判断，如果shardlndex&#x3D;&#x3D;shardTotal，表示所有分片都上传完成了,如果shardindex&lt;shardTotal，继续上传下一个分片。以下在big-file中进行\n\nif (shardIndex &lt; shardTotal) &#123;  // 上传下一个分片  param.shardIndex = param.shardIndex + 1;  _this.upload(param);&#125; else &#123;  _this.afterUpload(resp);  $(&quot;#&quot; + _this.inputId + &quot;-input&quot;).val(&quot;&quot;);&#125;\n\n\n递归，不断的重复做某一件事（上传分片），直到某个条件成立（shardlndex&#x3D;&#x3D;shardTotal），退出重复做的事。\n\n然后将代码重构\n\n\n/** * 将分片数据转成base64进行上传 */upload (param) &#123;  let _this = this;  let shardIndex = param.shardIndex;  let shardTotal = param.shardTotal;  let shardSize = param.shardSize;  let fileShard = _this.getFileShard(shardIndex, shardSize);  // 将图片转为base64进行传输  let fileReader = new FileReader();  fileReader.onload = function (e) &#123;    let base64 = e.target.result;    // console.log(&quot;base64:&quot;, base64);    param.shard = base64;    Loading.show();    _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/file/admin/upload&#x27;, param).then((response) =&gt; &#123;      Loading.hide();      let resp = response.data;      console.log(&quot;上传文件成功：&quot;, resp);      if (shardIndex &lt; shardTotal) &#123;        // 上传下一个分片        param.shardIndex = param.shardIndex + 1;        _this.upload(param);      &#125; else &#123;        _this.afterUpload(resp);        $(&quot;#&quot; + _this.inputId + &quot;-input&quot;).val(&quot;&quot;);      &#125;    &#125;);  &#125;;  fileReader.readAsDataURL(fileShard);&#125;,\n\ngetFileShard (shardIndex, shardSize) &#123;  let _this = this;  let file = _this.$refs.file.files[0];  let start = (shardIndex - 1) * shardSize;  //当前分片起始位置  let end = Math.min(file.size, start + shardSize); //当前分片结束位置  let fileShard = file.slice(start, end); //从文件中截取当前的分片数据  return fileShard;&#125;,\n\n9-4 分片合并功能开发按分片顺序合并成原始文件：\n\n保存到本地的分片名是xxx.mp4.1，但是我们返给前端和保存进数据库的path都用xxx.mp4\n\nUploadController首先我们先修改下路径，一个文件带多余后缀的，一个不带的\n\n\nString path = new StringBuffer(dir)        .append(File.separator)        .append(key)        .append(&quot;.&quot;)        .append(suffix)        .toString();String localPath = new StringBuffer(path)        .append(&quot;.&quot;)        .append(fileDto.getShardIndex()).toString();String fullPath = FILE_PATH + localPath;\n\n\n然后我们想要将分片合并，这时我们就要判断分片是不是最后一个分片，如果是就调用本地方法merge\n\nif(fileDto.getShardIndex().equals(fileDto.getShardTotal()) )&#123;//因为是一个对象所以用equals    this.merge(fileDto);&#125;\n\n\n最后修改merge\n\npublic void merge(FileDto fileDto) throws Exception &#123;        LOG.info(&quot;合并分片开始&quot;);        String path = fileDto.getPath();//这个是全路径，我们只需要绝对路径        path = path.replace(FILE_DOMAIN,&quot;&quot;);        Integer ShardTotal = fileDto.getShardTotal();        File newFile = new File(FILE_PATH + path);        //FileOutputStream outputStream = new FileOutputStream(newFile, true);//文件追加写入        //FileInputStream fileInputStream = null;//分片文件       // byte[] byt = new byte[10 * 1024 * 1024];       // int len;       // try &#123;            for (int i = 0; i &lt; shardTotal; i++) &#123;                //读取第i个分片                fileInputStream = new FileInputStream(new File(FILE_PATH + path+&quot;.&quot;+(i+1)));                while ((len = fileInputStream.read(byt)) != -1) &#123;                    outputStream.write(byt, 0, len);                &#125;            &#125;       // &#125;catch (IOException e)&#123;            //LOG.error(&quot;分片异常&quot;,e);        //&#125;finally &#123;           // try &#123;              //  if(fileInputStream!=null)&#123;               //     fileInputStream.close();              //  &#125;              //  outputStream.close();              //  LOG.info(&quot;IO流关闭&quot;);//&#125;catch (Exception e)&#123;               // LOG.error(&quot;IO流关闭&quot;,e);            &#125;        &#125;        LOG.info(&quot;合并分片结束&quot;);    &#125;&#125;\n\n合并完成后删除多余分片:1.大文件断点续传与极速秒传：合并成原始文件后，删除所有分片\n\n就是在合并分片结束后加一个删除分片\n\nSystem.gc();//删除分片LOG.info(&quot;删除分片开始&quot;);for (int i = 0; i &lt; shardTotal; i++) &#123;    String filePath = FILE_PATH+path+&quot;.&quot;+(i+1);    File file = new File(filePath);    boolean result = file.delete();    LOG.info(&quot;删除&#123;&#125;,&#123;&#125;&quot;,filePath,result?&quot;成功&quot; : &quot;失败&quot;);&#125;LOG.info(&quot;删除分片结束&quot;);\n\n9-5 分片检查与极速秒传上传分片之前先进行分片检查：1.大文件断点续传与极速秒传：上传分片之前先进行分片检查，支持断点续传\n\n开始上传之前，先检查资源率当前的文件是否上传过了（数据库是否有记录），如果上传过了，已经传到第几个分片了。\n\n首先在FileService中增加方法\n\n\n/** * 根据文件标识查询数据库记录 */public FileDto findByKey(String key)&#123;    return CopyUtil.copy(selectByKet(key),FileDto.class);&#125;\n\n\n然后再UploadController中使用\n\n@GetMapping(&quot;/check/&#123;key&#125;&quot;)public  ResponseDto check(@PathVariable String key)&#123;    LOG.info(&quot;减产上传分片开始：&#123;&#125;&quot;,key);    ResponseDto responseDto = new ResponseDto();    FileDto fileDto = fileService.findByKey(key);    responseDto.setContent(fileDto);    return  responseDto;&#125;\n\n\n最后修改big-file将uploadFile方法中的_this.upload改为  _this.check(param);增加check方法\n\n/** * 检查文件状态，是否已上传过？上传到第几个分片？ */check(param)&#123;  let _this =this;  _this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/file/admin/check/&#x27;+param.key).then((response)=&gt;&#123;    let resp = response.data;    if (resp.success)&#123;      let obj = resp.content;      if (!obj)&#123;        param.shardIndex = 1;        console.log(&quot;没有找到文件记录，从分片1开始上传&quot;);        _this.upload(param);      &#125;else&#123;        param.shardIndex = obj.shardIndex+1;        console.log(&quot;找到文件记录，从分片&quot;+param.shardIndex+&quot;开始上传&quot;);        _this.upload(param);      &#125;    &#125;else&#123;      Toast.warning(&quot;文件上传失败&quot;);      $(&quot;#&quot;+_this.inputId+&quot;-input&quot;).val(&quot;&quot;);    &#125;  &#125;)&#125;,\n\n极速秒传：就是检查是否已经上传过了文件，如果上传过了就显示极速秒传\n\n首先再big-file中的check增加代码\n\n/** * 检查文件状态，是否已上传过？上传到第几个分片？ */check(param)&#123;  let _this =this;  _this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/file/admin/check/&#x27;+param.key).then((respond)=&gt;&#123;    let resp = respond.data;    if (resp.success)&#123;      let obj = resp.content;      if (!obj)&#123;        param.shardIndex = 1;        console.log(&quot;没有找到文件记录，从分片1开始上传&quot;);        _this.upload(param);      &#125;else if(obj.shardIndex === obj.shardTotal)&#123;//增加这行        Toast.success(&quot;文件极速秒传成功！&quot;);        _this.afterUpload(resp);        $(&quot;#&quot;+_this.inputId+&quot;-input&quot;).val(&quot;&quot;);      &#125;else&#123;        param.shardIndex = obj.shardIndex+1;        console.log(&quot;找到文件记录，从分片&quot;+param.shardIndex+&quot;开始上传&quot;);        _this.upload(param);      &#125;    &#125;else&#123;      Toast.warning(&quot;文件上传失败&quot;);      $(&quot;#&quot;+_this.inputId+&quot;-input&quot;).val(&quot;&quot;);    &#125;  &#125;)&#125;,\n\n\n再UploadController中增加,返回前端的应该是全路径\n\npublic  ResponseDto check(@PathVariable String key)&#123;    LOG.info(&quot;减产上传分片开始：&#123;&#125;&quot;,key);    ResponseDto responseDto = new ResponseDto();    FileDto fileDto = fileService.findByKey(key);    if(fileDto != null)&#123;//增加这个        fileDto.setPath(FILE_DOMAIN+fileDto.getPath());    &#125;    responseDto.setContent(fileDto);    return  responseDto;&#125;\n\n增加上传进度条：\n\n可以做成vue组件，也可以做成is工具类，做成vue组件的话，就只能在vue框架中使用，做成js组件的话可以在isp页面、thymelea模板页面、angular等前端框架中直接使用。\n\nprogress-div显示的进度条，progress-overlay：背景遮罩，将页面所有的元素挡住，不可点击任何地方，常用于防止重复提交。\n\n做成is全局工具类，可以直接使用，不需要import\n\n首先再js中创建Progress.js代码\n\n\nProgress = &#123;  show: function (width) &#123;    let _this = this;    _this.width = width;    if ($(&quot;#progress-div&quot;).length &gt; 0) &#123;      $(&quot;.progress&quot;).attr(&quot;data-percent&quot;, width);      $(&quot;.progress-bar&quot;).width(width + &quot;%&quot;);    &#125; else &#123;      let progressDiv = &quot;&lt;div id=\\&quot;progress-div\\&quot; style=\\&quot;z-index: 10011;\\n&quot; +        &quot;    position: fixed;\\n&quot; +        &quot;    padding: 10px;\\n&quot; +        &quot;    margin: 0px 0px 0px -150px;\\n&quot; +        &quot;    width: 300px;\\n&quot; +        &quot;    top: 40%;\\n&quot; +        &quot;    left: 50%;\\n&quot; +        &quot;    text-align: center;\\n&quot; +        &quot;    height: 45px;\\n&quot; +        &quot;    color: rgb(0, 0, 0);\\n&quot; +        &quot;    border: 3px solid rgb(170, 170, 170);\\n&quot; +        &quot;    background-color: rgb(255, 255, 255);\\n&quot; +        &quot;    cursor: wait;\\&quot;&gt;&lt;div class=\\&quot;progress pos-rel\\&quot; data-percent=\\&quot;&quot; + width + &quot;%\\&quot;&gt;&lt;div class=\\&quot;progress-bar\\&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&quot;;      $(&quot;#progress-div&quot;).remove();      $(&quot;body&quot;).append(progressDiv);      // 背景遮罩      $(&quot;body&quot;).append($(&quot;&lt;div id=\\&quot;progress-overlay\\&quot; style=\\&quot;z-index: 10010;\\n&quot; +        &quot;  border: none;\\n&quot; +        &quot;  margin: 0px;\\n&quot; +        &quot;  padding: 0px;\\n&quot; +        &quot;  width: 100%;\\n&quot; +        &quot;  height: 100%;\\n&quot; +        &quot;  top: 0px;\\n&quot; +        &quot;  left: 0px;\\n&quot; +        &quot;  background-color: rgb(0, 0, 0);\\n&quot; +        &quot;  opacity: 0.6;\\n&quot; +        &quot;  cursor: wait;\\n&quot; +        &quot;  position: fixed;\\&quot;&gt;&lt;/div&gt;&quot;));      $(&quot;.progress-bar&quot;).width(width + &quot;%&quot;);    &#125;  &#125;,  hide: function () &#123;    setTimeout(function () &#123;      $(&quot;#progress-div&quot;).remove();      $(&quot;#progress-overlay&quot;).remove();    &#125;, 1000);  &#125;&#125;;\n\n\n然后再index中引入\n\n&lt;!--  进度条  --&gt;&lt;script src=&quot;&lt;%= BASE_URL %&gt;static/js/progress.js&quot;&gt;&lt;/script&gt;\n\n\n在big-file中使用\n\nProgress.show(parseInt((shardIndex-1)*100/shardTotal));console.log(&quot;上传文件成功：&quot;, resp);Progress.show(parseInt((shardIndex)*100/shardTotal));Progress.hide(); \n\n大文件断点续传与极速秒传：讲师师头像和课程封面改用大文件组件：\n\n就是将teacher和course中file改为big-file，并且将大组件引入。\n\n我们还将改下big-file中，hex_md5中的参数，如果直接传入file，所得的md5永远都是一个值，因为这样相当于传入一个空数组\n\n\n//生成文件标识，标识多次上传的是不是同一文件let key = hex_md5(file.name+file.size+file.type);let key10 = parseInt(key,16);let key62 = Tool._10to62(key10);console.log(key,key10,key62);console.log(hex_md5(Array()));\n\n9-6 文件上传流程图\n\n\n第10章 基于阿里云OSS的文件上传在线视频课程的核心内容就是视频，保障视频不外泄是程序的重中之重，所以我们需要对视频做加密处理，本章我们选择阿里云视频加密，阿里云视频点播是对OSS的包装，支持防盗链和视频加密。\n\n10-1 阿里云OSS简介\n前面介绍的文件上传是基于本地文件服务器的文件上传，但是自己搭文件服务器会有很多运维的问题，比如磁盘满了要扩容，高峰期要增加带宽，低谷期要减少带宽，为了安全，我们还要对文件做备份等等所以一般会选择云平台来存储文件，云平台有很多，比如阿里云、腾讯云、百度云等，云平台做得最好的是亚马逊我们这里选择国内最大的阿里云。\n防盗链：防止别人盗用你网站资源链接，包括视频，音频，图片等\n从浏览器通过ECS（服务器）访问OSS算内网访问，不算流量费，但是要考虑ECS的带宽问题。从浏览器直接访问OSS资源，算外网访问OSS需付流量费，但是可以不用考虑带宽\n\n10-2 基于OSS接口的文件上传阿里云OSS控台的使用:\n\nbucket：存储空间，名称必须是全阿里云唯一\n上传的文件默认都继承bucket，这里的设置读写权限，只针对当前的文件有效\n\n基于OSS接口实现文件上传:1.大文件断点续传与极速秒传：基于oss接口实现文件上传，增加文件追加上传oss-append和简单上传oss-simple\n\n首先开通OSS，然后就可以上传文件了，在权限管理的RAM创建用户\nKey ID就是开发文档里的那个\n\n\n\n这个页面就有很多示例\n\n每次分片上传都是一个新的请求所以在每次请求里，只需要append一次\n\n我们在course和file的pom.xml中都加入\n\n\n&lt;!--阿里云oss--&gt;&lt;dependency&gt;   &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;   &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;   &lt;version&gt;3.10.2&lt;/version&gt;&lt;/dependency&gt;\n\n\n首先在file中创建一个新的controller（OssController），里面一个追加上传，一个简单上传\n\npackage com.course.file.controller.admin;import com.alibaba.fastjson.JSONObject;import com.aliyun.oss.OSS;import com.aliyun.oss.OSSClientBuilder;import com.aliyun.oss.model.AppendObjectRequest;import com.aliyun.oss.model.AppendObjectResult;import com.aliyun.oss.model.ObjectMetadata;import com.aliyun.oss.model.PutObjectRequest;import com.course.server.dto.FileDto;import com.course.server.dto.ResponseDto;import com.course.server.enums.FileUseEnum;import com.course.server.service.FileService;import com.course.server.util.Base64ToMultipartFile;import com.course.server.util.UuidUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import javax.annotation.Resource;import java.io.ByteArrayInputStream;import java.io.File;import java.io.IOException;@RequestMapping(&quot;/admin&quot;)@RestControllerpublic class OssController &#123;    private static final Logger LOG = LoggerFactory.getLogger(OssController.class);    public static final String BUSINESS_NAME = &quot;文件上传&quot;;    @Value(&quot;$&#123;accessKeyId&#125;&quot;)    private String accessKeyId;    @Value(&quot;$&#123;accessKeySecret&#125;&quot;)    private String accessKeySecret;    @Value(&quot;$&#123;endpoint&#125;&quot;)    private String endpoint;    @Value(&quot;$&#123;ossDomain&#125;&quot;)    private String ossDomain;    @Value(&quot;$&#123;bucket&#125;&quot;)    private String bucket;    @Resource    private FileService fileService;   @PostMapping(&quot;/oss-append&quot;)    public ResponseDto fileUpload(@RequestBody FileDto fileDto) throws IOException &#123;       LOG.info(&quot;上传文件开始&quot;);       String use = fileDto.getUse();       String key = fileDto.getKey();       String suffix = fileDto.getSuffix();       Integer shardIndex = fileDto.getShardIndex();       Integer shardSize = fileDto.getShardSize();       String shardBase64 = fileDto.getShard();       MultipartFile shard = Base64ToMultipartFile.base64ToMultipart(shardBase64);       // 保存文件到本地       FileUseEnum useEnum = FileUseEnum.getByCode(use);       //如果文件夹不存在则创建       String dir = useEnum.name().toLowerCase();       String path = new StringBuffer(dir)               .append(File.separator)               .append(key)               .append(&quot;.&quot;)               .append(suffix)               .toString();               // 创建OSSClient实例。       OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);       ObjectMetadata meta = new ObjectMetadata();       meta.setContentType(&quot;text/plain&quot;);       // 通过AppendObjectRequest设置多个参数。       AppendObjectRequest appendObjectRequest = new AppendObjectRequest(bucket, path, new ByteArrayInputStream(shard.getBytes()),meta);       // 第一次追加。       // 设置文件的追加位置。       appendObjectRequest.setPosition((long) ((shardIndex - 1) * shardSize));       AppendObjectResult appendObjectResult = ossClient.appendObject(appendObjectRequest);       // 文件的64位CRC值。此值根据ECMA-182标准计算得出。       System.out.println(appendObjectResult.getObjectCRC());       System.out.println(JSONObject.toJSONString(appendObjectResult));       ossClient.shutdown();       LOG.info(&quot;保存文件记录开始&quot;);       fileDto.setPath(path);       fileService.save(fileDto);       ResponseDto responseDto = new ResponseDto();       fileDto.setPath(ossDomain + path);       responseDto.setContent(fileDto);       return responseDto;   &#125;    @PostMapping(&quot;/oss-simple&quot;)    public ResponseDto fileUpload(@RequestParam MultipartFile file, String use) throws Exception &#123;        LOG.info(&quot;上传文件开始&quot;);        FileUseEnum useEnum = FileUseEnum.getByCode(use);        String key = UuidUtil.getShortUuid();        String fileName = file.getOriginalFilename();        String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;) + 1).toLowerCase();        String dir = useEnum.name().toLowerCase();        String path = dir + &quot;/&quot; + key + &quot;.&quot; + suffix;        // 创建OSSClient实例。        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);        // 创建PutObjectRequest对象。//        String content = &quot;Hello OSS&quot;;        // &lt;yourObjectName&gt;表示上传文件到OSS时需要指定包含文件后缀在内的完整路径，例如abc/efg/123.jpg。        PutObjectRequest putObjectRequest = new PutObjectRequest(bucket, path, new ByteArrayInputStream(file.getBytes()));        // 如果需要上传时设置存储类型与访问权限，请参考以下示例代码。        // ObjectMetadata metadata = new ObjectMetadata();        // metadata.setHeader(OSSHeaders.OSS_STORAGE_CLASS, StorageClass.Standard.toString());        // metadata.setObjectAcl(CannedAccessControlList.Private);        // putObjectRequest.setMetadata(metadata);        // 上传字符串。        ossClient.putObject(putObjectRequest);//        LOG.info(&quot;保存文件记录开始&quot;);//        fileDto.setPath(path);//        fileService.save(fileDto);        ResponseDto responseDto = new ResponseDto();        FileDto fileDto = new FileDto();        fileDto.setPath(ossDomain + path);        responseDto.setContent(fileDto);        return responseDto;    &#125;&#125;\n\n\n里面的一些参数我们在application中写入\n\n#ossaccessKeyId = 自己申请的IdaccessKeySecret = 自己申请的endpoint = http://oss-cn-shanghai.aliyuncs.comossDomain = http://course-imooc123.oss-cn-shanghai.aliyuncs.combucket = course-imooc123\n\n\n然后分别把big-file和file.vue的upload\n\n_this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/file/admin/oss-append&#x27;, param) _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/file/admin/oss-simple&#x27;, param)\n\n\n使用的时候，就跟平常一样，引入组件\n\n10-3 阿里云视频点播服务介绍阿里云视频点播服务介绍：\n\n视频点播（ApsaraVideo VoD，简称VoD）是集视频采集、编辑、上传、媒体资源管理、自动化转码处理（窄带高清™）、视频审核分析、分发加速于一体的一站式音视频点播解决方案。\n\n视频点播控台的使用：\n\n视频点播帮助文档概览：\n\n10-4 基于OSS原生SDK上传视频到点播1VOD上传并加密转码：\n1.视频加密与授权播放：基于oss原生SDK上传视频到点播服务，官方示例代码\n\n在course和server中pom都加入jar包\n\n&lt;!--阿里云oss--&gt;&lt;dependency&gt;   &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;   &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;   &lt;version&gt;3.10.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 阿里云vod --&gt;&lt;dependency&gt;   &lt;groupId&gt;com.aliyun&lt;/groupId&gt;   &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;   &lt;version&gt;4.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;com.aliyun&lt;/groupId&gt;   &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt;   &lt;version&gt;2.15.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;   &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;   &lt;version&gt;3.4&lt;/version&gt;&lt;/dependency&gt;\n\n\n在server的util中增加VodUtil\n\npackage com.course.server.util;import com.alibaba.fastjson.JSONObject;import com.aliyun.oss.OSSClient;import com.aliyuncs.DefaultAcsClient;import com.aliyuncs.exceptions.ClientException;import com.aliyuncs.profile.DefaultProfile;import com.aliyuncs.vod.model.v20170321.CreateUploadVideoRequest;import com.aliyuncs.vod.model.v20170321.CreateUploadVideoResponse;import org.apache.commons.codec.binary.Base64;import java.io.File;public class VodUtil &#123;    public static DefaultAcsClient initVodClient(String accessKeyId, String accessKeySecret) throws ClientException &#123;        // 根据点播接入服务所在的Region填写，例如：接入服务在上海，则填cn-shanghai；其他区域请参见存储说明。        String regionId = &quot;cn-shanghai&quot;;        DefaultProfile profile = DefaultProfile.getProfile(regionId, accessKeyId, accessKeySecret);        DefaultAcsClient client = new DefaultAcsClient(profile);        return client;    &#125;    public static CreateUploadVideoResponse createUploadVideo(DefaultAcsClient vodClient) throws ClientException &#123;        CreateUploadVideoRequest request = new CreateUploadVideoRequest();        request.setFileName(&quot;vod_test.mp4&quot;);        request.setTitle(&quot;this is title&quot;);        //request.setDescription(&quot;this is desc&quot;);        //request.setTags(&quot;tag1,tag2&quot;);        //CoverURL示例：http://example.aliyundoc.com/test_cover_****.jpg        //request.setCoverURL(&quot;&lt;your CoverURL&gt;&quot;);        //request.setCateId(-1L);        //request.setTemplateGroupId(&quot;&quot;);        //request.setWorkflowId(&quot;&quot;);        //request.setStorageLocation(&quot;&quot;);        //request.setAppId(&quot;app-1000000&quot;);        //设置请求超时时间        request.setSysReadTimeout(1000);        request.setSysConnectTimeout(1000);        return vodClient.getAcsResponse(request);    &#125;    public static OSSClient initOssClient(JSONObject uploadAuth, JSONObject uploadAddress) &#123;        String endpoint = uploadAddress.getString(&quot;Endpoint&quot;);        String accessKeyId = uploadAuth.getString(&quot;AccessKeyId&quot;);        String accessKeySecret = uploadAuth.getString(&quot;AccessKeySecret&quot;);        String securityToken = uploadAuth.getString(&quot;SecurityToken&quot;);        return new OSSClient(endpoint, accessKeyId, accessKeySecret, securityToken);    &#125;    public static void uploadLocalFile(OSSClient ossClient, JSONObject uploadAddress, String localFile) &#123;        String bucketName = uploadAddress.getString(&quot;Bucket&quot;);        String objectName = uploadAddress.getString(&quot;FileName&quot;);        File file = new File(localFile);        ossClient.putObject(bucketName, objectName, file);    &#125;    public static void main(String[] argv) &#123;        //您的AccessKeyId        String accessKeyId = &quot;您的AccessKeyId&quot;;        //您的AccessKeySecret        String accessKeySecret = &quot;您的AccessKeySecret&quot;;        //需要上传到VOD的本地视频文件的完整路径，需要包含文件扩展名        String localFile = &quot;C:\\\\Users\\\\1\\\\Desktop\\\\fang\\\\course\\\\admin\\\\public\\\\static\\\\image\\\\小节视频\\\\test.mp4&quot;;        try &#123;            // 初始化VOD客户端并获取上传地址和凭证            DefaultAcsClient vodClient = initVodClient(accessKeyId, accessKeySecret);            CreateUploadVideoResponse createUploadVideoResponse = createUploadVideo(vodClient);            // 执行成功会返回VideoId、UploadAddress和UploadAuth            String videoId = createUploadVideoResponse.getVideoId();            JSONObject uploadAuth = JSONObject.parseObject(                    Base64.decodeBase64(createUploadVideoResponse.getUploadAuth()),JSONObject.class);            JSONObject uploadAddress = JSONObject.parseObject(                    Base64.decodeBase64(createUploadVideoResponse.getUploadAddress()),JSONObject.class);            // 使用UploadAuth和UploadAddress初始化OSS客户端            OSSClient ossClient = initOssClient(uploadAuth, uploadAddress);            // 上传文件，注意是同步上传会阻塞等待，耗时与文件大小和网络上行带宽有关            uploadLocalFile(ossClient, uploadAddress, localFile);            System.out.println(&quot;Put local file succeed, VideoId : &quot; + videoId);        &#125; catch (Exception e) &#123;            System.out.println(&quot;Put local file fail, ErrorMessage : &quot; + e.getLocalizedMessage());        &#125;    &#125;    private static String decodeBase64(String data) &#123;        return new String(Base64.decodeBase64(data));    &#125; &#125;\n\n10-5 基于OSS原生SDK上传视频到点播22.视频加密与授权播放：基于OSS原生SDK上传视频到点播服务，上传到指定分类并自动转码：\n\n把上面这部分注释注释掉\n\nrequest.setCoverURL(&quot;https://s2.loli.net/2022/03/18/Out79eVMalPJjCE.png&quot;);request.setCateId(1000384585L);request.setTemplateGroupId(&quot;f563e13b2a67fdd2b4e44bc1b1d421c2&quot;);\n\n3.视频点播不支持追加上传：\n\n在上面uploadLocalFile方法中官方示例中用是简单上传putObiect，我们要改成我们需要的追加上传,很遗憾是不能实现的。\n\n项目集成VOD上传：\n1.视频加密与授权播放：小节增加vod字段：\n\n我们首先在all小节处增加一列\n\nalter table `section` add column (`vod` char(32) comment &#x27;VOD|阿里云VOD&#x27;);\n\n\n然后mybatis-generator，然后我们还需要在sectionDto增加新增的变量。\n\n先对big-file进行修改\n\n\n//设置两个默认值shardSize:&#123;  default:50*1024&#125;,url:&#123;  default:&quot;oss-append&quot;&#125;,//使用默认值let shardSize = _this.shardSize;_this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/file/admin/&#x27;+_this.url, param)\n\n2，视频加密与授权播放：增加vod组件，用于上传视频到视频点播服务：\n\nvod组件就是对big-file组件做了一层封装，要注意度，封装得越多，灵活度就越低。\n\n然后我们就在组件中创建一个vod.vue\n\n\n&lt;template&gt;  &lt;big-file v-bind:input-id=&quot;inputId&quot;            v-bind:text=&quot;text&quot;            v-bind:suffixs=&quot;suffixs&quot;            v-bind:use=&quot;use&quot;            v-bind:after-upload=&quot;afterUpload&quot;            v-bind:shard-size=&quot;shardSize&quot;            v-bind:url=&quot;oss-append&quot;&gt;&lt;/big-file&gt;&lt;/template&gt;&lt;script&gt;import BigFile from &quot;./big-file&quot;export default &#123;  components:&#123;BigFile&#125;,  name: &#x27;vod&#x27;,  props: &#123;    text: &#123;      default: &quot;上传VOD&quot;    &#125;,    inputId: &#123;      default: &quot;vod-upload&quot;    &#125;,    suffixs: &#123;      default: []    &#125;,    use: &#123;      default: &quot;&quot;    &#125;,    shardSize:&#123;      default:50*1024    &#125;,    afterUpload: &#123;      type: Function,      default: null    &#125;,  &#125;,  data: function () &#123;    return &#123;    &#125;  &#125;,  methods: &#123;  &#125;&#125;&lt;/script&gt;\n\n\n我们在js里对video赋值，vue会监听到值的变化”并渲染视频控件。如果还没渲染完，我们就去获取时长，这时就会得到NaN，所以需要加延时获取。因此我们修改section获取时长代码，增加一个延迟。另外我们在section中使用vod组件。\n\n/** * 获取时长 */getTime()&#123;  let _this=this;  setTimeout(function ()&#123;let ele =document.getElementById(&quot;video&quot;);    _this.section.time =parseInt(ele.duration,10);  &#125;,100);  &#125;,\n\n3.视频加密与授权播放：file表增加vod字段\n\n我们给file也增加vod字段，其他忽略\n\nalter table `file` add column (`vod` char(32) comment &#x27;Vod|阿里云Vod&#x27;);\n\n4.视频加密与授权播放：增加视频点播文件上传功能\n\n我们首先修改下application，并将OssController对应的值也进行修改\n\n#ossoss.accessKeyId = 自己申请的oss.accessKeySecret = 自己申请的oss.endpoint = http://oss-cn-shanghai.aliyuncs.comoss.domain = http://course-imooc123.oss-cn-shanghai.aliyuncs.comoss.bucket = course-imooc123#vodvod.accessKeyId = 自己申请的vod.accessKeySecret = 自己申请的\n\n\n由于视频点播不支持追加上传，所以使用vod组件进行上传的，只能有一个分片，所以我们将shardSize写死，不给暴漏出去,就默认1G\n\nv-bind:shard-size=&quot;1000*1024*1024&quot;\n\n\n接下来修改VodUtil\n\n//给函数增加一个参数public static CreateUploadVideoResponse createUploadVideo(DefaultAcsClient vodClient,String fileName) throws ClientException &#123;    request.setFileName(fileName);    request.setTitle(fileName);&#125;//在main中使用该函数String fileName = &quot;test.mp4&quot;;CreateUploadVideoResponse createUploadVideoResponse = createUploadVideo(vodClient,fileName);             /**     * 增加简单上传     * @param ossClient     * @param uploadAddress     * @param inputStream     */    public static void uploadLocalFile(OSSClient ossClient, JSONObject uploadAddress, InputStream inputStream) &#123;        String bucketName = uploadAddress.getString(&quot;Bucket&quot;);        String objectName = uploadAddress.getString(&quot;FileName&quot;);        //单文件上传        ossClient.putObject(bucketName, objectName, inputStream);    &#125;\n\n\n下面加这个方法的目的就是去获取播放地址\n\n/** * 取源文件信息 * @param client * @param videoId * @return * @throws ClientException */public static GetMezzanineInfoResponse getMezzanineInfo(DefaultAcsClient client,String videoId) throws ClientException &#123;    GetMezzanineInfoRequest request = new GetMezzanineInfoRequest();    request.setVideoId(videoId);    //源片下载地址过期时间    request.setAuthTimeout(3600L);    return client.getAcsResponse(request);&#125;\n\n\n阿里云JAR里的实体类里没有重写tostring（方法，所以每次打印日志都要用JSoN.to]sONString()，这就是为什么我要求自己的实体类要生成tostring（）\n\nSystem.out.println(&quot;视频上传成功, VideoId : &quot; + videoId);//再这之后添加代码GetMezzanineInfoResponse response = new GetMezzanineInfoResponse();response = getMezzanineInfo(vodClient,videoId);System.out.println(&quot;获取视频信息,response : &quot;+ JSON.toJSONString(response));\n\n\n我们新建一个VodController\n\npackage com.course.file.controller.admin;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.aliyun.oss.OSSClient;import com.aliyuncs.DefaultAcsClient;import com.aliyuncs.vod.model.v20170321.CreateUploadVideoResponse;import com.aliyuncs.vod.model.v20170321.GetMezzanineInfoResponse;import com.course.server.dto.FileDto;import com.course.server.dto.ResponseDto;import com.course.server.enums.FileUseEnum;import com.course.server.service.FileService;import com.course.server.util.Base64ToMultipartFile;import com.course.server.util.VodUtil;import org.apache.commons.codec.binary.Base64;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.MultipartFile;import javax.annotation.Resource;import java.io.File;import java.io.IOException;@RequestMapping(&quot;/admin&quot;)@RestControllerpublic class VodController &#123;    private static final Logger LOG = LoggerFactory.getLogger(VodController.class);    public static final String BUSINESS_NAME = &quot;文件上传&quot;;    @Value(&quot;$&#123;vod.accessKeyId&#125;&quot;)    private String accessKeyId;    @Value(&quot;$&#123;vod.accessKeySecret&#125;&quot;)    private String accessKeySecret;    @Resource    private FileService fileService;   @PostMapping(&quot;/vod&quot;)    public ResponseDto fileUpload(@RequestBody FileDto fileDto) throws IOException &#123;       LOG.info(&quot;上传文件开始&quot;);       String use = fileDto.getUse();       String key = fileDto.getKey();       String suffix = fileDto.getSuffix();       Integer shardIndex = fileDto.getShardIndex();       Integer shardSize = fileDto.getShardSize();       String shardBase64 = fileDto.getShard();       MultipartFile shard = Base64ToMultipartFile.base64ToMultipart(shardBase64);       // 保存文件到本地       FileUseEnum useEnum = FileUseEnum.getByCode(use);       //如果文件夹不存在则创建       String dir = useEnum.name().toLowerCase();       String path = new StringBuffer(dir)               .append(File.separator)               .append(key)               .append(&quot;.&quot;)               .append(suffix)               .toString();       String vod =&quot;&quot;;       String fileUrl = &quot;&quot;;       try &#123;           // 初始化VOD客户端并获取上传地址和凭证           DefaultAcsClient vodClient = VodUtil.initVodClient(accessKeyId, accessKeySecret);           CreateUploadVideoResponse createUploadVideoResponse = VodUtil.createUploadVideo(vodClient,path);           // 执行成功会返回VideoId、UploadAddress和UploadAuth           vod = createUploadVideoResponse.getVideoId();           JSONObject uploadAuth = JSONObject.parseObject(                   Base64.decodeBase64(createUploadVideoResponse.getUploadAuth()),JSONObject.class);           JSONObject uploadAddress = JSONObject.parseObject(                   Base64.decodeBase64(createUploadVideoResponse.getUploadAddress()),JSONObject.class);           // 使用UploadAuth和UploadAddress初始化OSS客户端           OSSClient ossClient = VodUtil.initOssClient(uploadAuth, uploadAddress);           // 上传文件，注意是同步上传会阻塞等待，耗时与文件大小和网络上行带宽有关           VodUtil.uploadLocalFile(ossClient, uploadAddress, shard.getInputStream());           System.out.println(&quot;视频上传成功, VideoId : &quot; + vod);           GetMezzanineInfoResponse response =  VodUtil.getMezzanineInfo(vodClient,vod);           System.out.println(&quot;获取视频信息,response : &quot;+ JSON.toJSONString(response));           fileUrl = response.getMezzanine().getFileURL();           ossClient.shutdown();       &#125; catch (Exception e) &#123;           System.out.println(&quot;文件上传失败, ErrorMessage : &quot; + e.getLocalizedMessage());       &#125;       LOG.info(&quot;保存文件记录开始&quot;);       fileDto.setPath(path);       fileDto.setVod(vod);       fileService.save(fileDto);       ResponseDto responseDto = new ResponseDto();       fileDto.setPath(fileUrl);//返回给前端的需要一个可播放的地址，为了自动获取时长       responseDto.setContent(fileDto);       return responseDto;   &#125;&#125;\n\n\n修改section\n\n//获取到的可播放地址是有时效的，所以就算保存到数据库也会过期没用。以后会根据vod来播放，所以我们保存的时候将video的全路径清空，在save方法中加_this.section.video=&quot;&quot;;//上传完文件后，多返回一个vod，那么我们在afterUpload方法中将vod放到section.vod中let vod =resp.content.vod;_this.section.vod = vod;\n\n5.视频加密与授权播放：文件检查时，根据是否是视频点播文件来获取视频信息\n\n在UploadController中check方法增加判断vod是否有值，如过有就上传vod的地址，如果没有就上传本地地址\n\n@Value(&quot;$&#123;vod.accessKeyId&#125;&quot;)private String accessKeyId;@Value(&quot;$&#123;vod.accessKeySecret&#125;&quot;)private String accessKeySecret;if(fileDto != null)&#123;    if (StringUtils.isEmpty(fileDto.getVod()))&#123;        fileDto.setPath(FILE_DOMAIN+fileDto.getPath());    &#125;else&#123;        DefaultAcsClient vodClient = VodUtil.initVodClient(accessKeyId, accessKeySecret);        GetMezzanineInfoResponse response =  VodUtil.getMezzanineInfo(vodClient,fileDto.getVod());        System.out.println(&quot;获取视频信息,response : &quot;+ JSON.toJSONString(response));        String fileUrl = response.getMezzanine().getFileURL();        fileDto.setPath(fileUrl);    &#125;&#125;\n\n10-6 视频授权播放功能开发阿里云播放器的基本使用:\n1.视频加密与授权播放：集成阿里云播放器，制作player播放器组件\n\n我们再次创建一个组件player.vue\n\n&lt;template&gt;  &lt;div v-bind:id=&quot;playerId&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export  default &#123;    name:&#x27;player&#x27;,    props:&#123;      playerId:&#123;        default:&quot;player-div&quot;      &#125;,    &#125;,    data: function ()&#123;      return&#123;        aliPlayer:&#123;&#125;,//播放器实例      &#125;    &#125;,    methods:&#123;      playUrl(url)&#123;        let _this=this;        console.log(&quot;开始播放:&quot;,url);        //如果已经有播放器了，则将播放器的div删除        if (_this.aliPlayer)&#123;          _this.aliPlayer=null;          $(&quot;#J_prismPlayer&quot;).remove();        &#125;        //初始播放器        $(&quot;#&quot;+_this.playerId).append(&quot;&lt;div class=\\&quot;prism-player\\&quot; id=\\&quot;J_prismPlayer\\&quot;&gt;&lt;/div&gt;&quot;);        _this.aliPlayer = new Aliplayer(&#123;          id: &#x27;J_prismPlayer&#x27;,          width: &#x27;100%&#x27;,          autoplay:false,          source:url,          cover:&#x27;https://s2.loli.net/2022/03/01/6wagXDIZQGcebUt.png&#x27;,        &#125;,function(player)&#123;          console.log(&#x27;播放器创建好了&#x27;)        &#125;);      &#125;    &#125;  &#125;&lt;/script&gt;\n\n\n然后我们在index中引入代码js和css\n\n&lt;!--  阿里云播放器--&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://g.alicdn.com/de/prismplayer/2.9.19/skins/default/aliplayer-min.css&quot; /&gt;  &lt;!--  阿里云播放器--&gt;&lt;script charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;https://g.alicdn.com/de/prismplayer/2.9.19/aliplayer-min.js&quot;&gt;&lt;/script&gt; \n\n\n最后我们对section进行修改\n\n//增加了player，并且将video隐藏起来，不能注释掉，因为我们要用它获取时长&lt;player ref=&quot;player&quot;&gt;&lt;/player&gt;&lt;video v-bind:src=&quot;section.video&quot; id=&quot;video&quot; controls=&quot;controls&quot; class=&quot;hidden&quot;&gt;&lt;/video&gt;//引入player组件import Player from &quot;../../components/player&quot;;components: &#123;Player, Pagination,BigFile,Vod&#125;,//在afterUpload方法中增加，通过url播放视频_this.$refs.player.playUrl(video);\n\n获取vod授权码并授权播放\n1.视频加密与授权播放：获取vod授权码并授权播放，需要在存储管理中将权限设置成公共读         \n\n首先在VodUtil中增加\n\n/** * 获取播放凭证函数 * @param client * @return * @throws Exception */public static GetVideoPlayAuthResponse getVideoPlayAuth(DefaultAcsClient client, String videoId) throws Exception &#123;    GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest();    request.setVideoId(videoId);    return client.getAcsResponse(request);&#125;\n\n\n然后我们在VodController中增加请求\n\n@RequestMapping(value = &quot;/get-auth/&#123;vod&#125;&quot;, method = RequestMethod.GET)public ResponseDto getAuth(@PathVariable String vod) throws ClientException, ClientException &#123;    LOG.info(&quot;获取播放授权开始: &quot;);    ResponseDto responseDto = new ResponseDto();    DefaultAcsClient client = VodUtil.initVodClient(accessKeyId, accessKeySecret);    GetVideoPlayAuthResponse response = new GetVideoPlayAuthResponse();    try &#123;        response = VodUtil.getVideoPlayAuth(client, vod);        LOG.info(&quot;授权码 = &#123;&#125;&quot;, response.getPlayAuth());        responseDto.setContent(response.getPlayAuth());        //VideoMeta信息        LOG.info(&quot;VideoMeta = &#123;&#125;&quot;, JSON.toJSONString(response.getVideoMeta()));    &#125; catch (Exception e) &#123;        System.out.print(&quot;ErrorMessage = &quot; + e.getLocalizedMessage());    &#125;    LOG.info(&quot;获取播放授权结束&quot;);    return responseDto;&#125;\n\n\n一个页面可能会放多个player组件，所以需要把id做成动态变化，一个页面的元素，id值要是唯一的。修改player.vue\n\n $(&quot;#&quot;+_this.playerId+&#x27;-player&#x27;).remove();//初始播放器$(&quot;#&quot;+_this.playerId).append(&quot;&lt;div class=\\&quot;prism-player\\&quot; id=\\&quot;&quot;+_this.playerId+&quot;-player\\&quot;&gt;&lt;/div&gt;&quot;);_this.aliPlayer = new Aliplayer(&#123;  id: _this.playerId+&#x27;-player&#x27;,&#125;\n\n\n我们在player组件增加一个方法，设置播放凭证\n\nplayVod (vod) &#123;  let _this = this;  Loading.show();  _this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/file/admin/get-auth/&#x27; + vod).then((response)=&gt;&#123;    Loading.hide();    let resp = response.data;    if (resp.success) &#123;      //如果已经有播放器了，则将播放器div删除      if (_this.aliPlayer) &#123;        _this.aliPlayer = null;        $(&quot;#&quot; + _this.playerId + &#x27;-player&#x27;).remove();      &#125;      // 初始化播放器      $(&quot;#&quot; + _this.playerId).append(&quot;&lt;div class=\\&quot;prism-player\\&quot; id=\\&quot;&quot; + _this.playerId + &quot;-player\\&quot;&gt;&lt;/div&gt;&quot;);      _this.aliPlayer = new Aliplayer(&#123;        id: _this.playerId + &#x27;-player&#x27;,        width: &#x27;100%&#x27;,        autoplay: false,        vid: vod,        playauth: resp.content,        cover: &#x27;http://liveroom-img.oss-cn-qingdao.aliyuncs.com/logo.png&#x27;,        encryptType:1, //当播放私有加密流时需要设置。      &#125;,function(player)&#123;        console.log(&#x27;播放器创建好了。&#x27;)      &#125;);    &#125; else &#123;      Toast.warning(&#x27;播放错误。&#x27;)    &#125;  &#125;)&#125;\n\n\n我们再创建一个带有模态框的播放器组件modal-player，里面包含了player组件\n\n&lt;template&gt;  &lt;div id=&quot;player-modal&quot; class=&quot;modal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot;&gt;    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;      &lt;div class=&quot;modal-content&quot;&gt;        &lt;div class=&quot;modal-body&quot;&gt;          &lt;player v-bind:player-id=&quot;&#x27;modal-player-div&#x27;&quot;                  ref=&quot;player&quot;&gt;&lt;/player&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import Player from &quot;./player&quot;;  export default &#123;    name: &#x27;modal-player&#x27;,    components: &#123;Player&#125;,    data: function () &#123;      return &#123;        aliPlayer: &#123;&#125;, // 播放器实例      &#125;    &#125;,    methods: &#123;      playUrl(url) &#123;        let _this = this;        _this.$refs.player.playUrl(url);      &#125;,      playVod(vod) &#123;        let _this = this;        _this.$refs.player.playVod(vod);        $(&quot;#player-modal&quot;).modal(&quot;show&quot;);      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;  #player-modal .modal-body &#123;    padding: 0;  &#125;&lt;/style&gt;\n\n\n接下来我们设置个section，改动如下\n\n//将视频改为VOD&lt;th&gt;VOD&lt;/th&gt;//操作中增加一个按钮 &lt;button v-on:click=&quot;play(section)&quot; class=&quot;btn btn-xs btn-info&quot;&gt;    &lt;i class=&quot;ace-icon fa fa-video-camera bigger-120&quot;&gt;&lt;/i&gt; &lt;/button&gt;//给player设置一个id&lt;player v-bind:player-id=&quot;&#x27;form-player-div&#x27;&quot; ref=&quot;player&quot;&gt;&lt;/player&gt;//再最后一个div前面加&lt;modal-player ref=&quot;modalPlayer&quot;&gt;&lt;/modal-player&gt;//引入组件import ModalPlayer from &quot;../../components/modal-player&quot;;components: &#123;ModalPlayer, Player, Pagination,BigFile,Vod&#125;,//增加play方法play(section)&#123;  let _this=this;  _this.$refs.modalPlayer.playVod(section.vod);&#125;\n\n","tags":["完整项目"]},{"title":"完整项目之Spring Cloud + Vue 前后端分离4-1","url":"/2022/03/07/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E4%B9%8BSpring%20Cloud%20+%20Vue%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%204-1/","content":"第11章 用户管理与登录本章将演示用户管理及控台登录功能的开发，登录拦截是一个管理控台最基本的权限拦截，防止出现未登录用户直接访问控台界面或接口，同时保障系统内部用户的信息安全，介绍单点登录功能的开发，单点登录SSO（Single Sign On）在大型网站设计中非常常见，用户只需要登录一次就可以访问所有相互信任的应用系统，是提升用户体…\n\n11-1 增加用户管理功能用户表设计与基本代码生成：\n1.用户管理与登录：用户表设计与基本代码生成\n\n创建sql\n\n#用户drop table if exists `user`;create table `user`(                  `id` char(8) not null default &#x27;&#x27; comment &#x27;id&#x27;,                  `login_name` varchar(50)  not null comment &#x27;登录名&#x27;,                  `name` varchar(50)  comment &#x27;昵称&#x27;,                  `password` char(32) not null  comment &#x27;密码&#x27;,                  primary key (`id`),                  unique key `login_name_unique`(`login_name`))engine =innodb default charset=utf8mb4 comment=&#x27;用户&#x27;;\n\n\n然后修改前端后端为system，然后就开始代码生成器\n\n最后在admin中修改代码\n\n\n&lt;li class=&quot;active&quot; id=&quot;system-user-sidebar&quot;&gt; &lt;router-link to=&quot;/system/user&quot;&gt;    &lt;i class=&quot;menu-icon fa fa-caret-right&quot;&gt;&lt;/i&gt;    用户管理 &lt;/router-link&gt;  &lt;b class=&quot;arrow&quot;&gt;&lt;/b&gt;&lt;/li&gt;\n\n\n修改router，增加路由\n\n增加用户名是否已存在校验：\n1.用户管理与登录：增加用户名是否已存在校验2.增加自定义业务异常\n\n\n登录名是不可编辑的，登录名一般会跟其它表有关联，一旦登录名改了，这些关联信息就没有了。\n\n根据传入登录名到数据库中查找是否有记录，有记录就说明用户名已存在\n\n我们在UserService中增加方法\n\n\n/** * 根据登录名查询用户信息 * @param loginName * @return */public User selectByLoginName(String loginName) &#123;    UserExample userExample = new UserExample();    userExample.createCriteria().andLoginNameEqualTo(loginName);    List&lt;User&gt; userList = userMapper.selectByExample(userExample);    if (CollectionUtils.isEmpty(userList)) &#123;        return null;    &#125; else &#123;        return userList.get(0);    &#125;&#125;\n\n\n然后我们在其insert方法中，增加判断，我们在业务上的逻辑校验，在校验不通过时，使用业务异常（自定义异常）\n\nUser userDb = this.selectByLoginName(user.getLoginName());if(userDb != null)&#123; throw new BusinessException(BusinessExceptionCode.USER_LOGIN_NAME_EXIST);&#125;\n\n\n我们在com.course.server.exception增加自定义异常，先写BusinessException，\n\n继承RuntimeException的一个好处就是代码不需要捕获。如果是直接继承Exception，代码需要捕获，否则编译不通过。\n\n\npackage com.course.server.exception;public class BusinessException extends RuntimeException&#123;    private BusinessExceptionCode code;    public BusinessException (BusinessExceptionCode code) &#123;        super(code.getDesc());        this.code = code;    &#125;    public BusinessExceptionCode getCode() &#123;        return code;    &#125;    public void setCode(BusinessExceptionCode code) &#123;        this.code = code;    &#125;    /**     * 不写入堆栈信息，提高性能，抛出业务异常时，不打印堆栈信息，一方面是提高性能，另一方面是没有业务异常没必要看堆栈信息     */    @Override    public Throwable fillInStackTrace() &#123;        return this;    &#125;&#125;\n\n\n看上面的代码里面有个BusinessExceptionCode，我们也写下文件，它也是个枚举就是没有code了\n\npackage com.course.server.exception;public enum BusinessExceptionCode &#123;       USER_LOGIN_NAME_EXIST(&quot;登录名已存在&quot;),     ;    private String desc;    BusinessExceptionCode(String desc) &#123;        this.desc = desc;    &#125;    public String getDesc() &#123;        return desc;    &#125;    public void setDesc(String desc) &#123;        this.desc = desc;    &#125;&#125;\n\n\n我们还要对BusinessException做个全局的捕获，我们复制business里的ControllerExceptionHandler到system的controller下面，进行修改\n\npackage com.course.system.controller;import com.course.server.dto.ResponseDto;import com.course.server.exception.BusinessException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;@ControllerAdvicepublic class ControllerExceptionHandler &#123;    private static final Logger LOG = LoggerFactory.getLogger(ControllerExceptionHandler.class);    @ExceptionHandler(value = BusinessException.class)    @ResponseBody    public ResponseDto businessExceptionHandler(BusinessException e) &#123;        ResponseDto responseDto = new ResponseDto();        responseDto.setSuccess(false);        LOG.error(&quot;业务异常：&#123;&#125;&quot;, e.getCode().getDesc());        responseDto.setMessage(e.getCode().getDesc());        return responseDto;    &#125;&#125;\n\n\n下面我们修改user.vue，\n\n//为了让登录名新增是可以修改，修改时不能进行修改我们增加了disabled&lt;div class=&quot;form-group&quot;&gt;  &lt;label class=&quot;col-sm-2 control-label&quot;&gt;登录名&lt;/label&gt;  &lt;div class=&quot;col-sm-10&quot;&gt;    &lt;input v-model=&quot;user.loginName&quot; v-bind:disabled=&quot;user.id&quot; class=&quot;form-control&quot;&gt;  &lt;/div&gt;&lt;/div&gt;\n\n\n以后我们会有很多业务异常使用方法在BusinessExceptionCode增加一种异常枚举；在业务代码中抛出指定枚举类型的业务异常\n\n侧边栏激活样式优化\n1.用户管理与登录：侧边栏激活样式优化\n\n现在菜单栏的样式是这样的，我们要做的是当前菜单的父菜单的同级菜单，下面所有的子菜单，清空激活样式\n\n\n\n只需要在admin的activeSidebar方法，判断是否有父菜单的时候加，然后把原来标签的active都去了\n\n\nparentLi.siblings().find(&quot;li&quot;).removeClass(&quot;active&quot;);\n\n\n改完之后\n\n还有一个问题问题：访问根目录时，页面显示的是admin.vue，但是右边的content部分是空的，没有路由到任何一个子路由\n\n\n\n我们将其重定位到Login，在router中增加一个\n\n\n,&#123;    path: &quot;&quot;,    redirect: &quot;/login&quot;,&#125;\n\n2.用户管理与登录：解决从登录页面跳到控台主页时，侧边栏失效的问题\n\n但是随机而来的又有一个问题：从登录页面跳转到控台主页时，菜单失效了。因为打开登录页面时，会去加载所需的js，包括ace.min.js，这里会去做很多的初始化包括侧边栏的点击事件，但是此时还没有侧边栏。\n\n解决方法：进入控台主页时，重新加载ace.min.js，只需要在admin的mounted方法添加\n\n\n$.getScript(&#x27;/ace/assets/js/ace.min.js&#x27;);\n\n\n小提示：大家在用很多第三方框架或jquery插件时，如果发现有些功能不起作用，如果看不懂源码，可以尝试这种方法解决，把核心的js重新加载一遍\n\n11-2 密码的加密传输与加密存储加密算法MD5与盐值\n\n网站的数据库里已经把原值和密文都算好并存储超来了，如果刚好你输入的密文在数据库里有，就能解出来\n盐值也叫salt值，加上盐值后，密文不容易被破解（查询）\n\n密码加密传输和加密加密\n1.用户管理与登录：密码加密传输和加密存储\n\n所有人的密码存成明文的话，至少程序员可以直接到生产上看到\n\n从路由器的日志，我可以看到所有人浏览的网站的地址、用户名、密码，如果密码刚好是明文传输，那就泄露了，如果是简单的md5，也很容易被破解，所以需要加个盐值。\n\n盐值可以是随机的一串值，但是所有用到盐值的地方必须是同一个值。如果你是做平台系统，有多个客户用你的平台，最好是一个客户一个盐值。\n\n我们只需要在user.vue的save方法使用md5就能完成加密\n\n\n_this.user.password = hex_md5(_this.user.password+KEY);\n\n\n当然我们为了保险，我们要设置两层加密，所以我们在UserController的save方法中也使用md5\n\nuserDto.setPassword(DigestUtils.md5DigestAsHex(userDto.getPassword().getBytes()));\n\n增加修改密码功能\n1.用户管理与登录：增加重置密码功能：编辑用户信息的时候不修改密码\n\n修改用户信息和修改密码应该分开，做成两个功能\n\n首先我们设置下user.vue，只有新增时密码才显示出来，修改时不显示密码修改\n\n\n&lt;div v-show=&quot;!user.id&quot; class=&quot;form-group&quot;&gt;  &lt;label class=&quot;col-sm-2 control-label&quot;&gt;密码&lt;/label&gt;  &lt;div class=&quot;col-sm-10&quot;&gt;    &lt;input v-model=&quot;user.password&quot; type=&quot;password&quot; class=&quot;form-control&quot;&gt;  &lt;/div&gt;&lt;/div&gt;\n\n\nmybatis-generator生成的方法里，updateByPrimarykeySelective会对字段进行非空判断，再更新，如果值为空就不更新，原理就是利mybatis的if拼成动态sql。\n\n我们在UserService中修改updata\n\n\nprivate void update(User user)&#123;    user.setPassword(null);    userMapper.updateByPrimaryKeySelective(user);&#125;\n\n\n\n接下来我们要做的就是设置一个重置密码的操作下面修改user.vue\n\n//增加一个修改密码表单&lt;div id=&quot;edit-password-modal&quot; class=&quot;modal fade&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot;&gt;  &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;    &lt;div class=&quot;modal-content&quot;&gt;      &lt;div class=&quot;modal-header&quot;&gt;        &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;        &lt;h4 class=&quot;modal-title&quot;&gt;修改密码&lt;/h4&gt;      &lt;/div&gt;      &lt;div class=&quot;modal-body&quot;&gt;        &lt;form class=&quot;form-horizontal&quot;&gt;          &lt;div class=&quot;form-group&quot;&gt;            &lt;label class=&quot;control-label col-sm-2&quot;&gt;密码&lt;/label&gt;            &lt;div class=&quot;col-sm-10&quot;&gt;              &lt;input class=&quot;form-control&quot; type=&quot;password&quot; v-model=&quot;user.password&quot; name=&quot;password&quot;&gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/form&gt;      &lt;/div&gt;      &lt;div class=&quot;modal-footer&quot;&gt;        &lt;button type=&quot;button&quot; class=&quot;btn btn-white btn-default btn-round&quot; data-dismiss=&quot;modal&quot;&gt;          &lt;i class=&quot;ace-icon fa fa-times&quot;&gt;&lt;/i&gt;          取消        &lt;/button&gt;        &lt;button type=&quot;button&quot; class=&quot;btn btn-white btn-info btn-round&quot; v-on:click=&quot;savePassword()&quot;&gt;          &lt;i class=&quot;ace-icon fa fa-plus blue&quot;&gt;&lt;/i&gt;          保存密码        &lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;&lt;!-- /.modal-content --&gt;  &lt;/div&gt;&lt;!-- /.modal-dialog --&gt;&lt;/div&gt;&lt;!-- /.modal --&gt;//在操作中增加一个按钮 &lt;button v-on:click=&quot;editPassword(user)&quot; class=&quot;btn btn-xs btn-info&quot;&gt;     &lt;i class=&quot;ace-icon fa fa-key bigger-120&quot;&gt;&lt;/i&gt;&lt;/button&gt;//增加editPassword点击事件 /**    * 重置密码    * @param user*/editPassword(user) &#123;    let _this = this;    _this.user = $.extend(&#123;&#125;, user);    _this.user.password = null;    $(&quot;#edit-password-modal&quot;).modal(&quot;show&quot;);&#125;,//增加savePassword点击事件 /**     * 点击重置     */    savePassword() &#123;      let _this = this;      _this.user.password = hex_md5(_this.user.password+KEY);      Loading.show();      _this.$ajax.post(process.env.VUE_APP_SERVER +&#x27;/system/admin/user/save-password&#x27;, _this.user).then((respond) =&gt; &#123;        Loading.hide();        let resp = respond.data;        if (resp.success) &#123;          $(&quot;#edit-password-modal&quot;).modal(&quot;hide&quot;);          _this.list(1);          Toast.success(&quot;保存成功&quot;);        &#125;else&#123;          Toast.warning(resp.message);        &#125;      &#125;)    &#125;,\n\n\n然后我们在服务端UserService增加保存密码的方法\n\n/** * 重置密码 * @param userDto */public void savePassword(UserDto userDto)&#123;    User user = new User();    user.setId(userDto.getId());    user.setPassword(userDto.getPassword());    userMapper.updateByPrimaryKeySelective(user);&#125;\n\n\n我们还需要再UserController中写个savepassword请求\n\n/** * 重置密码 */@PostMapping(&quot;/save-password&quot;)public ResponseDto savePassword(@RequestBody UserDto userDto)&#123;    userDto.setPassword(DigestUtils.md5DigestAsHex(userDto.getPassword().getBytes()));    ResponseDto responseDto = new ResponseDto();    userService.savePassword(userDto);    responseDto.setContent(userDto);    return responseDto;&#125;\n\n\n\n思考：我现在存到数据库里面的密码是密文，那用户登录的时候，我数据库里面的密码解密不出来了，我怎么知道用户输入的密码对不对？\n\n11-3 基本的登录功能开发基本的登录功能开发\n1.用户管理与登录：基本的登录功能开发，校验用户名密码\n\n我们先修改login.vue\n\n &lt;label class=&quot;block clearfix&quot;&gt;&lt;span class=&quot;block input-icon input-icon-right&quot;&gt; &lt;input v-model=&quot;user.loginName&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;用户名&quot;/&gt; &lt;i class=&quot;ace-icon fa fa-user&quot;&gt;&lt;/i&gt;&lt;/span&gt;          &lt;/label&gt;          &lt;label class=&quot;block clearfix&quot;&gt;&lt;span class=&quot;block input-icon input-icon-right&quot;&gt; &lt;input v-model=&quot;user.password&quot; type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot;/&gt; &lt;i class=&quot;ace-icon fa fa-lock&quot;&gt;&lt;/i&gt;&lt;/span&gt;          &lt;/label&gt;//然后设置一个data数据data: function () &#123;    return &#123;      user: &#123;&#125;,    &#125;  &#125;,//设置login方法 login()&#123;      let _this = this;      _this.user.password = hex_md5(_this.user.password+KEY);      Loading.show();      _this.$ajax.post(process.env.VUE_APP_SERVER +&#x27;/system/admin/user/login&#x27;, _this.user).then((respond) =&gt; &#123;        Loading.hide();        let resp = respond.data;        if (resp.success) &#123;          console.log(resp.content)          this.$router.push(&quot;/welcome&quot;)        &#125;else &#123;          Toast.warning(resp.message);        &#125;        &#125;);    &#125;,\n\n\n然后我们设置UserController\n\n/** * 登录 */@PostMapping(&quot;/login&quot;)public ResponseDto login(@RequestBody UserDto userDto)&#123;    userDto.setPassword(DigestUtils.md5DigestAsHex(userDto.getPassword().getBytes()));    ResponseDto responseDto = new ResponseDto();    LoginUserDto loginUserDto = userService.login(userDto);    responseDto.setContent(loginUserDto);    return responseDto;&#125;\n\n\n接着userService也增加login方法\n\n登录验证思考：是否是根据用户名+密码到数据中去查找记录？\n\n用户名+密码去数据库查找的话，程序不知道是用户名不对，还是密码不对。程序应该要能知道，比如我如果发现有大量的用户名不对的报错，说明有人正在不断的探测我系统的用户名\n\n再次思考：如果用户名不对，提示给前端的是：用户名不存在。如果是密码不对，提示给前端的是：密码不对。是否是这样？\n\n\n/** * 登录 * @param userDto */public LoginUserDto login(UserDto userDto)&#123;    User user = selectByLoginName((userDto.getLoginName()));    if(user == null)&#123;        LOG.info(&quot;用户名不存在,&#123;&#125;&quot;,userDto.getLoginName());        throw new BusinessException(BusinessExceptionCode.LOGIN_ERROR);    &#125;else&#123;        if (user.getPassword().equals(userDto.getPassword()))&#123;            return CopyUtil.copy(user,LoginUserDto.class);        &#125;else&#123;            LOG.info(&quot;密码不对,输入密码:&#123;&#125;,数据库密码:&#123;&#125;&quot;,userDto.getPassword(),user.getPassword());            throw new BusinessException(BusinessExceptionCode.LOGIN_ERROR);        &#125;    &#125;\n\n\n如果你直接告诉前端说用户名不存在，我做为一个黑客的话，可以拿着现成的一堆用户名，包括手机号邮箱，不断的探测哪些用户名是你系统里有了。不要给别人任何机会获取你系统的关键信息。这时我们在BusinessExceptionCode中增加一个变量\n\nLOGIN_ERROR(&quot;用户名或密码错误&quot;),\n\n\n另外我们还需要增加一个LoginUserDto，用于返回返回信息\n\npackage com.course.server.dto;public class LoginUserDto &#123;    /**     * id     */    private String id;    /**     * 登录名     */    private String loginName;    /**     * 昵称     */    private String name;    public String getId() &#123;        return id;    &#125;    public void setId(String id) &#123;        this.id = id;    &#125;    public String getLoginName() &#123;        return loginName;    &#125;    public void setLoginName(String loginName) &#123;        this.loginName = loginName;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        StringBuilder sb = new StringBuilder();        sb.append(getClass().getSimpleName());        sb.append(&quot; [&quot;);        sb.append(&quot;Hash = &quot;).append(hashCode());        sb.append(&quot;, id=&quot;).append(id);        sb.append(&quot;, loginName=&quot;).append(loginName);        sb.append(&quot;, name=&quot;).append(name);        sb.append(&quot;]&quot;);        return sb.toString();    &#125;&#125;\n\n登录后保存登录信息\n1.用户管理与登录：登录后前端保存登录信息并显示\n\n前端的信息保存有多种选择：h5的localStorage，sessionStorage；js的全局变量，vue的store等\n\nsessionStorage在页面刷新的时候，信息不会丢；关闭页面后，信息自动清空，适合用来存储登录信息\n\nlocalStorage在关闭页面后，登录信息还是在的，适合一些内网使用的系统保存登录信息\n\n用js全局变量或vue的store，刷新浏览器的时候，信息会丢失。\n\n把登录信息的保存和读取做成通用的方法\n\n小技巧：在获取一些对象的时候，加上||{ }，避免获取属性值时报错\n\n再这我们在tool.js将登录信息的保存和读取做成通用的方法\n\n\n/** * 保存登录信息 * @param loginUser */setLoginUser:function (loginUser)&#123;    SessionStorage.set(SESSION_KEY_LOGIN_USER,loginUser);&#125;,/** * 获取登录信息 * @param loginUser * @returns &#123;any|&#123;&#125;&#125; */getLoginUser:function (loginUser)&#123;    return SessionStorage.get(SESSION_KEY_LOGIN_USER) ||&#123;&#125;;&#125;,\n\n\n然后我们在session-storage中设置一个常量\n\nSESSION_KEY_LOGIN_USER = &quot;SESSION_KEY_LOGIN_USER&quot;; // 登录信息\n\n\n我们在login.vue\n\nif (resp.success) &#123;  console.log(&quot;登录成功：&quot;,resp.content)  Tool.setLoginUser(resp.content)//增加这个  this.$router.push(&quot;/welcome&quot;)\n\n\n我们在admin\n\n//先增加datadata: function () &#123;  return &#123;    loginUser: &#123;&#125;,  &#125;&#125;,//在mounted:function初始化时获取 _this.loginUser  = Tool.getLoginUser()//最后在头像处将名字显示出来&lt;span class=&quot;user-info&quot;&gt;    &lt;small&gt;Welcome,&lt;/small&gt;    &#123;&#123; loginUser.name &#125;&#125;&lt;/span&gt;\n\n\n11-4 退出登录与记住登录增加推出登录功能\n1.用户管理与登录：增加退出登录功能，清空前后增的会话缓存\n\n退出登录：清空当前登录的缓存信息，并跳到登录页面\n\n我们先修改下admin页面头像里的三个\n\n\n//头像里的三个文字&lt;ul class=&quot;user-menu dropdown-menu-right dropdown-menu dropdown-yellow dropdown-caret dropdown-close&quot;&gt;  &lt;li&gt;    &lt;a href=&quot;#&quot;&gt;      &lt;i class=&quot;ace-icon fa fa-cog&quot;&gt;&lt;/i&gt;      系统设置    &lt;/a&gt;  &lt;/li&gt;  &lt;li&gt;    &lt;a href=&quot;profile.html&quot;&gt;      &lt;i class=&quot;ace-icon fa fa-user&quot;&gt;&lt;/i&gt;      个人信息    &lt;/a&gt;  &lt;/li&gt;  &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt;  &lt;li&gt;    &lt;a v-on:click=&quot;logout()&quot; href=&quot;#&quot;&gt;      &lt;i class=&quot;ace-icon fa fa-power-off&quot;&gt;&lt;/i&gt;      登出登录    &lt;/a&gt;  &lt;/li&gt;&lt;/ul&gt;//上面登录页面有一个logoutlogout()&#123;      let _this = this;      Loading.show();      _this.$ajax.get(process.env.VUE_APP_SERVER +&#x27;/system/admin/user/logout&#x27;).then((response) =&gt; &#123;        Loading.hide();        let resp = response.data;        if (resp.success) &#123;          Tool.setLoginUser(null);          this.$router.push(&quot;/login&quot;)        &#125;else &#123;          Toast.warning(resp.message);        &#125;      &#125;);    &#125;,\n\n\n我们再在server的dto在增加一个常字段Constants\n\npackage com.course.server.dto;public class Constants &#123;    public static final String LOGIN_USER = &quot;LOGIN_USER&quot;;&#125;\n\n\n接下来写后端，一般登录信息在前后端都会保存，后端缓存\n\n/** * 登录，这是后端的缓存 */@PostMapping(&quot;/login&quot;)public ResponseDto login(@RequestBody UserDto userDto, HttpServletRequest request)&#123;    userDto.setPassword(DigestUtils.md5DigestAsHex(userDto.getPassword().getBytes()));    ResponseDto responseDto = new ResponseDto();    LoginUserDto loginUserDto = userService.login(userDto);    request.getSession().setAttribute(Constants.LOGIN_USER,loginUserDto);    responseDto.setContent(loginUserDto);    return responseDto;&#125;/** * 退出登录 */@GetMapping(&quot;/logout&quot;)public ResponseDto logout(HttpServletRequest request)&#123;    ResponseDto responseDto = new ResponseDto();    request.getSession().removeAttribute(Constants.LOGIN_USER);//去掉后端缓存    return responseDto;&#125;\n\n增加记住登录信息功能\n1.用户管理与登录：增加记住登录信息功能\n\n使用localStorage来保存输入的用户名密码\n\n如果不清空本地缓存，重新打开页面时会再次显示记住的用户名密码\n\n能获取到缓存的值，说明上一次有勾选“记住我\n\n我们首先在local-storage设置一个常量\n\n\nLOCAL_KEY_REMEMBER_USER =&quot;LOCAL_KEY_REMEMBER_USER&quot;;\n\n\n然后我们对login进行修改\n\n//给记住我增加一个model&lt;div class=&quot;clearfix&quot;&gt;  &lt;label class=&quot;inline&quot;&gt;    &lt;input v-model=&quot;remember&quot; type=&quot;checkbox&quot; class=&quot;ace&quot;/&gt;    &lt;span class=&quot;lbl&quot;&gt; 记住我&lt;/span&gt;  &lt;/label&gt;//data中设置remember    data: function () &#123;    return &#123;      user: &#123;&#125;,      remember:true    &#125;  &#125;,//在初始化时写以下代码let _this=this;//从缓存中获取记住的用户名密码,如果获取不到说明上一次没有勾选上“记住我”let rememberUser = LocalStorage.get(LOCAL_KEY_REMEBER_USER);if(rememberUser)&#123;    _this.user = rememberUser; &#125;//登录代码    methods:&#123;    login()&#123;      let _this = this;      let passwordShow = _this.user.password;//新增，先获取明文密码      _this.user.password = hex_md5(_this.user.password+KEY);      Loading.show();      _this.$ajax.post(process.env.VUE_APP_SERVER +&#x27;/system/admin/user/login&#x27;, _this.user).then((response) =&gt; &#123;        Loading.hide();        let resp = response.data;        if (resp.success) &#123;          console.log(&quot;登录成功：&quot;,resp.content)          let loginUser = resp.content;//新增          Tool.setLoginUser(resp.content)          this.$router.push(&quot;/welcome&quot;)    ///////////////////////////////////////以下新增          //判断“记住我”          if(_this.remember)&#123;            //如果勾就记住我,则将用户名密码保存到本地缓存这里需要保存密码明文，否则登录时又会再加一层密            LocalStorage.set(LOCAL_KEY_REMEBER_USER,&#123;              loginName:loginUser.loginName,              password:passwordShow            &#125;);          &#125;else&#123;            //没有勾选“记住我”时，要把本地缓存清空否则按照Mounted的逻验·下次打开时会自动显示用户名密码            LocalStorage.set(LOCAL_KEY_REMEBER_USER,null);          &#125;    ///////////////////////////////////////////////        &#125;else &#123;          Toast.warning(resp.message);        &#125;        &#125;);    &#125;,\n\n\n2.用户管理与登录：增加记住登录信息功能，安全加固，本地缓存\n修改login.vue\nlogin()&#123;  let _this = this;  //////////////////////////////////////////////////////////////  //将明文存储到缓存中  // let passwordShow = _this.user.password;  //如果密码是从缓存带出来的，则不需要重新加密  let md5 = hex_md5(_this.user.password);  let rememberUser = LocalStorage.get(LOCAL_KEY_REMEBER_USER)||&#123;&#125;;  if (md5 !== rememberUser.md5)&#123;    _this.user.password = hex_md5(_this.user.password+KEY);  &#125;  //////////////////////////////////////////////////////////////////  Loading.show();  _this.$ajax.post(process.env.VUE_APP_SERVER +&#x27;/system/admin/user/login&#x27;, _this.user).then((response) =&gt; &#123;    Loading.hide();    let resp = response.data;    if (resp.success) &#123;      console.log(&quot;登录成功：&quot;,resp.content)      let loginUser = resp.content;      Tool.setLoginUser(resp.content)      this.$router.push(&quot;/welcome&quot;)/////////////////////////////////////////////////////////////////////////////      //判断“记住我”      if(_this.remember)&#123;        //如果勾就记住我,则将用户名密码保存到本地缓存这里需要保存密码明文，否则登录时又会再加一层密        //原：这里需要保存密码明文，否则登陆时又会再增加一层密        //新：这里保存密码密文，并保存密文md5，用于检测密码是否被重新输入过        let md5 = hex_md5(_this.user.password)        LocalStorage.set(LOCAL_KEY_REMEBER_USER,&#123;          loginName:loginUser.loginName,          password:_this.user.password,          md5: md5        &#125;);//////////////////////////////////////////////////////////////////////////////////      &#125;else&#123;        //没有勾选“记住我”时，要把本地缓存清空否则按照Mounted的逻验·下次打开时会自动显示用户名密码        LocalStorage.set(LOCAL_KEY_REMEBER_USER,null);      &#125;    &#125;else &#123;      Toast.warning(resp.message);    &#125;    &#125;);&#125;,\n\n\n从刚才的记住我这个功能，大家可以看出来，一个是记住明文，一是记住密文，虽然实现的功能是一样的，但是安全性上不一样，所以我们写程序不只是把功能写出来，还要严谨，不要留下坑\n\n11-5 增加登录图形验证码集成图形验证码kaptcha\n1.用户管理与登录：集成图形验证码kaptcha\n\n我们首先再course和server的pom.xml中添加\n\n&lt;!-- 图形验证码 --&gt;&lt;dependency&gt;   &lt;groupId&gt;com.github.penggle&lt;/groupId&gt;   &lt;artifactId&gt;kaptcha&lt;/artifactId&gt;   &lt;version&gt;2.3.2&lt;/version&gt;&lt;/dependency&gt;\n\n\n然后在server的config中添加KaptchaConfig，如果项目中有多个页面会用到验证码图片，且图片的大小颜色等都不一样，就可以增加多个生成验证码图片方法\n\npackage com.course.server.config;import com.google.code.kaptcha.impl.DefaultKaptcha;import com.google.code.kaptcha.util.Config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.Properties;@Configurationpublic class KaptchaConfig &#123;    @Bean    public DefaultKaptcha getDefaultKaptcha() &#123;        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();        Properties properties = new Properties();        properties.setProperty(&quot;kaptcha.border&quot;, &quot;no&quot;);//        properties.setProperty(&quot;kaptcha.border.color&quot;, &quot;105,179,90&quot;);        properties.setProperty(&quot;kaptcha.textproducer.font.color&quot;, &quot;blue&quot;);        properties.setProperty(&quot;kaptcha.image.width&quot;, &quot;90&quot;);        properties.setProperty(&quot;kaptcha.image.height&quot;, &quot;32&quot;);        properties.setProperty(&quot;kaptcha.textproducer.font.size&quot;, &quot;24&quot;);        properties.setProperty(&quot;kaptcha.session.key&quot;, &quot;code&quot;);        properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;, &quot;4&quot;);        properties.setProperty(&quot;kaptcha.textproducer.font.names&quot;, &quot;Arial&quot;);        properties.setProperty(&quot;kaptcha.noise.color&quot;, &quot;255,96,0&quot;);        properties.setProperty(&quot;kaptcha.noise.impl&quot;, &quot;com.google.code.kaptcha.impl.NoNoise&quot;);//        properties.setProperty(&quot;kaptcha.obscurificator.impl&quot;, &quot;com.google.code.kaptcha.impl.WaterRipple&quot;);        properties.setProperty(&quot;kaptcha.obscurificator.impl&quot;, &quot;com.course.server.util.NoWaterRipple&quot;);        Config config = new Config(properties);        defaultKaptcha.setConfig(config);        return defaultKaptcha;    &#125;    @Bean    public DefaultKaptcha getWebKaptcha() &#123;        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();        Properties properties = new Properties();        properties.setProperty(&quot;kaptcha.border&quot;, &quot;no&quot;);//        properties.setProperty(&quot;kaptcha.border.color&quot;, &quot;105,179,90&quot;);        properties.setProperty(&quot;kaptcha.textproducer.font.color&quot;, &quot;blue&quot;);        properties.setProperty(&quot;kaptcha.image.width&quot;, &quot;90&quot;);        properties.setProperty(&quot;kaptcha.image.height&quot;, &quot;45&quot;);        properties.setProperty(&quot;kaptcha.textproducer.font.size&quot;, &quot;30&quot;);        properties.setProperty(&quot;kaptcha.session.key&quot;, &quot;code&quot;);        properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;, &quot;4&quot;);        properties.setProperty(&quot;kaptcha.textproducer.font.names&quot;, &quot;Arial&quot;);        properties.setProperty(&quot;kaptcha.noise.impl&quot;, &quot;com.google.code.kaptcha.impl.NoNoise&quot;);        properties.setProperty(&quot;kaptcha.obscurificator.impl&quot;, &quot;com.google.code.kaptcha.impl.WaterRipple&quot;);        Config config = new Config(properties);        defaultKaptcha.setConfig(config);        return defaultKaptcha;    &#125;&#125; \n\n\n然后再system的admin添加KaptchaController\n\npackage com.course.system.controller.admin;import com.google.code.kaptcha.impl.DefaultKaptcha;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.imageio.ImageIO;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.image.BufferedImage;import java.io.ByteArrayOutputStream;@RestController@RequestMapping(&quot;/admin/kaptcha&quot;)public class KaptchaController &#123;    @Qualifier(&quot;getDefaultKaptcha&quot;)    @Autowired    DefaultKaptcha defaultKaptcha;    @GetMapping(&quot;/image-code/&#123;imageCodeToken&#125;&quot;)    public void imageCode(@PathVariable(value = &quot;imageCodeToken&quot;) String imageCodeToken, HttpServletRequest request, HttpServletResponse httpServletResponse) throws Exception&#123;        ByteArrayOutputStream jpegOutputStream = new ByteArrayOutputStream();        try &#123;            // 生成验证码字符串            String createText = defaultKaptcha.createText();            // 将生成的验证码放入会话缓存中，后续验证的时候用到             request.getSession().setAttribute(imageCodeToken, createText);            // 使用验证码字符串生成验证码图片            BufferedImage challenge = defaultKaptcha.createImage(createText);            ImageIO.write(challenge, &quot;jpg&quot;, jpegOutputStream);        &#125; catch (IllegalArgumentException e) &#123;            httpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND);            return;        &#125;        // 定义response输出类型为image/jpeg类型，使用response输出流输出图片的byte数组        byte[] captchaChallengeAsJpeg = jpegOutputStream.toByteArray();        httpServletResponse.setHeader(&quot;Cache-Control&quot;, &quot;no-store&quot;);        httpServletResponse.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);        httpServletResponse.setDateHeader(&quot;Expires&quot;, 0);        httpServletResponse.setContentType(&quot;image/jpeg&quot;);        ServletOutputStream responseOutputStream = httpServletResponse.getOutputStream();        responseOutputStream.write(captchaChallengeAsJpeg);        responseOutputStream.flush();        responseOutputStream.close();    &#125;&#125;\n\n页面显示验证码及刷新验证码\n1.用户管理与登录：页面显示验证码及刷新验证码\n\n验证码功能分为显示和验证两个步骤，用token将两个步骤关联起\n\n我们首先给Tool.js增加一个方法，原理：以62进制为例，随机生成一个0~61的数值，比如41，那边就取chars数组中的第41个字符，这样重复做8遍，就生成了8位的62进制数，重复的概率是62的8次方。也可以生成更长的数值。\n\n\n/** * 随机生成[len]长度的[radix]进制数 * @param len * @param radix 默认62 * @returns &#123;string&#125; */uuid: function (len, radix) &#123;    let chars = &#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#x27;.split(&#x27;&#x27;);    let uuid = [];    radix = radix || chars.length;    for (let i = 0; i &lt; len; i++) &#123;        uuid[i] = chars[0 | Math.random() * radix];    &#125;    return uuid.join(&#x27;&#x27;);&#125;,\n\n\n然后我们修改login.vue\n\n //增加一个验证码框，在Bootstrap中找&lt;label class=&quot;block clearfix&quot;&gt;&lt;span class=&quot;block input-icon input-icon-right&quot;&gt;&lt;div class=&quot;input-group&quot;&gt;                &lt;input  type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;验证码&quot; &gt;                &lt;span class=&quot;input-group-addon&quot; id=&quot;basic-add2on&quot;&gt;                  &lt;img v-on:click=&quot;loadImageCode()&quot; id=&quot;image-code&quot; alt=&quot;验证码&quot;/&gt;                &lt;/span&gt;              &lt;/div&gt;&lt;/span&gt;&lt;/label&gt;//初始时加载一次验证码图片_this.loadImageCode(); /**     * 加载验证码方法     */    loadImageCode:function ()&#123;      let _this =this;      _this.imageCodeToken = Tool.uuid(8);      $(&#x27;#image-code&#x27;).attr(&#x27;src&#x27;,process.env.VUE_APP_SERVER+&#x27;/system/admin/kaptcha/image-code/&#x27;+_this.imageCodeToken);    &#125;,\n\n登录增加验证码校验\n\n在userdto中增加属性，增加属性后，记得Alt+lnsert生成get，set，toString（）方法\n\n/** * 验证码 */private String imageCode;/** * 图片验证码 */private String imageCodeToken;\n\n\n在登录里面，增加验证码校验：通过token去缓存中获取验证码字符串，并和用户输入的字符串做比较，在这我们修改UserController的login\n\n/** * 登录 */@PostMapping(&quot;/login&quot;)public ResponseDto login(@RequestBody UserDto userDto, HttpServletRequest request)&#123;    LOG.info(&quot;用户登录开始&quot;);    userDto.setPassword(DigestUtils.md5DigestAsHex(userDto.getPassword().getBytes()));    ResponseDto responseDto = new ResponseDto();    ////////////////////////////////////////////////////////////////////////////////////    //根据验证码token去获取缓存中的验证码，和用户输入的验证码是否一致    String imageCode = (String) request.getSession().getAttribute(userDto.getImageCodeToken());    if (StringUtils.isEmpty(imageCode))&#123;        responseDto.setSuccess(false);        responseDto.setMessage(&quot;验证码已过期&quot;);        LOG.info(&quot;用户登录失败&quot;);        return responseDto;    &#125;    if (!imageCode.toLowerCase().equals(userDto.getImageCode().toLowerCase()))&#123;        responseDto.setSuccess(false);        responseDto.setMessage(&quot;验证码不对&quot;);        LOG.info(&quot;用户登录失败&quot;);        return responseDto;    &#125;else&#123;        //验证码通过后，移除验证码        request.getSession().removeAttribute(userDto.getImageCodeToken());    &#125;    ///////////////////////////////////////////////////////////////////////////////    LoginUserDto loginUserDto = userService.login(userDto);    request.getSession().setAttribute(Constants.LOGIN_USER,loginUserDto);    responseDto.setContent(loginUserDto);    return responseDto;&#125;\n\n\n前后端分离会有一个问题，每次ajax请求，后端的session是不一样的。在springboo+jsp，或springboot+thymeleaf中，不会有这个问题。获取的验证码一致都是空，这个问题在页面中显示：\n\n下面开始解决验证码获取为空的方法，在main.js中加入\n\n\n//解决每次ajax请求·对应的sessionId不一致的问题axios.defaults.withCredentials =true;\n\n\n登录验证出错时，将密码清空，同时刷新验证码图片\n\n刷新验证码会让网站更安全，但是会辆性一点用户体验，需要折中选择\n\n只需要在login.vue中login方法登陆不成功时输入下面代码，就可以将密码清空，同时刷新验证码图片\n\n\n_this.user.password = &quot;&quot;;_this.loadImageCode();\n\n11-6 单点登录功能开发单点登录解决方案介绍\n\n生产发布时，至少是双节点，防止单台宕机\nrequest.getSession（）可以访问这片空间\n问题一：B节点中，没有经历过之前的登录，Session没有保存登录用户信息，于是B节点会认为未登录过，会拦截掉业务请\n解决方法一：IP_HASH，对客户端IP做HASH计算，负载均衡SLB中，会根据HASH值将该IP所有的请求固定的发往其中一台，缺点，当其中一个节点宕机，则该节点下的用户需要重新登录；另一个缺点是对SLB不能灵活的配置流量此如A这台机器性能好一点可以分配流量高一些\n解决方法二：不管是在哪一台做的登录，登录完成后，会把登录信息保存到redis中。当业务请求进来时，再到redis中获取登录信息，能获取到就表示已登录；未获取到就表示未登录，拦截掉请求\n\n\n\n功能：只要在其中一个产品中登录过，其他关联的产品都不需要再登录\n\ntoken：登录标识，每个用户每次登录，都会生成不同的token\n\n单点登录（Single Sign On），简称为SSO，核心功能为session共享\n\n需要解决Session共享的场景：1.同个应用多节点共享登录信息；2.多个项目间共享登录信息。一般我们通常说的单点登录系统，是用来解决场景2的\n\n\n\n集成redis\n1，用户管理与登录：集成redis，图片验证码的存储从session改为redis\n\n首先在server集成pom.xml\n\n&lt;!-- redis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n然后在application中增加配置\n\n# redis配置spring.redis.host=r-uf6ljbcdaxobsifyctpd.redis.rds.aliyuncs.comspring.redis.port=6379spring.redis.password=Redis000\n\n\n然后我们在KaptchaController中修改放验证码操作\n\n//注入@Resourcepublic RedisTemplate redisTemplate;// 将生成的验证码放入会话缓存中，后续验证的时候用到// request.getSession().setAttribute(imageCodeToken, createText);//将生成的验证码放入redis缓存中后续验证的时候用到redisTemplate.opsForValue().set(imageCodeToken,createText,300, TimeUnit.SECONDS);\n\n\n最后在UserController进行取操作\n\n//注入@Resourcepublic RedisTemplate redisTemplate;//根据验证码token去获取缓存中的验证码，和用户输入的验证码是否一致//String imageCode = (String)request.getSession().getAttribute(userDto.getImageCodeToken());String imageCode =(String)redisTemplate.opsForValue().get(userDto.getImageCodeToken());LOG.info(&quot;从redis中获取到验证码:&#123;&#125;&quot;,imageCode);\n\n生成登录token并存储到redis中\n1.用户管理与登录；生成登录token并存储到redis中：退出登录删除token\n\n我们在LoginUserDto增加\n\n/** * 登录凭证 */private String token;\n\n\n然后修改UserController，这里也可以直接保存loginUserDto对象，但是需要序列化。如果是跨应用使用的，比如A应用存，B应用取，一般会把值转成JSON字符串\n\n   //验证码通过后，移除验证码    //request.getSession().removeAttribute(userDto.getImageCodeToken());    redisTemplate.delete(userDto.getImageCodeToken());&#125;LoginUserDto loginUserDto = userService.login(userDto);String token = UuidUtil.getShortUuid();loginUserDto.setToken(token);//request.getSession().setAttribute(Constants.LOGIN_USER,loginUserDto);redisTemplate.opsForValue().set(token, JSON.toJSONString(loginUserDto),300, TimeUnit.SECONDS);responseDto.setContent(loginUserDto);return responseDto;/////////////////////////////////////////////////////**     * 退出登录     */    @GetMapping(&quot;/logout/&#123;token&#125;&quot;)    public ResponseDto logout(@PathVariable String token)&#123;        ResponseDto responseDto = new ResponseDto();        //request.getSession().removeAttribute(Constants.LOGIN_USER);       redisTemplate.delete(token);       LOG.info(&quot;从redis中删除token:&#123;&#125;&quot;,token);        return responseDto;    &#125;\n\n\n相应的admin.vue，增加token参数\n\n_this.$ajax.get(process.env.VUE_APP_SERVER +&#x27;/system/admin/user/logout/&#x27;+_this.loginUser.token)\n\n11-7 前后端登录拦截1.用户管理与登录；基于Vue路由的登录拦截\n\n首先在router的admin下增加meta\n\npath: &quot;/&quot;,name:&quot;admin&quot;,component: Admin,meta:&#123;    loginRequire:true&#125;,\n\n\n最后我们在main.js增加，就实现了拦截\n\n//路由拦截器router.beforeEach((to,from,next) =&gt;&#123;  if (to.matched.some(function (item)&#123;    return item.meta.loginRequire  &#125;))&#123;    let loginUser = Tool.getLoginUser();    if(Tool.isEmpty(loginUser))&#123;      next(&#x27;/login&#x27;);    &#125;else&#123;      next();    &#125;  &#125;else&#123;    next();  &#125;&#125;);\n\n在请求headers中统一增加token\n\n问题：界面拦住了，但是所有的接口都可以直接访问，非常危险，这时我们要做的就是基于后端的登录拦截\n\n就是在main.js的axias拦截器中增加，可以用这种给所有请求加了统一的系统参数，比如在header里加上请求流水，请求时间等\n\n\nlet token =Tool.getLoginUser().token;if (Tool.isNotEmpty(token))&#123;  config.headers.token = token;  console.log(&quot;请求headers增加token:&quot;,token);&#125;\n\ngateway增加登录拦截\n1.用户管理与登录：：在Gateway中增加登录拦截器\n\n不是所有的请求都需要做登录拦截，比如登录接口、验证码图片接口\n\n我们首先在application中增加过滤配置\n\n\nspring.cloud.gateway.routes[0].filters[0].name=LoginAdminspring.cloud.gateway.routes[0].filters[0].args[0]=true\n\n\n然后我们给系统加一个过滤器，在gateway下增加一个filter软件包，建立一个类LoginAdminGatewayFilterFactory\n\npackage com.course.gateway.filter;import org.springframework.cloud.gateway.filter.GatewayFilter;import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;import org.springframework.stereotype.Component;import javax.annotation.Resource;@Componentpublic class LoginAdminGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;Object&gt; &#123;    @Resource    LoginAdminGatewayFilter loginAdminGatewayFilter;    @Override    public GatewayFilter apply(Object config) &#123;        return loginAdminGatewayFilter;    &#125;&#125;\n\n\n最后在同包下建立实现类LoginAdminGatewayFilter\n\npackage com.course.gateway.filter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.cloud.gateway.filter.GatewayFilter;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.core.Ordered;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;@Componentpublic class LoginAdminGatewayFilter implements GatewayFilter, Ordered &#123;    private static final Logger LOG = LoggerFactory.getLogger(LoginAdminGatewayFilter.class);    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        //获取header的token参数        String token = exchange.getRequest().getHeaders().getFirst(&quot;token&quot;);        LOG.info(&quot;控台登录验证开始，token：&#123;&#125;&quot;, token);        return chain.filter(exchange);        &#125;    @Override    public int getOrder()    &#123;        return 1;    &#125;&#125;\n\n2.用户管理与登录：gateway实现控台登录拦截功能\n\n我们给gateway的pom.xml增加，gateway模块并没有依赖server模块，所以有些jar包redis，json等，需要单独在pom.xml中增加依赖\n\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 热部署DevTools --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n在LoginAdminGatewayFilter做如下修改\n\n//注入@Resourceprivate RedisTemplate redisTemplate;//判断拦截 @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;    //////////////////////////////////////////////////////////        String path = exchange.getRequest().getURI().getPath();        //请求地址不包含/admin/的，不是控台请求，不需要拦截        if(!path.contains(&quot;/admin/&quot;))&#123;            return chain.filter(exchange);        &#125;        if (path.contains(&quot;/system/admin/user/login&quot;)                ||path.contains(&quot;/system/admin/user/logout&quot;)                ||path.contains(&quot;/system/admin/kaptcha&quot;))&#123;            LOG.info(&quot;不需要控台登录验证:&#123;&#125;&quot;,path);            return chain.filter(exchange);        &#125;    ///////////////////////////////////////////////////////////////        //获取header的token参数        String token = exchange.getRequest().getHeaders().getFirst(&quot;token&quot;);        LOG.info(&quot;控台登录验证开始，token：&#123;&#125;&quot;, token);    /////////////////////////////////////////////////////////////////        if (token == null||token.isEmpty())&#123;            LOG.info(&quot;token为空，请求被拦截&quot;);            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);            return exchange.getResponse().setComplete();        &#125;        Object object = redisTemplate.opsForValue().get(token);        if (object == null)&#123;            LOG.warn(&quot;token无效，请求被拦截&quot;);            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);            return exchange.getResponse().setComplete();        &#125;else&#123;            LOG.info(&quot;已登录:&#123;&#125;&quot;,object);            return chain.filter(exchange);        &#125;    ////////////////////////////////////////////////////////////////////////////        &#125;\n\n11-8 用户登录流程图验证码图片登录\n\n\n登录的流程\n\n\n\n\n\n\n第12章 通用权限设计本章演示通用权限功能开发，不依赖任何使用第三方框架，使用经典的资源、角色、用户关联，灵活且维护，可以细粒度的控制菜单、按钮、接口的权限，适用于通用后台管理系统的权限管理。\n\n12-1 通用权限解决方案介绍\n目前一些知名的权限框架有Shiro和SpringSecurity。正常情况，直接用框架没什么问题。方便，快速，但是需要一定的学习成本，得学习如何使用这些框架。\n用框架还有一个缺点是不好定制，因为每个产品的业务都不太一样，要控制的权限都不太一样，此时如果硬是套用框架就会很别扭\n经典的权限管理设计：用户和角色关联，角色和资源关联\n两张关联表的配置，可以单独设计界面，也可以直接做到角色管理界面里。\n权限初始化，系统上线时，要初始化这五张表的数据。初始有一个用户能登录能管理角色，管理资源，分配权限\n疑问：前端已经对菜单和按钮做拦截，用户不能操作，为什么还要对接口做拦截？\n重要提示：所有前端的设计都是不安全的\n\n\n12-2 资源配置管理资源表的设计与基本代码生成\n1.通用权限管理：资源表的设计与基本代码生成\n\n资源的名称一般是用页面上看得见的元素：菜单、按钮等。\n\n页面对vue框架来说，就是路由\n\n如果是一个页面的所有操作统一控制权限，request可以填相关接口的前缀\n\n我们首先写sql\n\n\n# 资源drop table if exists `resource`;create table `resource`(                       `id` char(6) not null default &#x27;&#x27; comment &#x27;id&#x27;,                       `name` varchar(100) not null comment &#x27;名称|菜单或按钮&#x27;,                       `page` varchar(50) null comment &#x27;页面|路由&#x27;,                       `request` varchar(200) null comment &#x27;请求|接口&#x27;,                       `parent` char(6)  comment &#x27;父id&#x27;,                       primary key (`id`))engine =innodb default charset=utf8mb4 comment=&#x27;资源&#x27;;insert into `resource` values (&#x27;01&#x27;,&#x27;系统管理&#x27;,null,null,null);insert into `resource` values (&#x27;0101&#x27;,&#x27;用户管理&#x27;,&#x27;/system/user&#x27;,null,&#x27;01&#x27;);insert into `resource` values (&#x27;010101&#x27;,&#x27;保存&#x27;,null,&#x27;[&quot;/system/admin/user/list&quot;,&quot;/system/admin/user/save&quot;]&#x27;,&#x27;0101&#x27;);insert into `resource` values (&#x27;010102&#x27;,&#x27;删除&#x27;,null,&#x27;[&quot;/system/admin/user/delete&quot;]&#x27;,&#x27;0101&#x27;);insert into `resource` values (&#x27;010103&#x27;,&#x27;重置密码&#x27;,null,&#x27;[&quot;/system/admin/user/save-password&quot;]&#x27;,&#x27;0101&#x27;);insert into `resource` values (&#x27;0102&#x27;,&#x27;资源管理&#x27;,&#x27;/system/resource&#x27;,null,&#x27;01&#x27;);insert into `resource` values (&#x27;010201&#x27;,&#x27;保存/显示&#x27;,null,&#x27;[&quot;/system/admin/resource&quot;]&#x27;,&#x27;0102&#x27;);insert into `resource` values (&#x27;0103&#x27;,&#x27;角色管理&#x27;,&#x27;/system/role&#x27;,null,&#x27;01&#x27;);insert into `resource` values (&#x27;010301&#x27;,&#x27;角色/权限管理&#x27;,null,&#x27;[&quot;/system/admin/role&quot;]&#x27;,&#x27;0103&#x27;);\n\n\n接着就开始一顿操作，代码生成器，最后生成vue时，ResourceService和ResourceController会出现一个问题，原因：资源表的实体类是Resource，和@Resbutee注解同名！导致冲突\n\n解决上面的问题就是直接写全\n\n下面开始修改admin\n\n\n&lt;li class=&quot;&quot;&gt;  &lt;router-link to=&quot;/system/resource&quot;&gt;    &lt;i class=&quot;menu-icon fa fa-caret-right&quot;&gt;&lt;/i&gt;    资源管理  &lt;/router-link&gt;  &lt;b class=&quot;arrow&quot;&gt;&lt;/b&gt;&lt;/li&gt;\n\n\n最后改下router.js\n\n,&#123;    path: &quot;system/resource&quot;,    name:&quot;system/resource&quot;,    component: Resource,&#125;\n\n资源树的保存\n1.通用权限管理：资源树的保存\n\n资源点是开发阶段就确定的，所以并不是上线后再一个一个配置的。\n\n资源管理最简单的一种方案：上线前准备好sql，刷库\n\n在这里将资源管理做成资源树进行管理，填入数据：带有层级结构的json字符串\n\n用法：以后开发新功能的时候，就在该文件里加入新的资源可以上线前将新的资源json通过控台保存进数据库\n\n\n[&#123;  &quot;id&quot;: &quot;01&quot;,&quot;name&quot;: &quot;系统管理&quot;,  &quot;children&quot;:[&#123;    &quot;id&quot;:&quot;0101&quot;,&quot;name&quot;:&quot;用户管理&quot;,&quot;page&quot;:&quot;/system/user&quot;,    &quot;children&quot;:[        &#123;&quot;id&quot;:&quot;010101&quot;,&quot;name&quot;:&quot;保存&quot;,&quot;request&quot;:[&quot;/system/admin/user/list&quot;,&quot;/system/admin/user/save&quot;]&#125;,        &#123;&quot;id&quot;:&quot;010102&quot;,&quot;name&quot;:&quot;删除&quot;,&quot;request&quot;:[&quot;/system/admin/user/delete&quot;]&#125;,        &#123;&quot;id&quot;:&quot;010103&quot;,&quot;name&quot;:&quot;重置密码&quot;,&quot;request&quot;:[&quot;/system/admin/user/save-password&quot;]&#125;      ]&#125;,    &#123;      &quot;id&quot;:&quot;0102&quot;,&quot;name&quot;:&quot;资源管理&quot;,&quot;page&quot;:&quot;/system/resource&quot;,      &quot;children&quot;:[        &#123;&quot;id&quot;:&quot;010201&quot;,&quot;name&quot;:&quot;保存/显示&quot;,&quot;request&quot;:[&quot;/system/admin/resource&quot;]&#125;      ]    &#125;, &#123;        &quot;id&quot;:&quot;0103&quot;,&quot;name&quot;:&quot;角色管理&quot;,&quot;page&quot;:&quot;/system/role&quot;,        &quot;children&quot;:[            &#123;&quot;id&quot;:&quot;010301&quot;,&quot;name&quot;:&quot;角色/权限管理&quot;,&quot;request&quot;:[&quot;/system/admin/role&quot;]&#125;          ]      &#125;]&#125;]\n\n\n接下来修改下resource.vue，\n\n//新增去了，加上保存，并且删除模态框&lt;div class=&quot;row&quot;&gt;  &lt;div class=&quot;col-md-6&quot;&gt;    &lt;textarea id=&quot;resource-textarea&quot; class=&quot;form-control&quot; v-model=&quot;resourceStr&quot; name=&quot;resource&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;    &lt;br&gt;    &lt;button id=&quot;save-btn&quot; type=&quot;button&quot; class=&quot;btn btn-primary&quot; v-on:click=&quot;save()&quot;&gt;      保存    &lt;/button&gt;  &lt;/div&gt;  &lt;hr&gt;//然后data新增一个resourceStr绑定到多行文本框里的resourceStr:&quot;&quot;,//然后add和edit都删了//最后修改下save  save() &#123;      let _this = this;/////////////////////////////////////////////以下是修改      // 保存校验      if (Tool.isEmpty(_this.resourceStr)) &#123;        Toast.warning(&quot;资源不能为空！&quot;);        return;      &#125;      let json = JSON.parse(_this.resourceStr);      Loading.show();      _this.$ajax.post(process.env.VUE_APP_SERVER +&#x27;/system/admin/resource/save&#x27;, json).then((respond) =&gt; &#123;/////////////////////////////////////////////////        Loading.hide();        let resp = respond.data;        if (resp.success) &#123;          $(&quot;#form-modal&quot;).modal(&quot;hide&quot;);          _this.list(1);          Toast.success(&quot;保存成功&quot;);        &#125;else&#123;          Toast.warning(resp.message);        &#125;      &#125;)    &#125;,\n\n\n接下来修改下ResourceController的save，原本是一个个保存，现在直接保存整个字符串\n\n@PostMapping(&quot;/save&quot;)public ResponseDto save(@RequestBody String jsonStr)&#123;    //保存校验        ValidatorUtil.require(jsonStr, &quot;资源&quot;);    ResponseDto responseDto = new ResponseDto();    resourceService.saveJson(jsonStr);    return responseDto;&#125;\n\n\n然后我们修改ResourceDto\n\nprivate List&lt;ResourceDto&gt; children;//嵌套实类结构\n\n\n最后我们修改ResourceService\n\n/** * 新增，ID是自定义好的，不是自动生成的，将setId删除 */private void insert(Resource resource)&#123;    resourceMapper.insert(resource);&#125; /**     * 保存资源树     * @param json     */    @Transactional    public void saveJson(String json)&#123;        List&lt;ResourceDto&gt; jsonList = JSON.parseArray(json, ResourceDto.class);        List&lt;ResourceDto&gt; list = new ArrayList&lt;&gt;();//将带有嵌套结构的jsonList里所有的节点取出来，组成简单的list        if (!CollectionUtils.isEmpty(jsonList))&#123;            for (ResourceDto d:jsonList)&#123;                d.setParent(&quot;&quot;);                add(list,d);            &#125;        &#125;        LOG.info(&quot;共&#123;&#125;条&quot;,list.size());        resourceMapper.deleteByExample(null);//把数据库整张表清空        for (int i = 0; i &lt; list.size(); i++) &#123;            this.insert(CopyUtil.copy(list.get(i),Resource.class));        &#125;    &#125; /**     * 递归，将树形节点全部取出来，放到list。add方法是一个递归函数，功能是将d节点下的子节点添加到list中如果子节点下还有孙子节点，则递归调用add方法     * @param list     * @param dto     */    public void add(List&lt;ResourceDto&gt; list,ResourceDto dto)&#123;        list.add(dto);        if(!CollectionUtils.isEmpty(dto.getChildren()))&#123;            for (ResourceDto d:dto.getChildren())&#123;                d.setParent(dto.getId());                add(list,d);            &#125;        &#125;    &#125;\n\n资源树的显示\n\n\n我们首先修改resource.vue\n\n//在保存按钮下新增，下面表格就可以删了&lt;div class=&quot;col-md-6&quot;&gt;  &lt;ul id=&quot;tree&quot; class=&quot;ztree&quot;&gt;&lt;/ul&gt;&lt;/div&gt;//data中增加对象tree:&#123;&#125;,//对list进行修改list() &#123;      let _this = this;      Loading.show();      _this.$ajax.get(process.env.VUE_APP_SERVER +&#x27;/system/admin/resource/load-tree&#x27;)      .then((res) =&gt; &#123;        Loading.hide();        let response = res.data;        _this.resources = response.content;        //初始树        _this.initTree();      &#125;)    &#125;,//增加一个初始化树 initTree()&#123;      let _this =this;      let setting=&#123;        data:&#123;          simpleData:&#123;            idKey:&quot;id&quot;,            pIdKey:&quot;parent&quot;,            rootPId:&quot;&quot;,          &#125;        &#125;      &#125;;      _this.zTree = $.fn.zTree.init($(&quot;#tree&quot;),setting,_this.resources);      _this.zTree.expandAll(true);    &#125;\n\n\n在ResourceController就增加了一个方法\n\n/** * 资源树查询 */@GetMapping(&quot;/load-tree&quot;)public  ResponseDto loadTree()&#123;    ResponseDto responseDto = new ResponseDto();    List&lt;ResourceDto&gt; resourceDtoList = resourceService.loadTree();    responseDto.setContent(resourceDtoList);    return responseDto;&#125;\n\n\n接下来修改下对应的ResourceService\n\n/** * 按约定将列表转成树 * 要求：ID要正序排列 */public List&lt;ResourceDto&gt; loadTree() &#123;    ResourceExample example = new ResourceExample();    example.setOrderByClause(&quot;id asc&quot;);    List&lt;Resource&gt; resourceList = resourceMapper.selectByExample(example);    List&lt;ResourceDto&gt; resourceDtoList = CopyUtil.copyList(resourceList, ResourceDto.class);    for (int i = resourceDtoList.size() - 1; i &gt;= 0; i--) &#123;        //当前要移动的记录        ResourceDto child = resourceDtoList.get(i);        //如果当前节点没有父节点，则不用往下了        if (StringUtils.isEmpty(child.getParent())) &#123;            continue;        &#125;        //查找父节点        for (int j = i - 1; j &gt;= 0; j--) &#123;            ResourceDto parent = resourceDtoList.get(j);            if (child.getParent().equals(parent.getId())) &#123;                if (CollectionUtils.isEmpty(parent.getChildren())) &#123;                    parent.setChildren(new ArrayList&lt;&gt;());                &#125;                //添加到最前面，否则会变成倒序，因为循环是从后往前循环的                parent.getChildren().add(0, child);                //子节点找到父节点后删除列表中的子节点                resourceDtoList.remove(child);            &#125;        &#125;    &#125;    return resourceDtoList;&#125;\n\n\n资源的保存是将树结构转成列表，重点是children属性；资源的显示是将列表转成树结构，重点是parent属性。\n\n小知识：一边循环list，一边删除list中的对象，可以使用倒序循环\n\n\n12-3角色权限管理基本的角色管理功能\n1.通用权限管理：增加基本的角色管理功能2.资源列表补全\n\n\n我们首先写sql，然后代码生成器\n\n# 角色drop table if exists `role`;create table `role`(                           `id` char(8) not null default &#x27;&#x27; comment &#x27;id&#x27;,                           `name` varchar(50) not null comment &#x27;角色&#x27;,                           `desc` varchar(100) not null comment &#x27;描述&#x27;,                           primary key (`id`))engine =innodb default charset=utf8mb4 comment=&#x27;角色&#x27;;insert into `role` values (&#x27;00000000&#x27;,&#x27;系统管理员&#x27;,&#x27;管理用户、角色权限&#x27;);insert into `role` values (&#x27;00000001&#x27;,&#x27;开发&#x27;,&#x27;维护资源&#x27;);insert into `role` values (&#x27;00000002&#x27;,&#x27;业务管理员&#x27;,&#x27;负责业务管理&#x27;);\n\n\nadmin增加\n\n&lt;b class=&quot;arrow&quot;&gt;&lt;/b&gt;&lt;/li&gt;&lt;li class=&quot;&quot; id=&quot;system-role-sidebar&quot;&gt;  &lt;router-link to=&quot;/system/role&quot;&gt;    &lt;i class=&quot;menu-icon fa fa-caret-right&quot;&gt;&lt;/i&gt;    角色管理  &lt;/router-link&gt;\n\n\n最后修改router.js\n\n,&#123;    path: &quot;system/role&quot;,    name:&quot;system/role&quot;,    component: Role,&#125;\n\n\n另外我们把resource.js补全\n\n[&#123;    &quot;id&quot;: &quot;01&quot;,&quot;name&quot;: &quot;系统管理&quot;,    &quot;children&quot;:[&#123;      &quot;id&quot;:&quot;0101&quot;,&quot;name&quot;:&quot;用户管理&quot;,&quot;page&quot;:&quot;/system/user&quot;,      &quot;children&quot;:[        &#123;&quot;id&quot;:&quot;010101&quot;,&quot;name&quot;:&quot;保存&quot;,&quot;request&quot;:[&quot;/system/admin/user/list&quot;,&quot;/system/admin/user/save&quot;]&#125;,        &#123;&quot;id&quot;:&quot;010102&quot;,&quot;name&quot;:&quot;删除&quot;,&quot;request&quot;:[&quot;/system/admin/user/delete&quot;]&#125;,        &#123;&quot;id&quot;:&quot;010103&quot;,&quot;name&quot;:&quot;重置密码&quot;,&quot;request&quot;:[&quot;/system/admin/user/save-password&quot;]&#125;      ]    &#125;,    &#123;      &quot;id&quot;:&quot;0102&quot;,&quot;name&quot;:&quot;资源管理&quot;,&quot;page&quot;:&quot;/system/resource&quot;,      &quot;children&quot;:[        &#123;&quot;id&quot;:&quot;010201&quot;,&quot;name&quot;:&quot;保存/显示&quot;,&quot;request&quot;:[&quot;/system/admin/resource&quot;]&#125;      ]    &#125;, &#123;        &quot;id&quot;:&quot;0103&quot;,&quot;name&quot;:&quot;角色管理&quot;,&quot;page&quot;:&quot;/system/role&quot;,        &quot;children&quot;:[            &#123;&quot;id&quot;:&quot;010301&quot;,&quot;name&quot;:&quot;角色/权限管理&quot;,&quot;request&quot;:[&quot;/system/admin/role&quot;]&#125;          ]      &#125;]&#125;,&#123;  &quot;id&quot;: &quot;02&quot;,&quot;name&quot;: &quot;业务管理&quot;,  &quot;children&quot;:[&#123;    &quot;id&quot;:&quot;0201&quot;,&quot;name&quot;:&quot;分类管理&quot;,&quot;page&quot;:&quot;/business/category&quot;,    &quot;children&quot;:[      &#123;&quot;id&quot;:&quot;020101&quot;,&quot;name&quot;:&quot;增删改查&quot;,&quot;request&quot;:[&quot;/business/admin/category&quot;]&#125;     ]  &#125;,&#123;      &quot;id&quot;:&quot;0202&quot;,&quot;name&quot;:&quot;课程管理&quot;,&quot;page&quot;:&quot;/business/course&quot;,      &quot;children&quot;:[        &#123;&quot;id&quot;:&quot;020201&quot;,&quot;name&quot;:&quot;增删改查&quot;,&quot;request&quot;:[&quot;/business/admin/course&quot;,&quot;/business/admin/category/all&quot;]&#125;      ]    &#125;,&#123;      &quot;id&quot;:&quot;0203&quot;,&quot;name&quot;:&quot;讲师管理&quot;,&quot;page&quot;:&quot;/business/teacher&quot;,      &quot;children&quot;:[        &#123;&quot;id&quot;:&quot;020301&quot;,&quot;name&quot;:&quot;增删改查&quot;,&quot;request&quot;:[&quot;/business/admin/teacher&quot;]&#125;      ]    &#125;]  &#125;,&#123;  &quot;id&quot;: &quot;03&quot;,&quot;name&quot;: &quot;文件管理&quot;,  &quot;children&quot;:[&#123;    &quot;id&quot;:&quot;0301&quot;,&quot;name&quot;:&quot;文件管理&quot;,&quot;page&quot;:&quot;/file/file&quot;,    &quot;children&quot;:[      &#123;&quot;id&quot;:&quot;030101&quot;,&quot;name&quot;:&quot;文件管理&quot;,&quot;request&quot;:[&quot;/file/admin/file&quot;]&#125;    ]  &#125;]&#125;]\n\n增加角色资源关联功能\n1.通用权限管理：增加角色资源关联表，生成持久层和服务端代码\n\n\n首先添加sql,然后mybatis和server代码生成器，界面就用role的\n\n# 角色-资源关联表drop table if exists `role_resource`;create table `role_resource`(                       `id` char(8) not null default &#x27;&#x27; comment &#x27;id&#x27;,                       `role_id` char(8) not null  comment &#x27;角色|id&#x27;,                       `resource_id` char(6) not null  comment &#x27;资源|id&#x27;,                       primary key (`id`))engine =innodb default charset=utf8mb4 comment=&#x27;角色资源关联&#x27;;insert into `role_resource` values (&#x27;00000000&#x27;,&#x27;00000000&#x27;,&#x27;01&#x27;);insert into `role_resource` values (&#x27;00000001&#x27;,&#x27;00000000&#x27;,&#x27;0101&#x27;);insert into `role_resource` values (&#x27;00000002&#x27;,&#x27;00000000&#x27;,&#x27;010101&#x27;);insert into `role_resource` values (&#x27;00000003&#x27;,&#x27;00000000&#x27;,&#x27;010102&#x27;);insert into `role_resource` values (&#x27;00000004&#x27;,&#x27;00000000&#x27;,&#x27;010103&#x27;);insert into `role_resource` values (&#x27;00000005&#x27;,&#x27;00000000&#x27;,&#x27;0102&#x27;);insert into `role_resource` values (&#x27;00000006&#x27;,&#x27;00000000&#x27;,&#x27;010201&#x27;);insert into `role_resource` values (&#x27;00000007&#x27;,&#x27;00000000&#x27;,&#x27;0103&#x27;);insert into `role_resource` values (&#x27;00000008&#x27;,&#x27;00000000&#x27;,&#x27;010301&#x27;);\n\n2.通用权限管理：点击【关联资源】按钮时，加载资源树\n\n\n显示图片如下所示\n\n我们只修改role就行\n\n\n//在操作那加一个按钮&lt;button v-on:click=&quot;editResource(role)&quot; class=&quot;btn btn-xs btn-info&quot;&gt;  &lt;i class=&quot;ace-icon fa fa-list bigger-120&quot;&gt;&lt;/i&gt;&lt;/button&gt;//增加一个模态框&lt;!-- 角色资源关联配置 --&gt;    &lt;div id=&quot;resource-modal&quot; class=&quot;modal fade&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot;&gt;      &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;        &lt;div class=&quot;modal-content&quot;&gt;          &lt;div class=&quot;modal-header&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;            &lt;h4 class=&quot;modal-title&quot;&gt;角色资源关联配置&lt;/h4&gt;          &lt;/div&gt;          &lt;div class=&quot;modal-body&quot;&gt;            &lt;ul id=&quot;tree&quot; class=&quot;ztree&quot;&gt;&lt;/ul&gt;          &lt;/div&gt;          &lt;div class=&quot;modal-footer&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-white btn-default btn-round&quot; data-dismiss=&quot;modal&quot;&gt;              &lt;i class=&quot;ace-icon fa fa-times&quot;&gt;&lt;/i&gt;              关闭            &lt;/button&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-white btn-info btn-round&quot; v-on:click=&quot;saveResource()&quot;&gt;              &lt;i class=&quot;ace-icon fa fa-plus blue&quot;&gt;&lt;/i&gt;              保存            &lt;/button&gt;          &lt;/div&gt;        &lt;/div&gt;&lt;!-- /.modal-content --&gt;      &lt;/div&gt;&lt;!-- /.modal-dialog --&gt;    &lt;/div&gt;&lt;!-- /.modal --&gt;//在data中加两个对象    resource:[],      zTree:&#123;&#125;,//增加这几个方法/**     * 点击【编辑】     */    editResource(role) &#123;      let _this = this;      _this.role = $.extend(&#123;&#125;, role);      _this.loadResource();      $(&quot;#resource-modal&quot;).modal(&quot;show&quot;);    &#125;,    /**     * 加载资源树     */    loadResource() &#123;      let _this = this;      Loading.show();      _this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/system/admin/resource/load-tree&#x27;).then((res)=&gt;&#123;        Loading.hide();        let response = res.data;        _this.resources = response.content;        // 初始化树        _this.initTree();      &#125;)    &#125;,    /**     * 初始资源树     */    initTree() &#123;      let _this = this;      let setting = &#123;        check: &#123;          enable: true        &#125;,        data: &#123;          simpleData: &#123;            idKey: &quot;id&quot;,            pIdKey: &quot;parent&quot;,            rootPId: &quot;&quot;,            enable: true          &#125;        &#125;      &#125;;      _this.zTree = $.fn.zTree.init($(&quot;#tree&quot;), setting, _this.resources);      _this.zTree.expandAll(true);    &#125;,\n\n3.通用权限管理：点击资源树模态框【保存】按钮时，保存角色资源关联表\n\n\n增加一个保存功能\n\n现在role.vue中添加保存方法\n\n\n/** * 资源模态框点击【保存】 */saveResource() &#123;  let _this = this;  let resources = _this.zTree.getCheckedNodes();  console.log(&quot;勾选的资源：&quot;, resources);  // 保存时，只需要保存资源id，所以使用id数组进行参数传递  let resourceIds = [];  for (let i = 0; i &lt; resources.length; i++) &#123;    resourceIds.push(resources[i].id);  &#125;  _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/system/admin/role/save-resource&#x27;, &#123;    id: _this.role.id,    resourceIds: resourceIds  &#125;).then((response)=&gt;&#123;    let resp = response.data;    if (resp.success) &#123;      Toast.success(&quot;保存成功!&quot;);    &#125; else &#123;      Toast.warning(resp.message);    &#125;  &#125;);&#125;,\n\n\n再在roledto增加字段\n\nprivate List&lt;String&gt; resourceIds;\n\n\n接下来修改RoleController\n\n/** * 保存资源 * @param roleDto */@PostMapping(&quot;/save-resource&quot;)public ResponseDto saveResource(@RequestBody RoleDto roleDto) &#123;    LOG.info(&quot;保存角色资源关联开始&quot;);    ResponseDto&lt;RoleDto&gt; responseDto = new ResponseDto&lt;&gt;();    roleService.saveResource(roleDto);    responseDto.setContent(roleDto);    return responseDto;&#125;\n\n\n最后修改RoleService\n\n@Resourceprivate RoleResourceMapper roleResourceMapper; /**     * 按角色保存资源     */    @Transactional    public void saveResource(RoleDto roleDto) &#123;        String roleId = roleDto.getId();        List&lt;String&gt; resourceIds = roleDto.getResourceIds();        // 清空库中所有的当前角色下的记录        RoleResourceExample example = new RoleResourceExample();        example.createCriteria().andRoleIdEqualTo(roleId);        roleResourceMapper.deleteByExample(example);        // 保存角色资源        for (int i = 0; i &lt; resourceIds.size(); i++) &#123;            RoleResource roleResource = new RoleResource();            roleResource.setId(UuidUtil.getShortUuid());            roleResource.setRoleId(roleId);            roleResource.setResourceId(resourceIds.get(i));            roleResourceMapper.insert(roleResource);        &#125;    &#125;\n\n4.通用权限管理：打开资源树模态框时，加载角色资源关联数据，并自动勾选树节点\n\n\n批量操作的思路：先将原有的删除，再批量新增\n\n首先修改role.vue\n\n\n//在loadResource方法初始化树后加载资源// 初始化树_this.initTree();_this.listRoleResource();/**     * 加载角色资源关联记录     */    listRoleResource() &#123;      let _this = this;      _this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/system/admin/role/list-resource/&#x27; + _this.role.id).then((response)=&gt;&#123;        let resp = response.data;        let resources = resp.content;        // 勾选查询到的资源：先把树的所有节点清空勾选，再勾选查询到的节点        _this.zTree.checkAllNodes(false);        for (let i = 0; i &lt; resources.length; i++) &#123;          let node = _this.zTree.getNodeByParam(&quot;id&quot;, resources[i]);          _this.zTree.checkNode(node, true);        &#125;      &#125;);    &#125;,\n\n\n接下来在RoleController\n\n/** * 加载已关联的资源 */@GetMapping(&quot;/list-resource/&#123;roleId&#125;&quot;)public ResponseDto listResource(@PathVariable String roleId) &#123;    LOG.info(&quot;加载资源开始&quot;);    ResponseDto responseDto = new ResponseDto&lt;&gt;();    List&lt;String&gt; resourceIdList = roleService.listResource(roleId);    responseDto.setContent(resourceIdList);    return responseDto;&#125;\n\n\n最后在RoleService\n\n/** * 按角色加载资源 * @param roleId */public List&lt;String&gt; listResource(String roleId) &#123;    RoleResourceExample example = new RoleResourceExample();    example.createCriteria().andRoleIdEqualTo(roleId);    List&lt;RoleResource&gt; roleResourceList = roleResourceMapper.selectByExample(example);    List&lt;String&gt; resourceIdList = new ArrayList&lt;&gt;();    for (int i = 0, l = roleResourceList.size(); i &lt; l; i++) &#123;        resourceIdList.add(roleResourceList.get(i).getResourceId());    &#125;    return resourceIdList;&#125;\n\n增加角色用户关联功能\n1.通用权限管理：增加角色用户关联表，生成持久层和服务端代码\n\n\n首先建立sql，然后代码生成器\n\n# 角色-用户关联表drop table if exists `role_user`;create table `role_user`(                                `id` char(8) not null default &#x27;&#x27; comment &#x27;id&#x27;,                                `role_id` char(8) not null  comment &#x27;角色|id&#x27;,                                `user_id` char(8) not null  comment &#x27;用户|id&#x27;,                                primary key (`id`))engine =innodb default charset=utf8mb4 comment=&#x27;角色用户关联&#x27;;insert into `role_user` values (&#x27;00000000&#x27;,&#x27;00000000&#x27;,&#x27;10000000&#x27;);\n\n2.通用权限管理：点击【关联用户】按钮时，加载所有用户\n\n\n加一个按钮显示这样的界面\n\n只需要修改role.vue\n\n\n//增加用户按钮&lt;button v-on:click=&quot;editUser(role)&quot; class=&quot;btn btn-xs btn-info&quot;&gt;  &lt;i class=&quot;ace-icon fa fa-user bigger-120&quot;&gt;&lt;/i&gt;&lt;/button&gt;//增加一个模态框 &lt;!-- 角色用户关联配置 --&gt;    &lt;div id=&quot;user-modal&quot; class=&quot;modal fade&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot;&gt;      &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;        &lt;div class=&quot;modal-content&quot;&gt;          &lt;div class=&quot;modal-header&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;            &lt;h4 class=&quot;modal-title&quot;&gt;角色用户关联配置&lt;/h4&gt;          &lt;/div&gt;          &lt;div class=&quot;modal-body&quot;&gt;            &lt;div class=&quot;row&quot;&gt;              &lt;div class=&quot;col-md-6&quot;&gt;                &lt;table id=&quot;user-table&quot; class=&quot;table table-hover&quot;&gt;                  &lt;tbody&gt;                  &lt;tr v-for=&quot;user in users&quot;&gt;                    &lt;td&gt;&#123;&#123;user.loginName&#125;&#125;&lt;/td&gt;                    &lt;td class=&quot;text-right&quot;&gt;                      &lt;a  href=&quot;javascript:;&quot; class=&quot;&quot;&gt;                        &lt;i class=&quot;ace-icon fa fa-arrow-circle-right blue&quot;&gt;&lt;/i&gt;                      &lt;/a&gt;                    &lt;/td&gt;                  &lt;/tr&gt;                  &lt;/tbody&gt;                &lt;/table&gt;              &lt;/div&gt;              &lt;div class=&quot;col-md-6&quot;&gt;                &lt;table id=&quot;role-user-table&quot; class=&quot;table table-hover&quot;&gt;                  &lt;tbody&gt;                  &lt;tr v-for=&quot;user in roleUsers&quot;&gt;                    &lt;td&gt;&#123;&#123;user.loginName&#125;&#125;&lt;/td&gt;                    &lt;td class=&quot;text-right&quot;&gt;                      &lt;a v-on:click=&quot;deleteUser(user)&quot; href=&quot;javascript:;&quot; class=&quot;&quot;&gt;                        &lt;i class=&quot;ace-icon fa fa-trash blue&quot;&gt;&lt;/i&gt;                      &lt;/a&gt;                    &lt;/td&gt;                  &lt;/tr&gt;                  &lt;/tbody&gt;                &lt;/table&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;div class=&quot;modal-footer&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-white btn-default btn-round&quot; data-dismiss=&quot;modal&quot;&gt;              &lt;i class=&quot;ace-icon fa fa-times&quot;&gt;&lt;/i&gt;              关闭            &lt;/button&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-white btn-info btn-round&quot; v-on:click=&quot;saveUser()&quot;&gt;              &lt;i class=&quot;ace-icon fa fa-plus blue&quot;&gt;&lt;/i&gt;              保存            &lt;/button&gt;          &lt;/div&gt;        &lt;/div&gt;&lt;!-- /.modal-content --&gt;      &lt;/div&gt;&lt;!-- /.modal-dialog --&gt;    &lt;/div&gt;&lt;!-- /.modal --&gt;//data中增加users:[],roleUsers:[]/**     * 点击【用户】     */    editUser(role) &#123;      let _this = this;      _this.role = $.extend(&#123;&#125;, role);      _this.listUser();      $(&quot;#user-modal&quot;).modal(&quot;show&quot;);    &#125;,    /**     * 查询所有用户     */    listUser() &#123;      let _this = this;      _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/system/admin/user/list&#x27;, &#123;        page: 1,        size: 9999      &#125;).then((response)=&gt;&#123;        let resp = response.data;        if (resp.success) &#123;          _this.users = resp.content.list;          console.log(_this.users);        &#125; else &#123;          Toast.warning(resp.message);        &#125;      &#125;)    &#125;,\n\n3.通用权限管理：点击用户模态框【保存】按钮时，保存角色用户关联表\n\n\n增加一个这样的功能\n\n依赖vue的双向数据绑定特性，可以将复杂的页面操作变成，简单的数据操作。很多前端框架都有双向数据绑定的特性，比如angular，微信小程序\n\n先修改role.vue\n\n\n//分别修改右边和左边的模态框&lt;a v-on:click=&quot;addUser(user)&quot; href=&quot;javascript:;&quot; class=&quot;&quot;&gt;&lt;a v-on:click=&quot;deleteUser(user)&quot; href=&quot;javascript:;&quot; class=&quot;&quot;&gt;//增加对应方法，最后一个方法是保存时候的 /**     * 角色中增加用户     */    addUser(user) &#123;      let _this = this;      // 如果当前要添加的用户在右边列表中已经有了，则不用再添加      let users = _this.roleUsers;      for (let i = 0; i &lt; users.length; i++) &#123;        if (user === users[i]) &#123;          return;        &#125;      &#125;      _this.roleUsers.push(user);    &#125;,    /**     * 角色中删除用户     */    deleteUser(user) &#123;      let _this = this;      Tool.removeObj(_this.roleUsers, user);    &#125;,    /**     * 角色用户模态框点击【保存】     */    saveUser() &#123;      let _this = this;      let users = _this.roleUsers;      // 保存时，只需要保存用户id，所以使用id数组进行参数传递      let userIds = [];      for (let i = 0; i &lt; users.length; i++) &#123;        userIds.push(users[i].id);      &#125;      _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/system/admin/role/save-user&#x27;, &#123;        id: _this.role.id,        userIds: userIds      &#125;).then((response)=&gt;&#123;        console.log(&quot;保存角色用户结果：&quot;, response);        let resp = response.data;        if (resp.success) &#123;          Toast.success(&quot;保存成功!&quot;);        &#125; else &#123;          Toast.warning(resp.message);        &#125;      &#125;)    &#125;,\n\n\n我们接下来要修改RoleDto\n\n//增加这个private List&lt;String&gt; userIds;\n\n\n接下来RoleController\n\n/** * 保存用户 * @param roleDto */@PostMapping(&quot;/save-user&quot;)public ResponseDto saveUser(@RequestBody RoleDto roleDto) &#123;    LOG.info(&quot;保存角色用户关联开始&quot;);    ResponseDto&lt;RoleDto&gt; responseDto = new ResponseDto&lt;&gt;();    roleService.saveUser(roleDto);    responseDto.setContent(roleDto);    return responseDto;&#125;\n\n\n最后修改RoleService\n\n@Resourceprivate RoleUserMapper roleUserMapper; /**     * 按角色保存用户     */    public void saveUser(RoleDto roleDto) &#123;        String roleId = roleDto.getId();        List&lt;String&gt; userIdList = roleDto.getUserIds();        // 清空库中所有的当前角色下的记录        RoleUserExample example = new RoleUserExample();        example.createCriteria().andRoleIdEqualTo(roleId);        roleUserMapper.deleteByExample(example);        // 保存角色用户        for (int i = 0; i &lt; userIdList.size(); i++) &#123;            RoleUser roleUser = new RoleUser();            roleUser.setId(UuidUtil.getShortUuid());            roleUser.setRoleId(roleId);            roleUser.setUserId(userIdList.get(i));            roleUserMapper.insert(roleUser);        &#125;    &#125;\n\n4.通用权限管理：打开用户模态框时，加载角色用户关联数据\n\n\n查关联表，得到的是userld，但是显示需要的是loginName。这里也可以通过写自定义mapper，把user表和role_user表关联得到loginName\n\n首先修改role.vue\n\n\n//在listUser中成功时添加 _this.listRoleUser(); /**     * 加载角色用户     */    listRoleUser() &#123;      let _this = this;      _this.roleUsers = [];      _this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/system/admin/role/list-user/&#x27; + _this.role.id).then((res)=&gt;&#123;        let response = res.data;        let userIds = response.content;        // 根据加载到用户ID，到【所有用户数组：users】中查找用户对象，用于列表显示        for (let i = 0; i &lt; userIds.length; i++) &#123;          for (let j = 0; j &lt; _this.users.length; j++) &#123;            if (userIds[i] === _this.users[j].id) &#123;              _this.roleUsers.push(_this.users[j]);            &#125;          &#125;        &#125;      &#125;);    &#125;,\n\n\n然后修改RoleController\n\n/** * 加载用户 * @param roleId */@GetMapping(&quot;/list-user/&#123;roleId&#125;&quot;)public ResponseDto listUser(@PathVariable String roleId) &#123;    LOG.info(&quot;加载用户开始&quot;);    ResponseDto responseDto = new ResponseDto&lt;&gt;();    List&lt;String&gt; userIdList = roleService.listUser(roleId);    responseDto.setContent(userIdList);    return responseDto;&#125;\n\n\n最后修改RoleService\n\n/** * 按角色加载用户 * @param roleId */public List&lt;String&gt; listUser(String roleId) &#123;    RoleUserExample example = new RoleUserExample();    example.createCriteria().andRoleIdEqualTo(roleId);    List&lt;RoleUser&gt; roleUserList = roleUserMapper.selectByExample(example);    List&lt;String&gt; userIdList = new ArrayList&lt;&gt;();    for (int i = 0, l = roleUserList.size(); i &lt; l; i++) &#123;        userIdList.add(roleUserList.get(i).getUserId());    &#125;    return userIdList;&#125;\n\n12-4 登录时获取资源权限读取当前登录用户所属的角色的所有资源\n1.通用权限管理：登录时，读取当前登录用户所属的角色的所有资源\n\n\n一个资源可以会用到多个接口，多个资源的接口就可能重复，所以这里用Set去重\n\n在LoginUserDto中增加\n\n\n/** * 所有资源用于前端界面控制 */private List&lt;ResourceDto&gt; resources;/** * 所有资源中的请求，用于后端接口拦截 */private HashSet&lt;String&gt; requests;\n\n\n关于User的权限设置比较细，每个请求接口都可以单独控制。关于Resource的权限设置比较粗，所有接口用同一个request控制\n\n在com.course.server.mapper.my下建立MyUserMapper.xml\n\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.course.server.mapper.my.MyUserMapper&quot; &gt;    &lt;!-- 一个用户可以属于多个角色，配置的资源可能重复，所以用distinct去重 --&gt;    &lt;select id=&quot;findResources&quot; resultType=&quot;com.course.server.dto.ResourceDto&quot;&gt;        select distinct r.id, r.`name`, r.page, r.request, r.parent        from role_user ru, role_resource rr, resource r        where ru.user_id = #&#123;userId&#125;        and ru.role_id = rr.role_id        and rr.resource_id = r.id        order by r.id asc    &lt;/select&gt;&lt;/mapper&gt;\n\n\n然后再com.course.server.mapper.my下建立MyUserMapper.java\n\npackage com.course.server.mapper.my;import com.course.server.dto.ResourceDto;import org.apache.ibatis.annotations.Param;import java.util.List;public interface MyUserMapper &#123;    List&lt;ResourceDto&gt; findResources(@Param(&quot;userId&quot;) String userId);&#125;\n\n\n最后我们修改UserService\n\n/** * 为登录用户读取权限 */private void setAuth(LoginUserDto loginUserDto) &#123;    List&lt;ResourceDto&gt; resourceDtoList = myUserMapper.findResources(loginUserDto.getId());    loginUserDto.setResources(resourceDtoList);    // 整理所有有权限的请求，用于接口拦截    HashSet&lt;String&gt; requestSet = new HashSet&lt;&gt;();    if (!CollectionUtils.isEmpty(resourceDtoList)) &#123;        for (int i = 0, l = resourceDtoList.size(); i &lt; l; i++) &#123;            ResourceDto resourceDto = resourceDtoList.get(i);            String arrayString = resourceDto.getRequest();            List&lt;String&gt; requestList = JSON.parseArray(arrayString, String.class);            if (!CollectionUtils.isEmpty(requestList)) &#123;                requestSet.addAll(requestList);            &#125;        &#125;    &#125;    LOG.info(&quot;有权限的请求：&#123;&#125;&quot;, requestSet);    loginUserDto.setRequests(requestSet);&#125;//最后使用这个在login方法    public LoginUserDto login(UserDto userDto)&#123;        User user = selectByLoginName((userDto.getLoginName()));        if(user == null)&#123;            LOG.info(&quot;用户名不存在,&#123;&#125;&quot;,userDto.getLoginName());            throw new BusinessException(BusinessExceptionCode.LOGIN_ERROR);        &#125;else&#123;            if (user.getPassword().equals(userDto.getPassword()))&#123;////////////////////////////////////////////////////////////////////                //登陆成功                LoginUserDto loginUserDto = CopyUtil.copy(user,LoginUserDto.class);                //为登录用户获取权限                setAuth(loginUserDto);                return loginUserDto;///////////////////////////////////////////////////////////////////////////            &#125;else&#123;                LOG.info(&quot;密码不对,输入密码:&#123;&#125;,数据库密码:&#123;&#125;&quot;,userDto.getPassword(),user.getPassword());                throw new BusinessException(BusinessExceptionCode.LOGIN_ERROR);            &#125;        &#125;    &#125;\n\n修复讲师管理显示错位的BUG\n1.通用权限管理：修复讲师管理显示错位的BUG.自定义样式要加上前缀，防止冲突，vue组件样式加scoped\n\n\n问题：讲师管理页面，讲师的显示重叠在一起了。但是这个页面已经很久没动过了。之前介绍讲师管理时，都是确认了页面正常才提交的代码。不知道从什么时候开始出现这个BUG？\ncss样式的问题，可以优先用F12开发者工具来查看没有可疑的样式\n前端常见问题：引入新的css文件后，导致原有页面显示错乱\n写自定义样式的时候！不要用通用的单词，很容易和别人的样式出现冲突，可以给样式加上一些固定的，有意义的前缀\n解决方法：为每个样式加一个“aliplayer前缀！或者加一个顶级的”.aliplayer”样式\n\n12-5 权限拦截功能开发前端界面权限拦截\n1.通用权限管理：前端界面权限拦截，完成用户管理\n\n\n目前只修改了用户管理的权限拦截，以用户管理为例\n\n每次修改权限配置，需要重新登录后才生效\n\n我们首先在tool.js增加方法\n\n\n /**   * 查找是否有权限   * @param id 资源id   */  hasResource: function (id) &#123;    let _this = this;    let resources = _this.getLoginUser().resources;    if (_this.isEmpty(resources)) &#123;      return false;    &#125;    for (let i = 0; i &lt; resources.length; i++) &#123;      if (id === resources[i].id) &#123;        return true;      &#125;    &#125;    return false;  &#125;&#125;;\n\n\n接下来修改admin\n\n//在html中要使用vue方法，这个方法得在methods中定义/** * 查找是否有权限 * @param id */hasResource(id) &#123;  return Tool.hasResource(id);&#125;,//使用的话就在li里加v-show &lt;li v-show=&quot;hasResource(&#x27;0101&#x27;)&quot; class=&quot;&quot; id=&quot;system-user-sidebar&quot;&gt;               &lt;router-link to=&quot;/system/user&quot;&gt;                  &lt;i class=&quot;menu-icon fa fa-caret-right&quot;&gt;&lt;/i&gt;                  用户管理               &lt;/router-link&gt;                &lt;b class=&quot;arrow&quot;&gt;&lt;/b&gt;              &lt;/li&gt;\n\n\nuser修改也一样\n\n2.通用权限管理：前端界面权限拦截，完成所有界面控制\n\n\n如果一个页面的所有按钮是统一控制的那么只需要控制菜单就可以了，不需要给每个按钮加权限控制代码\n就是给admin其他菜单加上v-show\n\n路由权限判断\n1.通用权限管理：前端界面权限拦截，增加路由权限判断\n\n\n因为我们前端的路由是不带&#x2F;的所以我们修改resource.json\n\n[&#123;  &quot;id&quot;: &quot;00&quot;,&quot;name&quot;: &quot;欢迎&quot;,&quot;page&quot;: &quot;welcome&quot;&#125;,  &#123;    &quot;id&quot;: &quot;01&quot;,&quot;name&quot;: &quot;系统管理&quot;,    &quot;children&quot;:[&#123;      &quot;id&quot;:&quot;0101&quot;,&quot;name&quot;:&quot;用户管理&quot;,&quot;page&quot;:&quot;system/user&quot;,      &quot;children&quot;:[        &#123;&quot;id&quot;:&quot;010101&quot;,&quot;name&quot;:&quot;保存&quot;,&quot;request&quot;:[&quot;/system/admin/user/list&quot;,&quot;/system/admin/user/save&quot;]&#125;,        &#123;&quot;id&quot;:&quot;010102&quot;,&quot;name&quot;:&quot;删除&quot;,&quot;request&quot;:[&quot;/system/admin/user/delete&quot;]&#125;,        &#123;&quot;id&quot;:&quot;010103&quot;,&quot;name&quot;:&quot;重置密码&quot;,&quot;request&quot;:[&quot;/system/admin/user/save-password&quot;]&#125;      ]    &#125;,    &#123;      &quot;id&quot;:&quot;0102&quot;,&quot;name&quot;:&quot;资源管理&quot;,&quot;page&quot;:&quot;system/resource&quot;,      &quot;children&quot;:[        &#123;&quot;id&quot;:&quot;010201&quot;,&quot;name&quot;:&quot;保存/显示&quot;,&quot;request&quot;:[&quot;/system/admin/resource&quot;]&#125;      ]    &#125;, &#123;        &quot;id&quot;:&quot;0103&quot;,&quot;name&quot;:&quot;角色管理&quot;,&quot;page&quot;:&quot;system/role&quot;,        &quot;children&quot;:[            &#123;&quot;id&quot;:&quot;010301&quot;,&quot;name&quot;:&quot;角色/权限管理&quot;,&quot;request&quot;:[&quot;/system/admin/role&quot;]&#125;          ]      &#125;]&#125;,&#123;  &quot;id&quot;: &quot;02&quot;,&quot;name&quot;: &quot;业务管理&quot;,  &quot;children&quot;:[&#123;    &quot;id&quot;:&quot;0201&quot;,&quot;name&quot;:&quot;分类管理&quot;,&quot;page&quot;:&quot;business/category&quot;,    &quot;children&quot;:[      &#123;&quot;id&quot;:&quot;020101&quot;,&quot;name&quot;:&quot;增删改查&quot;,&quot;request&quot;:[&quot;/business/admin/category&quot;]&#125;     ]  &#125;,&#123;      &quot;id&quot;:&quot;0202&quot;,&quot;name&quot;:&quot;课程管理&quot;,&quot;page&quot;:&quot;business/course&quot;,      &quot;children&quot;:[        &#123;&quot;id&quot;:&quot;020201&quot;,&quot;name&quot;:&quot;增删改查&quot;,&quot;request&quot;:[&quot;/business/admin/course&quot;,&quot;/business/admin/category/all&quot;]&#125;      ]    &#125;,&#123;      &quot;id&quot;:&quot;0203&quot;,&quot;name&quot;:&quot;讲师管理&quot;,&quot;page&quot;:&quot;business/teacher&quot;,      &quot;children&quot;:[        &#123;&quot;id&quot;:&quot;020301&quot;,&quot;name&quot;:&quot;增删改查&quot;,&quot;request&quot;:[&quot;/business/admin/teacher&quot;]&#125;      ]    &#125;]  &#125;,&#123;  &quot;id&quot;: &quot;03&quot;,&quot;name&quot;: &quot;文件管理&quot;,  &quot;children&quot;:[&#123;    &quot;id&quot;:&quot;0301&quot;,&quot;name&quot;:&quot;文件管理&quot;,&quot;page&quot;:&quot;file/file&quot;,    &quot;children&quot;:[      &#123;&quot;id&quot;:&quot;030101&quot;,&quot;name&quot;:&quot;文件管理&quot;,&quot;request&quot;:[&quot;/file/admin/file&quot;]&#125;    ]  &#125;]&#125;]\n\n\n修改admin\n\n/** * 查找是否有权限 * @param router */hasResourceRouter(router) &#123;  let _this = this;  let resources = Tool.getLoginUser().resources;  if (Tool.isEmpty(resources)) &#123;    return false;  &#125;  for (let i = 0; i &lt; resources.length; i++) &#123;    if (router === resources[i].page) &#123;      return true;    &#125;  &#125;  return false;&#125;,//在mounted使用，第一次加载amin.vue时，需要判断路由权限。比如从登录页跳到控台主页，或者刷新控台主页时，会执行mountedif (!_this.hasResourceRouter(_this.$route.name)) &#123;      _this.$router.push(&quot;/login&quot;);    &#125;//进入控台主页后，发生子路由跳转时，会触发watch if (!_this.hasResourceRouter(val.name)) &#123;          _this.$router.push(&quot;/login&quot;);          return;        &#125;\n\n后端接口权限判断\n1.通用权限管理：增加后端接口权限拦截\n\n\n在做登录功能时，我们也对接口做了登录校验，否则容易被绕开登录，直接调用后端接口。这里同样需要对接口做权限拦截\n\n比如资源的保存：path&#x3D;system&#x2F;admin&#x2F;resource&#x2F;save，而配置的request&#x3D;system&#x2F;admin&#x2F;resource，那么path.contain(request)就是true\n\n可以在vue的拦截器中，针对401返回码做判断，如果是401，就跳到登录页面\n\n我们修改LoginAdminGatewayFilter\n\n\n//在已登录这进行判断else&#123;    LOG.info(&quot;已登录:&#123;&#125;&quot;,object);    // 增加权限校验，gateway里没有LoginUserDto，所以全部用JSON操作    LOG.info(&quot;接口权限校验，请求地址：&#123;&#125;&quot;, path);    boolean exist = false;    JSONObject loginUserDto = JSON.parseObject(String.valueOf(object));    redisTemplate.opsForValue().set(token, JSON.toJSONString(loginUserDto), 3600, TimeUnit.SECONDS);    JSONArray requests = loginUserDto.getJSONArray(&quot;requests&quot;);    // 遍历所有【权限请求】，判断当前请求的地址是否在【权限请求】里    for (int i = 0, l = requests.size(); i &lt; l; i++) &#123;        String request = (String) requests.get(i);        if (path.contains(request)) &#123;            exist = true;            break;        &#125;    &#125;    if (exist) &#123;        LOG.info(&quot;权限校验通过&quot;);    &#125; else &#123;        LOG.warn(&quot;权限校验未通过&quot;);        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);        return exchange.getResponse().setComplete();    &#125;    return chain.filter(exchange);&#125;\n\n","tags":["完整项目"]},{"title":"完整项目之Spring Cloud + Vue 前后端分离5","url":"/2022/03/20/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E4%B9%8BSpring%20Cloud%20+%20Vue%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%205/","content":"第14章 项目优化至此整个项目的主框架和主业务都开发完成了，这一章将对项目做一些优化，比如控台报表显示，spring boot多环境配置，缓存的使用等。\n\n14-1 项目初始化1.增加readme.md，添加项目介绍2.修改初始化sql\n\n\nreadme.md是用来写一些项目描述信息，git远程仓库可以自动识别该页面，并显示到仓库首页下方\n有一个现象：sql初始化后，登录控台时，日志显示登录成功，但是页面一直在登录页面，没有跳到欢迎页面\n修改sql，增加一个00欢迎，并且将0101和0102和0103的page的开头&#x2F;去掉\n\n# 角色-资源关联表增加这一行insert into `role_resource` values (&#x27;00000009&#x27;,&#x27;00000000&#x27;,&#x27;00&#x27;);\n\n\n还有一个现象：点击大章时，跳到登录页面。原因是：大章显示不显示再侧边栏，但是它也是一个单独的页面，也有路由，所以需要配置资源，同样还有小节页面，课程内容页面\n\n,&#123;  &quot;id&quot;:&quot;0206&quot;,&quot;name&quot;:&quot;大章管理&quot;,&quot;page&quot;:&quot;business/chapter&quot;,  &quot;children&quot;:[    &#123;&quot;id&quot;:&quot;020601&quot;,&quot;name&quot;:&quot;增删改查&quot;,&quot;request&quot;:[&quot;/business/admin/chapter&quot;]&#125;  ]&#125;,&#123;  &quot;id&quot;:&quot;0207&quot;,&quot;name&quot;:&quot;小节管理&quot;,&quot;page&quot;:&quot;business/section&quot;,  &quot;children&quot;:[    &#123;&quot;id&quot;:&quot;020701&quot;,&quot;name&quot;:&quot;增删改查&quot;,&quot;request&quot;:[&quot;/business/admin/section&quot;]&#125;  ]&#125;,&#123;  &quot;id&quot;:&quot;0208&quot;,&quot;name&quot;:&quot;内容管理&quot;,&quot;page&quot;:&quot;business/content&quot;,  &quot;children&quot;:[    &#123;&quot;id&quot;:&quot;020801&quot;,&quot;name&quot;:&quot;增删改查&quot;,&quot;request&quot;:[&quot;/business/admin/course&quot;,&quot;/business/admin/course-content-file&quot;]&#125;  ]&#125;\n\n14-2 控台欢迎页开发1.控台欢迎页面开发，增加顶部统计\n\n\n修改welcome.vue\n\n&lt;div&gt;  &lt;div class=&quot;space-12&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;row&quot;&gt;    &lt;div class=&quot;col-xs-12&quot;&gt;      &lt;div class=&quot;text-center&quot;&gt;        &lt;span class=&quot;btn btn-app btn-sm btn-light no-hover&quot;&gt;            &lt;span class=&quot;line-height-1 bigger-170 blue&quot;&gt; 518 &lt;/span&gt;            &lt;br&gt;            &lt;span class=&quot;line-height-1 smaller-90&quot;&gt; 课程 &lt;/span&gt;        &lt;/span&gt;        &lt;span class=&quot;btn btn-app btn-sm btn-yellow no-hover&quot;&gt;            &lt;span class=&quot;line-height-1 bigger-170&quot;&gt; 6,321 &lt;/span&gt;            &lt;br&gt;            &lt;span class=&quot;line-height-1 smaller-90&quot;&gt; 大章 &lt;/span&gt;        &lt;/span&gt;        &lt;span class=&quot;btn btn-app btn-sm btn-pink no-hover&quot;&gt;            &lt;span class=&quot;line-height-1 bigger-170&quot;&gt; 4,182 &lt;/span&gt;            &lt;br&gt;            &lt;span class=&quot;line-height-1 smaller-90&quot;&gt; 小节 &lt;/span&gt;        &lt;/span&gt;        &lt;span class=&quot;btn btn-app btn-sm btn-success no-hover&quot;&gt;            &lt;span class=&quot;line-height-1 bigger-170&quot;&gt; 5.23 &lt;/span&gt;            &lt;br&gt;            &lt;span class=&quot;line-height-1 smaller-90&quot;&gt; 会员(万) &lt;/span&gt;        &lt;/span&gt;        &lt;span class=&quot;btn btn-app btn-sm btn-primary no-hover&quot;&gt;            &lt;span class=&quot;line-height-1 bigger-170&quot;&gt; 12.76 &lt;/span&gt;            &lt;br&gt;            &lt;span class=&quot;line-height-1 smaller-90&quot;&gt; 报名(万) &lt;/span&gt;        &lt;/span&gt;        &lt;span class=&quot;btn btn-app btn-sm btn-grey no-hover&quot;&gt;            &lt;span class=&quot;line-height-1 bigger-170&quot;&gt; 32.96 &lt;/span&gt;            &lt;br&gt;            &lt;span class=&quot;line-height-1 smaller-90&quot;&gt; 评论(万) &lt;/span&gt;        &lt;/span&gt;      &lt;/div&gt;      &lt;div class=&quot;space-12&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;\n\n2.控台欢迎页面开发，增加了新增评论，新增注册会员，课程报名统计显示\n\n\n问题：代码时两块分别占满12格的div，正常情况下是上下显示的，但是现在显示出来是有重叠部分。布局显示错乱，大概率是多个css样式冲突了，不同的css文件里起了相同的名字\n\n我们经常通过在element窗口修改html或css，来调试显示效果，之后将最终的html或css样式复制到项目代码里\n\n在上面修改之后增加\n\n\n  &lt;div class=&quot;hr hr2 hr-double&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;space-12&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;col-sm-12 infobox-container&quot;&gt;  &lt;div class=&quot;infobox infobox-green&quot;&gt;    &lt;div class=&quot;infobox-icon&quot;&gt;      &lt;i class=&quot;ace-icon fa fa-comments&quot;&gt;&lt;/i&gt;    &lt;/div&gt;    &lt;div class=&quot;infobox-data&quot;&gt;      &lt;span class=&quot;infobox-data-number&quot;&gt;332&lt;/span&gt;      &lt;div class=&quot;infobox-content&quot;&gt;新增评论&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;stat stat-success&quot;&gt;8%&lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;infobox infobox-blue&quot;&gt;    &lt;div class=&quot;infobox-icon&quot;&gt;      &lt;i class=&quot;ace-icon fa fa-twitter&quot;&gt;&lt;/i&gt;    &lt;/div&gt;    &lt;div class=&quot;infobox-data&quot;&gt;      &lt;span class=&quot;infobox-data-number&quot;&gt;58&lt;/span&gt;      &lt;div class=&quot;infobox-content&quot;&gt;新增注册会员&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;badge badge-success&quot;&gt;      +10%      &lt;i class=&quot;ace-icon fa fa-arrow-up&quot;&gt;&lt;/i&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;infobox infobox-pink&quot;&gt;    &lt;div class=&quot;infobox-icon&quot;&gt;      &lt;i class=&quot;ace-icon fa fa-shopping-cart&quot;&gt;&lt;/i&gt;    &lt;/div&gt;    &lt;div class=&quot;infobox-data&quot;&gt;      &lt;span class=&quot;infobox-data-number&quot;&gt;108&lt;/span&gt;      &lt;div class=&quot;infobox-content&quot;&gt;课程报名&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;stat stat-important&quot;&gt;4%&lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;space-12&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;hr hr2 hr-double&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;space-12&quot;&gt;&lt;/div&gt;\n\n3.控台欢迎页面开发，增加销售量报表统计显示\n\n\n图表可以使用jqery插件，这里ace模板用到的jquery.flot插件\n\n在上面之后增加\n\n\n&lt;div class=&quot;col-sm-12&quot;&gt;  &lt;div class=&quot;widget-box transparent&quot;&gt;    &lt;div class=&quot;widget-header widget-header-flat&quot;&gt;      &lt;h4 class=&quot;widget-title lighter&quot;&gt;        &lt;i class=&quot;ace-icon fa fa-signal&quot;&gt;&lt;/i&gt;        销售量      &lt;/h4&gt;    &lt;/div&gt;    &lt;div class=&quot;widget-body&quot;&gt;      &lt;div class=&quot;widget-main padding-4&quot;&gt;        &lt;div id=&quot;sales-charts&quot;&gt;&lt;/div&gt;      &lt;/div&gt;&lt;!-- /.widget-main --&gt;    &lt;/div&gt;&lt;!-- /.widget-body --&gt;  &lt;/div&gt;&lt;!-- /.widget-box --&gt;  &lt;div class=&quot;space-12&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;hr hr2 hr-double&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;space-12&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- /.col --&gt;////////////////////////////////////////////////////////////////////////////////////////////mounted:function () &#123;    let _this = this;    _this.drawSaleChart();  &#125;,  methods:&#123;    drawSaleChart() &#123;      // 生成随机两组数据      let d1 = [];      for (let i = 0; i &lt; 30; i += 1) &#123;        d1.push([i + 1, 2000 + Math.floor((Math.random()*100)+1)]);      &#125;      let d2 = [];      for (let i = 0; i &lt; 30; i += 1) &#123;        d2.push([i + 1, 1900 + Math.floor((Math.random()*100)+1)]);      &#125;      let sales_charts = $(&#x27;#sales-charts&#x27;).css(&#123;&#x27;width&#x27;:&#x27;100%&#x27; , &#x27;height&#x27;:&#x27;220px&#x27;&#125;);      $.plot(&quot;#sales-charts&quot;, [        &#123; label: &quot;最近30天&quot;, data: d1 &#125;,        &#123; label: &quot;上一周期&quot;, data: d2 &#125;,      ], &#123;        hoverable: true,        shadowSize: 0,        series: &#123;          lines: &#123; show: true &#125;,          points: &#123; show: true &#125;        &#125;,        xaxis: &#123;          tickLength: 0        &#125;,        yaxis: &#123;          tickLength: 0        &#125;,        grid: &#123;          backgroundColor: &#123; colors: [ &quot;#fff&quot;, &quot;#fff&quot; ] &#125;,          borderWidth: 1,          borderColor:&#x27;#555&#x27;        &#125;      &#125;);    &#125;,  &#125;\n\n5.控台欢迎页面开发，增加课程销售排名和分类销售排名统计显示\n\n\n接着上面的修改\n\n&lt;div class=&quot;col-sm-6&quot;&gt;  &lt;div class=&quot;widget-box transparent&quot;&gt;    &lt;div class=&quot;widget-header widget-header-flat&quot;&gt;      &lt;h4 class=&quot;widget-title lighter&quot;&gt;        &lt;i class=&quot;ace-icon fa fa-star orange&quot;&gt;&lt;/i&gt;        课程销售排名      &lt;/h4&gt;    &lt;/div&gt;    &lt;div class=&quot;widget-body&quot;&gt;      &lt;div class=&quot;widget-main no-padding&quot;&gt;        &lt;table class=&quot;table table-bordered table-striped&quot;&gt;          &lt;thead class=&quot;thin-border-bottom&quot;&gt;          &lt;tr&gt;            &lt;th&gt;              &lt;i class=&quot;ace-icon fa fa-caret-right blue&quot;&gt;&lt;/i&gt;课程名称            &lt;/th&gt;            &lt;th&gt;              &lt;i class=&quot;ace-icon fa fa-caret-right blue&quot;&gt;&lt;/i&gt;价格            &lt;/th&gt;            &lt;th&gt;              &lt;i class=&quot;ace-icon fa fa-caret-right blue&quot;&gt;&lt;/i&gt;购买数            &lt;/th&gt;          &lt;/tr&gt;          &lt;/thead&gt;          &lt;tbody&gt;          &lt;tr&gt;            &lt;td&gt;开发工具IDEA从入门到爱不释手&lt;/td&gt;            &lt;td&gt;              &lt;b class=&quot;green&quot;&gt;￥299.00&lt;/b&gt;            &lt;/td&gt;            &lt;td&gt;              &lt;span class=&quot;label label-warning arrowed arrowed-right&quot;&gt;5,132&lt;/span&gt;            &lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;            &lt;td&gt;开发工具IDEA从入门到爱不释手&lt;/td&gt;            &lt;td&gt;              &lt;b class=&quot;red&quot;&gt;￥388.00&lt;/b&gt;            &lt;/td&gt;            &lt;td&gt;              &lt;span class=&quot;label label-warning arrowed arrowed-right&quot;&gt;3,132&lt;/span&gt;            &lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;            &lt;td&gt;开发工具IDEA从入门到爱不释手&lt;/td&gt;            &lt;td&gt;              &lt;b class=&quot;green&quot;&gt;￥199.00&lt;/b&gt;            &lt;/td&gt;            &lt;td&gt;              &lt;span class=&quot;label label-warning arrowed arrowed-right&quot;&gt;2,132&lt;/span&gt;            &lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;            &lt;td&gt;开发工具IDEA从入门到爱不释手&lt;/td&gt;            &lt;td&gt;              &lt;b class=&quot;green&quot;&gt;￥299.00&lt;/b&gt;            &lt;/td&gt;            &lt;td&gt;              &lt;span class=&quot;label label-success arrowed arrowed-right&quot;&gt;1,654&lt;/span&gt;            &lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;            &lt;td&gt;开发工具IDEA从入门到爱不释手&lt;/td&gt;            &lt;td&gt;              &lt;b class=&quot;green&quot;&gt;￥199.00&lt;/b&gt;            &lt;/td&gt;            &lt;td&gt;              &lt;span class=&quot;label label-success arrowed arrowed-right&quot;&gt;1,254&lt;/span&gt;            &lt;/td&gt;          &lt;/tr&gt;          &lt;/tbody&gt;        &lt;/table&gt;      &lt;/div&gt;&lt;!-- /.widget-main --&gt;    &lt;/div&gt;&lt;!-- /.widget-body --&gt;  &lt;/div&gt;&lt;!-- /.widget-box --&gt;&lt;/div&gt;&lt;!-- /.col --&gt;&lt;div class=&quot;col-sm-6&quot;&gt;  &lt;div class=&quot;widget-box transparent&quot;&gt;    &lt;div class=&quot;widget-header widget-header-flat&quot;&gt;      &lt;h4 class=&quot;widget-title lighter&quot;&gt;        &lt;i class=&quot;ace-icon fa fa-star orange&quot;&gt;&lt;/i&gt;        分类销售排名      &lt;/h4&gt;    &lt;/div&gt;    &lt;div class=&quot;widget-body&quot;&gt;      &lt;div class=&quot;widget-main&quot;&gt;        &lt;div id=&quot;piechart-placeholder&quot;&gt;&lt;/div&gt;      &lt;/div&gt;&lt;!-- /.widget-main --&gt;    &lt;/div&gt;&lt;!-- /.widget-body --&gt;  &lt;/div&gt;&lt;!-- /.widget-box --&gt;&lt;/div&gt;&lt;!-- /.col --&gt;////////////////////////////////////////////////////////////////////////////mounted增加一个 _this.drawPieChart(); //////////////////////////////////////////////////////////////////////////methods增加一个     drawPieChart() &#123;      let placeholder = $(&#x27;#piechart-placeholder&#x27;).css(&#123;&#x27;width&#x27;:&#x27;90%&#x27; , &#x27;min-height&#x27;:&#x27;180px&#x27;&#125;);      let data = [        &#123; label: &quot;Java&quot;,  data: 38.7, color: &quot;#68BC31&quot;&#125;,        &#123; label: &quot;Python&quot;,  data: 24.5, color: &quot;#2091CF&quot;&#125;,        &#123; label: &quot;Android&quot;,  data: 18.6, color: &quot;#DA5430&quot;&#125;,        &#123; label: &quot;其它&quot;,  data: 10, color: &quot;#FEE074&quot;&#125;,      ];      $.plot(placeholder, data, &#123;        series: &#123;          pie: &#123;            show: true,            tilt:0.8,            highlight: &#123;              opacity: 0.25            &#125;,            stroke: &#123;              color: &#x27;#fff&#x27;,              width: 2            &#125;,            startAngle: 2          &#125;        &#125;,        legend: &#123;          show: true,          position: &quot;ne&quot;,          labelBoxBorderColor: null,          margin:[-30,15]        &#125;        ,        grid: &#123;          hoverable: true,          clickable: true        &#125;      &#125;)    &#125;\n\n\n其实还需要引入图标的插件，但是我们之前就把所有的插件都复制过来了，所以这里不修改\n\n14-3 前后端多环境配置1，springboot多环境配置使用application-xxx.propertie来设置不同环境的配置，xxx表示环境名称公共模块要打包，不能带spring-boot-maven-plugin插件springboot.jar包启动命令：java -jar aaa.jar --spring.profiles.active=xxx，xxx表示环境名称\n\n\n常见的环境有以下这些：开发、测试、集成、联调、准备生成、灰度、生产\n\n问题：发布生产时，端口号和本地开发的不一样。需要根据不同的环境配置不同的端口，我们以system为例\n\napplication-xxx.properties，xxx就是环境名，可自定义，可以叫dev也可以叫development\n\n我们将system的application.properties复制一份重命名为application-dev.properties，里面就放要修改的比如端口号server.port&#x3D;19001，怎么让他生效呢，我们只需要如下图所示，在有效配置文件写上dev即可\n\n通过在启动命令里增加spring.profiles.active的变量值，达到支持多环境的效果\n\n问题：本地和生产的数据库配置肯定是不一样的，ip、端口、用户名、密码等都不一样。需要根据不同的环境配置不同的数据库连接。数据库配置是放到server模块的，然后操作跟上面一样。\n\n问题：项目怎么打包？\n\n在父模块中增加了spring-boot-maven-plugin，那么打包时，所以子模块都会按这个插件来打包，但是server模块并不需要启动，不需要这个插件。\n\n我们只需要将所有需要启动的模块，都加上spring-boot-maven-plugin插件,同时将course根目录的这段插件删除\n\n\n&lt;build&gt;   &lt;plugins&gt;      &lt;plugin&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;      &lt;/plugin&gt;   &lt;/plugins&gt;&lt;/build&gt;\n\n\n然后如图所示instalinstall下，就是打包了\n\n那么我们打包后的文件去了哪？先找到maven的本地仓库，然后就可以在文件夹中看到了\n\n问题：打好的jar包咋用？\n\n我们在命令行进入想使用的jar包的文件夹target，然后输入java -jar xxx.jar；如果想在生产上使用java -jar xxx.jar –spring.profiles.active&#x3D;dev\n\n\n14-4 前后端缓存的使用\n高频查询，低频修改的数据，特别适合使用缓存，我们以web的index.vue为例\n\n/** * 查询新上好课 */listNew() &#123;  let _this = this;//////////////////////////////////////////////////////////////////////////////////////////  // 新上好课不经常变，又经常被访问，适合用缓存  // 判断是否有缓存  let news = SessionStorage.get(&quot;news&quot;);  if (!Tool.isEmpty(news)) &#123;    _this.news = news;    return;  &#125;//////////////////////////////////////////////////////////////////////////////////////////    _this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/business/web/course/list-new&#x27;).then((response)=&gt;&#123;    console.log(&quot;查询新上好课结果：&quot;, response);    let resp = response.data;    if (resp.success) &#123;      _this.news = resp.content;//////////////////////////////////////////////////////////////////////////////////////////      // 保存到缓存      SessionStorage.set(&quot;news&quot;, _this.news);//////////////////////////////////////////////////////////////////////////////////////////    &#125;  &#125;).catch((response)=&gt;&#123;    console.log(&quot;error：&quot;, response);  &#125;)&#125;,\n\n\n控台管理的缓存使用思路：可以使用LocalStorags最大程度的减少请求，配合主动清除缓存来处理过期数据\n主动清除缓存来处理过期数据：在右上角菜单中增加【清除分类缓存】【清楚除资源缓存】或【清除全部缓存】，点击的时候，清除相应的缓存。\n\n第15章 课程总结本章将带大家回顾总结课程重点难点\n\n环境的搭建\n代码生成器\n文件上传和视频播放\n通用权限设计\n第16章 项目功能升级本章是对课程做的升级，核心是对部分功能升级优化，比如优化验证码的清晰度，优化登录token超时的问题，关闭播放器模态框时停止播放，还会分享学习Vue事件总线、Vue新增属性的数据绑定等新的技能。\n\n16-1 已提交的代码讲解1.将gateway中的路由配置改为IP，用lb://时，有时候会有延迟，需要等一会才能访问\n\n\n后续介绍生产发布时，会将eureak换成nacos，既是注册中心，又是配置中心，解决不同环境使用不同配置。开发环境用ip.port，生产环境用lb。修改gateway的application.properties\n\nspring.cloud.gateway.routes[1].uri=http://192.168.0.105:9002#spring.cloud.gateway.routes[1].uri=lb://business\n\n2.BUG修复，文件上传改为OSS后，文件检查check方法中，应该拼上OSS地址\n\n\n我们修改UploadController\n\n@Value(&quot;$&#123;oss.domain&#125;&quot;)private String OSS_DOMAIN;//在check方法中使用OSS_DOMAINif (StringUtils.isEmpty(fileDto.getVod()))&#123;\tfileDto.setPath(OSS_DOMAIN+fileDto.getPath());&#125;\n\n3.修改redis地址\n\n\n遇到的问题：把redis地址改成了自己的redis，结果存进去后，取不到值。这是因为修改redis地址只改了一个，要两个都改，server和gateway的application.properties\n\nspring.redis.host=127.0.0.1spring.redis.port=6379spring.redis.password=Redis000\n\n4.BUG修复：注册时，验证码校验通过后，短信记录未变成已使用\n\n\n在SmsService中的validCode方法，自始至终都用的smsDb这个，从数据库里直接取。\n\n5.解决侧边栏收缩按钮不起作用的BUG\n\n\nwindow.open是js原生方法，用于打开某个页面，我们修改admin的login.vue的login()方法修改\n\n// _this.$router.push(&quot;/welcome&quot;);window.open(&quot;/welcome&quot;, &quot;_self&quot;);\n\n\n因为我们现在使用的是js原生的跳转，这是admin.vue的这个就可以注释了\n\n// $.getScript(&#x27;/ace/assets/js/ace.min.js&#x27;);\n\n16-2 验证码图片清晰度优化\n我们在com.course.server.util增加NoWaterRipple.java\n\npackage com.course.server.util;import com.google.code.kaptcha.GimpyEngine;import com.google.code.kaptcha.util.Configurable;import java.awt.*;import java.awt.image.BufferedImage;import java.awt.image.ImageObserver;public class NoWaterRipple extends Configurable implements GimpyEngine &#123;      public NoWaterRipple()&#123;&#125;      @Override      public BufferedImage getDistortedImage(BufferedImage baseImage) &#123;         //NoiseProducer noiseProducer = this.getConfig().getNoiseImpl();         BufferedImage distortedImage = new BufferedImage(baseImage.getWidth(), baseImage.getHeight(), 2);         Graphics2D graphics = (Graphics2D)distortedImage.getGraphics();         //RippleFilter rippleFilter = new RippleFilter();         //rippleFilter.setWaveType(0);         //rippleFilter.setXAmplitude(2.6F);         //rippleFilter.setYAmplitude(1.7F);         //rippleFilter.setXWavelength(15.0F);         //rippleFilter.setYWavelength(5.0F);         //rippleFilter.setEdgeAction(0);         //WaterFilter waterFilter = new WaterFilter();         //waterFilter.setAmplitude(1.5F);         //waterFilter.setPhase(10.0F);         //waterFilter.setWavelength(2.0F);         //BufferedImage effectImage = waterFilter.filter(baseImage, (BufferedImage)null);         //effectImage = rippleFilter.filter(effectImage, (BufferedImage)null);         graphics.drawImage(baseImage, 0, 0, (Color)null, (ImageObserver)null);         graphics.dispose();         //noiseProducer.makeNoise(distortedImage, 0.1F, 0.1F, 0.25F, 0.25F);         //noiseProducer.makeNoise(distortedImage, 0.1F, 0.25F, 0.5F, 0.9F);         return distortedImage;      &#125;   &#125;\n\n\n然后将KaptchaConfig进行修改\n\n//properties.setProperty(&quot;kaptcha.obscurificator.impl&quot;, &quot;com.google.code.kaptcha.impl.WaterRipple&quot;);properties.setProperty(&quot;kaptcha.obscurificator.impl&quot;, &quot;com.course.server.util.NoWaterRipple&quot;);\n\n16-3 Vue CLI多环境编译1.增加配置文件vue.config.js，作用类似于springboot的application.properties，参考文档时cli.vue.js的那部分2.修改BASE_URL改为相对路径，对应配置publicPath\n\n\n修改package.json\n\n&quot;build-dev&quot;: &quot;vue-cli-service build --mode dev&quot;,&quot;build-prod&quot;: &quot;vue-cli-service build --mode prod&quot;,\n\n\n然后在npm编译，双击后，就会在admin模块出现dist目录，这就是编译后的结果。但是编译之后会把我们的BASE_URL变成&#x2F;，这时我们在admin根目录下新增vue.config.js\n\n\n//本地开发使用绝对路径，生产开发使用相对路径module.exports = &#123;  publicPath: process.env.NODE_ENV === &#x27;production&#x27;      ? &#x27;/&#x27;      : &#x27;/&#x27;&#125;;\n\n\n要发布的话，就是将dist目录拷贝到服务器上，用nginx，tomcat，nodejs等容器启动\n\n16-4 新增视频时没有触发绑定1.两种方法解决新增讲师头像不能实时预览的问题\n\n\n新增时，teacher是空对象，初始没有image属性，也就不会有对应的监听操作，所以即使js代码里为image赋值，也不不会渲染到页面上，而编辑时，teacher是从后端返回的，此时所有属性都会有，即使存的是空值。\n\n原理大概是vue会为存在的属性生成set，get方法，在方法中做文章，如果初始空对象，没有任何属性，也就不会生成方法。\n\n我们有两个方法，第一个就是初始化时就给teacher一个image属性（可以为null），在add方法中修改；方法二就是在afterUpload方法中强制渲染\n\n\n//新增讲师，上传头像后不能实时预览，解决方法一_this.teacher = &#123;  image:null&#125;;///////////////////////////////////////////////////// 新增讲师，上传头像后不能实时预览，解决方法二_this.$forceUpdate();\n\n16-5 关闭播放器模态框时停止播放\n问题：关闭模态框时，视频还在播放\n\n正常功能：关闭模态框时，自动停止播放\n\n步骤一：找到关闭模态框的事件\n\n步骤二：找到视频播放器暂停的方法\n\n我们修改player.vue在methods中增加\n\n\npause() &#123;  let _this = this;  _this.aliPlayer.pause();&#125;,\n\n\n然后我们修改modal-player.vue，增加如下\n\nmounted() &#123;  let _this = this;  // 当关闭模态框时，暂停播放  $(&#x27;#player-modal&#x27;).on(&#x27;hidden.bs.modal&#x27;, function (e) &#123;    _this.$refs.player.pause();  &#125;)&#125;,\n我们解决：修改fontawesome-cdn地址的问题\n\n\n用CDN的好处，就是代码中不用加入各种依赖，只要引入cdn地址就可了并且加载的资源都不占用本地的带宽和流量。缺点就是受人牵制CDN可能失效，所以需要找稳定，当然也有付费的CDN。我们在index.html中重新引入\n\n&lt;link href=&quot;https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css&quot; rel=&quot;stylesheet&quot;&gt;\n\n16-6 登录token超时优化1.登陆超时时，前端axios拦截器统一处理，跳到登录页面\n\n\n正确的做法：登录超时时，跳回登录页面\n\n应该想办法统一的拦截超时请求，而不是对每个请求做超时判断\n\n我们修改admin里的main.js。error里加如下\n\n\naxios.interceptors.request.use(function (response)&#123;  console.log(&quot;返回结果:&quot;,response);  return response;&#125;,error =&gt; &#123;  console.log(&quot;返回拦截：&quot;, error.response);  let response = error.response;  const status = response.status;  if (status === 401) &#123;    // 判断状态码是401 跳转到登录    console.log(&quot;未登录，跳到登录页面&quot;);    Tool.setLoginUser(null);    router.push(&#x27;/login&#x27;);  &#125;  return &#123;    data: &#123;      success: false,      message: &quot;请重新登录&quot;    &#125;  &#125;;&#125;);\n\n\n因为在刚才加的错误处理中，最后return时，只构造了success和message，所以这里的resp.content就是null，后面再加一个.list就会报错。这是我们修改user.vue，再list方法中加一个判断\n\nif (resp.success) &#123;  _this.users = resp.content.list;  _this.$refs.pagination.render(page, resp.content.total);&#125;\n\n1.gateway每次登录验证成功，刷新登录token超时时间\n\n\n超时时间指的是空闲时间，如果控台一直有操作，就应该不算超时，就应该刷新token超时时间\n\n只需要再LoginAdminGatewayFilter中加一行\n\n\nLOG.info(&quot;已登录:&#123;&#125;&quot;,object);// 增加权限校验，gateway里没有LoginUserDto，所以全部用JSON操作LOG.info(&quot;接口权限校验，请求地址：&#123;&#125;&quot;, path);boolean exist = false;JSONObject loginUserDto = JSON.parseObject(String.valueOf(object));/////////////////////////////////////////////////////////////////////////下面这一行redisTemplate.opsForValue().set(token, JSON.toJSONString(loginUserDto), 3600,  TimeUnit.SECONDS);\n\n16-7 Vue事件总线使用案例1.增加事件总线，用于两个毫无关系的组件之间触发事件，代码不好跟踪，尽量少用2.前端调试可以要打断点的地方增一行：debugger\n\n\n实现功能：点击播放小节视频时，如果需要登录，则直接弹出登录窗口\n\n如何实现两个毫无关系的组件之间的方法调用？使用事件总线\n\n功能第一步：定义一个全局的事件总线\n\n首先在web的main.js添加\n\n\n//事件总线EventBusVue.prototype.$event = new Vue();\n\n\n事件总线的使用分为两步，1发送事件，2监听事件\n\n事件总线是全局的，所有组件都可以往总线里发送个事件，所有的组件都可以监听里面的事件。就像一根通往干家万户的电线一样。\n\n功能实现第二步：播放方法里，发送一个打开登录窗口事件，使用$emit触发一个事件，事件名称可自定义。\n\n我们在detail.vue的play方法中的判断是否是会员里添加\n\n\n// Toast.warning(&quot;请先登录&quot;);// 触发打开登录窗口事件，用到事件总线_this.$event.$emit(&quot;openLoginModal&quot;, &quot;111&quot;);\n\n\n功能实现第三步：在登陆组件中增加监听打开登录窗口的事件，打开登录窗口事件随时都有可能有，login组件不知道何时来，所以应该初始化的事件就开始监听。使用$on监听事件，监听的事件名称要和$emit的事件名称一致。同时给事件总线传参数。如果要传递多个参数：可以将多个参数变成json对象进行传递。\n\n前端调试按巧：在要调试（打断点）的地方，加一行代码：debugger：注意：浏览器需要打开开发者工具（按F12才能生效）\n\n我们修改login.vue，在初始化mounted加入如下代码\n\n\n// 监听事件总线，openLoginModal事件_this.$event.$on(&quot;openLoginModal&quot;, function (param) &#123;  console.log(param);  // 前端调试可以使用debugger。  // debugger;  _this.openLoginModal();&#125;)\n\n\n事件总线实际上就是空的vue组件\n\n第17章 生产打包与发布本章是对课程做的升级，核心是掌握如何将整个项目发布到生产环境，通过外网来访问\n\n17-1 注册中心&amp;配置中心Nacos注册中心\n\n使用Nacos和使用Redis，MQ类似，要先下载并启动server端。Java代码中加入client端依赖去连接server端\n\n启动就点击如图所示：\n\n启动成功就会显示后台地址：\n\n默认账号密码都是nacos\n\ntype &#x3D;pom，可以理解为一组依赖，比如有10个Jar，只需要引入一个type&#x3D;pom的依赖就可以了，不需要引入10个jar包依赖。我们给course的pom添加依赖\n\n\n&lt;dependency&gt;   &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;   &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;   &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;   &lt;type&gt;pom&lt;/type&gt;   &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt;\n\n\n将system模块的注册中心，从eureka改为nacos\n\n&lt;!--        &lt;dependency&gt;--&gt;&lt;!--            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;--&gt;&lt;!--            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;--&gt;&lt;!--        &lt;/dependency&gt;--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;\n\n\n也要修改system的配置文件\n\n#eureka.client.service-url.defaultZone=http://localhost:8761/eureka/spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848\n\n\n然后把system启动类的注释换成@EnableDiscoveryClient\n\n17-2 注册中心&amp;配置中心Nacos21.system连接nacos配置中心\n\n\n因为将key写在源码里，容易泄露掉，所以这时候就需要一个配置中心，将特殊的配置梵高配置中心，而不是放到源码里\n\n对于公司来说，开发人员能够看到所有生产的数据库地址、用户名、密码，是不安全的，为了避免程序员删库跑路，需要将生成配置放到配置中心，只有有权限的人才能登录配置中心修改配置。怎么配置的，看nacos文档。\n\n下面我们新建一个配置\n\n客户端的使用需要增加一个依赖，哪里需要就在哪个pom.xml增加依赖\n\n\n&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n官方使用是使用了applicationContext，我们可以跟正常使用application.properties的写法一样，用@Value注解\n\n在这之前， 必须使用 bootstrap.properties 配置文件来配置Nacos Server 地址，Spring Boot中有两个上下文，一种是bootstrap，另一种是spplication，bootstrap是应用程序的父上下文，bootstrap的优先级高于application。bootstrap主要用于从额外的资源中加载配置文件。我们在system的resources中新建配置文件bootstrap.properties\n\n\nspring.cloud.nacos.config.server-addr=127.0.0.1:8848\n\n\n@Value注解需要记住，用法：@Value(“${xxx}”)，也可以使用带默认值的写法，比如@Value(“${system.test:TEST}”),当没有写system.test配置项时，就用”TEST”\n\n接下来写一个测试请求TestController，用来读取配置中心岗配置好的system.test的值\n\n\npackage com.course.system.controller;import com.course.server.dto.ResponseDto;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(&quot;/test&quot;)public class TestController &#123;    @Value(&quot;$&#123;system.test&#125;&quot;)    private String systemTest;    @GetMapping(&quot;/list&quot;)    public ResponseDto list() &#123;        ResponseDto responseDto = new ResponseDto();        responseDto.setContent(systemTest);        return responseDto;    &#125;&#125;\n\n\n实现功能：动态刷新配置。例如一些告警阈值配置，需要将阈值调低，立即生效，且不需要重启服务器\n\n方法一：客户端主动刷新：每30s会获取一次发生变化的配置值\n\n方法二：客户端被动监听：服务端有值发生变化时就主动告诉客户端拉取一次最新的值。两种方法同时存在，互补。防止某一方式因线程卡住等问题失效\n\n我们现在代码监听到了配置值发生变化，但是没有实时反应到程序的结果中.我们怎么做呢？就是在TestController增加一个注解@RefreshScope\n\n\n17-3 阿里云部署方案介绍\n首先RDS购买和配置，阿里云提供了musql、oracle等数据库服务，并且还有各种单机、集群方案，开箱即用，省去了我们大量的运维工作。\n接下来要初始化我们数据库，要在购买好的RDS上新那建项目实例，并执行初始化脚本。一个RDS可以创建多个实例，如果有多个学习项目，只需要购买一次RDS就可以了，减少学习成本\n接下来购买和配置ECS（就是一台虚拟机，可以选择windows或者linux，在其上安装各种应用程序）\n接下来安装SecureCRT(SecureCRT是ssh工具，主要用来远程执行命令，方便我们直接在本地电脑运行ECS服务器的命令。程序员最常用来看生产日志。)和WinSCP（是sftp工具，用来传文件到RDS，比如把打包好的源码上传到服务器上）。之前我用的是Xftp和Xshell\n然后是JDK的安装和配置\n然后是Nacos安装和启动\n然后是Nginx安装与配置（前端VueCLI编译打包后，使用Nginx启动，也可以使用Tomcat,Apache、Nodejs等容器来启动）\n然后是前后端模块打包与发布\n最后就是域名配置\n\n17-4 RDS购买与配置\n这个页面点击立即购买，选择自己想要的\n\n专有网络，可以理解为搭建个虚拟的局域网，把相关的服务器、数据库都放到同一个专有网络。默认就行\n\n购买成功后，我们进入RDS管理里面，设置下白名单\n\n白名单用法一：选择内网ECS服务器，只能被某几台ECS使用，安全性能高\n\n白名单用法二：填入特定的白名单，为了方便，我选择全部IP都可以访问，填入0.0.0.0&#x2F;0\n\n\n接下来的内容：创建一个courseimooc的数据库实例，以及对应的用户\n\n\n依旧是进入到管理里面，申请外网，这样内网地址和外网地址就都有了，在代码中配置数据库地址使用内网地址；通过本机客户端工具连接RDS、维护RDS，使用外网\n\n接下来先创建一个账号：\n\n然后我们在创建一个数据库\n\n然后我们就可以直接在管理的基本信息那登录数据库，登录的时候有个云资源授权，就是子账号（一般用作权限隔离。在企业中，不同的员工有不同的权限，可以通过子账号对员工划分权限）\n\n一般公司生产库不能通过外网连接，只能通过RDS控台来访问数据库。并且可以控制开发人员登录后只能查数据，不能修改表结构\n\n\n接下来我们要初始化我们数据库\n\n\n复制下外网地址，然后进入数据库连接，填入以下内容就行了\n\n17-5 ECS购买与配置\n这个页面点击立即购买，选择自己想要的，当选择可用区域我们要选择和数据库一样的可用区域，同样专有网络也要和RDS一样\n\n突发性能型：会有一个性能基准线，平时低于基准线会累计积分，在高峰期高于基准线时会消耗积分。\n\n安全组就是控制外网对ECS的端口访问，及ECS对外的访问。只有勾选的端口才能被外网访问到，这里会自动创建一个安全组，后续在部署应用时，需要再次设置安全组，开放8848，9000等端口。\n\n到了系统配置那一步，会设置账号密码，后续的登录ECS需要用到这组用户名和密码\n\n配置完之后就可以进入到管理控台了，里面也有ECS的管理，点进去就能看到公网IP和私有IP，复制下公网IP，\n\n然后我们使用SecureCRT工具，用于登录远程ECS并执行命令。\n\n作为开发人员需要熟悉一些常用的linux命令，生产部署主要是关于文件、文件夹的操作如cd lI rm tar等。生产运维就是关于进程、CPU、内存，如ps free top等，最常用的是查看日志，如grep tail等\n\nWinSCP是sftp工具，用于上传和下载文件\n\n\n17-6 JDK安装与Nacos安装在ECS中安装JDK\n\n\n首先在本电脑下载Java8版本，然后移到ECS中，或者直接使用SecureCRT使用wget+下载地址命令下载\n\n打文件名的前缀，再按Tab键，可以自动提取整个文件名\n\n重命名命令格式就是：mv 原名 现在名\n\n解压缩就是：tar -zxvf 文件名\n\nll命令是查看现在的文件夹\n\n我们配置JDK环境可以使用vim命令，编辑&#x2F;etc&#x2F;profile文件，加入JDK环境变量\n\n移动到文件最后，输入i，就进入编辑状态，新增下面三行，新增两个变量，JAVA_HOME和CLASSPATH第三方应用会用到，例如Tomcat，Nacos,并将&#x2F;bin目录加到PATH变量中，用于直接执行java，javac等命令\n\n\n\n然后按ESC键，退出编辑状态，再输入“:wg”保存并退出\n\n让配置好的变量立即生效，使用source&#x2F;etc&#x2F;profile，然后输入java，然后java-version就能识别我们的版本号了\n\n\n在ECS中安装Nacos\n\n\n首先把本电脑的nacos移动到ECS\n进入到nacos目录cd nacos ，cd bin ，ll就能看到本目录下所有的文件，然后就可以输入sh startup.sh运行\n然后我们可以用ps -ef是查看所有进程如果后面加”|”是管道符，可以在第一个指令的结果集里，再执行第二个指令，例如ps -ef | grep java，就是再第一个结果下查看java\nlinux环境启动nacos默认会失败，需要修改下nacos配置，linux的启动脚本配置的启动模式是集群，需要改成单机。关于集群部署，有兴趣的可以按官方文档，自己操作下。\n我们直接使用WinSCP进入到nacos的bin目录，我们编辑两个启动文件，搜索MODE就可以看到window使用的是单机，而linux是集群，我们把单机复制过去\ncluster和standalone是比较常见的单词，需要掌握。像缓存、消息队列等中间件，都会有单机和集群的部署方式。是属于偏架构师方向的知识\n回到命令窗口按上下键就可以找到之前使用的命令\ncurl命令可以用来发送get和post请求。发送get请求时，类似于在浏览器直接输入地址。增加-XPOST参数可以用来发送post请求。这里就可以输入curl 127.0.0.1:8848查看是否成功\n由于之前配置ECS时没有打开8848端口，所以现在还不能访问。我们进入到实例，然后管理，然后本实例安全组，点击配置规则，配置完就能访问了\n\n17-7 后台模块打包与发布1本节内容：将4个java应用发布到ECS上\n\n\n我们使用course下的install，把其下面的maven项目全部打包。\n\n以system为例，就会在system下面生成一个target里面有system+版本号.jar，我们将这个jar包放到服务器上用java命令运行就行了。如果想这个jar包只显示模块名，我们可以再pom.xml中的下增加\n\n\n&lt;finalName&gt;$&#123;artifactId&#125;&lt;/finalName&gt;\n\n\n将jar包移动到ECS中，然后使用命令行java -jar jar包名。可能会报错记得配置nacos，和ECS的端口\n\n为了安全，所有的后端Java应用，只有gateway允许被外部访问，其它应用都是内部应用，对外隐藏。否则别人通过外网直接system，那么权限控制就没用了。\n\n由于我们到了生产环境，所以我们要修改配置中心，我们来看看server中application数据库连接和我们现在生产的配置RDS哪几个不一样，本机和生产的用户名密码都是courseimooc，所以不用配到配置中心。生产有特殊配置的，需要覆盖代码的配置的，才需要配到配置中。我们只需要将下面这行再nacos进行配置,将localhost换成内网地址\n\n\nspring.datasource.url=jdbc:mysql://localhost:3306/courseimooc?characterEncoding=UTF8&amp;autoReconnect=true\n\n\n如果命令窗口出现中文乱码，只需要设置选项中会话选项里的外观的字符编码为UTF-8，但是这是一次性的，我们要永久解决这个问题，我们就修改配置文件在C:\\Users\\AppDate\\Config\\Sessions\\Default.ini找到Output Transformer Name改为UTF-8\n\n17-8 后台模块打包与发布2\n直接用java命令启动，就会一直占用当前会话窗口，不能执行其他命令。我们使用下面这命令行意思是在后台运行，并且生产日志\n\nnohup java -jar jar包名 &gt;/root/logs/名称.log 2&gt;&amp;1 &amp;\n\n\n关闭进程 kill -9 pid\n\n可题：SecureCRT一段时间不用的话就会自动断开可通过设置反空闲功能解决\n\n解决步骤：点击选项的全局选项的默认会话，里面编辑默认设置，发送字符可以填一个空格\n\n命令行输入history就能查看曾经输入的命令\n\n用tail命令查看最新日志，tail -200f error.log，查看最新的两百行，此时，会话窗口不能执行其他命令，正在实时等待最新日志，一旦有最新日志，就会实时显示到屏幕\n\n用grep命令查找某段日志 ，（grep 未获取 error.log）就会获取包含未获取关键字的日志段。grep -c 10 未获取 error.log这命令就会获取 未获取关键字的上下十行\n\ngrep通过搜索日志ID，来查看某一次请求完整的日志，方便分析问题，\n\n还可以通过搜索某个时间点的上下N行来分析问题，注意如果搜索的关键字包含空格，需要用“”包起来\n\n当然不要忘要为business和file增加配置中心，修改数据库连接。注意：到这一步，business和file的代码并没有加配置中心的配置，所以实际上还没有连到配置中心。\n\n\n17-9 Nginx安装与Vue项目发布\n我们发布含有多个Vue项目：一种方法：通过配置不同的二级目录，来访问不同的模块，第二种就是：通过配置不同的域名，来访问不同的模块\n\n命令行在线安装yum install xxx\n\n我们命令行输入nginx -v就可以查看版本\n\n怎么启动nginx呢？只需要输入service ngnix start\n\n验证启动成功，就是输入公网ip，里面有东西就是启动成功\n\n然后进入我们admin文件夹下的.env.prod就可以将公网ip进行替换了\n\n\nNODE_ENV=developmentVUE_APP_SERVER=公网ip\n\n\n然后修改vue.config.js\n\nmodule.exports = &#123;  publicPath: process.env.NODE_ENV === &#x27;production&#x27;      ? &#x27;/admin/&#x27;      : &#x27;/&#x27;&#125;;\n\n\n之后就可以打包了\n\n之后放到ECS种，配置nginx让他能够读到我们打包的vue，我们可以将自定义的配置放到&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;下，文件名xxx.conf。我们就写一个admin.conf文件\n\n当访问：47.103.86.218&#x2F;admin&#x2F;时，就会访问到服务器资源：&#x2F;root&#x2F;admin&#x2F;index.html\n\n设置完我们需要重启nginx，命令就是nginx -s reload\n\n安装完nginx后，会多一个nginx用户，并且默认以nginx用户启动，而admin相关的文件是用root用户上传的，这时nginx用户就没有权限去读admin相关的文件，所以访问时报错403，这时我们就要修改nginx.conf，将user nginx改为user root就行了，但是登录控台进去又报错是，是因为我们之前使用window.open（“&#x2F;welcome”），ip+端口后面的目录都会被去掉，而使用push，虽然也是&#x2F;welcome，但是因为是vue框架的绝对路径，所以会保留baseUrl的配置，即保留&#x2F;admin&#x2F;。这里还原成push写法\n\nvue cli有个解决404的方法，就是将我画出的那行复制到admin.conf里\n\n本节讲的是用二级目录配置会有很多问题\n\n\n17-10 域名配置1\n以域名courseimooc.com为例\n\n通过admin.courseimooc.com访问控台\n\n通过www.courseimooc.com访问web网站\n\n通过server.courseimooc.com来访问路由\n\n注意：不是所有的域名都能备案，如果是要长期用的，可以选择.com，.cn等能备案的域名。不能备案的域名不能解析到国内ECS，只能买国外或香港的ECS，网络肯定不如国内的好\n\n现在不能备案，但是我们要解析\n\n然后我们要更改ECS里的admin.conf，将server_name后面改为admin.courseimooc.com，然后因为2级目录也不需要了，所以location后一个&#x2F;就行了，然后我们刷新不需要&#x2F;admin了，就把try_files的&#x2F;admin去了，图片忘去了。\n\n因为是二级域名了，所以vue.config.js改回去\n\n\nmodule.exports = &#123;  publicPath: process.env.NODE_ENV === &#x27;production&#x27;      ? &#x27;./&#x27;      : &#x27;/&#x27;&#125;;\n\n17-11 域名配置2通过server.courseimooc.com来访问路由\n\n\n当我们进入页面，按F12会看到下面是通过ip和端口来访问的，我们需要将其改为域名\n\n我们首先依旧是解析域名\n\n其次为了掩盖端口，我们要在nginx做文章，我们在nginx的conf.d目录下在新建一个server.conf，他和admin.conf不同在于，它使用了反向代理，反向代理，代理的是服务器，浏览器只知道访问了80端口，并不知道真实的服务端是9000端口。正向代理，代理的是客户端，如VPN，服务端只知道被VPN服务器访阅了，但不知道真实的客户端来自哪里\n\n\n\n我们修改.env.prod\n\n\nNODE_ENV=developmentVUE_APP_SERVER=http://server.courseimooc.com\n\n\n改完这些\n\n通过www.courseimooc.com访问web网站\n\n\n同样需要解析域名\n\n修改web的.env.prod\n\n\nNODE_ENV=developmentVUE_APP_SERVER=http://www.imooc.com\n\n\n我们在nginx的conf.d目录下在新建一个web.conf\n\n注意：使用了配置中心后，要把项目中，用到@Value的配置移动到bootstrap.properties，或者配置到nacos中。就是bootstrap.properties和nacos任意一个地方要有配置，以file为例，把这部分移到bootstrap.properties\n\n在真实项目里，不会用这么暴力的kill-9，一般会搭配一些流量控制的功能，先将流量切断，等待当前所有的线程执行完，确认服务器日志没有再刷了，最后再kill-9\n扩展：本项目演示只用了一台服务器。真实的项目中，一般一个应用放一台服务器，不要把鸡蛋放在一个篮子里。并且每个应用会配置多个节点，防止宕（dang）机\n\n\n\n","tags":["完整项目"]},{"title":"完整项目之Spring Cloud + Vue 前后端分离4-2","url":"/2022/03/15/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E4%B9%8BSpring%20Cloud%20+%20Vue%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%204-2/","content":"第13章 网站开发本章将制作用于学员使用的网站，学习BootStrap的网站模板的使用，可以让程序员即使不会美工也可以写出漂亮的网站。\n\n13-1 网站模块的搭建新建web模板\n1.网站开发，增加web模块使用命令：vue create web\n\n\n大家拿到一个vue项目后，要先执行npm install，才能运行项目，一步会去下载node  module，类似于maven项目要先下载jar包\n步骤：vue create web —&gt; cd web —&gt; npm run serve\n\n多环境配置\n1.网站开发，web模块增加多环境配置启动命令，增加--port8081\n\n\n就是将admin里的两个配置文件复制过来，然后改package.json\n\n&quot;serve-dev&quot;: &quot;vue-cli-service serve --mode dev --port 8081&quot;,&quot;serve-prod&quot;: &quot;vue-cli-service serve --mode prod --port 8081&quot;,\n\n增加路由配置\n1.网站开发，web模块增加路由配置使用命令：npm install --Save vue-router\n\n\n这里只是增加了router依赖，后续开发页面时会增加router的配置\n\n13-2 集成bootstrap官方模板\n我们的控台admin，用的是免费的ace admin模板，ace也是基于bootstrap做的封装。有很多组织和个人以卖各种前端模板为生\n本章开发的前端网站，是基于bootstrap官方提供的原生模板\n\nbootstrap4.4.1文档介绍\n1.网站开发，增加bootstrp-4.4.1的js,css\n\n\njquery.slim是jquery的简化版也可以引入原版jquery。popper.js是一个js提示插件\n网站首页选用album模板，相册主题\n就是下载这个将其放到web的public\n\n集成album模板\n1.网站开发，集成album模板\n\n\n做前端的同学，会经常看到bundle这个词，就是将几个依赖的js或css，打包成一个bundle.js\n\n首先在index中加css和js\n\n\n&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= BASE_URL %&gt;bootstrap-4.4.1/css/bootstrap.min.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= BASE_URL %&gt;static/css/album.css&quot;&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.slim.min.js&quot; integrity=&quot;sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&lt;%= BASE_URL %&gt;bootstrap-4.4.1/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;\n\n\n将album模板中的body标签里的内容，复制到template标签中。修改app.vue\n\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;header&gt;      &lt;div class=&quot;collapse bg-dark&quot; id=&quot;navbarHeader&quot;&gt;        &lt;div class=&quot;container&quot;&gt;          &lt;div class=&quot;row&quot;&gt;            &lt;div class=&quot;col-sm-8 col-md-7 py-4&quot;&gt;              &lt;h4 class=&quot;text-white&quot;&gt;About&lt;/h4&gt;              &lt;p class=&quot;text-muted&quot;&gt;Add some information about the album below, the author, or any other background context. Make it a few sentences long so folks can pick up some informative tidbits. Then, link them off to some social networking sites or contact information.&lt;/p&gt;            &lt;/div&gt;            &lt;div class=&quot;col-sm-4 offset-md-1 py-4&quot;&gt;              &lt;h4 class=&quot;text-white&quot;&gt;Contact&lt;/h4&gt;              &lt;ul class=&quot;list-unstyled&quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;text-white&quot;&gt;Follow on Twitter&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;text-white&quot;&gt;Like on Facebook&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;text-white&quot;&gt;Email me&lt;/a&gt;&lt;/li&gt;              &lt;/ul&gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot;navbar navbar-dark bg-dark shadow-sm&quot;&gt;        &lt;div class=&quot;container d-flex justify-content-between&quot;&gt;          &lt;a href=&quot;#&quot; class=&quot;navbar-brand d-flex align-items-center&quot;&gt;            &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; aria-hidden=&quot;true&quot; class=&quot;mr-2&quot; viewBox=&quot;0 0 24 24&quot; focusable=&quot;false&quot;&gt;&lt;path d=&quot;M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z&quot;/&gt;&lt;circle cx=&quot;12&quot; cy=&quot;13&quot; r=&quot;4&quot;/&gt;&lt;/svg&gt;            &lt;strong&gt;Album&lt;/strong&gt;          &lt;/a&gt;          &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarHeader&quot; aria-controls=&quot;navbarHeader&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt;            &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt;          &lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/header&gt;    &lt;main role=&quot;main&quot;&gt;      &lt;section class=&quot;jumbotron text-center&quot;&gt;        &lt;div class=&quot;container&quot;&gt;          &lt;h1&gt;Album example&lt;/h1&gt;          &lt;p class=&quot;lead text-muted&quot;&gt;Something short and leading about the collection below—its contents, the creator, etc. Make it short and sweet, but not too short so folks don’t simply skip over it entirely.&lt;/p&gt;          &lt;p&gt;            &lt;a href=&quot;#&quot; class=&quot;btn btn-primary my-2&quot;&gt;Main call to action&lt;/a&gt;            &lt;a href=&quot;#&quot; class=&quot;btn btn-secondary my-2&quot;&gt;Secondary action&lt;/a&gt;          &lt;/p&gt;        &lt;/div&gt;      &lt;/section&gt;      &lt;div class=&quot;album py-5 bg-light&quot;&gt;        &lt;div class=&quot;container&quot;&gt;          &lt;div class=&quot;row&quot;&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/main&gt;    &lt;footer class=&quot;text-muted&quot;&gt;      &lt;div class=&quot;container&quot;&gt;        &lt;p class=&quot;float-right&quot;&gt;          &lt;a href=&quot;#&quot;&gt;Back to top&lt;/a&gt;        &lt;/p&gt;        &lt;p&gt;Album example is &amp;copy; Bootstrap, but please download and customize it for yourself!&lt;/p&gt;        &lt;p&gt;New to Bootstrap? &lt;a href=&quot;/&quot;&gt;Visit the homepage&lt;/a&gt; or read our &lt;a href=&quot;/docs/getting-started/introduction/&quot;&gt;getting started guide&lt;/a&gt;.&lt;/p&gt;      &lt;/div&gt;    &lt;/footer&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;App&#x27;,&#125;&lt;/script&gt;\n\n\n在增加一个album.css\n\n.jumbotron &#123;    padding-top: 3rem;    padding-bottom: 3rem;    margin-bottom: 0;    background-color: #fff;&#125;@media (min-width: 768px) &#123;    .jumbotron &#123;        padding-top: 6rem;        padding-bottom: 6rem;    &#125;&#125;.jumbotron p:last-child &#123;    margin-bottom: 0;&#125;.jumbotron h1 &#123;    font-weight: 300;&#125;.jumbotron .container &#123;    max-width: 40rem;&#125;footer &#123;    padding-top: 3rem;    padding-bottom: 3rem;&#125;footer p &#123;    margin-bottom: .25rem;&#125;\n\n顶部组件和底部组件提取\n1.网站开发，将顶部提取成the-header和the-footer组件\n\n\n小提示：在父组件中打入子组件的标签名，会自动引入子组件。\n\n在组件中先增加一个the-header，就是将header复制过来\n\n\n&lt;template&gt;  &lt;header&gt;    &lt;div class=&quot;collapse bg-dark&quot; id=&quot;navbarHeader&quot;&gt;      &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row&quot;&gt;          &lt;div class=&quot;col-sm-8 col-md-7 py-4&quot;&gt;            &lt;h4 class=&quot;text-white&quot;&gt;About1&lt;/h4&gt;            &lt;p class=&quot;text-muted&quot;&gt;Add some information about the album below, the author, or any other background context. Make it a few sentences long so folks can pick up some informative tidbits. Then, link them off to some social networking sites or contact information.&lt;/p&gt;          &lt;/div&gt;          &lt;div class=&quot;col-sm-4 offset-md-1 py-4&quot;&gt;            &lt;h4 class=&quot;text-white&quot;&gt;Contact&lt;/h4&gt;            &lt;ul class=&quot;list-unstyled&quot;&gt;              &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;text-white&quot;&gt;Follow on Twitter&lt;/a&gt;&lt;/li&gt;              &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;text-white&quot;&gt;Like on Facebook&lt;/a&gt;&lt;/li&gt;              &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;text-white&quot;&gt;Email me&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;navbar navbar-dark bg-dark shadow-sm&quot;&gt;      &lt;div class=&quot;container d-flex justify-content-between&quot;&gt;        &lt;a href=&quot;#&quot; class=&quot;navbar-brand d-flex align-items-center&quot;&gt;          &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; stroke-width=&quot;2&quot; aria-hidden=&quot;true&quot; class=&quot;mr-2&quot; viewBox=&quot;0 0 24 24&quot; focusable=&quot;false&quot;&gt;&lt;path d=&quot;M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z&quot;/&gt;&lt;circle cx=&quot;12&quot; cy=&quot;13&quot; r=&quot;4&quot;/&gt;&lt;/svg&gt;          &lt;strong&gt;Album&lt;/strong&gt;        &lt;/a&gt;        &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarHeader&quot; aria-controls=&quot;navbarHeader&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt;          &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt;        &lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/header&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;theHeader&#x27;,  &#125;&lt;/script&gt;\n\n\n在组件中先增加一个the-footer，就是将footer复制过来\n\n&lt;template&gt;  &lt;footer class=&quot;text-muted&quot;&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;p class=&quot;float-right&quot;&gt;        &lt;a href=&quot;#&quot;&gt;Back to top&lt;/a&gt;      &lt;/p&gt;      &lt;p&gt;Album example is &amp;copy; Bootstrap, but please download and customize it for yourself!&lt;/p&gt;      &lt;p&gt;New to Bootstrap? &lt;a href=&quot;/&quot;&gt;Visit the homepage&lt;/a&gt; or read our &lt;a href=&quot;/docs/getting-started/introduction/&quot;&gt;getting started guide&lt;/a&gt;.&lt;/p&gt;    &lt;/div&gt;  &lt;/footer&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name:&#x27;theFooter&#x27;,&#125;&lt;/script&gt;\n\n\n最后在app.vue\n\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;the-header&gt;&lt;/the-header&gt;    &lt;main role=&quot;main&quot;&gt;      &lt;section class=&quot;jumbotron text-center&quot;&gt;        &lt;div class=&quot;container&quot;&gt;          &lt;h1&gt;Album example&lt;/h1&gt;          &lt;p class=&quot;lead text-muted&quot;&gt;Something short and leading about the collection below—its contents, the creator, etc. Make it short and sweet, but not too short so folks don’t simply skip over it entirely.&lt;/p&gt;          &lt;p&gt;            &lt;a href=&quot;#&quot; class=&quot;btn btn-primary my-2&quot;&gt;Main call to action&lt;/a&gt;            &lt;a href=&quot;#&quot; class=&quot;btn btn-secondary my-2&quot;&gt;Secondary action&lt;/a&gt;          &lt;/p&gt;        &lt;/div&gt;      &lt;/section&gt;      &lt;div class=&quot;album py-5 bg-light&quot;&gt;        &lt;div class=&quot;container&quot;&gt;          &lt;div class=&quot;row&quot;&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;col-md-4&quot;&gt;              &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;                &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;                &lt;div class=&quot;card-body&quot;&gt;                  &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                  &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                    &lt;div class=&quot;btn-group&quot;&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                      &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                    &lt;/div&gt;                    &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/main&gt;    &lt;the-footer&gt;&lt;/the-footer&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import TheHeader from &quot;@/components/the-header&quot;;import TheFooter from &quot;@/components/the-footer&quot;;export default &#123;  name: &#x27;App&#x27;,  components: &#123;TheFooter, TheHeader&#125;,&#125;&lt;/script&gt;\n\n13-3 首页开发-1路由配置与文案修改\n1.网站开发，增加路由配置router.js，增加网站首页index.vue\n\n\n首先增加一个router.js\n\nimport Vue from &quot;vue&quot;import Router from &quot;vue-router&quot;import Index from &quot;./view/index&quot;Vue.use(Router);export default new Router(&#123;    mode: &quot;history&quot;,    base: process.env.BASE_URL,    routes: [&#123;        path: &quot;*&quot;,        redirect: &quot;/index&quot;,    &#125;, &#123;        path: &quot;/index&quot;,        component: Index    &#125;]&#125;)\n\n\n然后再mian.js中使用\n\nimport Vue from &#x27;vue&#x27;import App from &#x27;./app.vue&#x27;import router from &#x27;./router&#x27;//这个新增Vue.config.productionTip = falsenew Vue(&#123;  router,//还有这个新增  render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;)\n\n\n然后我们把app.vue的main部分复制到新建再src&#x2F;view里的index\n\n&lt;template&gt;  &lt;main role=&quot;main&quot;&gt;    &lt;section class=&quot;jumbotron text-center&quot;&gt;      &lt;div class=&quot;container&quot;&gt;        &lt;h1&gt;Album example&lt;/h1&gt;        &lt;p class=&quot;lead text-muted&quot;&gt;Something short and leading about the collection below—its contents, the creator, etc. Make it short and sweet, but not too short so folks don’t simply skip over it entirely.&lt;/p&gt;        &lt;p&gt;          &lt;a href=&quot;#&quot; class=&quot;btn btn-primary my-2&quot;&gt;Main call to action&lt;/a&gt;          &lt;a href=&quot;#&quot; class=&quot;btn btn-secondary my-2&quot;&gt;Secondary action&lt;/a&gt;        &lt;/p&gt;      &lt;/div&gt;    &lt;/section&gt;    &lt;div class=&quot;album py-5 bg-light&quot;&gt;      &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row&quot;&gt;          &lt;div class=&quot;col-md-4&quot;&gt;            &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;              &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;              &lt;div class=&quot;card-body&quot;&gt;                &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                  &lt;div class=&quot;btn-group&quot;&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                  &lt;/div&gt;                  &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;div class=&quot;col-md-4&quot;&gt;            &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;              &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;              &lt;div class=&quot;card-body&quot;&gt;                &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                  &lt;div class=&quot;btn-group&quot;&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                  &lt;/div&gt;                  &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;div class=&quot;col-md-4&quot;&gt;            &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;              &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;              &lt;div class=&quot;card-body&quot;&gt;                &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                  &lt;div class=&quot;btn-group&quot;&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                  &lt;/div&gt;                  &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;div class=&quot;col-md-4&quot;&gt;            &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;              &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;              &lt;div class=&quot;card-body&quot;&gt;                &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                  &lt;div class=&quot;btn-group&quot;&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                  &lt;/div&gt;                  &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;div class=&quot;col-md-4&quot;&gt;            &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;              &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;              &lt;div class=&quot;card-body&quot;&gt;                &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                  &lt;div class=&quot;btn-group&quot;&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                  &lt;/div&gt;                  &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;div class=&quot;col-md-4&quot;&gt;            &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;              &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;              &lt;div class=&quot;card-body&quot;&gt;                &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                  &lt;div class=&quot;btn-group&quot;&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                  &lt;/div&gt;                  &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;div class=&quot;col-md-4&quot;&gt;            &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;              &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;              &lt;div class=&quot;card-body&quot;&gt;                &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                  &lt;div class=&quot;btn-group&quot;&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                  &lt;/div&gt;                  &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;div class=&quot;col-md-4&quot;&gt;            &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;              &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;              &lt;div class=&quot;card-body&quot;&gt;                &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                  &lt;div class=&quot;btn-group&quot;&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                  &lt;/div&gt;                  &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;div class=&quot;col-md-4&quot;&gt;            &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;              &lt;svg class=&quot;bd-placeholder-img card-img-top&quot; width=&quot;100%&quot; height=&quot;225&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; aria-label=&quot;Placeholder: Thumbnail&quot; preserveAspectRatio=&quot;xMidYMid slice&quot; focusable=&quot;false&quot;&gt;&lt;title&gt;Placeholder&lt;/title&gt;&lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;#55595c&quot;/&gt;&lt;text x=&quot;50%&quot; y=&quot;50%&quot; fill=&quot;#eceeef&quot; dy=&quot;.3em&quot;&gt;Thumbnail&lt;/text&gt;&lt;/svg&gt;              &lt;div class=&quot;card-body&quot;&gt;                &lt;p class=&quot;card-text&quot;&gt;This is a wider card with supporting text below as a natural lead-in to additional content. This content is a little bit longer.&lt;/p&gt;                &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                  &lt;div class=&quot;btn-group&quot;&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                  &lt;/div&gt;                  &lt;small class=&quot;text-muted&quot;&gt;9 mins&lt;/small&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/main&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;index&#x27;,  &#125;&lt;/script&gt;\n\n\n没有使用route-view的话，就没有路由效果，因此我们再app.vue里进行替换\n\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;the-header&gt;&lt;/the-header&gt;    &lt;router-view&gt;&lt;/router-view&gt;//替换的    &lt;the-footer&gt;&lt;/the-footer&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import TheHeader from &quot;@/components/the-header&quot;;import TheFooter from &quot;@/components/the-footer&quot;;export default &#123;  name: &#x27;App&#x27;,  components: &#123;TheFooter, TheHeader&#125;,&#125;&lt;/script&gt;\n\n2.网站开发，导航条改为bootstrap导航条组件，文档:https://v4.bootcss.com/docs/components/navbar/\n\n\n将代码复制到the-header.vue\n\n&lt;template&gt;  &lt;header&gt;    &lt;nav class=&quot;navbar navbar-expand-lg navbar-light bg-light&quot;&gt;      &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Navbar&lt;/a&gt;      &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarSupportedContent&quot; aria-controls=&quot;navbarSupportedContent&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt;        &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt;      &lt;/button&gt;      &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarSupportedContent&quot;&gt;        &lt;ul class=&quot;navbar-nav mr-auto&quot;&gt;          &lt;li class=&quot;nav-item active&quot;&gt;            &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;Home &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;          &lt;/li&gt;          &lt;li class=&quot;nav-item&quot;&gt;            &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;Link&lt;/a&gt;          &lt;/li&gt;          &lt;li class=&quot;nav-item dropdown&quot;&gt;            &lt;a class=&quot;nav-link dropdown-toggle&quot; href=&quot;#&quot; id=&quot;navbarDropdown&quot; role=&quot;button&quot; data-toggle=&quot;dropdown&quot; aria-expanded=&quot;false&quot;&gt;              Dropdown            &lt;/a&gt;            &lt;div class=&quot;dropdown-menu&quot; aria-labelledby=&quot;navbarDropdown&quot;&gt;              &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Action&lt;/a&gt;              &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Another action&lt;/a&gt;              &lt;div class=&quot;dropdown-divider&quot;&gt;&lt;/div&gt;              &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Something else here&lt;/a&gt;            &lt;/div&gt;          &lt;/li&gt;          &lt;li class=&quot;nav-item&quot;&gt;            &lt;a class=&quot;nav-link disabled&quot;&gt;Disabled&lt;/a&gt;          &lt;/li&gt;        &lt;/ul&gt;        &lt;form class=&quot;form-inline my-2 my-lg-0&quot;&gt;          &lt;input class=&quot;form-control mr-sm-2&quot; type=&quot;search&quot; placeholder=&quot;Search&quot; aria-label=&quot;Search&quot;&gt;          &lt;button class=&quot;btn btn-outline-success my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;Search&lt;/button&gt;        &lt;/form&gt;      &lt;/div&gt;    &lt;/nav&gt;  &lt;/header&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;theHeader&#x27;,  &#125;&lt;/script&gt;\n\n3.网站开发，导航条美化:菜单名称修改；增加container布局；样式改为dark；4.集成fontawesome图标\n\n\nfontawesome是一个图标库，可以到官网注册后，获取自己的cdn链接\n\n在上面的the-header基础上进行修改\n\n\n&lt;template&gt;  &lt;header&gt;    &lt;nav class=&quot;navbar navbar-expand-lg navbar-dark bg-dark&quot;&gt;      &lt;div class=&quot;container&quot;&gt;      &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;        &lt;i class=&quot;fa fa-video-camera&quot;&gt;&lt;/i&gt;&amp;nbsp;小方课程      &lt;/a&gt;      &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarSupportedContent&quot; aria-controls=&quot;navbarSupportedContent&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt;        &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt;      &lt;/button&gt;      &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarSupportedContent&quot;&gt;        &lt;ul class=&quot;navbar-nav mr-auto&quot;&gt;          &lt;li class=&quot;nav-item active&quot;&gt;            &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;主页 &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;          &lt;/li&gt;          &lt;li class=&quot;nav-item active&quot;&gt;            &lt;a class=&quot;nav-link&quot; href=&quot;#&quot;&gt;全部课程&lt;/a&gt;          &lt;/li&gt;          &lt;li class=&quot;nav-item dropdown active&quot;&gt;            &lt;a class=&quot;nav-link dropdown-toggle&quot; href=&quot;#&quot; id=&quot;navbarDropdown&quot; role=&quot;button&quot; data-toggle=&quot;dropdown&quot; aria-expanded=&quot;false&quot;&gt;              更多            &lt;/a&gt;            &lt;div class=&quot;dropdown-menu&quot; aria-labelledby=&quot;navbarDropdown&quot;&gt;              &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;关于我们&lt;/a&gt;              &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;渠道合作&lt;/a&gt;              &lt;div class=&quot;dropdown-divider&quot;&gt;&lt;/div&gt;              &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;更多信息&lt;/a&gt;            &lt;/div&gt;          &lt;/li&gt;        &lt;/ul&gt;          &lt;span class=&quot;text-white&quot;&gt;欢迎：&lt;/span&gt;          &lt;button class=&quot;btn btn-outline-light my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;登录/注册&lt;/button&gt;      &lt;/div&gt;      &lt;/div&gt;    &lt;/nav&gt;  &lt;/header&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name:&#x27;theHeader&#x27;,  &#125;&lt;/script&gt;\n\n5.网站开发，底部文案修改\n\n\n就是修改the-footer\n\n&lt;template&gt;  &lt;footer class=&quot;text-muted&quot;&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;p class=&quot;float-right&quot;&gt;        &lt;a href=&quot;#&quot;&gt;回到顶部&lt;/a&gt;      &lt;/p&gt;      &lt;p&gt;欢迎来到小方视频售卖中心，第一次项目&lt;/p&gt;      &lt;p&gt;2021&amp;nbsp;leaning.com&lt;/p&gt;    &lt;/div&gt;  &lt;/footer&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name:&#x27;theFooter&#x27;,&#125;&lt;/script&gt;\n\n6.网站开发，大屏文案修改\n\n\n一样就是修改index.vue\n\n最新上线与好课推荐\n1.网站开发，增加【新上好课】后端接口测试地址\n\n\n以后web模块的请求全会放到web包下，将admin请求和web请求分开，方便做权限控制（business中controller），新建文件CourseController\n\npackage com.course.business.controller.web;import com.course.server.dto.CourseDto;import com.course.server.dto.PageDto;import com.course.server.dto.ResponseDto;import com.course.server.service.CourseService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import java.util.List;@RestController(&quot;webCourseController&quot;)@RequestMapping(&quot;/web/course&quot;)public class CourseController &#123;    private static final Logger LOG = LoggerFactory.getLogger(CourseController.class);    public static final String BUSINESS_NAME = &quot;课程&quot;;    @Resource    private CourseService courseService;    /**     * 列表查询，查询最新的3门已发布的课程     */    @GetMapping(&quot;/list-new&quot;)    public ResponseDto listNew() &#123;        PageDto pageDto = new PageDto();        pageDto.setPage(1);        pageDto.setSize(3);        ResponseDto responseDto = new ResponseDto();        List&lt;CourseDto&gt; courseDtoList = courseService.listNew(pageDto);        responseDto.setContent(courseDtoList);        return responseDto;    &#125;&#125;\n\n\n最后在CourseService添加方法\n\n/** * 新课列表查询，只查询已发布的，按创建日期倒序 */public List&lt;CourseDto&gt; listNew(PageDto pageDto) &#123;    PageHelper.startPage(pageDto.getPage(), pageDto.getSize());    CourseExample courseExample = new CourseExample();    courseExample.createCriteria().andStatusEqualTo(CourseStatusEnum.PUBLISH.getCode());    courseExample.setOrderByClause(&quot;created_at desc&quot;);    List&lt;Course&gt; courseList = courseMapper.selectByExample(courseExample);    return CopyUtil.copyList(courseList, CourseDto.class);&#125;\n\n2.网站首页开发，首页显示新上好课真实数据bootstrap4图片自适应：使用img-fluid安装axios：npm install axios --save3.初始user表，test/test\n\n\n前后端交互，使用axios，也可以用jquery\n\n我们首先npm install axios –save，然后修改main.js将axios 加进来\n\n\nimport axios from &quot;axios&quot;Vue.prototype.$ajax = axios;\n\n\n然后修改index.vue\n\n//新增data: function () &#123;  return &#123;    news: [],  &#125;&#125;,mounted() &#123;  let _this = this;  _this.listNew();&#125;,methods: &#123;  /**   * 查询新上好课   */  listNew() &#123;    let _this = this;    _this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/business/web/course/list-new&#x27;).then((response)=&gt;&#123;      console.log(&quot;查询新上好课结果：&quot;, response);      let resp = response.data;      if (resp.success) &#123;        _this.news = resp.content;      &#125;    &#125;).catch((response)=&gt;&#123;      console.log(&quot;error：&quot;, response);    &#125;)  &#125;,//修改 &lt;div v-for=&quot;o in news&quot; v-bind:key=&quot;o&quot; class=&quot;col-md-4&quot;&gt;            &lt;div class=&quot;card mb-4 shadow-sm&quot;&gt;              &lt;img class=&quot;img-fluid&quot; v-bind:src=&quot;o.image&quot;&gt;              &lt;div class=&quot;card-body&quot;&gt;                &lt;h4 class=&quot;&quot;&gt;&#123;&#123;o.name&#125;&#125;&lt;/h4&gt;                &lt;p class=&quot;card-text&quot;&gt;&#123;&#123;o.summary&#125;&#125;&lt;/p&gt;                &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;                  &lt;div class=&quot;btn-group&quot;&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;                  &lt;/div&gt;                  &lt;div class=&quot;text-muted&quot;&gt;                    &lt;span class=&quot;badge badge-info&quot;&gt;&lt;i class=&quot;fa fa-yen&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;&#123;&#123;o.price&#125;&#125;&lt;/span&gt;&amp;nbsp;                    &lt;span class=&quot;badge badge-info&quot;&gt;&lt;i class=&quot;fa fa-yen&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;&#123;&#123;o.enroll&#125;&#125;&lt;/span&gt;&amp;nbsp;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;\n\n13-4 首页开发-2最新上线与好课推荐\n1.网站首页开发课程card美化增加【最新上线】和【好课推荐】，【好课推荐】和【最新上线】使用的一样数据响应式的页面，使用rem代替px2.增加vue校验配置.eslintrc.js\n\n\n如果设置html标签的font-size&#x3D;16px，则1rem&#x3D;16px，0.5rer&#x3D;8px后续所有字体，边距都可以用rem作为单位\n\n首先在public的static中新建style.css，记得在index.html中引用\n\n\nhtml&#123;    font-size: 16px;&#125;\n\n\n然后把admin的.eslintrc.js复制到web\n\nmodule.exports = &#123;    root: true,    env: &#123;        node: true    &#125;,    &#x27;extends&#x27;: [        &#x27;plugin:vue/essential&#x27;,        &#x27;eslint:recommended&#x27;    ],    rules: &#123;        &#x27;no-console&#x27;: &#x27;off&#x27;,        &#x27;no-debugger&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;error&#x27; : &#x27;off&#x27;,        &#x27;no-undef&#x27;: &#x27;off&#x27;,        &#x27;vue/no-unused-vars&#x27;: &#x27;off&#x27;,        &#x27;vue/require-v-for-key&#x27;: &#x27;off&#x27;,        &#x27;no-unused-vars&#x27;: &#x27;off&#x27;,        &#x27;vue/no-unused-components&#x27;: &#x27;off&#x27;    &#125;,    parserOptions: &#123;        parser: &#x27;babel-eslint&#x27;    &#125;&#125;;\n\n\n然后我们把index.vue最新上线部分直接复制一下就变成了好课推荐\n\n&lt;div class =&quot;title1&quot;&gt;好课推荐&lt;/div&gt;&lt;div class=&quot;row&quot;&gt;  &lt;div v-for=&quot;o in news&quot;  class=&quot;col-md-4&quot;&gt;    &lt;div class=&quot;card mb-4 shadow-sm course&quot;&gt;      &lt;img class=&quot;img-fluid&quot; v-bind:src=&quot;o.image&quot;&gt;      &lt;div class=&quot;card-body&quot;&gt;        &lt;h4 class=&quot;&quot;&gt;&#123;&#123;o.name&#125;&#125;&lt;/h4&gt;        &lt;p class=&quot;card-text&quot;&gt;&#123;&#123;o.summary&#125;&#125;&lt;/p&gt;        &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;          &lt;div class=&quot;btn-group&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;          &lt;/div&gt;          &lt;div class=&quot;text-muted&quot;&gt;            &lt;span class=&quot;badge badge-info&quot;&gt;&lt;i class=&quot;fa fa-yen&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;&#123;&#123;o.price&#125;&#125;&lt;/span&gt;&amp;nbsp;            &lt;span class=&quot;badge badge-info&quot;&gt;&lt;i class=&quot;fa fa-yen&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;&#123;&#123;o.enroll&#125;&#125;&lt;/span&gt;&amp;nbsp;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;\n\n\n可以百度搜css3标题样式，有很多别人共享的样式，我们在index.vue加上样式\n\n&lt;style&gt;  .title1&#123;    margin-bottom: 2rem;    color: #fafafa;    letter-spacing: 0;    text-shadow: 0px 1px 0px #999, 0px 2px 0px #888, 0px 3px 0px #777, 0px 4px 0px #666, 0px 5px 0px #555, 0px 6px 0px #444, 0px 7px 0px #333, 0px 8px 7px #001135;    font-size: 2rem;  &#125;  .title2&#123;    margin-bottom: 2rem;    color: transparent;    -webkit-text-stroke: 1px black;    letter-spacing: 0.04em;    font-size: 2rem;  &#125;&lt;/style&gt;\n\n课程信息组件提取\n1.网站首页开发：增加课程card组件the-course\n\n\n首先增加组件the-course\n\n&lt;template&gt;  &lt;div class=&quot;card mb-4 shadow-sm course&quot;&gt;    &lt;img class=&quot;img-fluid&quot; v-bind:src=&quot;course.image&quot;&gt;    &lt;div class=&quot;card-body&quot;&gt;      &lt;h4 class=&quot;&quot;&gt;&#123;&#123;course.name&#125;&#125;&lt;/h4&gt;      &lt;p class=&quot;card-text&quot;&gt;&#123;&#123;course.summary&#125;&#125;&lt;/p&gt;      &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt;        &lt;div class=&quot;btn-group&quot;&gt;          &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;View&lt;/button&gt;          &lt;button type=&quot;button&quot; class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Edit&lt;/button&gt;        &lt;/div&gt;        &lt;div class=&quot;text-muted&quot;&gt;          &lt;span class=&quot;badge badge-info&quot;&gt;&lt;i class=&quot;fa fa-yen&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;&#123;&#123;course.price&#125;&#125;&lt;/span&gt;&amp;nbsp;          &lt;span class=&quot;badge badge-info&quot;&gt;&lt;i class=&quot;fa fa-yen&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;&#123;&#123;course.enroll&#125;&#125;&lt;/span&gt;&amp;nbsp;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name:&#x27;the-course&#x27;,  props:&#123;    course:&#123;&#125;  &#125;,  data:function ()&#123;    return &#123;&#125;  &#125;,&#125;&lt;/script&gt;&lt;style&gt;.course h4 &#123;  font-size: 1.25rem;  margin: 15px 0;&#125;.course .text-muted .badge &#123;  font-size: 1rem;&#125;&lt;/style&gt;\n\n\n然后修改index.vue使用\n\n&lt;div class=&quot;row&quot;&gt;  &lt;div v-for=&quot;o in news&quot; class=&quot;col-md-4&quot;&gt;    &lt;the-course v-bind:course=&quot;o&quot;&gt;&lt;/the-course&gt;  &lt;/div&gt;&lt;/div&gt;\n\n2.网站首页开发：课程card组件增加等级显示3，增加过滤器Filter.js\n\n\n我们首先增加一个枚举，需要在EnumGenerator.java改下路径\n\nstatic String path = &quot;web\\\\public\\\\static\\\\js\\\\enums.js&quot;;\n\n\n生成完enums.js后需要在index.html引用\n\n&lt;script src=&quot;&lt;%= BASE_URL %&gt;static/js/enums.js&quot;&gt;&lt;/script&gt;\n\n\n然后我们在admin中将filter.js拷过来\n\n/** * 数组过滤器 例如：这也是两个大括号包住SECTION_CHARGE | option..KV(section.charge) * @param object 例如：&#123;CHARGE:&#123;key:&quot;C&quot;, value:&quot;收费&quot;&#125;,FREE:&#123;key:&quot;F&quot;, value:&quot;免费&quot;&#125;&#125; * @param key 例如：C * @returns &#123;string&#125; 例如：收费 */let option..KV = (object, key) =&gt;  &#123;    if (!object || !key) &#123;        return &quot;&quot;;    &#125; else &#123;        let result = &quot;&quot;;        for(let enums in object)&#123;            if (key === object[enums][&quot;key&quot;]) &#123;                result = object[enums][&quot;value&quot;];            &#125;        &#125;        return result;    &#125;&#125;;/** * 时长格式化 * @param value 例如：36000 * @returns &#123;string&#125; 例如：10:00:00 */let format..Second = (value) =&gt; &#123;    value = value || 0;    let second = parseInt(value, 10); // 秒    let minute = 0; // 分    let hour = 0; // 小时    if (second &gt;= 60) &#123;        // 当大于60秒时，才需要做转换        minute = Math.floor(second / 60);        second = Math.floor(second % 60);        if (minute &gt;= 60) &#123;            hour = Math.floor(minute / 60);            minute = Math.floor(minute % 60);        &#125;    &#125; else &#123;        // 小于60秒时，直接显示，不需要处理    &#125;    let result = &quot;&quot; + PrefixInteger(second, 2) + &quot;&quot;;    // 拼上分钟    result = &quot;&quot; + PrefixInteger(minute, 2) + &quot;:&quot; + result;    // 拼上小时    result = &quot;&quot; + PrefixInteger(hour, 2) + &quot;:&quot; + result;    return result;&#125;;/** * 格式化指定长度，前面补0 */function PrefixInteger(num, length) &#123;    return (Array(length).join(&#x27;0&#x27;) + num).slice(-length);&#125;/** * 格式化文件大小 * @param value * @returns &#123;string&#125; */let formatFileSize = (value) =&gt; &#123;    value = value || 0;    let result;    if (value &gt; 100 * 1024) &#123;        result = Math.round((value / 1024 / 1024) * 100) / 100 + &quot;MB&quot;;    &#125; else &#123;        result = Math.round((value / 1024) * 100) / 100 + &quot;KB&quot;;    &#125;    return result;&#125;;export default &#123;    option..KV,    format..Second,    formatFileSize&#125;\n\n\n在main.js中定义\nimport filter from &quot;./filter/filter&quot;//全局过滤器Object.keys(filter).forEach(key=&gt;&#123;  Vue.filter(key,filter[key])&#125;);\n\n最后在the-course\n\n\n&lt;span class=&quot;badge badge-info&quot;&gt;&lt;i class=&quot;fa fa-yen&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;两个大括号包住course.price&lt;/span&gt;&amp;nbsp;&lt;span class=&quot;badge badge-info&quot;&gt;&lt;i class=&quot;fa fa-yen&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;两个大括号包住course.enroll&lt;/span&gt;&amp;nbsp;&lt;span class=&quot;badge badge-info&quot;&gt;两个大括号包住COURSE_LEVEL|option..KV(course.level)&lt;/span&gt;//新增的//data返回 data:function ()&#123;    return &#123;      COURSE_LEVEL:COURSE_LEVEL    &#125;  &#125;,\n\n13-5 课程列表页面开发课程列表数据显示\n1.网站首页开发，增加课程列表页【全部课程】，并增加路由\n\n\n首先在views中新加一个list.vue\n\n&lt;template&gt;  &lt;main role=&quot;main&quot;&gt;    &lt;div class=&quot;album py-5 bg-light&quot;&gt;      &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row&quot;&gt;          &lt;div v-for=&quot;o in courses&quot; class=&quot;col-md-4&quot;&gt;            &lt;the-course v-bind:course=&quot;o&quot;&gt;&lt;/the-course&gt;          &lt;/div&gt;          &lt;h3 v-show=&quot;courses.length === 0&quot;&gt;课程还未上架&lt;/h3&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/main&gt;&lt;/template&gt;&lt;script&gt;  import TheCourse from &quot;../components/the-course&quot;;  export default &#123;    components: &#123;TheCourse&#125;,    name: &#x27;list&#x27;,    data: function () &#123;      return &#123;        courses: [],      &#125;    &#125;,    mounted() &#123;      let _this = this;      _this.listCourse();    &#125;,    methods: &#123;      /**       * 查询课程列表       */      listCourse() &#123;        let _this = this;      &#125;,    &#125;  &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\n\n\n然后再router.js中加一个路由\n\n, &#123;    path: &quot;/list&quot;,    component: List&#125;\n\n\n接下来在index.vue中使用\n\n&lt;p&gt;  &lt;router-link to=&quot;/list&quot; class=&quot;btn btn-primary my-2 p-3 font-weight-bold&quot;&gt;点击进入所有课程&lt;/router-link&gt;&lt;/p&gt;\n\n\n同样在the-header中也使用\n\n&lt;li class=&quot;nav-item active&quot;&gt;  &lt;router-link to=&quot;/&quot; class=&quot;nav-link&quot; href=&quot;#&quot;&gt;主页 &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/router-link&gt;&lt;/li&gt;&lt;li class=&quot;nav-item active&quot;&gt;  &lt;router-link to=&quot;/list&quot; class=&quot;nav-link&quot; href=&quot;#&quot;&gt;全部课程&lt;/router-link&gt;&lt;/li&gt;\n\n2.网站首页开发，课程列表页调用后端接口显示真实数据\n\n\nCtrl+Alt+L格式化\n\n首先在CourseController中增加方法\n\n\n/** * 列表查询 */@PostMapping(&quot;/list&quot;)public ResponseDto list(@RequestBody PageDto pageDto) &#123;    ResponseDto responseDto = new ResponseDto();    courseService.list(pageDto);    responseDto.setContent(pageDto);    return responseDto;&#125;\n\n\n然后再list中完善方法\n\n/** * 查询课程列表 */listCourse(page) &#123;  let _this = this;  _this.$ajax.post(process.env.VUE_APP_SERVER+&#x27;/business/web/course/list&#x27;,&#123;    page:page,    size:3,  &#125;).then((response)=&gt;&#123;    let resp = response.data;    if (resp.sucess)&#123;      _this.courses = resp.content.list;    &#125;  &#125;).catch((response)=&gt;&#123;    console.log(&quot;error&quot;,response);  &#125;)&#125;,\n\n3.课程列表页面开发，后端接口只能查询已发布的课程\n\n\n如果列表查询接口的请求参数，只有分页相关的参数，可以使用PageDto作为传参的类。如果请求参数包含其他参数，则需要建立一个类CoursePageDto，集成PageDto，来传递更多的参数。因从我们加了CoursePageDto\n\npackage com.course.server.dto;public class CoursePageDto extends PageDto &#123;    private String status;    public String getStatus() &#123;        return status;    &#125;    public void setStatus(String status) &#123;        this.status = status;    &#125;    @Override    public String toString() &#123;        final StringBuffer sb = new StringBuffer(&quot;CoursePageDto&#123;&quot;);        sb.append(&quot;status=&#x27;&quot;).append(status).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, page=&quot;).append(page);        sb.append(&quot;, size=&quot;).append(size);        sb.append(&quot;, total=&quot;).append(total);        sb.append(&quot;, list=&quot;).append(list);        sb.append(&#x27;&#125;&#x27;);        return sb.toString();    &#125;&#125;\n\n\n然后我们再web的CourseController中将参数替换了\n\npublic ResponseDto list(@RequestBody CoursePageDto pageDto) &#123;//参数替换    ResponseDto responseDto = new ResponseDto();    pageDto.setStatus(CourseStatusEnum.PUBLISH.getCode());//新增    courseService.list(pageDto);    responseDto.setContent(pageDto);    return responseDto;&#125;\n\n\n这时CourseService中的list参数也得换，由于status查询条件不是必须的，控台接口进来就不需要这个条件，网站接口进来的有这个条件，所以增加一个status条件判断\n\npublic void list(CoursePageDto pageDto)&#123;//参数    CourseExample.Criteria criteria = courseExample.createCriteria();//都是新增    if(!StringUtils.isEmpty(pageDto.getStatus()))&#123;        criteria.andStatusEqualTo(pageDto.getStatus());    &#125;&#125;\n\n\n最后admin的coursecontroller也得将list参数进行修改\n\n4.课程列表页面开发，前端分页5.增加分页组件\n\n\n直接再admin中复制分页组件进行稍微修改\n\n&lt;template&gt;  &lt;div class=&quot;pagination&quot; role=&quot;group&quot; aria-label=&quot;分页&quot;&gt;    &lt;button type=&quot;button&quot; class=&quot;btn btn-outline-dark&quot;            v-bind:disabled=&quot;page === 1&quot;            v-on:click=&quot;selectPage(1)&quot;&gt;      1    &lt;/button&gt;    &lt;button type=&quot;button&quot; class=&quot;btn btn-outline-dark&quot;            v-bind:disabled=&quot;page === 1&quot;            v-on:click=&quot;selectPage(page - 1)&quot;&gt;      上一页    &lt;/button&gt;    &lt;button v-for=&quot;p in pages&quot; v-bind:id=&quot;&#x27;page-&#x27; + p&quot;            type=&quot;button&quot; class=&quot;btn btn-outline-dark&quot;            v-bind:class=&quot;&#123;&#x27;btn-primary active&#x27;:page == p&#125;&quot;            v-on:click=&quot;selectPage(p)&quot;&gt;      &#123;&#123;p&#125;&#125;    &lt;/button&gt;    &lt;button type=&quot;button&quot; class=&quot;btn btn-outline-dark&quot;            v-bind:disabled=&quot;page === pageTotal&quot;            v-on:click=&quot;selectPage(page + 1)&quot;&gt;      下一页    &lt;/button&gt;    &lt;button type=&quot;button&quot; class=&quot;btn btn-outline-dark&quot;            v-bind:disabled=&quot;page === pageTotal&quot;            v-on:click=&quot;selectPage(pageTotal)&quot;&gt;      两个大括号包住pageTotal||1    &lt;/button&gt;    &amp;nbsp;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;pagination&#x27;,  props: &#123;    list: &#123;      type: Function,      default: null    &#125;,    itemCount: Number // 显示的页码数，比如总共有100页，只显示10页，其它用省略号表示  &#125;,  data: function () &#123;    return &#123;      total: 0, // 总行数      size: 10, // 每页条数      page: 0, // 当前页码      pageTotal: 0, // 总页数      pages: [], // 显示的页码数组    &#125;  &#125;,  methods: &#123;    /**     * 渲染分页组件     * @param page     * @param total     */    render(page, total) &#123;      let _this = this;      _this.page = page;      _this.total = total;      _this.pageTotal = Math.ceil(total / _this.size);      _this.pages = _this.getPageItems(_this.pageTotal, page, _this.itemCount || 5);    &#125;,    /**     * 查询某一页     * @param page     */    selectPage(page) &#123;      let _this = this;      if (page &lt; 1) &#123;        page = 1;      &#125;      if (page &gt; _this.pageTotal) &#123;        page = _this.pageTotal;      &#125;      if (this.page !== page) &#123;        _this.page = page;        if (_this.list) &#123;          _this.list(page);        &#125;      &#125;    &#125;,    /**     * 当前要显示在页面上的页码     * @param total     * @param current     * @param length     * @returns &#123;Array&#125;     */    getPageItems(total, current, length) &#123;      let items = [];      if (length &gt;= total) &#123;        for (let i = 1; i &lt;= total; i++) &#123;          items.push(i);        &#125;      &#125; else &#123;        let base = 0;        // 前移        if (current - 0 &gt; Math.floor((length - 1) / 2)) &#123;          // 后移          base = Math.min(total, current - 0 + Math.ceil((length - 1) / 2)) - length;        &#125;        for (let i = 1; i &lt;= length; i++) &#123;          items.push(base + i);        &#125;      &#125;      return items;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.pagination &#123;  vertical-align: middle !important;  font-size: 16px;  margin-top: 0;  margin-bottom: 10px;&#125;.pagination button &#123;  margin-right: 5px;&#125;.btn-primary.active &#123;  background-color: #2f7bba !important;  border-color: #27689d !important;  color: white !important;  font-weight: 600;&#125;/*.pagination select &#123;*//*vertical-align: middle !important;*//*font-size: 16px;*//*margin-top: 0;*//*&#125;*/&lt;/style&gt;\n\n\n然后在list进行修改\n\n//分页组件使用&lt;div class=&quot;row&quot;&gt;  &lt;div class=&quot;col-md-12&quot;&gt;    &lt;pagination ref=&quot;pagination&quot; v-bind:list=&quot;listCourse&quot;&gt;&lt;/pagination&gt;  &lt;/div&gt;  &lt;/div&gt;&lt;br&gt;//初始化mounted() &#123; _this.$refs.pagination.size = 1;&#125;//在这个方法中进行渲染listCourse(page) &#123;        _this.$ajax.post(process.env.VUE_APP_SERVER+&#x27;/business/web/course/list&#x27;,&#123;          size:_this.$refs.pagination.size,//新增参数        &#125;).then((response)=&gt;&#123;          if (resp.sucess)&#123;            _this.$refs.pagination.render(page,resp.content.total);//增加得渲染          &#125;\n\n13-6 分类筛选功能开发分类筛选功能开发\n1.课程列表页面开发，加载所有分类2.增加axios接口访问日志拦截器\n\n\n先增加日志拦截器，修改main.js\n\n// 解决每次ajax请求，对应的sessionId不一致的问题axios.defaults.withCredentials = true;/** * axias拦截器 */axios.interceptors.request.use(function (config)&#123;  console.log(&quot;请求:&quot;,config);  return config;&#125;,error =&gt; &#123;&#125;);axios.interceptors.request.use(function (response)&#123;  console.log(&quot;返回结果:&quot;,response);  return response;&#125;,error =&gt; &#123;&#125;);\n\n\ntool.js同样也拷过来\n\nTool = &#123;    /**     * 空校验 null或&quot;&quot;都返回true     */    isEmpty: function (obj) &#123;        if ((typeof obj == &#x27;string&#x27;)) &#123;            return !obj || obj.replace(/\\s+/g, &quot;&quot;) == &quot;&quot;        &#125; else &#123;            return (!obj || JSON.stringify(obj) === &quot;&#123;&#125;&quot; || obj.length === 0);        &#125;    &#125;,    /**     * 非空校验     */    isNotEmpty: function (obj) &#123;        return !this.isEmpty(obj);    &#125;,    /**     * 长度校验     */    isLength: function (str, min, max) &#123;        return $.trim(str).length &gt;= min &amp;&amp; $.trim(str).length &lt;= max;    &#125;,    /**     * 时间格式化，date为空时取当前时间     */    dateFormat: function (format, date) &#123;        let result;        if (!date) &#123;            date = new Date();        &#125;        const option = &#123;            &quot;y+&quot;: date.getFullYear().toString(),        // 年            &quot;M+&quot;: (date.getMonth() + 1).toString(),     // 月            &quot;d+&quot;: date.getDate().toString(),            // 日            &quot;h+&quot;: date.getHours().toString(),           // 时            &quot;m+&quot;: date.getMinutes().toString(),         // 分            &quot;s+&quot;: date.getSeconds().toString()          // 秒        &#125;;        for (let i in option) &#123;            result = new RegExp(&quot;(&quot; + i + &quot;)&quot;).exec(format);            if (result) &#123;                format = format.replace(result[1], (result[1].length == 1) ? (option[i]) : (option[i].padStart(result[1].length, &quot;0&quot;)))            &#125;        &#125;        return format;    &#125;,    /**     * 移除对象数组中的对象     * @param array     * @param obj     * @returns &#123;number&#125;     */    removeObj: function (array, obj) &#123;        let index = -1;        for (let i = 0; i &lt; array.length; i++) &#123;            if (array[i] === obj) &#123;                array.splice(i, 1);                index = i;                break;            &#125;        &#125;        return index;    &#125;,    /**     * 10进制转62进制     * @param number     * @returns &#123;string&#125;     * @private     */    _10to62: function (number) &#123;        let chars = &#x27;0123456789abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ&#x27;;        let radix = chars.length;        let arr = [];        do &#123;            let mod = number % radix;            number = (number - mod) / radix;            arr.unshift(chars[mod]);        &#125; while (number);        return arr.join(&#x27;&#x27;);    &#125;,    /**     * 保存登录信息     * @param loginUser     */    setLoginUser:function (loginUser)&#123;        SessionStorage.set(SESSION_KEY_LOGIN_USER,loginUser);    &#125;,    /**     * 获取登录信息     * @param loginUser     * @returns &#123;any|&#123;&#125;&#125;     */    getLoginUser:function ()&#123;        return SessionStorage.get(SESSION_KEY_LOGIN_USER) ||&#123;&#125;;    &#125;,    /**     * 随机生成[len]长度的[radix]进制数     * @param len     * @param radix 默认62     * @returns &#123;string&#125;     */    uuid: function (len, radix) &#123;        let chars = &#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#x27;.split(&#x27;&#x27;);        let uuid = [];        radix = radix || chars.length;        for (let i = 0; i &lt; len; i++) &#123;            uuid[i] = chars[0 | Math.random() * radix];        &#125;        return uuid.join(&#x27;&#x27;);    &#125;,    /**     * 查找是否有权限     * @param id 资源id     */    hasResource: function (id) &#123;        let _this = this;        let resources = _this.getLoginUser().resources;        if (_this.isEmpty(resources)) &#123;            return false;        &#125;        for (let i = 0; i &lt; resources.length; i++) &#123;            if (id === resources[i].id) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;;\n\n\n修改list.vue\n\n//data中增加两个层级level1:[],level2:[],//mounted初始化  _this.allCategory();//增加方法      /**       * 所有分类查询       */      allCategory() &#123;        let _this = this;        _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/business/web/category/all&#x27;).then((response)=&gt;&#123;          let resp = response.data;          let categorys = resp.content;          // 将所有记录格式化成树形结构          _this.level1 = [];          for (let i = 0; i &lt; categorys.length; i++) &#123;            let c = categorys[i];            if (c.parent === &#x27;00000000&#x27;) &#123;              _this.level1.push(c);              for(let j =0;j&lt;categorys.level;j++)&#123;                let child = categorys[j];                if (child.parent ===c.id)&#123;                  if(Tool.isEmpty(c.children))&#123;                    c.children = [];                  &#125;                  c.children.push(child);                &#125;              &#125;            &#125; else &#123;              _this.level2.push(c);            &#125;          &#125;        &#125;)      &#125;,\n\n\n当然这时我们要在business&#x2F;web增加一个CategoryController\n\npackage com.course.business.controller.web;import com.course.server.dto.CategoryDto;import com.course.server.dto.ResponseDto;import com.course.server.service.CategoryService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import java.util.List;@RestController(&quot;webCategoryController&quot;)@RequestMapping(&quot;/web/category&quot;)public class CategoryController &#123;    private static final Logger LOG = LoggerFactory.getLogger(CategoryController.class);    public static final String BUSINESS_NAME = &quot;分类&quot;;    @Resource    private CategoryService categoryService;    /**     * 列表查询     */    @PostMapping(&quot;/all&quot;)    public ResponseDto all() &#123;        ResponseDto responseDto = new ResponseDto();        List&lt;CategoryDto&gt; categoryDtoList = categoryService.all();        responseDto.setContent(categoryDtoList);        return responseDto;    &#125;&#125;\n\n2.课程列表页面开发，两级分类访问慕课网显示\n\n\n修改list.vue\n\n&lt;div class=&quot;header-nav&quot;&gt;  &lt;div class=&quot;clearfix&quot;&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-12&quot;&gt;          &lt;a v-on:click=&quot;onClickLevel1(&#x27;00000000&#x27;)&quot; id=&quot;category-00000000&quot; href=&quot;javascript:;&quot; class=&quot;cur&quot;&gt;全部&lt;/a&gt;          &lt;a v-for=&quot;o in level1&quot; v-on:click=&quot;onClickLevel1(o.id)&quot; v-bind:id=&quot;&#x27;category-&#x27; + o.id&quot; href=&quot;javascript:;&quot;&gt;&#123;&#123;o.name&#125;&#125;&lt;/a&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;skill clearfix&quot;&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;row&quot;&gt;      &lt;div class=&quot;col-12&quot;&gt;        &lt;a v-on:click=&quot;onClickLevel2(&#x27;11111111&#x27;)&quot; id=&quot;category-11111111&quot; href=&quot;javascript:;&quot; class=&quot;on&quot;&gt;不限&lt;/a&gt;        &lt;a v-for=&quot;o in level2&quot; v-on:click=&quot;onClickLevel2(o.id)&quot; v-bind:id=&quot;&#x27;category-&#x27; + o.id&quot; href=&quot;javascript:;&quot;&gt;&#123;&#123;o.name&#125;&#125;&lt;/a&gt;        &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;//增加两个方法  /**       * 点击一级分类时       * @param level1Id       */      onClickLevel1(level1Id) &#123;        let _this = this;      &#125;,      /**       * 点击二级分类时       * @param level1Id       */      onClickLevel2(level2Id) &#123;        let _this = this;      &#125;,//增加两个样式&lt;style&gt;  /* 头部 一级分类 */.header-nav &#123;  height: auto;  background: #fff;  box-shadow: 0 8px 16px 0 rgba(28,31,33,.1);  padding: 16px 0;  box-sizing: border-box;  position: relative;  z-index: 1;  /*background-color: #d6e9c6;*/&#125;.header-nav&gt;div &#123;  width: 100%;  padding-left: 12px;  box-sizing: border-box;  margin-left: auto;  margin-right: auto;  /*background-color: #B4D5AC;*/&#125;.header-nav a &#123;  float: left;  font-size: 16px;  color: #07111b;  line-height: 50px;  height: 45px;  position: relative;  margin-right: 46px;  font-weight: 700;&#125;.header-nav a:hover &#123;  color: #c80;&#125;.header-nav a.cur &#123;  color: #c80;&#125;.header-nav a.cur:before &#123;  display: block;&#125;.header-nav a:before &#123;  display: none;  content: &#x27; &#x27;;  position: absolute;  bottom: 0;  background: #c80;  width: 16px;  height: 3px;  left: 50%;  margin-left: -8px;&#125;/* 二级分类 */.skill &#123;  width: 100%;  padding: 24px 0 0;  position: relative;  margin: 0 auto;&#125;.skill a.on &#123;  color: #c80;  background: rgba(204,136,0,.1);&#125;.skill a &#123;  float: left;  margin-right: 20px;  padding: 0 12px;  font-size: 14px;  color: #4d555d;  line-height: 32px;  border-radius: 6px;  margin-bottom: 12px;&#125;.skill a:hover &#123;  background: #d9dde1;&#125;&lt;/style&gt;\n\n3.课程列表页面开发，点击一级分类时显示激活状态，并显示对应的二级分类，如果点击的是全部，则显示所有的二级分类\n\n\n只修改list.vue\n\n//data中增加总分类categorys:[],//然后再allCategory中加上_this.categorys = categorys; /**       * 点击一级分类时       * @param level1Id       */      onClickLevel1(level1Id) &#123;        let _this = this;        // 点击一级分类时，显示激活状态        $(&quot;#category-&quot; + level1Id).siblings(&quot;a&quot;).removeClass(&quot;cur&quot;);        $(&quot;#category-&quot; + level1Id).addClass(&quot;cur&quot;);        // 点击一级分类时，二级分类【无限】按钮要设置激活状态        $(&quot;#category-11111111&quot;).siblings(&quot;a&quot;).removeClass(&quot;on&quot;);        $(&quot;#category-11111111&quot;).addClass(&quot;on&quot;);        // 注意：要先把level2中所有的值清空，再往里放        _this.level2 = [];        let categorys = _this.categorys;        // 如果点击的是【全部】，则显示所有的二级分类        if (level1Id === &#x27;00000000&#x27;) &#123;          for (let i = 0; i &lt; categorys.length; i++) &#123;            let c = categorys[i];            if (c.parent !== &quot;00000000&quot;) &#123;              _this.level2.push(c);            &#125;          &#125;        &#125;        // 如果点击的是某个一级分类，则显示该一级分类下的二级分类        if (level1Id !== &#x27;00000000&#x27;) &#123;          for (let i = 0; i &lt; categorys.length; i++) &#123;            let c = categorys[i];            if (c.parent === level1Id) &#123;              _this.level2.push(c);            &#125;          &#125;        &#125;      &#125;,\n\n4.课程列表页面开发，点击二级分类时显示激活状态\n\n\n也是修改list.vue\n\n/** * 点击二级分类时 * @param level1Id */onClickLevel2(level2Id) &#123;  let _this = this;  $(&quot;#category-&quot; + level2Id).siblings(&quot;a&quot;).removeClass(&quot;on&quot;);  $(&quot;#category-&quot; + level2Id).addClass(&quot;on&quot;);&#125;,\n\n5.课程列表页面开发，根据点击的分类进行课程筛选，动态sql不仅可以进行动态列查询，也可以进行动态表关联\n\n\n一级分类的全部激活时，level1id清空，二级分类的不限激活时，level2id清空，这样categoryid这个参数就是空的，即查询全部课程\n\n前端我们修改list.vue\n\n\n//data中增加两个要传入后端的参数level1Id: &quot;&quot;,level2Id: &quot;&quot;,//listCourse的传入后端的参数中加入categoryId: _this.level2Id || _this.level1Id || &quot;&quot;, // 优先取level2Id//再onClickLevel1中添加// 点击一级分类时，设置变量，用于课程筛选// 二级分类id为空，// 如果点击的是【全部】，则一级分类id为空_this.level2Id = null;_this.level1Id = level1Id;if (level1Id === &quot;00000000&quot;) &#123;\t_this.level1Id = null;&#125; // 最后重新加载课程列表_this.listCourse(1);//在onClickLevel2中// 点击二级分类时，设置变量，用于课程筛选// 如果点击的是【无限】，则二级分类id为空if (level2Id === &quot;11111111&quot;) &#123;\t_this.level2Id = null;&#125; else &#123;\t_this.level2Id = level2Id;&#125;// 重新加载课程列表_this.listCourse(1);\n\n\n下面开始修改后端首先MyCourseMapper.java\n\nList&lt;CourseDto&gt; list(@Param(&quot;pageDto&quot;) CoursePageDto pageDto);\n\n\n然后再CoursePageDto中新增字段\n\nprivate String categoryId;\n\n\n课程表+课程分类关联表两张表关联。多表关联查询，需要写自定义sql，这时修改MyCourseMapper.xml\n\n&lt;!-- web端【全部课程】页面，查询课程列表 --&gt;&lt;select id=&quot;list&quot; resultType=&quot;com.course.server.dto.CourseDto&quot;&gt;    select c.id, c.name, c.summary, time, price, image, level,    charge, status, enroll, sort, created_at as createdAt,    updated_at as updatedAt, teacher_id as teacherId    from `course` c    &lt;if test=&quot;pageDto.categoryId != null and pageDto.categoryId != &#x27;&#x27;&quot;&gt;        , course_category cc    &lt;/if&gt;    where 1 = 1    &lt;if test=&quot;pageDto.categoryId != null and pageDto.categoryId != &#x27;&#x27;&quot;&gt;        and c.id = cc.course_id        and cc.category_id = #&#123;pageDto.categoryId&#125;    &lt;/if&gt;    &lt;if test=&quot;pageDto.status != null and pageDto.status != &#x27;&#x27;&quot;&gt;        and c.status = #&#123;pageDto.status&#125;    &lt;/if&gt;    order by c.sort asc&lt;/select&gt;\n\n\n最后我们修改CourseService，将其全部替换\n\n/** * 列表查询：关联课程分类表 * @param pageDto */public void list(CoursePageDto pageDto) &#123;    PageHelper.startPage(pageDto.getPage(), pageDto.getSize());    List&lt;CourseDto&gt; courseDtoList = myCourseMapper.list(pageDto);    PageInfo&lt;CourseDto&gt; pageInfo = new PageInfo&lt;&gt;(courseDtoList);    pageDto.setTotal(pageInfo.getTotal());    pageDto.setList(courseDtoList);&#125;\n\n13-7 课程详情页面开发新增详情页面并配置路由\n1.课程列表页面开发，新增详情页面并配置路由2.课程报名数显示真实数据\n\n\n首先再views中增加detail.vue\n\n&lt;template&gt;  &lt;main role=&quot;main&quot;&gt;    &lt;div class=&quot;album py-5 bg-light&quot;&gt;      &lt;div class=&quot;container&quot;&gt;      &lt;h3&gt;课程详情&lt;/h3&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/main&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;detail&#x27;,  data: function () &#123;    return &#123;    &#125;  &#125;,  mounted() &#123;  &#125;,  methods: &#123;  &#125;&#125;&lt;/script&gt;\n\n\n然后增加路由\n\n, &#123;    path: &quot;/detail&quot;,    component: Detail&#125;\n\n\n最后在the-course中增加\n\n&lt;router-link v-bind:to=&quot;&#x27;/detail?id=&#x27; + course.id&quot; class=&quot;btn btn-outline-secondary&quot;&gt;课程详情&lt;/router-link&gt;\n\n\n还有那个报名人数之间就加了\n\n&lt;span class=&quot;badge badge-info&quot;&gt;&lt;i class=&quot;fa fa-yen&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;&#123;&#123;course.enroll&#125;&#125;&lt;/span&gt;&amp;nbsp;\n\n增加后端课程详情接口\n1.课程列表页面开发，增加后端课程详情接口,只能查询已发布的课程，包括内容、讲师、大章、小节信息\n\n\n首先修改CourseDto增加字段\n\nprivate List&lt;ChapterDto&gt; chapters;private List&lt;SectionDto&gt; sections;private String content;private TeacherDto teacher;\n\n\n然后增加CourseController\n\n@GetMapping(&quot;/find/&#123;id&#125;&quot;)public ResponseDto findCourse(@PathVariable String id) &#123;    LOG.info(&quot;查找课程开始：&#123;&#125;&quot;, id);    ResponseDto responseDto = new ResponseDto();    CourseDto courseDto = courseService.findCourse(id);    responseDto.setContent(courseDto);    LOG.info(&quot;查找课程结束：&#123;&#125;&quot;, responseDto);    return responseDto;&#125;\n\n\n接下来修改CourseService\n\n@Resourceprivate TeacherService teacherService;@Resourceprivate ChapterService chapterService;@Resourceprivate SectionService sectionService; /**     * 查找某一课程，供web模块用，只能查已发布的     * @param id     * @return     */    public CourseDto findCourse(String id) &#123;        Course course = courseMapper.selectByPrimaryKey(id);        if (course == null || !CourseStatusEnum.PUBLISH.getCode().equals(course.getStatus())) &#123;            return null;        &#125;        CourseDto courseDto = CopyUtil.copy(course, CourseDto.class);        // 查询内容        CourseContent content = courseContentMapper.selectByPrimaryKey(id);        if (content != null) &#123;            courseDto.setContent(content.getContent());        &#125;        // 查找讲师信息        TeacherDto teacherDto = teacherService.findById(courseDto.getTeacherId());        courseDto.setTeacher(teacherDto);        // 查找章信息        List&lt;ChapterDto&gt; chapterDtoList = chapterService.listByCourse(id);        courseDto.setChapters(chapterDtoList);        // 查找节信息        List&lt;SectionDto&gt; sectionDtoList = sectionService.listByCourse(id);        courseDto.setSections(sectionDtoList);        return courseDto;    &#125;\n\n\n接下来针对findCourse中的三个查找信息，修改teacherService，chapterService，sectionService\n\n/** * 查找 * @param id */public TeacherDto findById(String id) &#123;    Teacher teacher = teacherMapper.selectByPrimaryKey(id);    return CopyUtil.copy(teacher, TeacherDto.class);&#125;  /**     * 查询某一课程下的所有章     */    public List&lt;ChapterDto&gt; listByCourse(String courseId) &#123;        ChapterExample example = new ChapterExample();        example.createCriteria().andCourseIdEqualTo(courseId);        List&lt;Chapter&gt; chapterList = chapterMapper.selectByExample(example);        List&lt;ChapterDto&gt; chapterDtoList = CopyUtil.copyList(chapterList, ChapterDto.class);        return chapterDtoList;    &#125;  /**     * 查询某一课程下的所有节     */    public List&lt;SectionDto&gt; listByCourse(String courseId) &#123;        SectionExample example = new SectionExample();        example.createCriteria().andCourseIdEqualTo(courseId);        List&lt;Section&gt; sectionList = sectionMapper.selectByExample(example);        List&lt;SectionDto&gt; sectionDtoList = CopyUtil.copyList(sectionList, SectionDto.class);        return sectionDtoList;    &#125;\n\n前端界面显示课程信息\n1.课程列表页面开发，增加课程信息显示，可以使用@media(max-width:700px)来精细控制不同分辨率的显示样式\n\n\n如果地址是xxx？id&#x3D;a。那在vue代码里要获取id的值的话，可以使用this.$router.query.id\n\n修改detail.vue\n\n\n&lt;template&gt;  &lt;main role=&quot;main&quot;&gt;    &lt;div class=&quot;album py-5 bg-light&quot;&gt;      &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row course-head&quot;&gt;          &lt;div class=&quot;col-sm-6&quot; id=&quot;cover-video-div&quot;&gt;            &lt;img class=&quot;img-fluid&quot; v-bind:src=&quot;course.image&quot;&gt;          &lt;/div&gt;          &lt;div class=&quot;col-sm-6&quot;&gt;            &lt;h1&gt;&#123;&#123;course.name&#125;&#125;&lt;/h1&gt;            &lt;p class=&quot;course-head-item&quot;&gt;              &lt;span&gt;&lt;i class=&quot;fa fa-clock-o&quot;&gt;&lt;/i&gt; 两个大括号包住(course.time) | format..Second&lt;/span&gt;              &lt;span&gt;format..SecondCOURSE_LEVEL | option..KV(course.level)&lt;/span&gt;              &lt;span&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; &#123;&#123;course.enroll&#125;&#125;&lt;/span&gt;            &lt;/p&gt;            &lt;p class=&quot;course-head-desc&quot;&gt;&#123;&#123;course.summary&#125;&#125;&lt;/p&gt;            &lt;p class=&quot;course-head-price&quot;&gt;              &lt;span class=&quot;price-now text-danger&quot;&gt;&lt;i class=&quot;fa fa-yen&quot;&gt;&lt;/i&gt;&amp;nbsp;&#123;&#123;course.price&#125;&#125;&amp;nbsp;&amp;nbsp;&lt;/span&gt;            &lt;/p&gt;            &lt;p class=&quot;course-head-button-links&quot;&gt;              &lt;a  class=&quot;btn btn-lg btn-primary btn-shadow&quot; href=&quot;javascript:;&quot;&gt;立即报名&lt;/a&gt;            &lt;/p&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/main&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;detail&#x27;,  data: function () &#123;    return &#123;      id: &quot;&quot;,      course: &#123;&#125;,      teacher: &#123;&#125;,      chapters: [],      sections: [],      COURSE_LEVEL: COURSE_LEVEL,    &#125;  &#125;,  mounted() &#123;    let _this = this;    _this.id = _this.$route.query.id;    _this.findCourse();  &#125;,  methods: &#123;    findCourse() &#123;      let _this = this;      _this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/business/web/course/find/&#x27; + _this.id).then((response) =&gt; &#123;        let resp = response.data;        _this.course = resp.content;        _this.teacher = _this.course.teacher || &#123;&#125;;        _this.chapters = _this.course.chapters || [];        _this.sections = _this.course.sections || [];      &#125;)    &#125;,      &#125;&#125;&lt;/script&gt;&lt;style&gt;/* 课程信息 */.course-head &#123;&#125;.course-head h1 &#123;  font-size: 2rem;  margin-bottom: 1.5rem;&#125;.course-head-item span &#123;  margin-right: 1rem;&#125;.course-head-desc &#123;  font-size: 1rem;  color: #555&#125;.course-head a &#123;&#125;.course-head-price &#123;  font-size: 2rem;&#125;@media (max-width: 700px) &#123;  .course-head h1 &#123;    font-size: 1.5rem;  &#125;&#125;&lt;/style&gt;\n\n2.课程列表页面开发，增加课程内容显示\n\n\n在detail.vue中添加\n\n&lt;div class=&quot;row&quot;&gt;  &lt;!-- 课程内容 &amp; 大章小节 --&gt;  &lt;div class=&quot;col-md-9&quot;&gt;    &lt;!-- Nav tabs --&gt;    &lt;ul class=&quot;nav nav-tabs&quot;&gt;      &lt;li class=&quot;nav-item&quot;&gt;        &lt;a class=&quot;nav-link active&quot; href=&quot;#info&quot; data-toggle=&quot;tab&quot;&gt;课程介绍&lt;/a&gt;      &lt;/li&gt;      &lt;li class=&quot;nav-item&quot;&gt;        &lt;a class=&quot;nav-link&quot; href=&quot;#chapter&quot; data-toggle=&quot;tab&quot;&gt;章节目录&lt;/a&gt;      &lt;/li&gt;    &lt;/ul&gt;    &lt;br&gt;    &lt;!-- Tab panes --&gt;    &lt;div class=&quot;tab-content&quot;&gt;      &lt;div class=&quot;tab-pane active&quot; id=&quot;info&quot; v-html=&quot;course.content&quot;&gt;      &lt;/div&gt;      &lt;div class=&quot;tab-pane&quot; id=&quot;chapter&quot;&gt;      &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;!-- 讲师信息 --&gt;  &lt;div class=&quot;col-md-3&quot;&gt;  &lt;/div&gt;&lt;/div&gt;\n\n3.课程列表页面开发，增加讲师信息显示\n\n\n同样在detail.vue的讲师部分增加代码\n\n&lt;div class=&quot;col-md-3&quot;&gt;  &lt;div class=&quot;card&quot; style=&quot;width: 18rem;&quot;&gt;    &lt;img v-bind:src=&quot;teacher.image&quot; class=&quot;card-img-top&quot;&gt;    &lt;div class=&quot;card-body&quot;&gt;      &lt;h5 class=&quot;card-title&quot;&gt;&#123;&#123;teacher.name&#125;&#125;&lt;/h5&gt;      &lt;p class=&quot;card-text&quot;&gt;&#123;&#123;teacher.motto&#125;&#125;&lt;/p&gt;      &lt;p class=&quot;card-text&quot;&gt;&#123;&#123;teacher.intro&#125;&#125;&lt;/p&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;\n\n13-8 章节显示与视频播放大章和小节的分组显示\n1.课程详情页面开发，增加大章小节显示使用d-none d-sm-inline组合：超小屏时隐藏，其它显示v-for的第二变量是索引号\n\n\n第一个变量是遍历的每一个实体，第二变量是数组索引，从0开始\n\nd-none就是display:none，隐藏元素\n\n修改detail.vue\n\n\n//给 &lt;!-- Tab panes --&gt;中增加小节&lt;div class=&quot;tab-pane&quot; id=&quot;chapter&quot;&gt;  &lt;div v-for=&quot;chapter in chapters&quot; class=&quot;chapter&quot;&gt;    &lt;div  class=&quot;chapter-chapter&quot;&gt;      &lt;span class=&quot;folded-button&quot;&gt;&#123;&#123;chapter.name&#125;&#125;&lt;/span&gt;    &lt;/div&gt;    &lt;div &gt;      &lt;table class=&quot;table table-striped&quot;&gt;        &lt;tr v-for=&quot;(s, j) in chapter.sections&quot; class=&quot;chapter-section-tr&quot;&gt;          &lt;td class=&quot;col-sm-8 col-xs-12&quot;&gt;            &lt;div  class=&quot;section-title&quot;&gt;              &lt;i class=&quot;fa fa-video-camera d-none d-sm-inline&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;              &lt;span class=&quot;d-none d-sm-inline&quot;&gt;第&#123;&#123;j+1&#125;&#125;节&amp;nbsp;&amp;nbsp;&lt;/span&gt;              &#123;&#123;s.title&#125;&#125;              &lt;span v-show=&quot;s.charge !== SECTION_CHARGE.CHARGE.key&quot; class=&quot;badge badge-primary hidden-xs&quot;&gt;免费&lt;/span&gt;            &lt;/div&gt;          &lt;/td&gt;          &lt;td class=&quot;col-sm-1 text-right&quot;&gt;            &lt;span class=&quot;badge badge-primary&quot;&gt;两个大括号包住s.time | format..Second&lt;/span&gt;          &lt;/td&gt;        &lt;/tr&gt;      &lt;/table&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;//在data中增加上面使用的字段SECTION_CHARGE: SECTION_CHARGE//在findCourse中加循环// 将所有的节放入对应的章中        for (let i = 0; i &lt; _this.chapters.length; i++) &#123;          let c = _this.chapters[i];          c.sections = [];          for (let j = 0; j &lt; _this.sections.length; j++) &#123;            let s = _this.sections[j];            if (c.id === s.chapterId) &#123;              c.sections.push(s);            &#125;          &#125;        &#125;//增加css样式/* 章节列表 */.chapter &#123;  padding-bottom: 1.25rem;&#125;.chapter-chapter &#123;  font-size: 1.25rem;  padding: 1.25rem;  background-color: #23527c;  color: white;  cursor: pointer;&#125;.chapter-section-tr &#123;  font-size: 1rem;&#125;.chapter-section-tr td&#123;  padding: 1rem 1.25rem;  vertical-align: middle;&#125;/*鼠标手势*/.chapter-section-tr td .section-title&#123;  color: #555;&#125;.chapter-section-tr td .section-title:hover&#123;  color: #23527c;  font-weight: bolder;  cursor: pointer;&#125;/*行头小图标*/.chapter-section-tr td .section-title i&#123;  color: #2a6496;&#125;@media (max-width: 700px) &#123;  .chapter-chapter &#123;    font-size: 1.2rem;  &#125;  .chapter-section-tr &#123;    font-size: 0.9rem;  &#125;&#125;\n\n2.课程详情页面开发，增加大章小节收缩和展开注意：在v-for里写v-show.只修改属性不起作用，需要$set\n\n\n从后端加载出来的大章数据，是没有folded属性的，相当于chapter.folded&#x3D;false\n\n注意：v-for里面，如果用到了v-show，且v-show里面的控制属性值是随着界面操作而变化的，此时只修改属性值是不生效的，vue监听不到数组里的某个元素的值的变化。需要用到$set\n\n修改detail.vue\n\n\n&lt;div v-for=&quot;(chapter, i) in chapters&quot; class=&quot;chapter&quot;&gt;  &lt;div  v-on:click=&quot;doFolded(chapter, i)&quot; class=&quot;chapter-chapter&quot;&gt;    &lt;span &gt;&#123;&#123;chapter.name&#125;&#125;&lt;/span&gt;    &lt;span class=&quot;pull-right&quot;&gt;      &lt;i v-show=&quot;chapter.folded&quot; class=&quot;fa fa-plus-square&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;      &lt;i v-show=&quot;!chapter.folded&quot; class=&quot;fa fa-minus-square&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;    &lt;/span&gt;  &lt;/div&gt;  &lt;div v-show=&quot;!chapter.folded&quot;&gt;   /**     * 展开/收缩一个章节     * @param chapter     */    doFolded (chapter, i) &#123;      let _this = this;      chapter.folded = !chapter.folded;      // 在v-for里写v-show，只修改属性不起作用，需要$set      _this.$set(_this.chapters, i, chapter);    &#125;,\n\n3.课程详情页面开发，增加视频播放功能\n\n\n首先将admin里面player.vue组件复制过来，修改接口\n\n&lt;template&gt;  &lt;div v-bind:id=&quot;playerId&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export  default &#123;    name:&#x27;player&#x27;,    props:&#123;      playerId:&#123;        default:&quot;player-div&quot;      &#125;,    &#125;,    data: function ()&#123;      return&#123;        aliPlayer:&#123;&#125;,//播放器实例      &#125;    &#125;,    methods:&#123;      playUrl(url)&#123;        let _this=this;        console.log(&quot;开始播放:&quot;,url);        //如果已经有播放器了，则将播放器的div删除        if (_this.aliPlayer)&#123;          _this.aliPlayer=null;          $(&quot;#&quot;+_this.playerId+&#x27;-player&#x27;).remove();        &#125;        //初始播放器        $(&quot;#&quot;+_this.playerId).append(&quot;&lt;div class=\\&quot;prism-player\\&quot; id=\\&quot;&quot;+_this.playerId+&quot;-player\\&quot;&gt;&lt;/div&gt;&quot;);        _this.aliPlayer = new Aliplayer(&#123;          id: _this.playerId+&#x27;-player&#x27;,          width: &#x27;100%&#x27;,          autoplay:false,          source:url,          cover:&#x27;https://s2.loli.net/2022/03/01/6wagXDIZQGcebUt.png&#x27;,        &#125;,function(player)&#123;          console.log(&#x27;播放器创建好了&#x27;)        &#125;);      &#125;,      playVod (vod) &#123;        let _this = this;        Loading.show();          //下面admin改为了web        _this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/file/web/get-auth/&#x27; + vod).then((response)=&gt;&#123;          Loading.hide();          let resp = response.data;          if (resp.success) &#123;            //如果已经有播放器了，则将播放器div删除            if (_this.aliPlayer) &#123;              _this.aliPlayer = null;              $(&quot;#&quot; + _this.playerId + &#x27;-player&#x27;).remove();            &#125;            // 初始化播放器            $(&quot;#&quot; + _this.playerId).append(&quot;&lt;div class=\\&quot;prism-player\\&quot; id=\\&quot;&quot; + _this.playerId + &quot;-player\\&quot;&gt;&lt;/div&gt;&quot;);            _this.aliPlayer = new Aliplayer(&#123;              id: _this.playerId + &#x27;-player&#x27;,              width: &#x27;100%&#x27;,              autoplay: false,              vid: vod,              playauth: resp.content,              cover: &#x27;http://liveroom-img.oss-cn-qingdao.aliyuncs.com/logo.png&#x27;,              encryptType:1, //当播放私有加密流时需要设置。            &#125;,function(player)&#123;              console.log(&#x27;播放器创建好了。&#x27;)            &#125;);          &#125; else &#123;            Toast.warning(&#x27;播放错误。&#x27;)          &#125;        &#125;)      &#125;    &#125;  &#125;&lt;/script&gt;\n\n\n同样modal-play.vue不做任何修改\n\n&lt;template&gt;  &lt;div id=&quot;player-modal&quot; class=&quot;modal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot;&gt;    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;      &lt;div class=&quot;modal-content&quot;&gt;        &lt;div class=&quot;modal-body&quot;&gt;          &lt;player v-bind:player-id=&quot;&#x27;modal-player-div&#x27;&quot;                  ref=&quot;player&quot;&gt;&lt;/player&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import Player from &quot;./player&quot;;  export default &#123;    name: &#x27;modal-player&#x27;,    components: &#123;Player&#125;,    data: function () &#123;      return &#123;        aliPlayer: &#123;&#125;, // 播放器实例      &#125;    &#125;,    methods: &#123;      playUrl(url) &#123;        let _this = this;        _this.$refs.player.playUrl(url);      &#125;,      playVod(vod) &#123;        let _this = this;        _this.$refs.player.playVod(vod);        $(&quot;#player-modal&quot;).modal(&quot;show&quot;);      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;  #player-modal .modal-body &#123;    padding: 0;  &#125;&lt;/style&gt;\n\n\n然后再index.html中引入css和js\n\n&lt;!--  阿里云播放器--&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://g.alicdn.com/de/prismplayer/2.9.19/skins/default/aliplayer-min.css&quot; /&gt;&lt;!--  阿里云播放器--&gt;&lt;script charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;https://g.alicdn.com/de/prismplayer/2.9.19/aliplayer-min.js&quot;&gt;&lt;/script&gt;\n\n\n接下来把file文件包下面的VodController复制一份，保存到同文件包下新建的web文件包\n\npackage com.course.file.controller.web;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.aliyun.oss.OSSClient;import com.aliyuncs.DefaultAcsClient;import com.aliyuncs.exceptions.ClientException;import com.aliyuncs.vod.model.v20170321.CreateUploadVideoResponse;import com.aliyuncs.vod.model.v20170321.GetMezzanineInfoResponse;import com.aliyuncs.vod.model.v20170321.GetVideoPlayAuthResponse;import com.course.server.dto.FileDto;import com.course.server.dto.ResponseDto;import com.course.server.enums.FileUseEnum;import com.course.server.service.FileService;import com.course.server.util.Base64ToMultipartFile;import com.course.server.util.VodUtil;import org.apache.commons.codec.binary.Base64;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import javax.annotation.Resource;import java.io.File;import java.io.IOException;@RestController(&quot;webVodController&quot;)@RequestMapping(&quot;/web&quot;)public class VodController &#123;    private static final Logger LOG = LoggerFactory.getLogger(VodController.class);    public static final String BUSINESS_NAME = &quot;文件上传&quot;;    @Value(&quot;$&#123;vod.accessKeyId&#125;&quot;)    private String accessKeyId;    @Value(&quot;$&#123;vod.accessKeySecret&#125;&quot;)    private String accessKeySecret;    @Resource    private FileService fileService;   @PostMapping(&quot;/vod&quot;)    public ResponseDto fileUpload(@RequestBody FileDto fileDto) throws IOException &#123;       LOG.info(&quot;上传文件开始&quot;);       String use = fileDto.getUse();       String key = fileDto.getKey();       String suffix = fileDto.getSuffix();       Integer shardIndex = fileDto.getShardIndex();       Integer shardSize = fileDto.getShardSize();       String shardBase64 = fileDto.getShard();       MultipartFile shard = Base64ToMultipartFile.base64ToMultipart(shardBase64);       // 保存文件到本地       FileUseEnum useEnum = FileUseEnum.getByCode(use);       //如果文件夹不存在则创建       String dir = useEnum.name().toLowerCase();       String path = new StringBuffer(dir)               .append(File.separator)               .append(key)               .append(&quot;.&quot;)               .append(suffix)               .toString();       String vod =&quot;&quot;;       String fileUrl = &quot;&quot;;       try &#123;           // 初始化VOD客户端并获取上传地址和凭证           DefaultAcsClient vodClient = VodUtil.initVodClient(accessKeyId, accessKeySecret);           CreateUploadVideoResponse createUploadVideoResponse = VodUtil.createUploadVideo(vodClient,path);           // 执行成功会返回VideoId、UploadAddress和UploadAuth           vod = createUploadVideoResponse.getVideoId();           JSONObject uploadAuth = JSONObject.parseObject(                   Base64.decodeBase64(createUploadVideoResponse.getUploadAuth()),JSONObject.class);           JSONObject uploadAddress = JSONObject.parseObject(                   Base64.decodeBase64(createUploadVideoResponse.getUploadAddress()),JSONObject.class);           // 使用UploadAuth和UploadAddress初始化OSS客户端           OSSClient ossClient = VodUtil.initOssClient(uploadAuth, uploadAddress);           // 上传文件，注意是同步上传会阻塞等待，耗时与文件大小和网络上行带宽有关           VodUtil.uploadLocalFile(ossClient, uploadAddress, shard.getInputStream());           System.out.println(&quot;视频上传成功, VideoId : &quot; + vod);           GetMezzanineInfoResponse response =  VodUtil.getMezzanineInfo(vodClient,vod);           System.out.println(&quot;获取视频信息,response : &quot;+ JSON.toJSONString(response));           fileUrl = response.getMezzanine().getFileURL();           ossClient.shutdown();       &#125; catch (Exception e) &#123;           System.out.println(&quot;文件上传失败, ErrorMessage : &quot; + e.getLocalizedMessage());       &#125;       LOG.info(&quot;保存文件记录开始&quot;);       fileDto.setPath(path);       fileDto.setVod(vod);       fileService.save(fileDto);       ResponseDto responseDto = new ResponseDto();       fileDto.setPath(fileUrl);//返回给前端的需要一个可播放的地址，为了自动获取时长       responseDto.setContent(fileDto);       return responseDto;   &#125;    @RequestMapping(value = &quot;/get-auth/&#123;vod&#125;&quot;, method = RequestMethod.GET)    public ResponseDto getAuth(@PathVariable String vod) throws ClientException, ClientException, ClientException &#123;        LOG.info(&quot;获取播放授权开始: &quot;);        ResponseDto responseDto = new ResponseDto();        DefaultAcsClient client = VodUtil.initVodClient(accessKeyId, accessKeySecret);        GetVideoPlayAuthResponse response = new GetVideoPlayAuthResponse();        try &#123;            response = VodUtil.getVideoPlayAuth(client, vod);            LOG.info(&quot;授权码 = &#123;&#125;&quot;, response.getPlayAuth());            responseDto.setContent(response.getPlayAuth());            //VideoMeta信息            LOG.info(&quot;VideoMeta = &#123;&#125;&quot;, JSON.toJSONString(response.getVideoMeta()));        &#125; catch (Exception e) &#123;            System.out.print(&quot;ErrorMessage = &quot; + e.getLocalizedMessage());        &#125;        LOG.info(&quot;获取播放授权结束&quot;);        return responseDto;    &#125;&#125;\n\n\n最后修改detail.vue\n\n//再这添加on：click事件  &lt;div v-on:click=&quot;play(s)&quot; class=&quot;section-title&quot;&gt;//再html的最后添加    &lt;modal-player ref=&quot;modalPlayer&quot;&gt;&lt;/modal-player&gt;    &lt;/main&gt;//导入    import ModalPlayer from &quot;../components/modal-player&quot;;    components: &#123;ModalPlayer&#125;,//写方法 /**     * 播放视频     * @param section     */    play(section) &#123;      let _this = this;      _this.$refs.modalPlayer.playVod(section.vod);    &#125;,\n\n4.课程详情页面开发，对每个大章里面的小节进行排序\n\n\n我们现在web的Tool.js添加方法\n\n/** * 对象数组按key对应的值排序 * @param array * @param key * @returns &#123;*&#125; */sortAsc: function (array, key) &#123;    return array.sort(function (obj1, obj2) &#123;        let val1 = obj1[key];        let val2 = obj2[key];        if (val1 &lt; val2) &#123;            return -1;        &#125; else if (val1 &gt; val2) &#123;            return 1;        &#125; else &#123;            return 0;        &#125;    &#125;);&#125;\n\n\n然后再detail.vue中使用\n\n在大章循环最后使用findCourse() &#123;    // 将所有的节放入对应的章中    for (let i = 0; i &lt; _this.chapters.length; i++) &#123;      Tool.sortAsc(c.sections,&quot;sort&quot;);    &#125; &#125;\n\n5.课程详情页面开发，只有免费的视频才可直接播放，收费视频需要登录后才能播放   \n\n\n首先把toast.js复制过来\n\nToast = &#123;    success:function (message)&#123;        Swal.fire(&#123;            position: &#x27;top-end&#x27;,            icon: &#x27;success&#x27;,            title:message,            showConfirmButton: false,            timer: 3000        &#125;);    &#125;,    error:function (message)&#123;        Swal.fire(&#123;            position: &#x27;top-end&#x27;,            icon: &#x27;error&#x27;,            title: message,            showConfirmButton: false,            timer: 3000        &#125;);    &#125;,    warning:function (message)&#123;        Swal.fire(&#123;            position: &#x27;top-end&#x27;,            icon: &#x27;warning&#x27;,            title: message,            showConfirmButton: false,            timer: 3000        &#125;);    &#125;&#125;;\n\n\n然后index.html引入\n\n&lt;!--确认框和提示框--&gt;&lt;script src=&quot;//cdn.jsdelivr.net/npm/sweetalert2@11&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&lt;%= BASE_URL %&gt;static/js/toast.js&quot;&gt;&lt;/script&gt;\n\n\n最后在detail.vue使用\n\n/** * 播放视频 * @param section */play(section) &#123;  let _this = this;  if (section.charge === _this.SECTION_CHARGE.CHARGE.key ) &#123;    Toast.warning(&quot;请先登录&quot;);  &#125;else&#123;    _this.$refs.modalPlayer.playVod(section.vod);  &#125;&#125;,\n\n13-9 增加会员注册功能控台增加会员管理功能\n1.增加会员管理页面，新增member表，在之前代码生成器的步骤后面，加上以下步骤：1）在resource.json中增加新资源2）在【资源管理】页面，配置最新的resource.json3）在【角色管理】页面，为相应的角色配置新的资源4）重新登录控台自从控台加入权限管理功能后，新作的页面，需要增加这四部，配置相应的权限，才能使用新表的管理功能\n\n\n首先写sql，然后代码生成器一顿操作，记得后端和前端要改成business\n\n# 会员drop table if exists `member`;create table `member`(                       `id` char(8) not null default &#x27;&#x27; comment &#x27;id&#x27;,                       `mobile` varchar(11) not null comment &#x27;手机号&#x27;,                       `password` char(32) not null comment &#x27;密码&#x27;,                       `name` varchar(50)  comment &#x27;昵称&#x27;,                       `photo` varchar(200)  comment &#x27;头像url&#x27;,                       `register_time` datetime(3)  comment &#x27;注册时间&#x27;,                       primary key (`id`),                       unique key `mobile_unique`(`mobile`))engine =innodb default charset=utf8mb4 comment=&#x27;会员&#x27;;insert into `member` (id,mobile,password,name,photo,register_time) values (&#x27;00000000&#x27;,&#x27;12345678901&#x27;,&#x27;10000000&#x27;,&#x27;测试&#x27;,null,now());\n\n\n然后给admin的左侧菜单增加\n\n&lt;li v-show=&quot;hasResource(&#x27;0204&#x27;)&quot; class=&quot;&quot; id=&quot;business-member-sidebar&quot;&gt;  &lt;router-link to=&quot;/business/member&quot;&gt;    &lt;i class=&quot;menu-icon fa fa-caret-right&quot;&gt;&lt;/i&gt;    会员管理  &lt;/router-link&gt;  &lt;b class=&quot;arrow&quot;&gt;&lt;/b&gt;&lt;/li&gt;\n\n\n接着增加一个路由\n\n,&#123;    path: &quot;business/member&quot;,    name:&quot;business/member&quot;,    component: Member,&#125;\n\n\n到目前为止，跟我们前面介绍的制作表单功能的流程一样。但是由于加入权限功能，所以需要配置权限后才能看到页面。\n\n这给在resource.json中增加新资源，剩下的得再控台操作\n\n\n,&#123;  &quot;id&quot;:&quot;0204&quot;,&quot;name&quot;:&quot;会员管理&quot;,&quot;page&quot;:&quot;business/member&quot;,  &quot;children&quot;:[    &#123;&quot;id&quot;:&quot;020401&quot;,&quot;name&quot;:&quot;增删改查&quot;,&quot;request&quot;:[&quot;/business/admin/member&quot;]&#125;  ]&#125;\n\n2.增加会员管理页面，控台的会员管理，不能新增，修改·删除·可以查看会员信息·重置密码·报表统计等操作\n\n\n将MemberController得save和delete方法删除\n然后对于member.vue该删删\n\n网站增加会员注册功能\n1.会员登录注册功能开发，增加登录注册模态框，增加注册功能\n\n\n登录表单、注册表单、忘记密码表单放在同一模态框中\n\n首先我们进行web得MemberController增加，密码两层加密，传输加密+保存加密\n\n\npackage com.course.business.controller.web;import com.course.server.dto.MemberDto;import com.course.server.dto.ResponseDto;import com.course.server.service.MemberService;import com.course.server.util.ValidatorUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.util.DigestUtils;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@RestController(&quot;webMemberController&quot;)@RequestMapping(&quot;/web/member&quot;)public class MemberController &#123;    private static final Logger LOG = LoggerFactory.getLogger(MemberController.class);    public static final String BUSINESS_NAME = &quot;会员&quot;;    @Resource    private MemberService memberService;    /**     * 保存，id有值时更新，无值时新增     */    @PostMapping(&quot;/register&quot;)    public ResponseDto register(@RequestBody MemberDto memberDto) &#123;        // 保存校验        ValidatorUtil.require(memberDto.getMobile(), &quot;手机号&quot;);        ValidatorUtil.length(memberDto.getMobile(), &quot;手机号&quot;, 11, 11);        ValidatorUtil.require(memberDto.getPassword(), &quot;密码&quot;);        ValidatorUtil.length(memberDto.getName(), &quot;昵称&quot;, 1, 50);        ValidatorUtil.length(memberDto.getPhoto(), &quot;头像url&quot;, 1, 200);        // 密码加密        memberDto.setPassword(DigestUtils.md5DigestAsHex(memberDto.getPassword().getBytes()));        ResponseDto responseDto = new ResponseDto();        memberService.save(memberDto);        responseDto.setContent(memberDto);        return responseDto;    &#125;&#125;\n\n\n然后我们修改MemberService.java里面的insert方法\n\n/** * 插入 */private void insert(Member member)&#123;            Date now = new Date();            member.setId(UuidUtil.getShortUuid());            //下面这句是新增得            member.setRegisterTime(now);            memberMapper.insert(member);&#125;\n\n\n因为前端用到了加密，所以我们把md5.js拷过来\n\nvar KEY = &quot;!@#QWERT&quot;;/* * Configurable variables. You may need to tweak these to be compatible with * the server-side, but the defaults work in most cases. */var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      *//* * These are the functions you&#x27;ll usually want to call * They take string arguments and return either hex or base-64 encoded strings */function hex_md5(s)&#123; return binl2hex(core_md5(str2binl(s), s.length * chrsz));&#125;function b64_md5(s)&#123; return binl2b64(core_md5(str2binl(s), s.length * chrsz));&#125;function str_md5(s)&#123; return binl2str(core_md5(str2binl(s), s.length * chrsz));&#125;function hex_hmac_md5(key, data) &#123; return binl2hex(core_hmac_md5(key, data)); &#125;function b64_hmac_md5(key, data) &#123; return binl2b64(core_hmac_md5(key, data)); &#125;function str_hmac_md5(key, data) &#123; return binl2str(core_hmac_md5(key, data)); &#125;/* * Perform a simple self-test to see if the VM is working */function md5_vm_test()&#123;  return hex_md5(&quot;abc&quot;) == &quot;900150983cd24fb0d6963f7d28e17f72&quot;;&#125;/* * Calculate the MD5 of an array of little-endian words, and a bit length */function core_md5(x, len)&#123;  /* append padding */  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; ((len) % 32);  x[(((len + 64) &gt;&gt;&gt; 9) &lt;&lt; 4) + 14] = len;  var a =  1732584193;  var b = -271733879;  var c = -1732584194;  var d =  271733878;  for(var i = 0; i &lt; x.length; i += 16)  &#123;    var olda = a;    var oldb = b;    var oldc = c;    var oldd = d;    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);    a = safe_add(a, olda);    b = safe_add(b, oldb);    c = safe_add(c, oldc);    d = safe_add(d, oldd);  &#125;  return Array(a, b, c, d);&#125;/* * These functions implement the four basic operations the algorithm uses. */function md5_cmn(q, a, b, x, s, t)&#123;  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);&#125;function md5_ff(a, b, c, d, x, s, t)&#123;  return md5_cmn((b &amp; c) | ((~b) &amp; d), a, b, x, s, t);&#125;function md5_gg(a, b, c, d, x, s, t)&#123;  return md5_cmn((b &amp; d) | (c &amp; (~d)), a, b, x, s, t);&#125;function md5_hh(a, b, c, d, x, s, t)&#123;  return md5_cmn(b ^ c ^ d, a, b, x, s, t);&#125;function md5_ii(a, b, c, d, x, s, t)&#123;  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);&#125;/* * Calculate the HMAC-MD5, of a key and some data */function core_hmac_md5(key, data)&#123;  var bkey = str2binl(key);  if(bkey.length &gt; 16) bkey = core_md5(bkey, key.length * chrsz);  var ipad = Array(16), opad = Array(16);  for(var i = 0; i &lt; 16; i++)  &#123;    ipad[i] = bkey[i] ^ 0x36363636;    opad[i] = bkey[i] ^ 0x5C5C5C5C;  &#125;  var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);  return core_md5(opad.concat(hash), 512 + 128);&#125;/* * Add integers, wrapping at 2^32. This uses 16-bit operations internally * to work around bugs in some JS interpreters. */function safe_add(x, y)&#123;  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);&#125;/* * Bitwise rotate a 32-bit number to the left. */function bit_rol(num, cnt)&#123;  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));&#125;/* * Convert a string to an array of little-endian words * If chrsz is ASCII, characters &gt;255 have their hi-byte silently ignored. */function str2binl(str)&#123;  var bin = Array();  var mask = (1 &lt;&lt; chrsz) - 1;  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (i%32);  return bin;&#125;/* * Convert an array of little-endian words to a string */function binl2str(bin)&#123;  var str = &quot;&quot;;  var mask = (1 &lt;&lt; chrsz) - 1;  for(var i = 0; i &lt; bin.length * 32; i += chrsz)    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (i % 32)) &amp; mask);  return str;&#125;/* * Convert an array of little-endian words to a hex string. */function binl2hex(binarray)&#123;  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;  var str = &quot;&quot;;  for(var i = 0; i &lt; binarray.length * 4; i++)  &#123;    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((i%4)*8+4)) &amp; 0xF) +           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((i%4)*8  )) &amp; 0xF);  &#125;  return str;&#125;/* * Convert an array of little-endian words to a base-64 string */function binl2b64(binarray)&#123;  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;  var str = &quot;&quot;;  for(var i = 0; i &lt; binarray.length * 4; i += 3)  &#123;    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * ( i   %4)) &amp; 0xFF) &lt;&lt; 16)                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * ((i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * ((i+2)%4)) &amp; 0xFF);    for(var j = 0; j &lt; 4; j++)    &#123;      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);    &#125;  &#125;  return str;&#125;\n\n\n在index.html中引入md5\n\n&lt;!--  md5工具类--&gt;&lt;script src=&quot;&lt;%= BASE_URL %&gt;static/js/md5.js&quot;&gt;&lt;/script&gt;\n\n\n我们新建一个组件login.vue，用于注册登录\n\n&lt;template&gt;  &lt;div id=&quot;login-modal&quot; class=&quot;modal fade&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot;&gt;    &lt;div class=&quot;modal-dialog modal-login&quot; role=&quot;document&quot;&gt;      &lt;div class=&quot;modal-content&quot;&gt;        &lt;div class=&quot;modal-body&quot;&gt;          &lt;div class=&quot;register-div&quot; &gt;            &lt;h3&gt;注&amp;nbsp;&amp;nbsp;册&lt;/h3&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;input id=&quot;register-mobile&quot; v-model=&quot;memberRegister.mobile&quot;                     class=&quot;form-control&quot; placeholder=&quot;手机号&quot;&gt;            &lt;/div&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;div class=&quot;input-group&quot;&gt;                &lt;input id=&quot;register-mobile-code&quot; class=&quot;form-control&quot;                       placeholder=&quot;手机验证码&quot; v-model=&quot;memberRegister.code&quot;&gt;                &lt;div class=&quot;input-group-append&quot;&gt;                  &lt;button class=&quot;btn btn-outline-secondary&quot; id=&quot;register-send-code-btn&quot;                          v-on:click=&quot;sendSmsForRegister()&quot;&gt;发送验证码                  &lt;/button&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;input id=&quot;register-name&quot; v-model=&quot;memberRegister.name&quot;                     class=&quot;form-control&quot; placeholder=&quot;昵称&quot;&gt;            &lt;/div&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;input id=&quot;register-password&quot; v-model=&quot;memberRegister.passwordOriginal&quot;                     class=&quot;form-control&quot; placeholder=&quot;密码&quot; type=&quot;password&quot;&gt;            &lt;/div&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;input id=&quot;register-confirm-password&quot; v-model=&quot;memberRegister.confirm&quot;                     class=&quot;form-control&quot; placeholder=&quot;确认密码&quot;                     name=&quot;memberRegisterConfirm&quot; type=&quot;password&quot;&gt;            &lt;/div&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;button class=&quot;btn btn-primary btn-block submit-button&quot; v-on:click=&quot;register()&quot;&gt;                注&amp;nbsp;&amp;nbsp;册              &lt;/button&gt;            &lt;/div&gt;            &lt;div class=&quot;form-group to-login-div&quot;&gt;              &lt;a href=&quot;javascript:;&quot; &gt;我要登录&lt;/a&gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;&lt;!-- /.modal-content --&gt;    &lt;/div&gt;&lt;!-- /.modal-dialog --&gt;  &lt;/div&gt;&lt;!-- /.modal --&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;the-login&#x27;,  data: function () &#123;    return &#123;      memberRegister: &#123;&#125;,      remember: true, // 记住密码      imageCodeToken: &quot;&quot;,    &#125;  &#125;,  mounted() &#123;    let _this = this;  &#125;,  methods: &#123;    /**     * 打开登录注册窗口     */    openLoginModal() &#123;      let _this = this;      $(&quot;#login-modal&quot;).modal(&quot;show&quot;);    &#125;,    register() &#123;      let _this = this;      _this.memberRegister.password = hex_md5(_this.memberRegister.passwordOriginal + KEY);      // 调服务端注册接口      _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/business/web/member/register&#x27;, _this.memberRegister).then((response) =&gt; &#123;        let resp = response.data;        if (resp.success) &#123;          Toast.success(&quot;注册成功&quot;);        &#125; else &#123;          Toast.warning(resp.message);        &#125;      &#125;)    &#125;,  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;/* 登录框 */.login-div .input-group-addon &#123;  padding: 0;  border: 0;&#125;#login-modal h3 &#123;  text-align: center;  margin-bottom: 20px;&#125;#login-modal .modal-login &#123;  max-width: 400px;&#125;#login-modal input:not(.remember) &#123;  height: 45px;  font-size: 16px;&#125;#login-modal .submit-button &#123;  height: 50px;  font-size: 20px;&#125;#login-modal .to-login-div &#123;  text-align: center;&#125;&lt;/style&gt;\n\n\n然后我们在the-header中使用\n\n &lt;span class=&quot;text-white&quot;&gt;欢迎：&lt;/span&gt; //新增一个click时间  &lt;button v-on:click=&quot;openLoginModal()&quot; class=&quot;btn btn-outline-light my-2 my-sm-0&quot; type=&quot;submit&quot;&gt;登录/注册&lt;/button&gt;    &lt;/div&gt;    &lt;/div&gt;  &lt;/nav&gt;  //在这里使用组件  &lt;the-login ref=&quot;loginComponent&quot;&gt;&lt;/the-login&gt;&lt;/header&gt;//导入组件import TheLogin from &quot;./login&quot;;components: &#123;TheLogin&#125;,methods:&#123;    /**    * 打开登录注册窗口    */\topenLoginModal() &#123;        let _this = this;        _this.$refs.loginComponent.openLoginModal();\t\t&#125;,\t\t&#125;\n\n13-10 增加登录与退出登录功能登录、注册、忘记密码之间的切换\n1.会员登录注册功能开发·增加登录框和忘记密码框·并实现登录框、注册框·忘记密码框切换，默认显示登录框\n\n\n我们修改login.vue\n\n////////////////////////////////////////////////////////////////////////////增加登录&lt;div class=&quot;login-div&quot; v-show=&quot;MODAL_STATUS === STATUS_LOGIN&quot;&gt;  &lt;h3&gt;登&amp;nbsp;&amp;nbsp;录&lt;/h3&gt;  &lt;div class=&quot;form-group&quot;&gt;    &lt;input v-model=&quot;member.mobile&quot; class=&quot;form-control&quot; placeholder=&quot;手机号&quot;&gt;  &lt;/div&gt;  &lt;div class=&quot;form-group&quot;&gt;    &lt;input class=&quot;form-control&quot; type=&quot;password&quot; placeholder=&quot;密码&quot; v-model=&quot;member.password&quot;&gt;  &lt;/div&gt;  &lt;div class=&quot;form-group&quot;&gt;    &lt;div class=&quot;input-group&quot;&gt;      &lt;input id=&quot;image-code-input&quot; class=&quot;form-control&quot; type=&quot;text&quot; placeholder=&quot;验证码&quot;             v-model=&quot;member.imageCode&quot;&gt;      &lt;div class=&quot;input-group-addon&quot; id=&quot;image-code-addon&quot;&gt;        &lt;img id=&quot;image-code&quot; alt=&quot;验证码&quot; v-on:click=&quot;loadImageCode()&quot;/&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;form-group&quot;&gt;    &lt;button  class=&quot;btn btn-primary btn-block submit-button&quot;&gt;      登&amp;nbsp;&amp;nbsp;录    &lt;/button&gt;  &lt;/div&gt;  &lt;div class=&quot;form-group&quot;&gt;    &lt;div class=&quot;checkbox&quot;&gt;      &lt;label&gt;        &lt;input type=&quot;checkbox&quot; class=&quot;remember&quot; v-model=&quot;remember&quot;&gt; 记住密码      &lt;/label&gt;      &lt;div class=&quot;pull-right&quot;&gt;        &lt;a href=&quot;javascript:;&quot; v-on:click=&quot;toForgetDiv()&quot;&gt;忘记密码&lt;/a&gt;&amp;nbsp;        &lt;a href=&quot;javascript:;&quot; v-on:click=&quot;toRegisterDiv()&quot;&gt;我要注册&lt;/a&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;form-group to-register-div&quot;&gt;  &lt;/div&gt;&lt;/div&gt;//////////////////////////////////////////////////修改下注册的div和我要登陆那增加事件&lt;div class=&quot;register-div&quot; v-show=&quot;MODAL_STATUS === STATUS_REGISTER&quot; &gt;&lt;div class=&quot;form-group to-login-div&quot;&gt;    &lt;a href=&quot;javascript:;&quot; v-on:click=&quot;toLoginDiv()&quot;&gt;我要登录&lt;/a&gt;&lt;/div&gt;////////////////////////////////////////////////////////////////增加忘记密码          &lt;div class=&quot;forget-div&quot; v-show=&quot;MODAL_STATUS === STATUS_FORGET&quot;&gt;            &lt;h3&gt;忘记密码&lt;/h3&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;input id=&quot;forget-mobile&quot; v-model=&quot;memberForget.mobile&quot;                     class=&quot;form-control&quot; placeholder=&quot;手机号&quot;&gt;            &lt;/div&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;div class=&quot;input-group&quot;&gt;                &lt;input id=&quot;forget-mobile-code&quot; class=&quot;form-control&quot;                       placeholder=&quot;手机验证码&quot; v-model=&quot;memberForget.smsCode&quot;&gt;                &lt;div class=&quot;input-group-append&quot;&gt;                  &lt;button class=&quot;btn btn-outline-secondary&quot; id=&quot;forget-send-code-btn&quot;&gt;                    发送验证码                  &lt;/button&gt;                &lt;/div&gt;              &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;input id=&quot;forget-password&quot; v-model=&quot;memberForget.passwordOriginal&quot;                     class=&quot;form-control&quot; placeholder=&quot;密码&quot; type=&quot;password&quot;&gt;            &lt;/div&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;input id=&quot;forget-confirm-password&quot; v-model=&quot;memberForget.confirm&quot;                     class=&quot;form-control&quot; placeholder=&quot;确认密码&quot; type=&quot;password&quot;&gt;            &lt;/div&gt;            &lt;div class=&quot;form-group&quot;&gt;              &lt;button  class=&quot;btn btn-primary btn-block submit-button&quot;&gt;                重&amp;nbsp;&amp;nbsp;置              &lt;/button&gt;            &lt;/div&gt;            &lt;div class=&quot;form-group to-login-div&quot;&gt;              &lt;a href=&quot;javascript:;&quot; v-on:click=&quot;toLoginDiv()&quot;&gt;我要登录&lt;/a&gt;            &lt;/div&gt;          &lt;/div&gt;///////////////////////////////////////////////////data中增加    data: function () &#123;    return &#123;      // 模态框内容切换：登录、注册、忘记密码      STATUS_LOGIN: &quot;STATUS_LOGIN&quot;,      STATUS_REGISTER: &quot;STATUS_REGISTER&quot;,      STATUS_FORGET: &quot;STATUS_FORGET&quot;,      MODAL_STATUS: &quot;&quot;,      member: &#123;&#125;,      memberForget: &#123;&#125;,    &#125;    &#125;//////////////////////////////////////////////////////////初始化时增加mounted() &#123;    let _this = this;    _this.toLoginDiv();  &#125;, //////////////////////////---------------登录框、注册框、忘记密码框切换-----------------    toLoginDiv() &#123;      let _this = this;      _this.MODAL_STATUS = _this.STATUS_LOGIN    &#125;,    toRegisterDiv() &#123;      let _this = this;      _this.MODAL_STATUS = _this.STATUS_REGISTER    &#125;,    toForgetDiv() &#123;      let _this = this;      _this.MODAL_STATUS = _this.STATUS_FORGET    &#125;,\n\n增加登录验证码功能\n1.会员登录注册功能开发·登录框显示验证码\n\n\n在business&#x2F;web下拷贝复制过来的KaptchaController\n\npackage com.course.business.controller.web;import com.google.code.kaptcha.impl.DefaultKaptcha;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import javax.imageio.ImageIO;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.image.BufferedImage;import java.io.ByteArrayOutputStream;import java.util.concurrent.TimeUnit;@RestController@RequestMapping(&quot;/web/kaptcha&quot;)public class KaptchaController &#123;    @Qualifier(&quot;getDefaultKaptcha&quot;)    @Autowired    DefaultKaptcha defaultKaptcha;    @Resource    public RedisTemplate redisTemplate;    @GetMapping(&quot;/image-code/&#123;imageCodeToken&#125;&quot;)    public void imageCode(@PathVariable(value = &quot;imageCodeToken&quot;) String imageCodeToken, HttpServletRequest request, HttpServletResponse httpServletResponse) throws Exception&#123;        ByteArrayOutputStream jpegOutputStream = new ByteArrayOutputStream();        try &#123;            // 生成验证码字符串            String createText = defaultKaptcha.createText();            // 将生成的验证码放入会话缓存中，后续验证的时候用到//             request.getSession().setAttribute(imageCodeToken, createText);            //将生成的验证码放入redis缓存中后续验证的时候用到            redisTemplate.opsForValue().set(imageCodeToken,createText,300, TimeUnit.SECONDS);            // 使用验证码字符串生成验证码图片            BufferedImage challenge = defaultKaptcha.createImage(createText);            ImageIO.write(challenge, &quot;jpg&quot;, jpegOutputStream);        &#125; catch (IllegalArgumentException e) &#123;            httpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND);            return;        &#125;        // 定义response输出类型为image/jpeg类型，使用response输出流输出图片的byte数组        byte[] captchaChallengeAsJpeg = jpegOutputStream.toByteArray();        httpServletResponse.setHeader(&quot;Cache-Control&quot;, &quot;no-store&quot;);        httpServletResponse.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);        httpServletResponse.setDateHeader(&quot;Expires&quot;, 0);        httpServletResponse.setContentType(&quot;image/jpeg&quot;);        ServletOutputStream responseOutputStream = httpServletResponse.getOutputStream();        responseOutputStream.write(captchaChallengeAsJpeg);        responseOutputStream.flush();        responseOutputStream.close();    &#125;&#125;\n\n\n接下来修改login.vue\n\n//////////////////////////////////////////////////////////////////////////增加刷新验证码功能toLoginDiv() &#123;  //显示登录框时就刷新一次验证码  _this.loadImageCode();&#125;,///////////////////////////////////////////////////////////////////////////  /**     * 加载图形验证码     */    loadImageCode: function () &#123;      let _this = this;      _this.imageCodeToken = Tool.uuid(8);      $(&#x27;#image-code&#x27;).attr(&#x27;src&#x27;, process.env.VUE_APP_SERVER + &#x27;/business/web/kaptcha/image-code/&#x27; + _this.imageCodeToken);    &#125;,\n\n2.会员登录注册功能开发，增加登录功能，包含图片验证码，将控台用户登录功能相关代码拷贝到会员登录，并将user替换成member\n\n\n直接将admin的local-storage和session-storage拷贝到web。记得引入\n\nLOCAL_KEY_REMEMBER_MEMBER = &quot;LOCAL_KEY_REMEMBER_MEMBER&quot;; // 记住我LocalStorage = &#123;    get: function (key) &#123;        let v = localStorage.getItem(key);        if (v &amp;&amp; typeof(v) !== &quot;undefined&quot; &amp;&amp; v !== &quot;undefined&quot;) &#123;            return JSON.parse(v);        &#125;    &#125;,    set: function (key, data) &#123;        localStorage.setItem(key, JSON.stringify(data));    &#125;,    remove: function (key) &#123;        localStorage.removeItem(key);    &#125;,    clearAll: function () &#123;        localStorage.clear();    &#125;&#125;;\n\nSESSION_KEY_LOGIN_MEMBER = &quot;SESSION_KEY_LOGIN_MEMBER&quot;; // 登录信息SessionStorage = &#123;    get: function (key) &#123;        let v = sessionStorage.getItem(key);        if (v &amp;&amp; typeof(v) !== &quot;undefined&quot; &amp;&amp; v !== &quot;undefined&quot;) &#123;            return JSON.parse(v);        &#125;    &#125;,    set: function (key, data) &#123;        sessionStorage.setItem(key, JSON.stringify(data));    &#125;,    remove: function (key) &#123;        sessionStorage.removeItem(key);    &#125;,    clearAll: function () &#123;        sessionStorage.clear();    &#125;&#125;;\n\n\n接下来修改tool.js，将User改为Member\n\n/** * 保存登录信息 * @param loginUser */setLoginMember:function (loginMember)&#123;    SessionStorage.set(SESSION_KEY_LOGIN_MEMBER,loginMember);&#125;,/** * 获取登录信息 * @param loginUser * @returns &#123;any|&#123;&#125;&#125; */getLoginMember:function ()&#123;    return SessionStorage.get(SESSION_KEY_LOGIN_MEMBER) ||&#123;&#125;;&#125;,\n\n\n然后修改index.vue\n\n//增加点击事件&lt;div class=&quot;form-group&quot;&gt;  &lt;button v-on:click=&quot;login()&quot; class=&quot;btn btn-primary btn-block submit-button&quot;&gt;    登&amp;nbsp;&amp;nbsp;录  &lt;/button&gt;//增加方法//---------------登录框-----------------    login () &#123;      let _this = this;      // 如果密码是从缓存带出来的，则不需要重新加密      let md5 = hex_md5(_this.member.password);      let rememberMember = LocalStorage.get(LOCAL_KEY_REMEMBER_MEMBER) || &#123;&#125;;      if (md5 !== rememberMember.md5) &#123;        _this.member.password = hex_md5(_this.member.password + KEY);      &#125;      _this.member.imageCodeToken = _this.imageCodeToken;      _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/business/web/member/login&#x27;, _this.member).then((response)=&gt;&#123;        let resp = response.data;        if (resp.success) &#123;          console.log(&quot;登录成功：&quot;, resp.content);          let loginMember = resp.content;          Tool.setLoginMember(resp.content);          // 判断“记住我”          if (_this.remember) &#123;            // 如果勾选记住我，则将用户名密码保存到本地缓存            // 这里保存密码密文，并保存密文md5，用于检测密码是否被重新输入过            let md5 = hex_md5(_this.member.password);            LocalStorage.set(LOCAL_KEY_REMEMBER_MEMBER, &#123;              mobile: loginMember.mobile,              password: _this.member.password,              md5: md5            &#125;);          &#125; else &#123;            // 没有勾选“记住我”时，要把本地缓存清空，否则下次显示登录框时会自动显示用户名密码            LocalStorage.set(LOCAL_KEY_REMEMBER_MEMBER, null);          &#125;          // 登录成功 TODO        &#125; else &#123;          Toast.warning(resp.message);          _this.member.password = &quot;&quot;;          _this.loadImageCode();        &#125;      &#125;);    &#125;,\n\n\n接下来我们看后端，修改business.controller的ControllerExceptionHandler增加统一业务异常处理\n\n@ExceptionHandler(value = BusinessException.class)@ResponseBodypublic ResponseDto businessExceptionHandler(BusinessException e) &#123;    ResponseDto responseDto = new ResponseDto();    responseDto.setSuccess(false);    LOG.error(&quot;业务异常：&#123;&#125;&quot;, e.getCode().getDesc());    responseDto.setMessage(e.getCode().getDesc());    return responseDto;&#125;\n\n\n然后我们修改business.controller.web.MemberController\n\n////////////////////////////////////////////////////注入@Resource(name = &quot;redisTemplate&quot;)private RedisTemplate redisTemplate;///////////////////////////////////////////////////////**     * 登录     */    @PostMapping(&quot;/login&quot;)    public ResponseDto login(@RequestBody MemberDto memberDto) &#123;        LOG.info(&quot;用户登录开始&quot;);        memberDto.setPassword(DigestUtils.md5DigestAsHex(memberDto.getPassword().getBytes()));        ResponseDto responseDto = new ResponseDto();        // 根据验证码token去获取缓存中的验证码，和用户输入的验证码是否一致        String imageCode = (String) redisTemplate.opsForValue().get(memberDto.getImageCodeToken());        LOG.info(&quot;从redis中获取到的验证码：&#123;&#125;&quot;, imageCode);        if (StringUtils.isEmpty(imageCode)) &#123;            responseDto.setSuccess(false);            responseDto.setMessage(&quot;验证码已过期&quot;);            LOG.info(&quot;用户登录失败，验证码已过期&quot;);            return responseDto;        &#125;        if (!imageCode.toLowerCase().equals(memberDto.getImageCode().toLowerCase())) &#123;            responseDto.setSuccess(false);            responseDto.setMessage(&quot;验证码不对&quot;);            LOG.info(&quot;用户登录失败，验证码不对&quot;);            return responseDto;        &#125; else &#123;            // 验证通过后，移除验证码            redisTemplate.delete(memberDto.getImageCodeToken());        &#125;        LoginMemberDto loginMemberDto = memberService.login(memberDto);        String token = UuidUtil.getShortUuid();        loginMemberDto.setToken(token);        redisTemplate.opsForValue().set(token, JSON.toJSONString(loginMemberDto), 3600, TimeUnit.SECONDS);        responseDto.setContent(loginMemberDto);        return responseDto;    &#125;\n\n\n然后我们在server.dto增加LoginMemberDto。控台保存登录用户信息用的是LoginUserDto，网站保存会员信息用的是LoginMemberDto\n\npackage com.course.server.dto;public class LoginMemberDto &#123;    private String id;    private String mobile;    private String name;    private String token;    private String photo;    public String getId() &#123;        return id;    &#125;    public void setId(String id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getMobile() &#123;        return mobile;    &#125;    public void setMobile(String mobile) &#123;        this.mobile = mobile;    &#125;    public String getToken() &#123;        return token;    &#125;    public void setToken(String token) &#123;        this.token = token;    &#125;    public String getPhoto() &#123;        return photo;    &#125;    public void setPhoto(String photo) &#123;        this.photo = photo;    &#125;    @Override    public String toString() &#123;        final StringBuffer sb = new StringBuffer(&quot;LoginMemberDto&#123;&quot;);        sb.append(&quot;id=&#x27;&quot;).append(id).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, mobile=&#x27;&quot;).append(mobile).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, token=&#x27;&quot;).append(token).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, photo=&#x27;&quot;).append(photo).append(&#x27;\\&#x27;&#x27;);        sb.append(&#x27;&#125;&#x27;);        return sb.toString();    &#125;&#125;\n\n\n接下来给server.dto的MemberDto增加两个字段\n\n/** * 图片验证码 */private String imageCode;/** * 图片验证码token */private String imageCodeToken;\n\n\n然后我们修改server.exception中的BusinessExceptionCode\n\n//两个字段LOGIN_USER_ERROR(&quot;用户名或密码错误&quot;),LOGIN_MEMBER_ERROR(&quot;手机号不存在或密码错误&quot;),\n\n\n修改MemberService，登录的时候要验证这个手机号是不是存在；控台验证时需要验证登录名是否存在，原理一样\n\n/** * 按手机号查找 * @param mobile * @return */public Member selectByMobile(String mobile) &#123;    if (StringUtils.isEmpty(mobile)) &#123;        return null;    &#125;    MemberExample example = new MemberExample();    example.createCriteria().andMobileEqualTo(mobile);    List&lt;Member&gt; memberList = memberMapper.selectByExample(example);    if (memberList == null || memberList.size() == 0) &#123;        return null;    &#125; else &#123;        return memberList.get(0);    &#125;&#125;/** * 登录 * @param memberDto */public LoginMemberDto login(MemberDto memberDto) &#123;    Member member = selectByMobile(memberDto.getMobile());    if (member == null) &#123;        LOG.info(&quot;手机号不存在, &#123;&#125;&quot;, memberDto.getMobile());        throw new BusinessException(BusinessExceptionCode.LOGIN_MEMBER_ERROR);    &#125; else &#123;        if (member.getPassword().equals(memberDto.getPassword())) &#123;            // 登录成功            LoginMemberDto loginMemberDto = CopyUtil.copy(member, LoginMemberDto.class);            return loginMemberDto;        &#125; else &#123;            LOG.info(&quot;密码不对, 输入密码：&#123;&#125;, 数据库密码：&#123;&#125;&quot;, memberDto.getPassword(), member.getPassword());            throw new BusinessException(BusinessExceptionCode.LOGIN_MEMBER_ERROR);        &#125;    &#125;&#125;\n\n\n修改UserService，因为把之前的BusinessExceptionCode中的字段修改了，所以也要把这里的字段也修改\n\n我们还给system.controller的ControllerExceptionHandler增加校验异常\n\n\n@ExceptionHandler(value = ValidatorException.class)@ResponseBodypublic ResponseDto validatorExceptionHandler(ValidatorException e) &#123;    ResponseDto responseDto = new ResponseDto();    responseDto.setSuccess(false);    LOG.warn(e.getMessage());    responseDto.setMessage(&quot;请求参数异常！&quot;);    return responseDto;&#125;\n\n2.会员登录注册功能开发，完善【记住我】功能，会员登录名是mobile，不是loginName\n\n\n修改login.vue\n\n//toLoginDiv中增加下面代码toLoginDiv() &#123;  // 从缓存中获取记住的用户名密码，如果获取不到，说明上一次没有勾选“记住我”  let rememberMember = LocalStorage.get(LOCAL_KEY_REMEMBER_MEMBER);  if (rememberMember) &#123;    _this.member = rememberMember;  &#125; &#125;\n\n3.会员登录注册功能开发，登录成功后，头部导航显示会员昵称\n\n\n首先修改the-header.vue\n\n//显示昵称&lt;span v-show=&quot;loginMember.id&quot; class=&quot;text-white pr-3&quot;&gt;您好：&#123;&#123;loginMember.name&#125;&#125;&lt;/span&gt;///////////////////////////////////////////////////增加 data: function () &#123;      return &#123;        loginMember: &#123;&#125;      &#125;    &#125;,    mounted() &#123;      let _this = this;      _this.loginMember = Tool.getLoginMember();    &#125;,//设置方法 setLoginMember(loginMember) &#123;        let _this = this;        _this.loginMember = loginMember;      &#125;,\n\n\n接下来使用setLoginMember方法在login.vue\n\n// 登录成功，在子组件里调用父组件的xxx方法，可以使用this.$parent.xxx_this.$parent.setLoginMember(loginMember);$(&quot;#login-modal&quot;).modal(&quot;hide&quot;);\n\n4.会员登录注册功能开发，增加退出登录功能\n\n\n我们先给business.controller.web的MemberController增加退出登录方法\n\n/** * 退出登录 */@GetMapping(&quot;/logout/&#123;token&#125;&quot;)public ResponseDto logout(@PathVariable String token) &#123;    ResponseDto responseDto = new ResponseDto();    redisTemplate.delete(token);    LOG.info(&quot;从redis中删除token:&#123;&#125;&quot;, token);    return responseDto;&#125;\n\n\n然后我们在修改the-header\n\n//退出登录和登录是互斥的&lt;span v-show=&quot;loginMember.id&quot; class=&quot;text-white pr-3&quot;&gt;您好：&#123;&#123;loginMember.name&#125;&#125;&lt;/span&gt;&lt;button v-show=&quot;loginMember.id&quot; v-on:click=&quot;logout()&quot; class=&quot;btn btn-outline-light my-2 my-sm-0&quot;&gt;退出登录&lt;/button&gt;&lt;button v-show=&quot;!loginMember.id&quot; v-on:click=&quot;openLoginModal()&quot; class=&quot;btn btn-outline-light my-2 my-sm-0&quot;&gt;登录/注册&lt;/button&gt;//增加退出方法logout () &#123;        let _this = this;        _this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/business/web/member/logout/&#x27; + _this.loginMember.token).then((response)=&gt;&#123;          let resp = response.data;          if (resp.success) &#123;            Tool.setLoginMember(null);            _this.loginMember = &#123;&#125;;            Toast.success(&quot;退出登录成功&quot;);            _this.$router.push(&quot;/&quot;);          &#125; else &#123;            Toast.warning(resp.message);          &#125;        &#125;);      &#125;,\n\n13-11 增加发送短信验证码功能1.会员登录注册功能开发，增加短信管理，生成代码后需要配置资源权限\n\n\n首先增加sql\n\n# 短信验证码drop table if exists `sms`;create table `sms`(                       `id` char(8) not null default &#x27;&#x27; comment &#x27;id&#x27;,                       `mobile` varchar(50) not null comment &#x27;手机号&#x27;,                       `code` char(6) not null comment &#x27;验证码&#x27;,                       `use` char(1)  not null comment &#x27;用途|枚举[SmsUseEnum]:REGISTER(&quot;R&quot;,&quot;注册&quot;),FORGET(&quot;F&quot;,&quot;忘记密码&quot;)&#x27;,                       `at` datetime(3)  comment &#x27;生成时间&#x27;,                       `status` char(1)  not null comment &#x27;状态|枚举[SmsStatusEnum]:USED(&quot;U&quot;,&quot;已使用&quot;),NOT_USED(&quot;N&quot;,&quot;未使用&quot;)&#x27;,                       primary key (`id`))engine =innodb default charset=utf8mb4 comment=&#x27;短信验证码&#x27;;\n\n\n然后我们给server.enums增加两个枚举SmsUseEnum和SmsStatusEnum\n\npackage com.course.server.enums;public enum SmsUseEnum &#123;    REGISTER(&quot;R&quot;, &quot;注册&quot;),    FORGET(&quot;F&quot;, &quot;忘记密码&quot;);    private String code;    private String desc;    SmsUseEnum(String code, String desc) &#123;        this.code = code;        this.desc = desc;    &#125;    public String getCode() &#123;        return code;    &#125;    public void setCode(String code) &#123;        this.code = code;    &#125;    public void setDesc(String desc) &#123;        this.desc = desc;    &#125;    public String getDesc() &#123;        return desc;    &#125;&#125;\n\npackage com.course.server.enums;public enum SmsStatusEnum &#123;    USED(&quot;U&quot;, &quot;已使用&quot;),    NOT_USED(&quot;N&quot;, &quot;未使用&quot;);    private String code;    private String desc;    SmsStatusEnum(String code, String desc) &#123;        this.code = code;        this.desc = desc;    &#125;    public String getCode() &#123;        return code;    &#125;    public void setCode(String code) &#123;        this.code = code;    &#125;    public void setDesc(String desc) &#123;        this.desc = desc;    &#125;    public String getDesc() &#123;        return desc;    &#125;&#125;\n\n\n然后我们经过各种代码生成器，对了还要改下EnumGenerator到admin，在增加以下代码\n\ntoJson(SmsUseEnum.class, bufferObject, bufferArray);toJson(SmsStatusEnum.class, bufferObject, bufferArray);\n\n\n然后我们在admin.vue增加菜单\n\n&lt;/li&gt; &lt;li v-show=&quot;hasResource(&#x27;0205&#x27;)&quot; class=&quot;&quot; id=&quot;business-sms-sidebar&quot;&gt;  &lt;router-link to=&quot;/business/sms&quot;&gt;    &lt;i class=&quot;menu-icon fa fa-caret-right&quot;&gt;&lt;/i&gt;    短信管理  &lt;/router-link&gt;  &lt;b class=&quot;arrow&quot;&gt;&lt;/b&gt;&lt;/li&gt;\n\n\n接下来增加路由\n\n,&#123;    path: &quot;business/sms&quot;,    name:&quot;business/sms&quot;,    component: Sms,&#125;\n\n\n当然resource.json也要加资源\n\n,&#123;  &quot;id&quot;:&quot;0205&quot;,&quot;name&quot;:&quot;短信管理&quot;,&quot;page&quot;:&quot;business/sms&quot;,  &quot;children&quot;:[    &#123;&quot;id&quot;:&quot;020501&quot;,&quot;name&quot;:&quot;增删改查&quot;,&quot;request&quot;:[&quot;/business/admin/sms&quot;]&#125;  ]&#125;\n\n2.会员登录注册功能开发，短信管理只能查看\n\n\n就是前端后端删删删\n\n增加发送验证码功能\n1.会员登录注册功能开发，增加发送短信验证码功能，同手机号同操作1分钟内不能重复发送短信\n\n\n一分钟内发送一次注册验证码和忘记密码验证码，是可以的。但是发两次注册验证码或者忘记密码验证码，是不可以的。\n\n我们首先给business.controller.web新建一个SmsController\n\n\npackage com.course.business.controller.web;import com.course.server.dto.ResponseDto;import com.course.server.dto.SmsDto;import com.course.server.service.SmsService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@RestController(&quot;webSmsController&quot;)@RequestMapping(&quot;/web/sms&quot;)public class SmsController &#123;    private static final Logger LOG = LoggerFactory.getLogger(SmsController.class);    public static final String BUSINESS_NAME = &quot;短信验证码&quot;;    @Resource    private SmsService smsService;    @RequestMapping(value = &quot;/send&quot;, method = RequestMethod.POST)    public ResponseDto send(@RequestBody SmsDto smsDto) &#123;        LOG.info(&quot;发送短信请求开始: &#123;&#125;&quot;, smsDto);        ResponseDto responseDto = new ResponseDto();        smsService.sendCode(smsDto);        LOG.info(&quot;发送短信请求结束&quot;);        return responseDto;    &#125;&#125;\n\n\n然后在smsService中增加方法\n\n/** * 发送短信验证码 * 同手机号同操作1分钟内不能重复发送短信 * @param smsDto */public void sendCode(SmsDto smsDto) &#123;    SmsExample example = new SmsExample();    SmsExample.Criteria criteria = example.createCriteria();    // 查找1分钟内有没有同手机号同操作发送记录且没被用过    criteria.andMobileEqualTo(smsDto.getMobile())            .andUseEqualTo(smsDto.getUse())            .andStatusEqualTo(SmsStatusEnum.NOT_USED.getCode())            .andAtGreaterThan(new Date(new Date().getTime() - 1 * 60 * 1000));    List&lt;Sms&gt; smsList = smsMapper.selectByExample(example);    if (smsList == null || smsList.size() == 0) &#123;        saveAndSend(smsDto);    &#125; else &#123;        LOG.warn(&quot;短信请求过于频繁, &#123;&#125;&quot;, smsDto.getMobile());        throw new BusinessException(BusinessExceptionCode.MOBILE_CODE_TOO_FREQUENT);    &#125;&#125;/** * 保存并发送短信验证码 * @param smsDto */private void saveAndSend(SmsDto smsDto) &#123;    // 生成6位数字    String code = String.valueOf((int)(((Math.random() * 9) + 1) * 100000));    smsDto.setAt(new Date());    smsDto.setStatus(SmsStatusEnum.NOT_USED.getCode());    smsDto.setCode(code);    this.save(smsDto);    // TODO 调第三方短信接口发送短信&#125;\n\n\n短信验证码可以接阿里云短信服务，在阿里云控台配置短信模板，然后再代码里配置模板id，再调用阿里云jar包里的发送短信方法就可以了，收费是0.045元&#x2F;条。\n\n给BusinessExceptionCode增加一个\n\n\nMOBILE_CODE_TOO_FREQUENT(&quot;短信请求过于平凡&quot;),\n\n\n最后修改login.vue，增加两个方法\n\n/** * 发送注册短信 */sendSmsForRegister() &#123;  let _this = this;  let sms = &#123;    mobile: _this.memberRegister.mobile,    use: SMS_USE.REGISTER.key  &#125;;      // 调服务端发送短信接口      _this.sendSmsCode(sms);&#125;,/** * 发送短信 */sendSmsCode(sms) &#123;  let _this = this;  // 调服务端发短信接口  _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/business/web/sms/send&#x27;, sms).then((res)=&gt; &#123;    let response = res.data;    if (response.success) &#123;      Toast.success(&quot;短信已发送&quot;);    &#125; else &#123;      Toast.warning(response.message);    &#125;  &#125;)&#125;,\n\n2.会员登录注册功能开发，增加发送短信验证码倒计时功能，可修改countdown参数进行调试\n\n\n点击发送按钮后，按钮变成不可点击，且显示倒计时\n\n修改login.vue\n\n\n//修改参数，增加id参数sendSmsForRegister() &#123;      // 调服务端发送短信接口  _this.sendSmsCode(sms, &quot;register-send-code-btn&quot;);&#125;,/////////////////////////////////////////////////////////////发送成功时调用倒计时 /**     * 发送短信     */    sendSmsCode(sms, btnId) &#123;//增加参数           if (response.success) &#123;          // 开始倒计时          _this.countdown = 60;          _this.setTime(btnId);       &#125;    &#125;,////////////////////////////////////////////////////////////////增加倒计时方法    /**     * 倒计时     * @param btnId     */    setTime(btnId) &#123;      let _this = this;      let btn = $(&quot;#&quot; + btnId);      if (_this.countdown === 0) &#123;        btn.removeAttr(&quot;disabled&quot;);        btn.text(&quot;获取验证码&quot;);        return;      &#125; else &#123;        btn.attr(&quot;disabled&quot;, true);        btn.text(&quot;重新发送(&quot; + _this.countdown + &quot;)&quot;);        _this.countdown--;      &#125;      setTimeout(function () &#123;        _this.setTime(btnId);      &#125;, 1000);    &#125;,\n\n13-12 完善登录注册校验功能增加手机号后端校验\n\n前端就修改login的sendSmsForRegister方法，增加如下：\n\n_this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/business/web/member/is-mobile-exist/&#x27; + _this.memberRegister.mobile).then((res)=&gt;&#123;  let response = res.data;  if (response.success) &#123;    Toast.warning(&quot;手机号已被注册&quot;);  &#125; else &#123;    // 调服务端发送短信接口    _this.sendSmsCode(sms, &quot;register-send-code-btn&quot;);  &#125;&#125;)\n\n\n我们修改business.controller.web的MemberController，增加方法\n\n/** * 校验手机号是否存在 * 存在则success=true，不存在则success=false */@GetMapping(value = &quot;/is-mobile-exist/&#123;mobile&#125;&quot;)public ResponseDto isMobileExist(@PathVariable(value = &quot;mobile&quot;) String mobile) throws BusinessException &#123;    LOG.info(&quot;查询手机号是否存在开始&quot;);    ResponseDto responseDto = new ResponseDto();    MemberDto memberDto = memberService.findByMobile(mobile);    if (memberDto == null) &#123;        responseDto.setSuccess(false);    &#125; else &#123;        responseDto.setSuccess(true);    &#125;    return responseDto;&#125;\n\n\n对应的MemberService也增加方法\n\n/** * 按手机号查找 * @param mobile * @return */public MemberDto findByMobile(String mobile) &#123;    Member member = this.selectByMobile(mobile);    return CopyUtil.copy(member, MemberDto.class);&#125;\n\n增加前端正则校验\n1.会员登录注册功能开发，注册时发送验证码前，增加手机号校验，手机号输入框失去焦点时，检验手机号2.增加正则表达式校验工具类\n\n\nPattern里面都是一些常用的正则表达式校验，再js中加入\n\nPattern = &#123;  // 用户名正则，2到16位（字母，数字，下划线）  loginNamePattern: /^[a-zA-Z0-9_]&#123;6,16&#125;$/,  // 昵称正则，6到20位中文，字母，数字，下划线  namePattern: /^[\\w\\u4e00-\\u9fa5]&#123;2,20&#125;$/,  // 强密码强度正则，最少8位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符  passwordStrongPattern: /^.*(?=.&#123;8,&#125;)(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/,  // 弱密码强度正则，最少6位，包括至少1字母，1个数字  passwordWeakPattern: /^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Za-z]).*$/,  // 手机号正则，11位数字，1开头  mobilePattern: /^1\\d&#123;10&#125;$/,  // 图片验证码正则，4位字母，数字  imageCodePattern: /^[a-zA-Z0-9]&#123;4&#125;$/,  // 手机验证码正则，6位数字  mobileCodePattern: /^[0-9]&#123;6&#125;$/,  validateLoginName: function (str) &#123;    if (Tool.isEmpty(str)) &#123;      return false;    &#125;    return this.loginNamePattern.test(str);  &#125;,  validateName: function (str) &#123;    if (Tool.isEmpty(str)) &#123;      return false;    &#125;    return this.namePattern.test(str);  &#125;,  validatePasswordStrong: function (str) &#123;    if (Tool.isEmpty(str)) &#123;      return false;    &#125;    return this.passwordStrongPattern.test(str);  &#125;,  validatePasswordWeak: function (str) &#123;    if (Tool.isEmpty(str)) &#123;      return false;    &#125;    return this.passwordWeakPattern.test(str);  &#125;,  validateMobile: function (str) &#123;    if (Tool.isEmpty(str)) &#123;      return false;    &#125;    return this.mobilePattern.test(str);  &#125;,  validateImageCode: function (str) &#123;    if (Tool.isEmpty(str)) &#123;      return false;    &#125;    return this.imageCodePattern.test(str);  &#125;,  validateMobileCode: function (str) &#123;    if (Tool.isEmpty(str)) &#123;      return false;    &#125;    return this.mobileCodePattern.test(str);  &#125;&#125;;\n\n\nindex中引入\n\n&lt;!--正则表达式校验--&gt;&lt;script src=&quot;&lt;%= BASE_URL %&gt;static/js/pattern.js&quot;&gt;&lt;/script&gt;\n\n\n最后就是修改login.vue\n\n//增加点击事件，再增加一个v-show。blur事件，当文本框失去焦点会触发blur事件&lt;h3&gt;注&amp;nbsp;&amp;nbsp;册&lt;/h3&gt;&lt;div class=&quot;form-group&quot;&gt;  &lt;input  v-on:blur=&quot;onRegisterMobileBlur()&quot;          v-bind:class=&quot;registerMobileValidateClass&quot;          id=&quot;register-mobile&quot; v-model=&quot;memberRegister.mobile&quot;          class=&quot;form-control&quot; placeholder=&quot;手机号&quot;&gt;  &lt;span v-show=&quot;registerMobileValidate === false&quot; class=&quot;text-danger&quot;&gt;手机号11位数字，且不能重复&lt;/span&gt;&lt;/div&gt;/////////////////////////////////////////////////////////再data中增加组件变量// 注册框显示错误信息registerMobileValidate: null,////////////////////////////////////////////computed，可以根据一个或多个组件变量，计算结果 computed: &#123;    registerMobileValidateClass: function () &#123;      return &#123;        &#x27;border-success&#x27;: this.registerMobileValidate === true,        &#x27;border-danger&#x27;: this.registerMobileValidate === false,      &#125;    &#125;,//再sendSmsForRegister方法中也要校验一次  if (!_this.onRegisterMobileBlur()) &#123;        return false;      &#125;  //-------------------------------- 注册框校验 ----------------------------    onRegisterMobileBlur () &#123;      let _this = this;      _this.registerMobileValidate = Pattern.validateMobile(_this.memberRegister.mobile);      return _this.registerMobileValidate;    &#125;,\n\n2.会员登录注册功能开发，完善注册输入框校验\n\n\n依旧是修改login.vue\n\n//每个部分都加校验&lt;input v-on:blur=&quot;onRegisterMobileCodeBlur()&quot;       v-bind:class=&quot;registerMobileCodeValidateClass&quot;       id=&quot;register-mobile-code&quot; class=&quot;form-control&quot;       placeholder=&quot;手机验证码&quot; v-model=&quot;memberRegister.code&quot;&gt;&lt;span v-show=&quot;registerMobileCodeValidate === false&quot; class=&quot;text-danger&quot;&gt;请输入短信6位验证码&lt;/span&gt;///////////////////////////////////////////////////////&lt;input  v-on:blur=&quot;onRegisterNameBlur()&quot;        v-bind:class=&quot;registerNameValidateClass&quot;        id=&quot;register-name&quot; v-model=&quot;memberRegister.name&quot;        class=&quot;form-control&quot; placeholder=&quot;昵称&quot;&gt;&lt;span v-show=&quot;registerNameValidate === false&quot; class=&quot;text-danger&quot;&gt;昵称2到20位中文，字母，数字，下划线组合&lt;/span&gt;///////////////////////////////////////////////////////&lt;input v-on:blur=&quot;onRegisterPasswordBlur()&quot;        v-bind:class=&quot;registerPasswordValidateClass&quot;        id=&quot;register-password&quot; v-model=&quot;memberRegister.passwordOriginal&quot;        class=&quot;form-control&quot; placeholder=&quot;密码&quot; type=&quot;password&quot;&gt;&lt;span v-show=&quot;registerPasswordValidate === false&quot; class=&quot;text-danger&quot;&gt;密码最少6位，包含至少1字母和1个数字&lt;/span&gt;///////////////////////////////////////////////////////    &lt;input v-on:blur=&quot;onRegisterConfirmPasswordBlur()&quot;        v-bind:class=&quot;registerConfirmPasswordValidateClass&quot;        id=&quot;register-confirm-password&quot; v-model=&quot;memberRegister.confirm&quot;        class=&quot;form-control&quot; placeholder=&quot;确认密码&quot;        name=&quot;memberRegisterConfirm&quot; type=&quot;password&quot;&gt;&lt;span v-show=&quot;registerConfirmPasswordValidate === false&quot; class=&quot;text-danger&quot;&gt;确认密码和密码一致&lt;/span&gt;/////////////////////////////////////////////////////////data中增加registerMobileCodeValidate: null,registerPasswordValidate: null,registerNameValidate: null,registerConfirmPasswordValidate: null,/////////////////////////////////////////////////////////////////computed增加 registerMobileCodeValidateClass: function () &#123;      return &#123;        &#x27;border-success&#x27;: this.registerMobileCodeValidate === true,        &#x27;border-danger&#x27;: this.registerMobileCodeValidate === false,      &#125;    &#125;,    registerPasswordValidateClass: function () &#123;      return &#123;        &#x27;border-success&#x27;: this.registerPasswordValidate === true,        &#x27;border-danger&#x27;: this.registerPasswordValidate === false,      &#125;    &#125;,    registerNameValidateClass: function () &#123;      return &#123;        &#x27;border-success&#x27;: this.registerNameValidate === true,        &#x27;border-danger&#x27;: this.registerNameValidate === false,      &#125;    &#125;,    registerConfirmPasswordValidateClass: function () &#123;      return &#123;        &#x27;border-success&#x27;: this.registerConfirmPasswordValidate === true,        &#x27;border-danger&#x27;: this.registerConfirmPasswordValidate === false,      &#125;    &#125;,    //-------------------------------- 注册框校验 ----------------------------onRegisterMobileCodeBlur () &#123;      let _this = this;      _this.registerMobileCodeValidate = Pattern.validateMobileCode(_this.memberRegister.smsCode);      return _this.registerMobileValidate;    &#125;,    onRegisterNameBlur () &#123;      let _this = this;      _this.registerNameValidate = Pattern.validateName(_this.memberRegister.name);      return _this.registerMobileValidate;    &#125;,    onRegisterPasswordBlur () &#123;      let _this = this;      _this.registerPasswordValidate = Pattern.validatePasswordWeak(_this.memberRegister.passwordOriginal);      return _this.registerMobileValidate;    &#125;,    onRegisterConfirmPasswordBlur () &#123;      let _this = this;      let confirmPassword = $(&quot;#register-confirm-password&quot;).val();      if (Tool.isEmpty(confirmPassword)) &#123;        return _this.registerConfirmPasswordValidate = false;      &#125;      return _this.registerConfirmPasswordValidate = (confirmPassword === _this.memberRegister.passwordOriginal);    &#125;,    \n\n3.会员登录注册功能开发，提交注册之前，先校验所有注册输入框，当有一个输入框校验为false时，其他不校验\n\n\n修改login的register方法，增加如下代码\n\n// 提交之前，先校验所有输入框// 注意：当有一个文本框校验为false时，其它不校验let validateResult = _this.onRegisterMobileBlur() &amp;&amp;    _this.onRegisterMobileCodeBlur() &amp;&amp;    _this.onRegisterNameBlur() &amp;&amp;    _this.onRegisterPasswordBlur() &amp;&amp;    _this.onRegisterConfirmPasswordBlur();if (!validateResult) &#123;  return;&#125;\n\n增加短信验证码校验\n1.会员登录注册功能开发，注册时增加短信验证码校验功能,短信验证码5分钟内有效，只能验证一次\n\n\n我们给MemberDto增加字段\n\n/** * 短信验证码 */private String smsCode;\n\n\n接下来我们修改MemberController\n\n///////////////////////////////////////////////////////////注入@Resourceprivate SmsService smsService;////////////////////////////////////////////////////////在register方法中加入// 校验短信验证码SmsDto smsDto = new SmsDto();smsDto.setMobile(memberDto.getMobile());smsDto.setCode(memberDto.getSmsCode());smsDto.setUse(SmsUseEnum.REGISTER.getCode());smsService.validCode(smsDto);LOG.info(&quot;短信验证码校验通过&quot;);\n\n\n然后我们修改SmsService\n\n/** * 验证码5分钟内有效，且操作类型要一致 * @param smsDto */public void validCode(SmsDto smsDto) &#123;    SmsExample example = new SmsExample();    SmsExample.Criteria criteria = example.createCriteria();    // 查找5分钟内同手机号同操作发送记录    criteria.andMobileEqualTo(smsDto.getMobile()).andUseEqualTo(smsDto.getUse()).andAtGreaterThan(new Date(new Date().getTime() - 5 * 60 * 1000));    List&lt;Sms&gt; smsList = smsMapper.selectByExample(example);    if (smsList != null &amp;&amp; smsList.size() &gt; 0) &#123;        Sms smsDb = smsList.get(0);        if (!smsDb.getCode().equals(smsDto.getCode())) &#123;            LOG.warn(&quot;短信验证码不正确&quot;);            throw new BusinessException(BusinessExceptionCode.MOBILE_CODE_ERROR);        &#125; else &#123;            smsDb.setStatus(SmsStatusEnum.USED.getCode());            smsMapper.updateByPrimaryKey(smsDb);        &#125;    &#125; else &#123;        LOG.warn(&quot;短信验证码不存在或已过期，请重新发送短信&quot;);        throw new BusinessException(BusinessExceptionCode.MOBILE_CODE_EXPIRED);    &#125;&#125;\n\n\n最后我们再BusinessExceptionCode增加字段\n\nMOBILE_CODE_ERROR(&quot;短信验证码不正确&quot;),MOBILE_CODE_EXPIRED(&quot;短信验证码不存在或已过期，请重新发送短信&quot;),\n\n增加忘记密码功能\n1.会员登录注册功能开发，增加忘记密码功能，包含短信验证，输入框校验等\n\n\n我们先修改login\n\n/////////////////////////////////////////忘记密码部分&lt;div class=&quot;form-group&quot;&gt;  &lt;input v-on:blur=&quot;onForgetMobileBlur()&quot;         v-bind:class=&quot;forgetMobileValidateClass&quot;         id=&quot;forget-mobile&quot; v-model=&quot;memberForget.mobile&quot;         class=&quot;form-control&quot; placeholder=&quot;手机号&quot;&gt;  &lt;span v-show=&quot;forgetMobileValidate === false&quot; class=&quot;text-danger&quot;&gt;手机号11位数字，且必须已注册&lt;/span&gt;&lt;/div&gt;////////////////////////////////////////////////&lt;input v-on:blur=&quot;onForgetMobileCodeBlur()&quot;        v-bind:class=&quot;forgetMobileCodeValidateClass&quot;        id=&quot;forget-mobile-code&quot; class=&quot;form-control&quot;        placeholder=&quot;手机验证码&quot; v-model=&quot;memberForget.smsCode&quot;&gt;&lt;div class=&quot;input-group-append&quot;&gt;&lt;button v-on:click=&quot;sendSmsForForget()&quot; class=&quot;btn btn-outline-secondary&quot; id=&quot;forget-send-code-btn&quot;&gt;发送验证码&lt;/button&gt;&lt;span v-show=&quot;forgetMobileCodeValidate === false&quot; class=&quot;text-danger&quot;&gt;请输入短信6位验证码&lt;/span&gt; /////////////////////////////////////////////////////  &lt;input v-on:blur=&quot;onForgetPasswordBlur()&quot;                     v-bind:class=&quot;forgetPasswordValidateClass&quot;                     id=&quot;forget-password&quot; v-model=&quot;memberForget.passwordOriginal&quot;                     class=&quot;form-control&quot; placeholder=&quot;密码&quot; type=&quot;password&quot;&gt;&lt;span v-show=&quot;forgetPasswordValidate === false&quot; class=&quot;text-danger&quot;&gt;密码最少6位，包含至少1字母和1个数字&lt;/span&gt;///////////////////////////////////////////////////////////////////&lt;input v-on:blur=&quot;onForgetConfirmPasswordBlur()&quot;                     v-bind:class=&quot;forgetConfirmPasswordValidateClass&quot;                     id=&quot;forget-confirm-password&quot; v-model=&quot;memberForget.confirm&quot;                     class=&quot;form-control&quot; placeholder=&quot;确认密码&quot; type=&quot;password&quot;&gt;&lt;span v-show=&quot;forgetConfirmPasswordValidate === false&quot; class=&quot;text-danger&quot;&gt;确认密码和密码一致&lt;/span&gt;&lt;button  v-on:click=&quot;resetPassword()&quot; class=&quot;btn btn-primary btn-block submit-button&quot;&gt;                重&amp;nbsp;&amp;nbsp;置&lt;/button&gt;/////////////////////////////////////////////////再data增加 // 忘记密码框显示错误信息 forgetMobileValidate: null, forgetMobileCodeValidate: null, forgetPasswordValidate: null, forgetConfirmPasswordValidate: null,////////////////////////////////////////////再computed增加forgetMobileValidateClass: function () &#123;      return &#123;        &#x27;border-success&#x27;: this.forgetMobileValidate === true,        &#x27;border-danger&#x27;: this.forgetMobileValidate === false,      &#125;    &#125;,    forgetMobileCodeValidateClass: function () &#123;      return &#123;        &#x27;border-success&#x27;: this.forgetMobileCodeValidate === true,        &#x27;border-danger&#x27;: this.forgetMobileCodeValidate === false,      &#125;    &#125;,    forgetPasswordValidateClass: function () &#123;      return &#123;        &#x27;border-success&#x27;: this.forgetPasswordValidate === true,        &#x27;border-danger&#x27;: this.forgetPasswordValidate === false,      &#125;    &#125;,    forgetConfirmPasswordValidateClass: function () &#123;      return &#123;        &#x27;border-success&#x27;: this.forgetConfirmPasswordValidate === true,        &#x27;border-danger&#x27;: this.forgetConfirmPasswordValidate === false,      &#125;    &#125;,////////////////////////////////////////////增加方法 /**     * 发送忘记密码短信     */    sendSmsForForget() &#123;      let _this = this;      if (!_this.onForgetMobileBlur()) &#123;        return false;      &#125;      let sms = &#123;        mobile: _this.memberForget.mobile,        use: SMS_USE.FORGET.key      &#125;;      _this.$ajax.get(process.env.VUE_APP_SERVER + &#x27;/business/web/member/is-mobile-exist/&#x27; + _this.memberForget.mobile).then((res)=&gt;&#123;        let response = res.data;        if (response.success) &#123;          _this.forgetMobileValidate = true;          _this.sendSmsCode(sms, &quot;forget-send-code-btn&quot;);        &#125; else &#123;          _this.forgetMobileValidate = false;          Toast.warning(&quot;手机号未注册&quot;);        &#125;      &#125;);    &#125;,    resetPassword() &#123;      let _this = this;      // 提交之前，先校验所有输入框      // 注意：当有一个文本框校验为false时，其它不校验      let validateResult = _this.onForgetMobileBlur() &amp;&amp;          _this.onForgetMobileCodeBlur() &amp;&amp;          _this.onForgetPasswordBlur() &amp;&amp;          _this.onForgetConfirmPasswordBlur();      if (!validateResult) &#123;        return;      &#125;      _this.memberForget.password = hex_md5(_this.memberForget.passwordOriginal + KEY);      // 调服务端密码重置接口      _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/business/web/member/reset-password&#x27;, _this.memberForget).then((res)=&gt;&#123;        let response = res.data;        if (response.success) &#123;          Toast.success(&quot;密码重置成功&quot;);          _this.toLoginDiv();        &#125; else &#123;          Toast.warning(response.message);        &#125;      &#125;).catch((response)=&gt;&#123;        console.log(&quot;error：&quot;, response);      &#125;)    &#125;,     //-------------------------------- 忘记密码框校验 ----------------------------    onForgetMobileBlur () &#123;      let _this = this;      return _this.forgetMobileValidate = Pattern.validateMobile(_this.memberForget.mobile);    &#125;,    onForgetMobileCodeBlur () &#123;      let _this = this;      return _this.forgetMobileCodeValidate = Pattern.validateMobileCode(_this.memberForget.smsCode);    &#125;,    onForgetPasswordBlur () &#123;      let _this = this;      return _this.forgetPasswordValidate = Pattern.validatePasswordWeak(_this.memberForget.passwordOriginal);    &#125;,    onForgetConfirmPasswordBlur () &#123;      let _this = this;      let forgetPassword = $(&quot;#forget-confirm-password&quot;).val();      if (Tool.isEmpty(forgetPassword)) &#123;        return _this.forgetConfirmPasswordValidate = false;      &#125;      return _this.forgetConfirmPasswordValidate = (forgetPassword === _this.memberForget.passwordOriginal);    &#125;\n\n\n修改MemberController\n\n@PostMapping(&quot;/reset-password&quot;)  public ResponseDto resetPassword(@RequestBody MemberDto memberDto) throws BusinessException &#123;      LOG.info(&quot;会员密码重置开始:&quot;);      memberDto.setPassword(DigestUtils.md5DigestAsHex(memberDto.getPassword().getBytes()));      ResponseDto&lt;MemberDto&gt; responseDto = new ResponseDto();        // 校验短信验证码      SmsDto smsDto = new SmsDto();      smsDto.setMobile(memberDto.getMobile());      smsDto.setCode(memberDto.getSmsCode());      smsDto.setUse(SmsUseEnum.FORGET.getCode());      smsService.validCode(smsDto);      LOG.info(&quot;短信验证码校验通过&quot;);        // 重置密码      memberService.resetPassword(memberDto);        return responseDto;  &#125;\n\n\n修改MemberService\n\n/** * 重置密码 */public void resetPassword(MemberDto memberDto) throws BusinessException &#123;    Member memberDb = this.selectByMobile(memberDto.getMobile());    if (memberDb == null) &#123;        throw new BusinessException(BusinessExceptionCode.MEMBER_NOT_EXIST);    &#125; else &#123;        Member member = new Member();        member.setId(memberDb.getId());        member.setPassword(memberDto.getPassword());        memberMapper.updateByPrimaryKeySelective(member);    &#125;&#125;\n\n\n最后再BusinessExceptionCode中增加字段\n\nMEMBER_NOT_EXIST(&quot;会员不存在&quot;),\n\n13-13 增加立即报名功能新增报名表并生成基本代码\n1.会员报名课程功能开发，新增报名表，生成服务端和持久层代码\n\n\n首先增加sql,然后就可以代码生成器了\n\n# 会员课程报名drop table if exists `member_course`;create table `member_course`(                       `id` char(8) not null default &#x27;&#x27; comment &#x27;id&#x27;,                       `member_id` char(8) not null comment &#x27;会员id&#x27;,                       `course_id` char(8) not null comment &#x27;课程id&#x27;,                       `at` datetime(3) not null comment &#x27;报名时间&#x27;,                       primary key (`id`),                       unique key `member_course_unique`(`member_id`,`course_id`))engine =innodb default charset=utf8mb4 comment=&#x27;会员课程报名&#x27;;\n\n登录后可报名课程\n1.会员报名课程功能开发，登录后可报名课程\n\n\n报名功能就是保存会员课程关联表，相当于生成的save方法\n\n我们再business.controller.web路径下新增一个MemberCourseController\n\n\npackage com.course.business.controller.web;import com.course.server.dto.MemberCourseDto;import com.course.server.dto.ResponseDto;import com.course.server.service.MemberCourseService;import com.course.server.util.ValidatorUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;@RestController(&quot;webMemberCourseController&quot;)@RequestMapping(&quot;/web/member-course&quot;)public class MemberCourseController &#123;    private static final Logger LOG = LoggerFactory.getLogger(MemberCourseController.class);    public static final String BUSINESS_NAME = &quot;会员课程报名&quot;;    @Resource    private MemberCourseService memberCourseService;    /**     * 保存，id有值时更新，无值时新增     */    @PostMapping(&quot;/enroll&quot;)    public ResponseDto enroll(@RequestBody MemberCourseDto memberCourseDto) &#123;        // 保存校验        ValidatorUtil.require(memberCourseDto.getMemberId(), &quot;会员id&quot;);        ValidatorUtil.require(memberCourseDto.getCourseId(), &quot;课程id&quot;);        ResponseDto responseDto = new ResponseDto();        memberCourseDto = memberCourseService.enroll(memberCourseDto);        responseDto.setContent(memberCourseDto);        return responseDto;    &#125;&#125;\n\n\n然后我们看下MemberCourseService，真实项目中，报名时需要对接第三方支付，比如支付宝，还要另外做一个支付回调接口，让支付宝告诉你会员是否支付成功，如果支付成功，再插入报名表\n\nprivate void insert(MemberCourse memberCourse)&#123;            Date now = new Date();            memberCourse.setId(UuidUtil.getShortUuid());            memberCourse.setAt(now);//增加这一行            memberCourseMapper.insert(memberCourse);&#125;//////////////////////////////////////////////////////////////////////////////////////////////////  /**     * 报名，先判断是否已报名     * @param memberCourseDto     */    public MemberCourseDto enroll(MemberCourseDto memberCourseDto) &#123;        MemberCourse memberCourseDb = this.select(memberCourseDto.getMemberId(), memberCourseDto.getCourseId());        if (memberCourseDb == null) &#123;            MemberCourse memberCourse = CopyUtil.copy(memberCourseDto, MemberCourse.class);            this.insert(memberCourse);            // 将数据库信息全部返回，包括id, at            return CopyUtil.copy(memberCourse, MemberCourseDto.class);        &#125; else &#123;            // 如果已经报名，则直接返回已报名的信息            return CopyUtil.copy(memberCourseDb, MemberCourseDto.class);        &#125;    &#125;    /**     * 根据memberId和courseId查询记录     */    public MemberCourse select(String memberId, String courseId) &#123;        MemberCourseExample example = new MemberCourseExample();        example.createCriteria()                .andCourseIdEqualTo(courseId)                .andMemberIdEqualTo(memberId);        List&lt;MemberCourse&gt; memberCourseList = memberCourseMapper.selectByExample(example);        if (CollectionUtils.isEmpty(memberCourseList)) &#123;            return null;        &#125; else &#123;            return memberCourseList.get(0);        &#125;    &#125;\n\n\n然后我们看下detail.vue页面\n\n////////////////////////////////////////////////////////再一次增加互斥显示&lt;p class=&quot;course-head-button-links&quot;&gt;  &lt;a v-show=&quot;!memberCourse.id&quot; v-on:click=&quot;enroll()&quot; class=&quot;btn btn-lg btn-primary btn-shadow&quot; href=&quot;javascript:;&quot;&gt;立即报名&lt;/a&gt;  &lt;a v-show=&quot;memberCourse.id&quot; href=&quot;#&quot; class=&quot;btn btn-lg btn-success btn-shadow disabled&quot;&gt;您已报名&lt;/a&gt;&lt;/p&gt;///////////////////////////////////////////////////data中增加memberCourse:&#123;&#125;,/////////////////////////////////////////////////////////////增加方法/**     * 报名     */    enroll() &#123;      let _this = this;      let loginMember = Tool.getLoginMember();      if (Tool.isEmpty(loginMember)) &#123;        Toast.warning(&quot;请先登录&quot;);        return;      &#125;      _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/business/web/member-course/enroll&#x27;, &#123;        courseId: _this.course.id,        memberId: loginMember.id      &#125;).then((response)=&gt;&#123;        let resp = response.data;        if (resp.success) &#123;          _this.memberCourse = resp.content;          Toast.success(&quot;报名成功！&quot;);        &#125; else &#123;          Toast.warning(resp.message);        &#125;      &#125;);    &#125;,\n\n已报名的才可播放收费视频\n1.会员报名课程功能开发，已报名的才可播放收费视频\n\n\n修改detail.vue\n\n/** * 播放视频 * @param section */play(section) &#123;  let _this = this;  if (section.charge === _this.SECTION_CHARGE.CHARGE.key ) &#123;////////////////////////////////////////////////////////////    let loginMember = Tool.getLoginMember();    if (Tool.isEmpty(loginMember)) &#123;///////////////////////////////////////////////////////////    Toast.warning(&quot;请先登录&quot;);    return;  &#125;else&#123;//////////////////////////////////////////////////////////      if (Tool.isEmpty(_this.memberCourse)) &#123;        Toast.warning(&quot;请先报名&quot;);        return;      &#125;//////////////////////////////////////////////////////////    &#125;  &#125;  _this.$refs.modalPlayer.playVod(section.vod);&#125;,\n\n进入课程详情页面时显示加载报名信息\n1.会员报名课程功能开发，加载完课程信后，如果一登陆，则加载报名信息\n\n\n现在刷新页面会导致前端报名信息丢失\n\n首先修改detail.vue\n\n\n//////////////////////////////////////////再findCourse中加入//获取报名信息_this.getEnroll();///////////////////////////////////////////写方法  /**     * 获取报名     */    getEnroll() &#123;      let _this = this;      let loginMember = Tool.getLoginMember();      if (Tool.isEmpty(loginMember)) &#123;        console.log(&quot;未登录&quot;);        return;      &#125;      _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/business/web/member-course/get-enroll&#x27;, &#123;        courseId: _this.course.id,        memberId: loginMember.id      &#125;).then((response)=&gt;&#123;        let resp = response.data;        if (resp.success) &#123;          _this.memberCourse = resp.content || &#123;&#125;;        &#125;      &#125;);    &#125;,\n\n\n然后我们修改web的MemberCourseController，增加\n\n/** * 保存，id有值时更新，无值时新增 */@PostMapping(&quot;/get-enroll&quot;)public ResponseDto getEnroll(@RequestBody MemberCourseDto memberCourseDto) &#123;    ResponseDto responseDto = new ResponseDto();    memberCourseDto = memberCourseService.getEnroll(memberCourseDto);    responseDto.setContent(memberCourseDto);    return responseDto;&#125;\n\n\n最后修改MemberCourseService\n\n/** * 获取报名信息 */public MemberCourseDto getEnroll(MemberCourseDto memberCourseDto) &#123;    MemberCourse memberCourse = this.select(memberCourseDto.getMemberId(), memberCourseDto.getCourseId());    return CopyUtil.copy(memberCourse, MemberCourseDto.class);&#125;\n\n","tags":["完整项目"]},{"title":"完整项目之Spring Cloud + Vue 前后端分离1","url":"/2022/01/07/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E4%B9%8BSpring%20Cloud%20+%20Vue%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/","content":"第1章 配置环境\n在Spring官网中点进这个Initializr，配置你想要的。\n\n\n然后安装nodejs，在IDEA中的Local输入npm get registry；如果不是淘宝镜像，那么就输入这个npm set registry http://registry.npm.taobao.org；再重新输入npm get registry查看，等待他安装完配置即可。\n再下载一个git\n\n\n\n第2章 使用Maven搭建SpringCloud项目2-1 使用Eureka搭建注册中心\nMaven两大核心功能：依赖管理（Jar包管理）+构建项目（项目打包）\nSpringCloud是管理多个SpringBoot应用的微服务框架\n项目初始化，要把代码管理优先做好，不管是学习还是工作，养成阶段性提交代码的习惯，代码管理工具选择git。\n一个项目里不是所有文件都需要提交到git中，.gitignore会帮我们自动排除。\nSpringBoot之所以流行就是因为只需要一个类，只有一个main函数就可以启动Java项目。\nMaven父子模块结构，父框架只需要一个pom.xml，子模块是正常的maven项目\nSpringBoot默认继承Tomcat\n\n2-2 搭建业务模块-system\n本章将介绍使用Maven搭建SpringCloud微服务项目，学习微服务核心组件：注册中心Eureka和路由Gateway。\n\n解决注册中心无法启动的问题：\n\n在resources文件下建立application.properties默认配置文件\n\nspring.application.name=eureka //应用名字server.port=8761//运行端口    /*因为本身就是注册中心，所以下面必须是false*/eureka.client.fetch-registry=falseeureka.client.refresh-with-eureka=false\n\n\n接下来需要在启动文件加注解：@EnableEurekaServer\n\nversion control窗口可以看到未提交的修改记录，也可以用看到整个项目包括其他人提交记录\n\nspringboot默认集成slf4框架，它定义了一些日志接口，规范日志输出，真正的实现是logback或者log4j，我们代码中写的都是slf4j的代码\n\n一定要看好依赖项是否正确https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies\n\n一般不用配置版本，用自带的好一些\n\n\n新建一个Maven子项目system\n\n2020版本idea version control 不见了 解决办法：可以进入Settings&#x2F;Preferences&#x2F;Version Control&#x2F;Commit将Use non-modal commit interface取消勾选\n\nmaven父子模块的配置：在子模块中使用parent标签指向父模块，在父模块中使用module标签引入子模块\n\n只需添加两个依赖：添加依赖项发现他不主动下载了，因此我们就使用自己添加的阿里云镜像吧。在C:\\Program Files\\JetBrains\\IntelliJ IDEA 2021.2.3\\plugins\\maven\\lib\\maven3\\conf的setting.xml中添加下面代码（注意是添加不是替换奥）\n\n\n&lt;mirror&gt;&lt;id&gt;nexus-aliyun&lt;/id&gt;&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;name&gt;Nexus aliyun&lt;/name&gt;&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt;\n\n\n由于注册中心都是接口开放出去的，所以我们注解用的RestController（返回的json格式的数据），如果返回的是页面就用Controller\n\n将system注册到注册中心：（只需要改三个地方）\n\n第一个就是之前增加的那个client依赖\n\n&lt;dependencies&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\n第二个就是在配置文件中增加配置，指向注册中心的地址\n\nspring.application.name=systemserver.port=9001eureka.client.service-url.defaultZone=http://localhost:8761/eureka/\n\n\n第三个就是在启动类里添加@EnableEurekaClient注解\n\n2-3 搭建路由模块-gateway\nSpringCloud的网关组件这里我们使用gateway。\n网关的主要功能：限流（流量控制）；重试（请求失败时重试，慎用）；跨域（前后端不在同一个域）；路由（转发请求）；鉴权（登陆校验，签名校验）等\n\n首先新建一个Maven子项目gateway：\n\n也是需要放入依赖的，然后修改相应配置\n\n&lt;dependencies&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;/dependencies&gt;\n\n路由转发：将外部请求转发到实际的业务，模块进行处理。在application.properties添加如下\nspring.application.name=gatewayserver.port=9000eureka.client.service-url.defaultZone=http://localhost:8761/eureka/spring.cloud.gateway.routes[0].id=system spring.cloud.gateway.routes[0].uri=http://192.168.0.105:9001spring.cloud.gateway.routes[0].predicates[0].name=Pathspring.cloud.gateway.routes[0].predicates[0].args[0]=/system/**\n\n\n目的就是将9001地址对外隐藏，暴露9000地址，访问的时：localhost:9000&#x2F;system&#x2F;*，实际处理是localhost:9001&#x2F;system&#x2F; * *\n\n我们想要在之前test前面加一个&#x2F;system，可以在system模块下的application.properties中添加：\n\n\nserver.servlet.context-path=/system //这样/system就算是根目录，以后所有添加下的文件夹都在它下面\n\n这时192.168.0.64:9001&#x2F;system&#x2F;test和192.168.0.64:9000&#x2F;system&#x2F;test都可以进行访问\n第3章 SpringBoot项目技术整合\n本章将介绍单个SpringBoot的纯后端应用的搭建，集成Mybatis框架及代码生成器，并集成热部署DevTools，学习单个应用的环境搭建及提高开发效率的准备。\n\n3-1 集成持久层框架Mybatis\n持久层：负责数据持久化，即将数据存储到数据库或硬盘等，断电也不会丢失数据。Mybatis是半自动ORM，Mybatis可以操作的花样更多，是首选的持久层框架。\n\nSystem模块集成Mybatis框架：\n\n数据库的准备工作1：创建一个本项目独用的数据库courseimooc\n\n数据库的准备工作2：创建courseimooc数据库专用用户，创建用户时，主机填写：localhost表示创建的用户，只能本机登陆数据库，远程不能登陆；填写%，表示允许本地和远程登陆数据库。然后对用户添加权限\n\n数据库的准备工作3：创建一张表\n\n引入Mybatis架包：Maven父子模块增加jar包依赖：先在父pom.xml中增加jar包依赖，再在子pom.xml中增加jar包依赖，子pom.xml不带版本号。\n\n\n&lt;!-- 集成mybatis --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;   &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;mysql&lt;/groupId&gt;   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;   &lt;version&gt;8.0.23&lt;/version&gt;&lt;/dependency&gt;\n\n\n还得另外配置\n\nspring.datasource.url=jdbc:mysql://localhost:3306/courseimooc?characterEncoding=UTF8&amp;autoReconnect=truespring.datasource.username=courseimoocspring.datasource.password=你自己的数据库密码spring.datasource.driver-class-name=com.mysql.jdbc.Driver //增加mysql驱动mybatis.mapper-locations=classpath:/mapper/*.xml\n\nmybatis使用实例：增加TestMapper.xml，放在resources&#x2F;mapper目录下。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.course.system.mapper.TestMapper&quot;&gt;    &lt;select id=&quot;list&quot; resultType=&quot;com.course.system.domain.Test&quot;&gt;        select `id` ,`name` from `test`;//真傻逼奥，记得加分号    &lt;/select&gt;&lt;/mapper&gt;\n\n一个项目一般会有controller，service，mapper三层，其中controller是请求的入口，service负责逻辑，mapper负责持久层\n3-2 项目优化\n记住你的mysql版本号一定要对。\n改时区法一：手动在 URL 上设置jdbc:mysql://localhost:3306/数据库名?serverTimezone\n法二：\n\n又他妈碰到了个问题，xml文件无法识别数据库的表名和字段，无法点击表名链接到数据源。在此我首先修改了\n\n其次改了这才好：\n\n\n查看差异：ctrl+alt+shift+D\n\n集成热部署DevTools:哪个包需要增加就在哪个包pom.xml下添加依赖。\n\n增加devtools依赖\n\n&lt;!-- 热部署DevTools --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n设置idea，ctrl+alt+s打开设置窗口，找到Compiler，自动构建就是代码编写时，自动编译。\n\n要在运行时自动编译\n\n随着项目的增加热部署的优势就更能体现了\n\n\n优化mybatis日志：在system的application.properties中添加\nlogging.level.com.course.system.mapper=trace\n\n3-3 搭建服务模块-server\n为什么要构建公共模块？业务拓展后，需要对表加一个字段，这时，如果要保持实体类和表结构一致，则所有模块的实体都要改，费时费力，如果哪个模块用到新的字段，就改哪实体类，时间一长，所有的实体类和表都对应不上，并且这种策略不能用mybatis代码生成器。\n\n\n新建公共模块-server：\n\n就是把system的com.course.system全部复制到server中，然后将system中的pom.xml中的依赖复制到server中，删除第一个配置client。\n\n\nsystem集成server模块：\n\n在course中引入架包：\n\n\n\n&lt;dependency&gt;   &lt;groupId&gt;com.course&lt;/groupId&gt;   &lt;artifactId&gt;server&lt;/artifactId&gt;   &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;\n\n\n迁移完后记得在systemapplication中添加@ComponentScan(“com.course”)，如果类中用了@Controller，@Repository，@Service,@Component四大注解标识之一了，那么如果不加上@ComponentScan，Spring就不会自动扫描类上的四大注解中的任何一个，那么四大注解下的类就不会被Spring扫描到，更不会装入Spring容器中，因此你配置的四大注解就失去了作用。\n\nctrl+shift+f代表查看代码在哪有\n\n\n\n集中配置\n如果直接将system中的application.properties复制到server中，那么server作为jar包被依赖，它的resources下的配置文件会和system下的配置文件冲突，生效的还是system的。那么我们应该怎么做呢？我们要做的就是在resources下新建一个config文件夹，将其移动到该文件夹中，spring默认会读config下的配置文件。\n\n\n\n3-4 集成mybatis generator\nidea集成mybatis-generator生成mybatis代码\n\n父pom.xml里增加mybatic-generator插件\n\n\n\n&lt;!-- mybatis generator 自动生成代码插件 --&gt;&lt;plugin&gt;   &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;   &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;   &lt;version&gt;1.3.7&lt;/version&gt;   &lt;configuration&gt;      &lt;configurationFile&gt;src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt;      &lt;overwrite&gt;true&lt;/overwrite&gt;      &lt;verbose&gt;true&lt;/verbose&gt;   &lt;/configuration&gt;   &lt;dependencies&gt;      &lt;dependency&gt;         &lt;groupId&gt;mysql&lt;/groupId&gt;         &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;         &lt;version&gt;8.0.23&lt;/version&gt;      &lt;/dependency&gt;   &lt;/dependencies&gt;&lt;/plugin&gt;\n\n\n添加配置文件generatorConfig.xml：加上反引号&#96;&#96;后，一些mysql的关键字就可以当作表明或者字段名来使用。\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt;        &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;!--覆盖生成XML文件--&gt;        &lt;plugin type=&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot; /&gt;        &lt;!-- 生成的实体类添加toString()方法 --&gt;        &lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot; /&gt;        &lt;!-- 不生成注释 --&gt;        &lt;commentGenerator&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://localhost:3306/courseimooc&quot;                        userId=&quot;courseimooc&quot;                        password=&quot;你自己的数据库密码&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- domain类的位置 --&gt;        &lt;javaModelGenerator targetProject=&quot;src\\main\\java&quot;                            targetPackage=&quot;com.course.server.domain&quot;/&gt;        &lt;!-- mapper xml的位置 --&gt;        &lt;sqlMapGenerator targetProject=&quot;src\\main\\resources&quot;                         targetPackage=&quot;mapper&quot;/&gt;        &lt;!-- mapper类的位置 --&gt;        &lt;javaClientGenerator targetProject=&quot;src\\main\\java&quot;                             targetPackage=&quot;com.course.server.mapper&quot;                             type=&quot;XMLMAPPER&quot; /&gt;&lt;!--        &lt;table tableName=&quot;test&quot; domainObjectName=&quot;Test&quot;/&gt;--&gt;&lt;!--        &lt;table tableName=&quot;chapter&quot; domainObjectName=&quot;Chapter&quot;/&gt;--&gt;&lt;!--        &lt;table tableName=&quot;section&quot; domainObjectName=&quot;Section&quot;/&gt;--&gt;&lt;!--        &lt;table tableName=&quot;course&quot; domainObjectName=&quot;Course&quot;/&gt;--&gt;&lt;!--        &lt;table tableName=&quot;course_content&quot; domainObjectName=&quot;CourseContent&quot;/&gt;--&gt;&lt;!--        &lt;table tableName=&quot;course_content_file&quot; domainObjectName=&quot;CourseContentFile&quot;/&gt;--&gt;&lt;!--        &lt;table tableName=&quot;teacher&quot; domainObjectName=&quot;Teacher&quot;/&gt;--&gt;&lt;!--        &lt;table tableName=&quot;file&quot; domainObjectName=&quot;File&quot;/&gt;--&gt;&lt;!--        &lt;table tableName=&quot;user&quot; domainObjectName=&quot;User&quot;/&gt;--&gt;&lt;!--        &lt;table tableName=&quot;resource&quot; domainObjectName=&quot;Resource&quot;/&gt;--&gt;&lt;!--        &lt;table tableName=&quot;role&quot; domainObjectName=&quot;Role&quot;/&gt;--&gt;&lt;!--        &lt;table tableName=&quot;role_resource&quot; domainObjectName=&quot;RoleResource&quot;/&gt;--&gt;&lt;!--        &lt;table tableName=&quot;role_user&quot; domainObjectName=&quot;RoleUser&quot;/&gt;--&gt;&lt;!--        &lt;table tableName=&quot;member&quot; domainObjectName=&quot;Member&quot;/&gt;--&gt;&lt;!--        &lt;table tableName=&quot;sms&quot; domainObjectName=&quot;Sms&quot;/&gt;--&gt;&lt;!--        &lt;table tableName=&quot;test&quot; domainObjectName=&quot;Test&quot;/&gt;--&gt;        &lt;table tableName=&quot;chapter&quot; domainObjectName=&quot;chapter&quot;/&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;\n\n\n创建一个maven启动命令mybatis-generator:generate  -e\n\n  \n  generatorConfig.xml是放在server模块下，所以这里选择server目录。\n\n解决mapper.xml重复生成代码问题：业务扩展，表结构发生变动时，需要重新生成持久层代码。这对编码有一个要求：生成器生成的四个文件绝对不可以手动修改。\n\ngeneratorConfig.xml里增加这个，原来的xml会被覆盖，所以绝对不要在生成的xml手动修改代码，因为下次再生成时，手动修改的代码会被覆盖掉。\n\n\n&lt;!--覆盖生成XML文件--&gt;&lt;plugin type=&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot; /&gt;\n\n\n通过Example，可以帮助我们写入where、order by，distinct等，需要熟练掌握，可以极大提高单表开发效率。\n\n小技巧：ctrl+alt+v，快速生成一个变量\n\n要按多个条件查询数据库，在java中表达式后面继续.andXXX；？是jdbc占位符，可用于防注入攻击，mybatis底层也是jdbc实现的\n\n\n第4章 使用Vue cli 4搭建管理控台\n本章将介绍Vue cli和bootstrap的使用。Vue是MVVM框架，其代码结构类似于Angular、微信小程序。Bootstrap是一个响应式框架，一套代码可适应PC，手机屏幕。本章使用Vue cli 4 + Bootstrap 3搭建控台管理应用，学习单页面应用搭建及响应式设计\n\n4-1 使用vue cli创建admin项目\nvue用法一：直接引入vue.js，适用于现成的jsp项目，thymeleaf项目等。这种用法不算前后端分离，发布时依然是前后端一起部署的。\nvue用法二：使用vuecli新建项目，前后端分离开发，分离部署\nidea默认使用windows自带的命令行，可以通过设置改为git bash\nvuecli安装按照这个来https://cli.vuejs.org/zh/guide/installation.html\nvuecli初始安装带了babel和eslint插件，babel：JavaScript编译器；eslint：代码规范检查\nmain.js是vue入口文件，用来初始化vue实例并集成所需要的插件\n\n4-2 集成bootstrap后台管理模板ace\nBootstrap来自推特，是目前最受欢迎的响应式框架。它基于html，css，JavaScript，简单易扩展，因此有很多第三方模板，栅格系统是bootstrap的布局核心。\n\n\nace admin模板介绍：http://ace.jeka.by/\nadmin增加ace模板：\n批量替换小技巧：找到要批量替换的公共点，可以包含特殊字符，”&#x3D;等，替换的时候，也加上这些特殊字符。ctrl+r替换\n建议把下面两个勾选，方便快速定位\neslintrc.js,用于检测代码规范。是一把双刃剑，一些检测没必要，可以通过修改配置禁用掉\n\n\n\n4-3 集成路由vue-route\n这里使用vue-route的版本是v3.5.3   npm install &#x76;&#x75;&#101;&#x2d;&#114;&#x6f;&#117;&#x74;&#x65;&#114;&#64;&#51;&#x2e;&#53;&#46;&#51;\n\n在命令行cd admin 然后npm install –save vue-router。\n\nrouter-view是路由嵌套标签，一般配合父子路由使用\n\nctrl+alt+l：格式化代码\n\n\n&lt;template&gt;下只能由一个div标签，所以需要用一个div把多个div标签括起来\n\n\nctrl+f：搜索页面\n\n在script标签里写的js代码是全局的，会影响其他页面\n\n\n4-4 控台欢迎页面开发mouted的使用：解决两个页面样式冲突问题\n\ncreated执行更早，在界面渲染之前执行，常用于加载初始化数据。mounted在界面渲染之后执行，常用于对界面元素的初始化操作\n组件每次加载，mounted都会再次执行\n\n使用router-view增加welcome子组件：\n\nrouter-view一般配合子路由使用；子路由配置不要以“&#x2F;”开头\n在哪使用welcome就在哪加入router-view\n\n控台页面元素修改：\n\n响应式设计的一个体现：根据屏幕分辨率不同，弹窗显示在不同位置\n在git中提交记录选择checkout菜单，可以让本地代码回到过去某一个提交点\nctrl+y：删除当前选中的行，只要某一行有部分被选中，这一行就会全部删除\ndata-toggle：用于按钮和模态框（弹出层）的事件绑定\nactive open：当前菜单是激活样式，并且把当前菜单的子菜单展开\n\n第5章 单表管理功能前后端开发\n本章将演示控台单表增删改查的前后端开发，重点学习前后端数据交互，Vue ajax库axios的使用，使用Vue自定义组件制作分页组件，Mybatis分页插件pagehelper的使用等功能。介绍常用的公共组件的使用，包括前端确认框、提示框、等待框，后端复制工具类、统一日志AOP等。\n\n5-1 大章列表查询功能开发1\n完成单表的增删改查：\n\n控台单表增删改查的前后端开发，重点学习前后端数据交互，vue ajax库axios的使用\n\n通用组件的开发：分页、确认框、提示框、等待框等：\n\n常用的公共组件：确认框、提示框、等待框，统一日志拦截器等。使用vue自定义组件制作分页组件，mybatis分页插件pagehelper的使用\n\n\n增加maven子项目business：\n\nshift+F6重命名。重命名就是重构，会将所有引用到的地方都一起改名，甚至是注释掉的代码也会一起修改。\n将system中一堆文件复制过去\n\n大章表设计及持久层代码生成：\n\nDTO：数据传输对象，用于数据传输。\ndomain内的实体，是mybatis-generator自动生成的，不允许手动修改，一旦修改，再次生成实体类时，所做的修改会被覆盖。\ndomain作用于service和mapper；dto作用于controller和service。\nctrl+alt+v为表达式生成一个变量\nBeanUtils是Spring提供的一个工具类，用于实体间的复制。后续会对BeanUtils做封闭，简化使用，提高开发效率。\n\n5-2 大章列表查询功能开发2新增chapter子页面并添加子路由，并使用假数据制作表格：\n\nshift+tab，反向缩进\n\n点击sidebar实现菜单页面跳转：\n\n二级菜单要显示出激活模式，只需要添加active样式\nsilbings,jquery的方法，获取所有兄弟节点\n&lt;router-link to=&quot;&quot;&gt;类似于&lt;a href=&quot;&quot;&gt;，用于链接跳转\n约定id的命名要和路由相关\n\n通用的sidebar点击激活样式方法：\n\nvue内置的watch，用来监测vue实例上的数据变动，$route也是一个变量。\n在router.js添加name，是为了通过name属性值，得到菜单id的值。约定优于配置\n在admin.vue添加watch，此时如果从login页面登陆跳转到welcome页面，welcome并不会有激活样式，这里的watch，只在admin下面的子组件互相跳转时有用。为了解决这个问题，需要在初始化也执行一句激活代码。\n还有一点需要注意，我们要把this变成本地变量，js中有this关键字，代表当前执行方法的对象。养成习惯，在方法开头，声明本地变量_this代替this。\n\n5-3 大章列表查询功能开发3集成axios完成前后端交互\n\n–save：在pacjage.json添加依赖。（不加–save的话，只是去下载插件，项目中并没有依赖插件） npm install axios –save\n\n以vue属性的方式使用axios：修改main.js\n\n\nimport axios from &quot;axios&quot;;Vue.prototype.$ajax = axios;\n\n\nVue.prototype.xxx，可以理解为Vue组件的全局变量。可以在任意Vue组件中，使用this.xxx来获取这个值。$是代表Vue全局 在chapter.vue中使用$ajax\n\nlist()&#123;  let _this=this;  _this.$ajax.get(&#x27;http://192.168.0.105:9002/business/chapter/list&#x27;).then((respond)=&gt;&#123;    console.log(&quot;查询大章列表结果:&quot;,respond);  &#125;)&#125;\n\n\nCORS，跨站点资源分享，属于跨域问题，同个IP的不同端口间的访问也属于跨域，前后端分离必然有跨域问题。解决跨域问题：增加CorsConfiguration.java在server中\n\npackage com.course.server.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123;    @Override    public void addCorsMappings(CorsRegistry registry) &#123;        registry.addMapping(&quot;/**&quot;)                .allowedOrigins(&quot;*&quot;)                .allowedHeaders(CorsConfiguration.ALL)                .allowedMethods(CorsConfiguration.ALL)                .allowCredentials(true)                .maxAge(3600); // 1小时内不需要再预检（发OPTIONS请求）    &#125;&#125;\n\n\nctrl+shift++：展开所有层级；+-：收缩所有层级\n\n使用data定义组件内的变量，可以用于做双向数据绑定。\n\n显示真实数据就是使用data定义变量，定义一个数组，在methods中将查询到的结果返回，再在特定的行里面引用样式的数据。\n\n没用了CorsResponseHeaderFilter.java\n\n\npackage com.course.server.config;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.cloud.gateway.filter.NettyWriteResponseFilter;import org.springframework.core.Ordered;import org.springframework.http.HttpHeaders;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;import java.util.ArrayList;/** * 跨域请求头重复处理过滤器 */public class CorsResponseHeaderFilter implements GlobalFilter, Ordered &#123;    @Override    public int getOrder() &#123;        // 指定此过滤器位于NettyWriteResponseFilter之后        // 即待处理完响应体后接着处理响应头        return NettyWriteResponseFilter.WRITE_RESPONSE_FILTER_ORDER + 1;    &#125;    @Override    @SuppressWarnings(&quot;serial&quot;)    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        return chain.filter(exchange).then(Mono.defer(() -&gt; &#123;            exchange.getResponse().getHeaders().entrySet().stream()                    .filter(kv -&gt; (kv.getValue() != null &amp;&amp; kv.getValue().size() &gt; 1))                    .filter(kv -&gt; (kv.getKey().equals(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN)                            || kv.getKey().equals(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS)))                    .forEach(kv -&gt;                    &#123;                        kv.setValue(new ArrayList&lt;String&gt;() &#123;&#123;                            add(kv.getValue().get(0));                        &#125;&#125;);                    &#125;);            return chain.filter(exchange);        &#125;));    &#125;&#125;\n\n使用gateway路由转发：使用gateway路由转发，vue页面只访问gateway\n\n单个SpringBoot应用使用CorsConfig解决跨域问题。使用SpringCloud Gateway的，使用CorsWebFilter解决跨域问题。\n\n现在统一在gateway中使用跨域配置，在GatewayApplication.java中添加配置\n\n\npackage com.course.gateway;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.context.annotation.Bean;import org.springframework.core.env.Environment;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.reactive.CorsWebFilter;import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;import org.springframework.web.util.pattern.PathPatternParser;@SpringBootApplication@EnableDiscoveryClientpublic class GatewayApplication &#123;\tprivate static final Logger LOG = LoggerFactory.getLogger(GatewayApplication.class);\tpublic static void main(String[] args) &#123;\t\tSpringApplication app = new SpringApplication(GatewayApplication.class);\t\tEnvironment env = app.run(args).getEnvironment();\t\tLOG.info(&quot;启动成功！！&quot;);\t\tLOG.info(&quot;Gateway地址: \\thttp://127.0.0.1:&#123;&#125;&quot;, env.getProperty(&quot;server.port&quot;));\t&#125;\t/**\t * 配置跨域\t * @return\t */\t@Bean\tpublic CorsWebFilter corsFilter() &#123;\t\tCorsConfiguration config = new CorsConfiguration();\t\tconfig.setAllowCredentials(Boolean.TRUE);\t\tconfig.addAllowedMethod(&quot;*&quot;);\t\tconfig.addAllowedOrigin(&quot;*&quot;);\t\tconfig.addAllowedHeader(&quot;*&quot;);\t\tconfig.setMaxAge(3600L);\t\tUrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());\t\tsource.registerCorsConfiguration(&quot;/**&quot;, config);\t\treturn new CorsWebFilter(source);\t&#125;&#125;\n\n\n如果配置的是ip端口，那么发布到生产时就可能会访问不到，就算配置了maven多环境，也需要提前知道上线后的IP和端口，因此就需要lb:&#x2F;&#x2F;(负载均衡)loadbalance：使用lb:&#x2F;&#x2F;+注册中心名字作为路由转发\n\nspring.cloud.gateway.routes[1].uri=http://192.168.0.105:9002//替换spring.cloud.gateway.routes[1].uri=lb://business\n\n5-4 分页功能开发集成分页插件pagehelper:\n\nmybatis-generator生成的代码是不带分页功能的，使用pagehelper插件来拓展分页功能。\n\n首先在course的pom.xml添加插件依赖，其次server中也添加，不过没有版本号\n\n\n&lt;!-- mybatis分页插件pagehelper --&gt;&lt;dependency&gt;   &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;   &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;1.2.10&lt;/version&gt;&lt;/dependency&gt;\n\n\n使用就是在ChapterService中添加：\n\nPageHelper.startPage(1,1);//查询第一条语句\n\n\n分页功能的关键字：limit。从日志看出该sql执行的是limit 1，相当于limit 0 1，即从第0行开始，查1条。\n\n插件分页语句规则：调用startPage方法之后，执行的第一个select语句会进行分页。\n\n分页查询功能需要两条sql，一条是查总记录数（通过每页条数计算出总共有多少页），一条是查当前页的记录。\n\n\n分页参数前后端交互：分页参数前后端交互，axios的post请求默认是以流的形式传递参数，所以controller里的参数要加@RequestBody注解\n\n使用泛型的地方都可以用Object代替，但是泛型可以在编译期就发现问题，并且避免了代码中写强制类型转换。\n\n接口请求参数传递，尽量使用post。使用get请求在url里拼参数的话，会使url变得很长，有些浏览器或服务器会对url长度做限制，导致请求失败。\n\n日志输出时，变量使用点位符，比如LOG.info(“输出：id&#x3D;{},姓名&#x3D;{},id,name”)，而不是LOG.info(“输出：id&#x3D;”+id+”,姓名&#x3D;”+name)\n\n\n@RequestBody//在controller中使用流的形式和$ajax的post相对应\n\n5-5前端分页组件的使用增加一个刷新按钮：\n\nfa样式是fontawesome图标，可以百度搜“fontawesome”查看所有图标的样式\nv-bind:list&#x3D;”list”，前面的list，是分页组件暴露出来的一个回调方法，后面的list，是chapter组件的list方法。\nprops，定义父组件向子组件传递的参数，可以是一个函数或数据。本组件中暴漏了两个参数list和itemCount给外部。\n\n&lt;p&gt;  &lt;button v-on:click=&quot;list()&quot; class=&quot;btn btn-white btn-default btn-round&quot;&gt;    &lt;i class=&quot;ace-icon fa fa-refresh red2&quot;&gt;&lt;/i&gt;    刷新  &lt;/button&gt;&lt;/p&gt;\n\n前端分页组件的使用：\n\n首先在admin软件包中的components添加pagination.vue\n\n&lt;template&gt;  &lt;div class=&quot;pagination&quot; role=&quot;group&quot; aria-label=&quot;分页&quot;&gt;    &lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-white btn-round&quot;             v-bind:disabled=&quot;page === 1&quot;            v-on:click=&quot;selectPage(1)&quot;&gt;      1    &lt;/button&gt;    &lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-white btn-round&quot;             v-bind:disabled=&quot;page === 1&quot;            v-on:click=&quot;selectPage(page - 1)&quot;&gt;      上一页    &lt;/button&gt;    &lt;button v-for=&quot;p in pages&quot; v-bind:id=&quot;&#x27;page-&#x27; + p&quot;             type=&quot;button&quot; class=&quot;btn btn-default btn-white btn-round&quot;            v-bind:class=&quot;&#123;&#x27;btn-primary active&#x27;:page == p&#125;&quot;             v-on:click=&quot;selectPage(p)&quot;&gt;      &#123;&#123;p&#125;&#125;    &lt;/button&gt;    &lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-white btn-round&quot;             v-bind:disabled=&quot;page === pageTotal&quot;            v-on:click=&quot;selectPage(page + 1)&quot;&gt;      下一页    &lt;/button&gt;    &lt;button type=&quot;button&quot; class=&quot;btn btn-default btn-white btn-round&quot;            v-bind:disabled=&quot;page === pageTotal&quot;            v-on:click=&quot;selectPage(pageTotal)&quot;&gt;    这是两个大括号里面是 分页总数||1    &lt;/button&gt;    &amp;nbsp;    &lt;span class=&quot;m--padding-10&quot;&gt;        每页        &lt;select v-model=&quot;size&quot;&gt;            &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;            &lt;option value=&quot;5&quot;&gt;5&lt;/option&gt;            &lt;option value=&quot;10&quot;&gt;10&lt;/option&gt;            &lt;option value=&quot;20&quot;&gt;20&lt;/option&gt;            &lt;option value=&quot;50&quot;&gt;50&lt;/option&gt;            &lt;option value=&quot;100&quot;&gt;100&lt;/option&gt;        &lt;/select&gt;        条，共【&#123;&#123;total&#125;&#125;】条    &lt;/span&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &#x27;pagination&#x27;,    props: &#123;      list: &#123;        type: Function,        default: null      &#125;,      itemCount: Number // 显示的页码数，比如总共有100页，只显示10页，其它用省略号表示    &#125;,    data: function () &#123;      return &#123;        total: 0, // 总行数        size: 10, // 每页条数        page: 0, // 当前页码        pageTotal: 0, // 总页数        pages: [], // 显示的页码数组      &#125;    &#125;,    methods: &#123;      /**       * 渲染分页组件       * @param page       * @param total       */      render(page, total) &#123;        let _this = this;        _this.page = page;        _this.total = total;        _this.pageTotal = Math.ceil(total / _this.size);        _this.pages = _this.getPageItems(_this.pageTotal, page, _this.itemCount || 5);      &#125;,      /**       * 查询某一页       * @param page       */      selectPage(page) &#123;        let _this = this;        if (page &lt; 1) &#123;          page = 1;        &#125;        if (page &gt; _this.pageTotal) &#123;          page = _this.pageTotal;        &#125;        if (this.page !== page) &#123;          _this.page = page;          if (_this.list) &#123;            _this.list(page);          &#125;        &#125;      &#125;,      /**       * 当前要显示在页面上的页码       * @param total       * @param current       * @param length       * @returns &#123;Array&#125;       */      getPageItems(total, current, length) &#123;        let items = [];        if (length &gt;= total) &#123;          for (let i = 1; i &lt;= total; i++) &#123;            items.push(i);          &#125;        &#125; else &#123;          let base = 0;          // 前移          if (current - 0 &gt; Math.floor((length - 1) / 2)) &#123;            // 后移            base = Math.min(total, current - 0 + Math.ceil((length - 1) / 2)) - length;          &#125;          for (let i = 1; i &lt;= length; i++) &#123;            items.push(base + i);          &#125;        &#125;        return items;      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;  .pagination &#123;    vertical-align: middle !important;    font-size: 16px;    margin-top: 0;    margin-bottom: 10px;  &#125;  .pagination button &#123;    margin-right: 5px;  &#125;  .btn-primary.active &#123;    background-color: #2f7bba !important;    border-color: #27689d !important;    color: white !important;    font-weight: 600;  &#125;  /*.pagination select &#123;*/  /*vertical-align: middle !important;*/  /*font-size: 16px;*/  /*margin-top: 0;*/  /*&#125;*/&lt;/style&gt;\n\n\n其次在chapter.vue中：\n\n&lt;script&gt;import Pagination from &quot;../../components/pagination&quot;;&lt;/script&gt;&lt;template&gt;&lt;pagination ref=&quot;pagination&quot; v-bind:list=&quot;list&quot; v-bind:itemCount=&quot;8&quot;&gt;&lt;/pagination&gt;&lt;/template&gt;export default &#123;    components: &#123;Pagination&#125;,&#125;list(page) &#123;        let _this = this;        Loading.show();        _this.$ajax.post(process.env.VUE_APP_SERVER + &#x27;/business/admin/chapter/list&#x27;, &#123;          page: page,          size: _this.$refs.pagination.size,        &#125;).then((response)=&gt;&#123; \t\t let resp = response.data;          _this.chapters = resp.list;          _this.$refs.pagination.render(page, resp.total);        &#125;)      &#125;,\n\n5-6 增加新增大章功能页面设计与前端代码开发：\n\n$(“.modal”)里的modal是css的选择器，模态框代码里有class&#x3D;”modal”样式，.modal()是内置的方法用于弹出或关闭模态框\n可以使用$(“.modal”).modal({backdrop:’static’})；禁止点空白的地方关闭，某些场景需求会用到这个功能。\n&lt;label for=&quot;id&quot;&gt;有个场景会经常用到：点击复选框checkbox时选中，使用label for后，点击label的文字，也能选中复制框\n模态框弹出和关闭，可以用js代码，也可以用button属性：data-dismiss&#x3D;”cdd选择器”关闭；data-toggle&#x3D;”css选择器”打开。\n\n短ID设计与后端代码开发：\n\n面试：为什么不用自增ID？自增ID至少有三个问题：1.ID是连续，容易被探测；2.需要+1次查询才能得到id的值；3.分布式存储中，id会出现重复。\n\nuuid是根据机器、时间等多个维度生成的32位16进制数，有生之年不会重复。\n\n短ID是根据将32位ID，转为62进制8位ID，减少存储空间。原理是将uuid转为10进制，再对62取余。也可以再添加两个符号，转为64进制。\n\n在server中添加一个UuidUtil\n\n\npackage com.course.server.util;import java.util.UUID;public class UuidUtil &#123;    public static String[] chars = new String[] &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;,            &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;,            &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;,            &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;,            &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;,            &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot; &#125;;    /**     * 获取短UUID     * @return     */    public static String getShortUuid() &#123;        StringBuffer shortBuffer = new StringBuffer();        String uuid = UuidUtil.getUuid();        for (int i = 0; i &lt; 8; i++) &#123;            String str = uuid.substring(i * 4, i * 4 + 4);            int x = Integer.parseInt(str, 16);            shortBuffer.append(chars[x % 0x3E]); // 对62取余        &#125;        return shortBuffer.toString();    &#125;    /**     * 获得32位UUID     */    public static String getUuid()&#123;        String uuid = UUID.randomUUID().toString();        //去掉“-”符号        return uuid.replaceAll(&quot;-&quot;, &quot;&quot;);    &#125;    public static void main(String[] args) &#123;        System.out.println(getShortUuid());    &#125;&#125;\n\n\n在ChapterService中添加\n\npublic void save(ChapterDto chapterDto)&#123;    chapterDto.setId(UuidUtil.getShortUuid());    Chapter chapter = new Chapter();    BeanUtils.copyProperties(chapterDto,chapter);    chapterMapper.insert(chapter);&#125;\n\n\n在ChapterController中添加\n\n@RequestMapping(&quot;/save&quot;)public ChapterDto list(@RequestBody ChapterDto chapterDto)&#123;    chapterService.save(chapterDto);    return chapterDto;&#125;\n\n\n在chapter.vue中添加方法\n\nsave(page)&#123;  let _this=this;  _this.$ajax.post(&#x27;http://192.168.0.105:9000/business/admin/chapter/save&#x27;,_this.chapter).then((respond)=&gt;&#123;    console.log(&quot;保存大章列表结果:&quot;,respond);  &#125;\n\n增加复制工具类CopyUtil:\n\nserver中增加代码\n\npackage com.course.server.util;import org.springframework.beans.BeanUtils;import org.springframework.util.CollectionUtils;import java.util.ArrayList;import java.util.List;public class CopyUtil &#123;    public static &lt;T&gt; List&lt;T&gt; copyList(List source, Class&lt;T&gt; clazz) &#123;        List&lt;T&gt; target = new ArrayList&lt;&gt;();        if (!CollectionUtils.isEmpty(source))&#123;            if (!CollectionUtils.isEmpty(source))&#123;                for (Object c: source) &#123;                    T obj = copy(c, clazz);                    target.add(obj);                &#125;            &#125;        &#125;        return target;    &#125;    public static &lt;T&gt; T copy(Object source, Class&lt;T&gt; clazz) &#123;        if (source == null) &#123;            return null;        &#125;        T obj = null;        try &#123;            obj = clazz.newInstance();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        BeanUtils.copyProperties(source, obj);        return obj;    &#125;&#125;\n\n统一返回参数ResponseDto：\n\n纯接口应用，一般会规范固定的请求参数，如版本号、请求流水等；再规范固定的返回参数，如返回码、返回描述等。方便调用方统一处理。\n\npackage com.course.server.dto;public class ResponseDto&lt;T&gt; &#123;    /**     * 业务上的成功或失败     */    private boolean success = true;    /**     * 返回码     */    private String code;    /**     * 返回信息     */    private String message;    /**     * 返回泛型数据，自定义类型     */    private T content;    public String getCode() &#123;        return code;    &#125;    public void setCode(String code) &#123;        this.code = code;    &#125;    public boolean getSuccess() &#123;        return success;    &#125;    public void setSuccess(boolean success) &#123;        this.success = success;    &#125;    public String getMessage() &#123;        return message;    &#125;    public void setMessage(String message) &#123;        this.message = message;    &#125;    public T getContent() &#123;        return content;    &#125;    public void setContent(T content) &#123;        this.content = content;    &#125;    @Override    public String toString() &#123;        final StringBuffer sb = new StringBuffer(&quot;ResponseDto&#123;&quot;);        sb.append(&quot;success=&quot;).append(success);        sb.append(&quot;, code=&#x27;&quot;).append(code).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, message=&#x27;&quot;).append(message).append(&#x27;\\&#x27;&#x27;);        sb.append(&quot;, content=&quot;).append(content);        sb.append(&#x27;&#125;&#x27;);        return sb.toString();    &#125;&#125;\n\n\n列表查询业务上一般都是成功的（查不到数据也是成功的），所以不需要判断success。保存有可能失败，所以需要判断success。\n\n问题：同一个页面有多个modal时，用class选择时，会出现重复，所以需要给每个modal增加id属性。\n\n\n5-7修改删除大章功能增加大章修改功能：增加修改大章功能，新增和修改用同一个保存功能，通过传入的参数id有没有值来判断\n\n新增和编辑功能弹出来的模态框是同一个。vue，controller，service调用的都是同一个方法，只是到service层再根据id是否有值来判断是新增还是删除。\nhidden-md：中等屏幕隐藏，其它可见：hidden-lg：大屏幕隐藏，其它可见。相反的有visible-xx.\n数据显示：将表格行数据显示到表单。反过来，数据修改：修改表单影响表格行数据。解决这个问题可以使用$.extend({},chapter)\n发现问题：对文本编辑后，点击新增弹出文本框，会带出上一次编辑过的值，只需要在add里添加_this.chapter&#x3D;{};即可\n\n增加大章删除功能：\n\nrestful是一种请求风格。简单理解：通过看url就能知道这个请求时要对什么资源做什么操作。\n1.在前端chapter.vue中删除样式按钮上添加；2.添加del方法\n\n//1.v-on:click=&quot;del(chapter.id)&quot;//2.    del(id) &#123;      let _this = this;      _this.$ajax.delete(&#x27;http://192.168.0.105:9000/business/admin/chapter/delete/&#x27; + id).then((respond) =&gt; &#123;        console.log(&quot;删除大章列表结果:&quot;, respond);        let resp = respond.data;        if (resp.success) &#123;          _this.list(1);        &#125;      &#125;)    &#125;\n\n\n在chaptercontroller中添加del\n\n@DeleteMapping (&quot;/delete/&#123;id&#125;&quot;)public ResponseDto del(@PathVariable  String id)&#123;    ResponseDto responseDto = new ResponseDto();    chapterService.delete(id);    return responseDto;&#125;\n\n\n在chapterservice添加delete\n\n public void delete(String id)&#123;    chapterMapper.deleteByPrimaryKey(id);&#125;\n\n5-8集成前端通用组件集成sweetalert2(https://sweetalert2.github.io/#download)用于界面消息确认框：因为删除是一个有风险的操作 ，需要有确认的动作\n\n首先在前端index.html中添加\n\n&lt;script src=&quot;//cdn.jsdelivr.net/npm/sweetalert2@11&quot;&gt;&lt;/script&gt;\n\n\n其次在chapter.vue中的del方法添加\n\ndel(id) &#123;  let _this = this;  Swal.fire(&#123;    title: &#x27;确认删除?&#x27;,    text: &quot;删除后不可恢复!&quot;,    icon: &#x27;warning&#x27;,    showCancelButton: true,    confirmButtonColor: &#x27;#3085d6&#x27;,    cancelButtonColor: &#x27;#d33&#x27;,    confirmButtonText: &#x27;确认!&#x27;  &#125;).then((result) =&gt; &#123;    if (result.isConfirmed) &#123;      _this.$ajax.delete(&#x27;http://192.168.0.105:9000/business/admin/chapter/delete/&#x27; + id).then((respond) =&gt; &#123;        console.log(&quot;删除大章列表结果:&quot;, respond);        let resp = respond.data;        if (resp.success) &#123;          _this.list(1);          Swal.fire(              &#x27;删除成功!&#x27;,              &#x27;你的文件已经删除&#x27;,              &#x27;success&#x27;          )        &#125;      &#125;)    &#125;  &#125;)&#125;\n\n制作消息提示框：制作toast组件，内部用sweetalert2实现\n\n通过修改timer可以设置弹出的时长，设置icon可以设置成成功、错误、警告等\n\n如果组件包括html代码，可以用vue组件；如果组件只有js代码，可以用原生的js\n\n首先在index.html中引入\n\n\n&lt;!--确认框和提示框--&gt;&lt;script src=&quot;//cdn.jsdelivr.net/npm/sweetalert2@11&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&lt;%= BASE_URL %&gt;static/js/toast.js&quot;&gt;&lt;/script&gt;&lt;!--必须是这样的，顺序不能颠倒--&gt;\n\n\n其次因为toast是通用的，所以将其单独放在static&#x2F;js&#x2F;toast.js中，代码：\n\nconst Toast = Swal.mixin(&#123;    toast: true,    position: &#x27;top-end&#x27;,    showConfirmButton: false,    timer: 3000,    timerProgressBar: true,    didOpen: (toast) =&gt; &#123;        toast.addEventListener(&#x27;mouseenter&#x27;, Swal.stopTimer)        toast.addEventListener(&#x27;mouseleave&#x27;, Swal.resumeTimer)    &#125;&#125;);toast = &#123;    success:function (message)&#123;        Toast.fire(&#123;            icon: &#x27;success&#x27;,            title: message        &#125;);    &#125;,    error:function (message)&#123;        Toast.fire(&#123;            icon: &#x27;error&#x27;,            title: message        &#125;);    &#125;,    waning:function (message)&#123;        Toast.fire(&#123;            icon: &#x27;waning&#x27;,            title:message        &#125;);    &#125;&#125;;\n\n\n在chapter.vue引用直接  ：toast.success(“保存成功”);即可\n\n集成blockUI用于界面等待框：制作Loading组件，内部用jquery blockui插件\n\n等待框的作用：1.让用户知道，后端正在处理，耐心等待；2.防止用户恶意重复点击\n\n首先在index引用\n\n\n&lt;!--  loading等待框--&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery.blockUI/2.70.0-2014.11.23/jquery.blockUI.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&lt;%= BASE_URL %&gt;static/js/loading.js&quot;&gt;&lt;/script&gt;\n\n\nloading.js写代码\n\nLoading =&#123;    show:function ()&#123;        $.blockUI(&#123;            message: &#x27;&lt;img src=&quot;/static/image/loading.gif&quot;/&gt;&#x27;,            css: &#123;                padding: &quot;10px&quot;,                left: &quot;50%&quot;,                width: &quot;80px&quot;,                marginLeft: &quot;-40px&quot;,            &#125;        &#125;);    &#125;,    hide:function ()&#123;        //故意做的延迟，实际不用        setTimeout(function ()&#123;            $.unblockUI();        &#125;,500)    &#125;&#125;;\n\n\n在chapter调用：就是Loading.show();Loading.hide();\n\n给提示框换个样式：\nToast = &#123;    success:function (message)&#123;        Swal.fire(&#123;            position: &#x27;top-end&#x27;,            icon: &#x27;success&#x27;,            title:message,            showConfirmButton: false,            timer: 3000        &#125;);    &#125;,    error:function (message)&#123;        Swal.fire(&#123;            position: &#x27;top-end&#x27;,            icon: &#x27;error&#x27;,            title: message,            showConfirmButton: false,            timer: 3000        &#125;);    &#125;,    warning:function (message)&#123;        Swal.fire(&#123;            position: &#x27;top-end&#x27;,            icon: &#x27;warning&#x27;,            title: message,            showConfirmButton: false,            timer: 3000        &#125;);    &#125;&#125;;\n\n\n组件化的好处，只需要修改组件代码，就可以改变组件的样式，使用的地方完全不用动\n\n制作Confirm组件：\n\n创建confirm.js文件\n\nConfirm = &#123;    show: function (message, callback) &#123;        Swal.fire(&#123;            title: &#x27;确认删除?&#x27;,            text: &quot;删除后不可恢复!&quot;,            icon: &#x27;warning&#x27;,            showCancelButton: true,            confirmButtonColor: &#x27;#3085d6&#x27;,            cancelButtonColor: &#x27;#d33&#x27;,            confirmButtonText: &#x27;确认!&#x27;        &#125;).then((result) =&gt; &#123;            if (result.isConfirmed) &#123;                if(callback)&#123;//回调函数                    callback();                &#125;            &#125;        &#125;)    &#125;&#125;\n\n\n在chapter.vue的del中使用\n\nConfirm.show(&quot;删除后不可恢复!&quot;,function ()&#123;  Loading.show();  _this.$ajax.delete(&#x27;http://192.168.0.105:9000/business/admin/chapter/delete/&#x27; + id).then((respond) =&gt; &#123;    Loading.hide();    console.log(&quot;删除大章列表结果:&quot;, respond);    let resp = respond.data;    if (resp.success) &#123;      _this.list(1);      Toast.success(&quot;删除成功&quot;);    &#125;  &#125;)&#125;);\n\n5-9代码优化前端代码校验:1.增加工具类tool.js和校验类validator.js2.大章保存非空和长度增加校验\n\n首先在index引用\n\n&lt;!--  通用工具类  --&gt;&lt;script src=&quot;&lt;%= BASE_URL %&gt;static/js/tool.js&quot;&gt;&lt;/script&gt;&lt;!--  校验类  --&gt;&lt;script src=&quot;&lt;%= BASE_URL %&gt;static/js/validator.js&quot;&gt;&lt;/script&gt;\n\n\n其次增加两个js\n\nTool = &#123;    /**     * 空校验 null或&quot;&quot;都返回true     */    isEmpty: function (obj) &#123;        if ((typeof obj == &#x27;string&#x27;)) &#123;            return !obj || obj.replace(/\\s+/g, &quot;&quot;) == &quot;&quot;        &#125; else &#123;            return (!obj || JSON.stringify(obj) === &quot;&#123;&#125;&quot; || obj.length === 0);        &#125;    &#125;,    /**     * 非空校验     */    isNotEmpty: function (obj) &#123;        return !this.isEmpty(obj);    &#125;,    /**     * 长度校验     */    isLength: function (str, min, max) &#123;        return $.trim(str).length &gt;= min &amp;&amp; $.trim(str).length &lt;= max;    &#125;,&#125;;\n\nValidator = &#123;    require: function (value, text) &#123;        if (Tool.isEmpty(value)) &#123;            Toast.warning(text + &quot;不能为空&quot;);            return false;        &#125; else &#123;            return true        &#125;    &#125;,    length: function (value, text, min, max) &#123;        if (!Tool.isLength(value, min, max)) &#123;            Toast.warning(text + &quot;长度&quot; + min + &quot;~&quot; + max + &quot;位&quot;);            return false;        &#125; else &#123;            return true        &#125;    &#125;&#125;;\n\n\n最后在chapter中save方法中调用：\n\n// 保存校验if (!Validator.require(_this.chapter.name, &quot;名称&quot;)    || !Validator.length(_this.chapter.courseId, &quot;课程ID&quot;, 1, 8)) &#123;  return;&#125;\n\n后端代码校验：是为了防止被绕过前端界面，利用第三方工具如postman，直接访问后端接口\n1.增加了后端校验工具类ValidatorUtil2.增加了统一异常处理ControllerExceptionHandler，关键字@ControllerAdvice\n\n\n自定义异常可以继承RuntimeException或Exception。一般项目内部的业务异常，可以用RuntimeException，不需要trycatch。如果是开发一些框架或工具类，明确告诉外部需要做异常处理的，可以用Exception。另外还需要考虑事务中的异常处理。在server中建立ValidatorException.java\n\npackage com.course.server.exception;public class ValidatorException extends RuntimeException&#123;    public ValidatorException(String message)&#123;super(message);&#125;&#125;\n\n\n其次在util中建立ValidatorUtil文件\n\npackage com.course.server.util;import com.course.server.exception.ValidatorException;import org.springframework.util.StringUtils;public class ValidatorUtil &#123;    /**     * 空校验（null or &quot;&quot;）     */    public static void require(Object str, String fieldName) &#123;        if (StringUtils.isEmpty(str)) &#123;            throw new ValidatorException(fieldName + &quot;不能为空&quot;);        &#125;    &#125;    /**     * 长度校验     */    public static void length(String str, String fieldName, int min, int max) &#123;        if (StringUtils.isEmpty(str)) &#123;            return;        &#125;        int length = 0;        if (!StringUtils.isEmpty(str)) &#123;            length = str.length();        &#125;        if (length &lt; min || length &gt; max) &#123;            throw new ValidatorException(fieldName + &quot;长度&quot; + min + &quot;~&quot; + max + &quot;位&quot;);        &#125;    &#125;&#125;\n\n\n如果直接在chaptercontroller中使用保存校验会出现问题：直接进行后端代码校验会出现问题：现象：后端出异常，导致前后收不到结果，vue中的.then方法没有执行，等待框没有关闭导致不能继续任何操作，只能刷新页面。\n\n// 保存校验ValidatorUtil.require(chapterDto.getName(), &quot;名称&quot;);ValidatorUtil.require(chapterDto.getCourseId(), &quot;课程ID&quot;);ValidatorUtil.length(chapterDto.getCourseId(), &quot;课程ID&quot;, 1, 8);\n\n\n解决这个问题，写一个统一处理方法就在controller软件包下建一个ControllerExceptionHandler.java\n\npackage com.course.business.controller;import com.course.server.dto.ResponseDto;import com.course.server.exception.ValidatorException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;@ControllerAdvice//@ControllerAdvice是Controller增强器，可以对Controller做统一的处理，如异常处理、数据处理等public class ControllerExceptionHandler &#123;    @ExceptionHandler(value = ValidatorException.class)    @ResponseBody//以JISON方式返回    public ResponseDto validatorExceptionHandler(ValidatorException e)&#123;    ResponseDto responseDto = new ResponseDto();    responseDto.setSuccess(false);    responseDto.setMessage(e.getMessage());    return responseDto;    &#125;&#125;\n\n\n有时候我们的接口原本是不对外的，或者只跟特定的第三方应用做对接，这时为了内部安全，不应该把参数的校验规则暴露出去，所以需要模糊返回信息。类似登录接门应该返回“用户名或密码错”，而不是“用户名不存在，或“密码错误”（容易被探测）。所以我们将返回统一信息如下，并设置一个日志返回真正信息。\n\nLOG.warn(e.getMessage());responseDto.setMessage(&quot;请求参数异常!&quot;);\n\n\n如果开发过程中提示“请求参数异常“说明后端有校验拦截，前端没有，此时应该把前端校验加上\n\n使用AOP制作一个统一日志输出\n\n\n1.增加了日志AOP，统一日志输出2.logback增加了打印日志跟踪号\n\n\n统一日志处理可以用AOP也可以用Spring拦截器\n\n约定优于配置。又一个约定：查询类接口以list或query开头，保存用save开头，删除用delete开头\n\n首先在chaptercontroller中添加\n\n\nprivate static final Logger LOG = LoggerFactory.getLogger(ChapterController.class);public static final String BUSINESS_NAME = &quot;大章&quot;;\n\n\nlogback进行一行修改\n\n&lt;encoder&gt;    &lt;Pattern&gt;%d&#123;ss.SSS&#125; %highlight(%-5level) %blue(%-30logger&#123;30&#125;:%-4line) %green(%-8X&#123;UUID&#125;) %msg%n&lt;/Pattern&gt;&lt;/encoder&gt;  \n\n\n在server中的config加入LogAspect.java\n\npackage com.course.server.config;import com.alibaba.fastjson.JSONObject;import com.alibaba.fastjson.support.spring.PropertyPreFilters;import com.course.server.util.UuidUtil;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.Signature;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.slf4j.MDC;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import org.springframework.web.multipart.MultipartFile;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import java.lang.reflect.Field;@Aspect@Componentpublic class LogAspect &#123;    private final static Logger LOG = LoggerFactory.getLogger(LogAspect.class);    /** 定义一个切点 */    @Pointcut(&quot;execution(public * com.course.*.controller..*Controller.*(..))&quot;)    public void controllerPointcut() &#123;&#125;    @Before(&quot;controllerPointcut()&quot;)    public void doBefore(JoinPoint joinPoint) throws Throwable &#123;        // 日志编号        MDC.put(&quot;UUID&quot;, UuidUtil.getShortUuid());        // 开始打印请求日志        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        Signature signature = joinPoint.getSignature();        String name = signature.getName();        // 打印业务操作        String nameCn = &quot;&quot;;        if (name.contains(&quot;list&quot;) || name.contains(&quot;query&quot;)) &#123;            nameCn = &quot;查询&quot;;        &#125; else if (name.contains(&quot;save&quot;)) &#123;            nameCn = &quot;保存&quot;;        &#125; else if (name.contains(&quot;delete&quot;)) &#123;            nameCn = &quot;删除&quot;;        &#125; else &#123;            nameCn = &quot;操作&quot;;        &#125;        // 使用反射，获取业务名称        Class clazz = signature.getDeclaringType();        Field field;        String businessName = &quot;&quot;;        try &#123;            field = clazz.getField(&quot;BUSINESS_NAME&quot;);            if (!StringUtils.isEmpty(field)) &#123;                businessName = (String) field.get(clazz);            &#125;        &#125; catch (NoSuchFieldException e) &#123;            LOG.error(&quot;未获取到业务名称&quot;);        &#125; catch (SecurityException e) &#123;            LOG.error(&quot;获取业务名称失败&quot;, e);        &#125;        // 打印请求信息        LOG.info(&quot;------------- 【&#123;&#125;】&#123;&#125;开始 -------------&quot;, businessName, nameCn);        LOG.info(&quot;请求地址: &#123;&#125; &#123;&#125;&quot;, request.getRequestURL().toString(), request.getMethod());        LOG.info(&quot;类名方法: &#123;&#125;.&#123;&#125;&quot;, signature.getDeclaringTypeName(), name);        LOG.info(&quot;远程地址: &#123;&#125;&quot;, request.getRemoteAddr());        // 打印请求参数        Object[] args = joinPoint.getArgs();        Object[] arguments  = new Object[args.length];        for (int i = 0; i &lt; args.length; i++) &#123;            if (args[i] instanceof ServletRequest                    || args[i] instanceof ServletResponse                    || args[i] instanceof MultipartFile) &#123;                continue;            &#125;            arguments[i] = args[i];        &#125;        // 排除字段，敏感字段或太长的字段不显示        String[] excludeProperties = &#123;&quot;shard&quot;&#125;;        PropertyPreFilters filters = new PropertyPreFilters();        PropertyPreFilters.MySimplePropertyPreFilter excludefilter = filters.addFilter();        excludefilter.addExcludes(excludeProperties);        LOG.info(&quot;请求参数: &#123;&#125;&quot;, JSONObject.toJSONString(arguments, excludefilter)); // 为空的会不打印，但是像图片等长字段也会打印    &#125;    @Around(&quot;controllerPointcut()&quot;)    public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;        long startTime = System.currentTimeMillis();        Object result = proceedingJoinPoint.proceed();        // 排除字段，敏感字段或太长的字段不显示        String[] excludeProperties = &#123;&quot;password&quot;, &quot;shard&quot;&#125;;        PropertyPreFilters filters = new PropertyPreFilters();        PropertyPreFilters.MySimplePropertyPreFilter excludefilter = filters.addFilter();        excludefilter.addExcludes(excludeProperties);        LOG.info(&quot;返回结果: &#123;&#125;&quot;, JSONObject.toJSONString(result, excludefilter));        LOG.info(&quot;------------- 结束 耗时：&#123;&#125; ms -------------&quot;, System.currentTimeMillis() - startTime);        return result;    &#125;&#125;\n\n\n当然需要添加依赖：根目录和server依赖\n\n&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.60&lt;/version&gt;&lt;/dependency&gt;&lt;!-- AOP --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;&lt;/dependency&gt;\n\n前端增加统一日志输出：在main.js\n/** * axias拦截器 */axios.interceptors.request.use(function (config)&#123;  console.log(&quot;请求:&quot;,config);  return config;&#125;,error =&gt; &#123;&#125;);axios.interceptors.request.use(function (response)&#123;  console.log(&quot;返回结果:&quot;,response);  return response;&#125;,error =&gt; &#123;&#125;);\n\n","tags":["完整项目"]},{"title":"改善深层神经网络：超参数调试、正则化以及优化第一周检测","url":"/2021/08/10/%E6%94%B9%E5%96%84%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%95%E3%80%81%E6%AD%A3%E5%88%99%E5%8C%96%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AC%AC%E4%B8%80%E5%91%A8%E6%A3%80%E6%B5%8B/","content":"答案见下方\n1.如果你有10,000,000个例子，你会如何划分训练&#x2F;开发&#x2F;测试集？A.33%训练，33%开发，33%测试\nB.60%训练，20%开发，20%测试\nC.98%训练，1%开发，1%测试\n2.开发和测试集应该：A.来自同一分布\nB.来自不同分布\nC.完全相同（一样的(x, y)对）\nD.数据数量应该相同\n3.如果你的神经网络方差很高，下列哪个尝试是可能解决问题的？A.添加正则项\nB.获取更多测试数据\nC.增加每个隐藏层的神经元数量\nD.用更深的神经网络\nE.用更多的训练数据\n4.你正在为苹果，香蕉和橘子制作分类器。 假设您的分类器在训练集上有0.5％的错误，以及开发集上有7％的错误。 以下哪项尝试是有希望改善你的分类器的分类效果的？A.增大正则化参数λ\nB.减小正则化参数λ\nC.获取更多训练数据\nD.用更大的神经网络\n5.什么是权重衰减？A.正则化技术（例如L2正则化）导致梯度下降在每次迭代时权重收缩\nB.在训练过程中逐渐降低学习率的过程\nC.如果神经网络是在噪声数据下训练的，那么神经网络的权值会逐渐损坏\nD.通过对权重值设置上限来避免梯度消失的技术\n6.当你增大正则化的超参数λ时会发生什么？A.权重变小（接近0）\nB.权重变大（远离0）\nC.2倍的λ导致2倍的权重\nD.每次迭代，梯度下降采取更大的步距（与λ成正比）\n7.在测试时候使用dropout：A.不随机关闭神经元，但保留1&#x2F;keep_brob因子\nB.随机关闭神经元，保留1&#x2F;keep_brob因子\nC.随机关闭神经元，但不保留1&#x2F;keep_brob因子\nD.不随机关闭神经元，也不保留1&#x2F;keep_brob因子\n8.将参数keep_prob从（比如说）0.5增加到0.6可能会导致以下情况（选出所有正确项）：A.正则化效应被增强\nB.正则化效应被减弱\nC.训练集的误差会增加\nD.训练集的误差会减小\n9.以下哪些技术可用于减少方差（减少过拟合）？（选出所有正确项）A.梯度消失\nB.数据扩充\nC.Dropout\nD.梯度检查\nE.Xavier初始化\nF.L2正则化\nG.梯度爆炸\n10.为什么要对输入x进行归一化？A.让参数初始化更快\nB.让代价函数更快地优化\nC.更容易做数据可视化\nD.是另一种正则化——有助减少方差\n\n答案：\nC\nA\nAE\nAC\nA\nA\nD(dropout只用在训练集上，目的是在每层添加噪声，降低对权重的依赖，从而防止过拟合。但是测试的时候不能用dropout，否则会影响评估.)\nBD(在编写tensorflow程序的时候，会发现训练的时候dropout的参数keep_prob&#x3D;0.8（0.5,0.9等等），在测试的时候keep_prob&#x3D;1.0，即不进行dropout。)\nBCF\nB\n\n","tags":["深度学习"]},{"title":"改善深层神经网络：超参数调试、正则化以及优化第二周检测","url":"/2021/08/10/%E6%94%B9%E5%96%84%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%95%E3%80%81%E6%AD%A3%E5%88%99%E5%8C%96%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AC%AC%E4%BA%8C%E5%91%A8%E6%A3%80%E6%B5%8B/","content":"答案见下方\n1.当输入从第8个mini-batch的第7个的例子的时候，你会用哪种符号表示第3层的激活？A.a^ [3]{8}(7)\nB.a^ [8]{7}(3)\nC.a^ [8]{3}(7)\nD.a^ [3]{7}(8)\n2. 关于mini-batch的说法哪个是正确的？A.mini-batch迭代一次（计算1个mini-batch），要比批量梯度下降迭代一次快\nB.用mini-batch训练完整个数据集一次，要比批量梯度下降训练完整个数据集一次快\nC.在不同的mini-batch下，不需要显式地进行循环，就可以实现mini-batch梯度下降，从而使算法同时处理所有的数据（矢量化）\n3.为什么最好的mini-batch的大小通常不是1也不是m，而是介于两者之间？A.如果mini-batch的大小是1，那么在你取得进展前，你需要遍历整个训练集\nB.如果mini-batch的大小是m，就会变成批量梯度下降。在你取得进展前，你需要遍历整个训练集\nC.如果mini-batch的大小是1，那么你将失去mini-batch将数据矢量化带来的的好处\nD.如果mini-batch的大小是m，就会变成随机梯度下降，而这样做经常会比mini-batch慢\n4.如果你的模型的成本J随着迭代次数的增加，绘制出来的图如下，那么：\nA.如果你正在使用mini-batch梯度下降，那可能有问题；而如果你在使用批量梯度下降，那是合理的\nB.如果你正在使用mini-batch梯度下降，那看上去是合理的；而如果你在使用批量梯度下降，那可能有问题\nC.无论你在使用mini-batch还是批量梯度下降，看上去都是合理的\nD.无论你在使用mini-batch还是批量梯度下降，都可能有问题\n5.假设一月的前三天卡萨布兰卡的气温是一样的：一月第一天: θ1&#x3D;10一月第二天: θ2&#x3D;10,假设您使用β&#x3D;0.5的指数加权平均来跟踪温度：v0&#x3D;0,vt&#x3D;βv_t−1+(1−β)θ_t。如果v2是在没有偏差修正的情况下计算第2天后的值，并且v2corrected是您使用偏差修正计算的值。 这些下面的值是正确的是？\nA.v2&#x3D;10,v2corrected&#x3D;10\nB.v2&#x3D;10,v2corrected&#x3D;7.5\nC.v2&#x3D;7.5,v2corrected&#x3D;7.5\nD.v2&#x3D;7.5,v2corrected&#x3D;10\n6.下面哪一个不是比较好的学习率衰减方法？A.α&#x3D;1&#x2F;(1+2∗t) α0\nB.α&#x3D;1&#x2F;sqrt(t) α0\nC.α&#x3D;0.95^ t α0\nD.α&#x3D;e^ t α0\n7.您在伦敦温度数据集上使用指数加权平均， 使用以下公式来追踪温度：vt&#x3D;βv_t−1+(1−β)θt。下图中红线使用的是β&#x3D;0.9来计算的。当你改变β时，你的红色曲线会怎样变化？（选出所有正确项）\nA.减小β，红色线会略微右移B.增加β，红色线会略微右移C.减小β，红线会更加震荡D.增加β，红线会更加震荡\n8.下图中的曲线是由：梯度下降，动量梯度下降（β&#x3D;0.5）和动量梯度下降（β&#x3D;0.9）。哪条曲线对应哪种算法？\nA.(1)是梯度下降；(2)是动量梯度下降（β&#x3D;0.9）；(3)是动量梯度下降（β&#x3D;0.5）\nB.(1)是梯度下降；(2)是动量梯度下降（β&#x3D;0.5）；(3)是动量梯度下降（β&#x3D;0.9）\nC.(1)是动量梯度下降（β&#x3D;0.5）；(2)是动量梯度下降（β&#x3D;0.9）；(3)是梯度下降\nD.(1)是动量梯度下降（β&#x3D;0.5）；(2)是梯度下降；(3)是动量梯度下降（β&#x3D;0.9）\n9.假设在一个深度学习网络中，批量梯度下降花费了大量时间时来找到一组参数值，使成本函数J(W[1],b[1],…,W[L],b[L])小。以下哪些方法可以帮助找到J值较小的参数值？A.令所有权重值初始化为0\nB.尝试调整学习率\nC.尝试mini-batch梯度下降\nD.尝试对权重进行更好的随机初始化\nE.尝试使用 Adam 算法\n10.关于Adam算法，下列哪一个陈述是错误的？A.Adam结合了Rmsprop和动量的优点\nB.Adam中的学习率超参数α通常需要调整\nC.我们经常使用超参数的“默认”值β1&#x3D;0,9,β2&#x3D;0.999,ϵ&#x3D;10−8\nD.Adam应该用于批梯度计算，而不是用于mini-batch\n\n答案：\nA\nC\nBC\nB\nD\nD\nBC\nB\nBCDE\nD\n\n","tags":["深度学习"]},{"title":"机器学习 day01初识机器学习","url":"/2021/07/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day01%E5%88%9D%E8%AF%86%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","content":"01 监督学习\n监督学习是指我们给算法一个数据集，其中包含了正确的答案。算法的目的就是给出更多的正确答案。\n回归是指我们设法预测连续值的属性，可以应用在预测房子价格等方面。\n分类是指我们设法预测离散值的输出(0或1)，可以应用在判断账户是否被入侵等方面。\n\n02 无监督学习\n无监督学习也会给一个数据集，但是数据集不包括正确答案(里面的数据要么都有相同的标签要么都没有标签)。无监督学习会将数据分为一个个不同的簇，这就是聚类算法。\n聚类算法可以应用在|搜集新闻并将相关新闻组合在一起|星系形成理论|市场销售等领域\n\n\n建议使用Octave免费开源的软件，许多学习算法都可以用几行代码将其实现。例如svd函数(奇异值分解)已经作为线性代数常规函数内置在Octave中了。\n","tags":["机器学习"]},{"title":"机器学习 day02单变量线性回归","url":"/2021/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day02%E5%8D%95%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","content":"01 模型描述为了更好的描述监督学习问题，需要给出训练集并以此构建一个模型。\n\n下面先学习几个符号：\n\nm:代表的是训练集有几个\nx:代表的是输入的特征\ny:代表的是输出，也就是预测的目标变量\nh:代表假设函数，引导从x得到y的函数\n\n02 代价函数（平方误差函数）\n可以通过代价函数来衡量假设函数的准确性。\n\n代价函数取值越小，假设函数就越准确。\n\n\n\n\n代价函数有助于我们弄清楚如何把最有可能的直线与我们的数据相拟合。\n\n在线性回归中，我们要解决的是最小化问题\n\n代价函数是解决回归问题最常用的手段\n\n\n\n03 梯度下降梯度下降法：可以将代价函数最小化\n\n一般将两个参数初始化为0，再不断的改变参数的值，使得代价函数取值达到最小。\n\n\na：代表学习率（永远为正），用来控制使用梯度下降时，迈出步子的大小。下面是a太小与太大的情况。\n\n\n\n导数的含义：针对于只有一个参数的，两种不同初始点的情况分析。\n\n\n\n事实上，当取值越接近最优解时，梯度下降的幅度也就越小，因为导数始终向0靠拢。\n\n\n04 线性回归的梯度下降\n将代价函数带入梯度下降算法，并求偏导数可得：\n\n\n\n将所求的偏导数带回梯度下降算法\n\n\n\n通过梯度下降算法，一步步的进行，最终可以得到与数据最拟合的直线\n\n\n","tags":["机器学习"]},{"title":"机器学习 day03线性代数基础","url":"/2021/07/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day03%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/","content":"01 矩阵与向量\n小写字母表示向量：a b c\n大写字母表示矩阵：A B C\n\n02 加法和标量乘法\n只有维度相同的矩阵才能相加\n一个数乘一个矩阵与一个矩阵乘一个数的结果相同\n\n\n03 矩阵向量乘法\n矩阵与向量相乘\n\n\n\n例子：\n\n\n\n将一个方程转化为矩阵向量相乘的形式\n\n\n04 矩阵相乘\n矩阵相乘计算原理：只需将第二个矩阵的每一列提取出来，计算矩阵与向量相乘，最终将其拼接成为最终答案。\n\n\n\n将三个方程转化为两个矩阵相乘的形式\n\n\n05 矩阵乘法特性\n不能使用乘法交换律（单位矩阵除外），会改变结果的维度及数值\n\n\n\n矩阵与实数一样，都符合乘法结合律\n\n\n06 逆和转置\n只有方阵才有逆矩阵\n\n\n\n矩阵的转置：将A的第一行变成A的转置的第一列，将A的第二行变成A的转置的第二列。。。。。。\n\n\n","tags":["机器学习"]},{"title":"机器学习 day04多变量线性回归","url":"/2021/07/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day04%E5%A4%9A%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","content":"01 多元线性回归–多特征向量情况下的假设形式\n一些符号表示：\n\n\n\n简化下面等式的表达方法：向量内积转化\n\n\n02 多元梯度下降算法\n多元线性回归方程+代价函数+梯度下降函数\n\n\n\n单元及多元线性回归的梯度下降法对比\n\n\n03 多元梯度下降法–特征缩放\n特征缩放的目的只是为了运行更快。使特征值比较接近，使图像变得比较圆。以至于梯度下降的速度更快，收敛所需要的迭代次数更少，收敛更快。缩放前后对比图如下：\n\n\n\n特征值的取值别太大也别太小，与下面这个范围足够接近最好。\n\n\n\n均值归一化的工作：X &#x3D;（当前值-平均值）&#x2F;【（最大值-最小值）只要是这个范围左右就可以】\n\n\n04 多元梯度下降法–学习率\n梯度算法正常工作图如下：代价函数随迭代次数的变化，最终收敛。\n\n\n\n如果所得图像不是一直减小的，那么需要减小学习率，当然学习率也不能过小，否则梯度下降将会十分缓慢，迭代次数无限增加。\n\n\n\n得到一个不错的学习率：按照三的倍数来取值，尝试一系列的学习率，找到个太小的值，再找到另一个太大的值，然后取太大的值，或者比太大的值略小的比较合理的值\n\n\n05 特征和多项式回归\n特征可以根据自己的需求选择合适的特征，例如将两个不同的特征相乘得到一个新的特征\n如果只用多次函数，适当使用特征缩放将起到很好的效果：\n\n\n\n可以有多种合理的选择，比如也可以是平方根。\n\n\n06 正规方程–区别于迭代方法的直接解法\n正规方程：对代价函数求偏导数，并将其置0，就可以得到使代价函数最小的值。\n\n\n\n方程的形式及例子：\n\n\n\n使用正规方程就不用对特征进行缩放了。\n\n选择合适的算法（梯度下降还是正规方程）一般特征&lt;10000时选用正规方程直接求解，他们二者的优缺点：\n\n\n\n07 正规方程在矩阵不可逆情况下的解决方法\n在Octave中pinv（伪逆）与inv（逆）是求逆矩阵的，就算矩阵没有逆，pinv也会求出它的逆。\n\n首先看是否有多余的特征（两个特征线性相关），选择进行删除，直到没有多余的为止；再观察是否特征过多，选择没有影响的特征进行删除。\n\n\n\n","tags":["机器学习"]},{"title":"机器学习 day05Octave教程","url":"/2021/07/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day05Octave%E6%95%99%E7%A8%8B/","content":"01 基本操作\n注释表达：%\n&gt;&gt; 1~= 2 %注释ans = 1\n\n\n\n不等号表达：~&#x3D;\n&gt;&gt; 1~= 2ans = 1\n\n\n\n隐藏提示命令：PS1(‘&gt;&gt; ‘);\noctave:6&gt; PS1(&#x27;&gt;&gt; &#x27;);&gt;&gt;\n\n\n\n想分配一个变量，但是不想在屏幕上显示结果：只需在结尾加分号（;）\n&gt;&gt; a = pi;&gt;&gt; a = pia = 3.1416\n\n\n\n显示命令：disp( );\n&gt;&gt; disp(a);3.1416\n\n用disp( );显示字符串\n&gt;&gt; disp(sprintf(&#x27;2 decimals:%0.2f&#x27;,a)) %0.2f:小数点后两位2 decimals:3.14\n\n显示更多的小数点后几位：format long\n&gt;&gt; format long&gt;&gt; aa = 3.141592653589793\n\n\n\n显示少量的小数点后几位：format short\n&gt;&gt; format short&gt;&gt; aa = 3.1416\n\n\n\n建立一个矩阵：\n\n\n&gt;&gt; A = [1 2;3 4;5 6]A =   1   2   3   4   5   6&gt;&gt; A = [1 2;&gt; 3 4;&gt; 5 6]A =   1   2   3   4   5   6\n\n\n\n\n建立向量：\n\n&gt;&gt; v = [1 2 3] %行向量v =   1   2   3&gt;&gt; v = [1; 2; 3] %列向量v =   1   2   3&gt;&gt; v = 1:0.1:2 %从1开始每次增加0.1到2的行向量v =    1.0000    1.1000    1.2000    1.3000    1.4000    1.5000    1.6000    1.7000    1.8000    1.9000    2.0000&gt;&gt; V = 1:6 %从1到6的整数V =   1   2   3   4   5   6\n\n\n生成单位矩阵\n\n&gt;&gt; ones(2,3) %2×3的ans =   1   1   1   1   1   1\n\n\n生成零矩阵\n\n&lt;&lt; zeros(2,3)ans =   0   0   0   0   0   0\n\n\n随机生成0到1的值\n\n&lt;&lt; rand(3,3)ans =   0.914686   0.131127   0.563647   0.296402   0.590713   0.134373   0.243013   0.477658   0.071331\n\n\n生成服从高斯分布的随机数：均值为0，标准差或者方差为1\n\n&lt;&lt;  w = randn(1,3)w =  -0.1177   2.0111   0.7261\n\n\n绘制直方图：hist( ):均值为-6，方差为10，标准差为根号10\n\n\n\n生成单位矩阵：eye( )\n\n&lt;&lt; eye(4)ans =Diagonal Matrix   1   0   0   0   0   1   0   0   0   0   1   0   0   0   0   1\n\n\n显示帮助：help eye;help help;按q退出\n\n显示矩阵大小:size( )\n\n\n&lt;&lt; A = [1 2; 3 4; 5 6]A =   1   2   3   4   5   6&lt;&lt; size(A)ans =   3   2&lt;&lt; size(A,1) %显示行数ans = 3&lt;&lt; size(A,2) %显示列数ans = 2\n\n\n返回最大维度大小：length( )|一般对向量使\n\n&lt;&lt; length(A)ans = 3 %3×2，最大维度为3&lt;&lt; length([1;2;3;4;5])ans = 5\n\n02 移动数据\n显示当前在内存中存储的所有变量：who\nwhos显示更加完善的信息\n\n&lt;&lt; whoVariables visible from the current scope:A    ans&lt;&lt; whosVariables visible from the current scope:variables in scope: top scope   Attr Name        Size                     Bytes  Class   ==== ====        ====                     =====  =====        A           3x2                         48  double        ans         1x10                        10  charTotal is 16 elements using 58 bytes\n\n\n载入文件格式：load+文件；load(‘文件’)\n删除某个变量：clear+变量\n存储数据到硬盘中：save+存储文件名+数据\n在找矩阵某一个元素时，：表示这一行或者这一列的元素\n\n&lt;&lt; A(2,1)ans = 3&lt;&lt; A(2,:)ans =   3   4&lt;&lt; A(:,2)ans =   2   4   6\n\n\n索引操作：同时取得1、3行所有元素\n\n&lt;&lt; A([1 3],:)ans =   1   2   5   6\n\n\n将第二列用其他元素代替\n\n&lt;&lt; A(:,2) = [10; 11; 12]A =    1   10    3   11    5   12    \n\n\n在A的右侧附加一列\n\n&lt;&lt; A = [A,[100; 200; 300]]A =     1    10   100     3    11   200     5    12   300\n\n\n把A所有元素放在单独的一列\n\n&lt;&lt; A(:)ans =     1     3     5    10    11    12   100   200   300\n\n\n将两个矩阵结合在一起\n\n&lt;&lt; A = [1 2; 3 4; 5 6]A =   1   2   3   4   5   6&lt;&lt;  B = [11 12; 13 14; 15 16]B =   11   12   13   14   15   16&lt;&lt; C = [A B] %左右结合C =    1    2   11   12    3    4   13   14    5    6   15   16&lt;&lt; C = [A;B] %上下结合C =    1    2    3    4    5    6   11   12   13   14   15   16\n\n03 计算数据\n两个矩阵相乘\n\n&lt;&lt; A = [1 2; 3 4; 5 6]A =   1   2   3   4   5   6&lt;&lt;  B = [11 12; 13 14; 15 16]B =   11   12   13   14   15   16&lt;&lt; C = [1 1;2 2]C =   1   1   2   2&lt;&lt; A*Cans =    5    5   11   11   17   17\n\n\n两个矩阵对应数相乘\n\n&lt;&lt; A.*Bans =   11   24   39   56   75   96\n\n\nA的每个元素进行乘方\n\n&lt;&lt; A.^2ans =    1    4    9   16   25   36\n\n\n求V对应元素的倒数\n\n&lt;&lt; V = [1; 2; 3]V =   1   2   3&lt;&lt; 1 ./Vans =   1.0000   0.5000   0.3333\n\n\n以e为底，v中元素为指数的幂运算\n\n&lt;&lt; exp(V)ans =    2.7183    7.3891   20.0855\n\n\n求绝对值：abs( )\n求相反数直接加-；例如-V\n将V中每个元素+1\n\n&lt;&lt; V + ones(length(V),1) %与V +1等价ans =   2   3   4\n\n\n求A的转置\n\n&lt;&lt; A&#x27;ans =   1   3   5   2   4   6\n\n\n求X最大的数及其索引\n\n&lt;&lt; X = [1 15 2 0.5]X =    1.0000   15.0000    2.0000    0.5000&lt;&lt; val = max(X)val = 15&lt;&lt; [val,ind] = max(X)val = 15ind = 2%如果A是矩阵，那么将求出每一列最大值&lt;&lt; max(A)ans =   5   6\n\n\nX中每个元素与3比较，根据结果返回真和假\n\n&lt;&lt; X&lt;3ans =  1  0  1  1\n\n\n找到比3小的数并返回其索引\n\n&lt;&lt; find(X&lt;3)ans =   1   3   4\n\n\n生成一个幻方矩阵，每行、每列、每个对角线加起来都等于一个数\n\n&lt;&lt; B = magic(3)B =   8   1   6   3   5   7   4   9   2\n\n\n找出B中&gt;&#x3D;7的元素，并返回下标\n\n&lt;&lt; [r,c] = find(B &gt;=7)r =   1   3   2c =   1   2   3\n\n\nX中所有元素相加\n\n&lt;&lt; sum(X)ans = 18.500\n\n\nX中所有元素相乘\n\n&lt;&lt; prod(X)ans = 15\n\n\n对X中元素向下取整\n\n&lt;&lt; floor(X)ans =    1   15    2    0\n\n\n对X中元素向上取整\n\n&lt;&lt; ceil(X)ans =    1   15    2    1\n\n\n取两个随机矩阵中较大的数组合成一个较大值的矩阵\n\n&lt;&lt;  max(rand(3),rand(3))ans =   0.6957   0.9634   0.7179   0.8404   0.9784   0.8319   0.5236   0.8063   0.6697\n\n\n取每一列&#x2F;行最大值\n\n&lt;&lt; max(B,[],1)ans =   8   9   7&lt;&lt; max(B,[],2)ans =   8   7   9\n\n\n求每一行、每一列、对角线相加\n\n&lt;&lt; C = magic(9)C =   47   58   69   80    1   12   23   34   45   57   68   79    9   11   22   33   44   46   67   78    8   10   21   32   43   54   56   77    7   18   20   31   42   53   55   66    6   17   19   30   41   52   63   65   76   16   27   29   40   51   62   64   75    5   26   28   39   50   61   72   74    4   15   36   38   49   60   71   73    3   14   25   37   48   59   70   81    2   13   24   35&lt;&lt; sum(C,2)ans =   369   369   369   369   369   369   369   369   369&lt;&lt; sum(C,1)ans =   369   369   369   369   369   369   369   369   369&lt;&lt; sum(sum(C.*eye(9))) %正对角线相加ans = 369&lt;&lt; sum(sum(C.*flipud(eye(9)))) %副对角线相加，flipud表示使矩阵垂直翻转ans = 369\n\n04 数据绘制\n绘制一个正弦函数图像：plot( );\n\n&lt;&lt; t = [0:0.01:0.98];&lt;&lt; y1 = sin(2*pi*4*t);&lt;&lt; plot(t,y1);\n\n\n\n绘制一个余弦函数图像：plot( );\n\n&lt;&lt; y2 = cos(2*pi*4*t);&lt;&lt; plot(t,y2);\n\n\n\n在旧的图像上面绘制新的图像：hold on;\n\n&lt;&lt; t = [0:0.01:0.98];&lt;&lt; y1 = sin(2*pi*4*t);&lt;&lt; y2 = cos(2*pi*4*t);&lt;&lt; plot(t,y1);&lt;&lt; hold on;&lt;&lt; plot(t,y2,&#x27;r&#x27;);\n\n\n\n加上横与纵轴的标签，标记两条函数，输入标题，并保存到桌面\n\n&lt;&lt; xlabel(&#x27;time&#x27;)&lt;&lt; ylabel(&#x27;value&#x27;)&lt;&lt; legend(&#x27;sin&#x27;, &#x27;cos&#x27;)&lt;&lt; title(&#x27;my plot&#x27;)&lt;&lt; cd &#x27;C:\\Users\\1\\Desktop&#x27;; print -dpng &#x27;plot.png&#x27;\n\n\n\n\n为不同图像标号：就可以同时有两个图像\n\n&lt;&lt; figure(1); plot(t,y1);&lt;&lt; figure(2); plot(t,y2);\n\n\n\n将一个界面分为两个格子，其中正弦占第一个，余弦占第二个\n\nsubplot(1,2,1);&lt;&lt; plot(t,y1);&lt;&lt; subplot(1,2,2);&lt;&lt; plot(t,y2);\n\n\n\n设置横竖轴的范围\n\n&lt;&lt; plot(t,y1);&lt;&lt; axis([0.5 1 -1 1])\n\n\n\n可视化矩阵\n\n&lt;&lt; A = magic(5)A =   17   24    1    8   15   23    5    7   14   16    4    6   13   20   22   10   12   19   21    3   11   18   25    2    9&lt;&lt; imagesc(A)\n\n\n\n生成颜色图像、灰度分布图并在右边加入一个颜色分布\n\n&lt;&lt; imagesc(A), colorbar, colormap gray;\n\n\n\n添加环境路径，找文件时，即使不在文件环境，也可以使用其中的函数\n\naddpath(&#x27;C:\\Users\\1\\Desktop&#x27;)\n\n05 控制语句\noctave可以返回多个返回值\n\n函数定义\n\n\nfunction J = costFunctionJ(X,y, theta)  m = size(X,1);  predictions = X*theta;  sqrError = (predictions-y).^2;  J = 1/(2*m) * sum(sqrError);\n\n\n函数使用\n\n&lt;&lt; addpath(&#x27;C:\\Users\\1\\Desktop&#x27;)&lt;&lt; X = [1 1; 1 2; 1 3]X =   1   1   1   2   1   3&lt;&lt; y = [1; 2; 3]y =   1   2   3&lt;&lt; theta = [0;1];&lt;&lt; J = costFunctionJ(X,y, theta)J = 0&lt;&lt; theta = [0;0];&lt;&lt; J = costFunctionJ(X,y, theta)J = 2.3333&lt;&lt; (1^2+2^2+3^2)/(2*3)ans = 2.3333\n\n06 矢量\n非向量化与向量化的代码对比\n\n\n\n用C++语言及C++线性库所写代码\n\n\n\n向量化\n\n\n","tags":["机器学习"]},{"title":"机器学习 day06Logistic回归","url":"/2021/07/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day06Logistic%E5%9B%9E%E5%BD%92/","content":"01 分类\n针对于离散值来进行分类：y &#x3D; {0，1}\n0表示负类，没有什么东西\n1表示正类，有什么东西\n不建议将线性回归函数应用于分类情况中\n使用线性回归在分类问题，如果一个值远离其他值，将会使线性回归算法不够准确。\n\n\n\nLogistic回归算法的预测值一直介于0和1之间，并不会像线性回归算法大于1或者小于0\n\n02 假设陈述\n假设陈述：当有一个分类问题的时候，我们要使用哪个方程来表示我们的假设。\nLogistic函数的形式如下：对线性回归方程稍作修改。\n\n\n\n输出某个数字，我们会把这个数字当作对一个输入x，y&#x3D;1的概率估计\n\n\n03 决策界限\n决策界限可以帮助我们理解Logistic回归的假设函数在计算什么。\n可以从图看出什么时候预测y &#x3D; 1;什么时候预测y &#x3D; 0;\n\n\n\n决策边界将一个平面划分为两个区域，其中一片区域假设函数预测y &#x3D; 1；另一片区域假设函数预测y &#x3D; 0。只要我们确定好了参数，我们就将完全确定决策边界。例如下图所示：可以得出直线 X1 + X2 &#x3D; 3就是决策边界。\n\n\n\n例题：我们怎么才能使用Logistic回归来拟合这些数据呢？多项式回归及线性回归可以在特征中添加额外的高阶多项式，Logistic回归也可以使用。\n\n\n\n决策边界不是训练集的属性，而是假设本身及其参数的属性，只要给定了参数向量就可以确定决策边界\n\n04 代价函数如何拟合Logistic回归模型的参数。当代价函数为0时，可以得出与预测值想拟合。\n\n\n如果将代价函数带入到Logistic回归中可以得到左侧图像非凸函数，可是我们想要得到右侧这样得凸函数。\n\n\n\n因此我们需要重新找到个代价函数可以用在Logistic回归中，保证找到全局最小值。下面使y &#x3D; 1情况下。\n\n\n\n下面使y &#x3D; 0情况下\n\n\n05 简化代价函数与梯度下降\n简化后得代价函数\n\n\n\n式子是在统计学中得极大似然法得来得，他是统计学中为不同模型快速寻找参数得方法。同时他是凸的。\n\n\n\n如何最小化代价函数：使用梯度下降算法。虽然Logistic回归中梯度下降算法与线性回归中的梯度下降算法长的一样，但是由于假设的定义发生了变化，所以实际上是两种截然不同的。\n\n\n06 高级优化\n一些高级算法的优缺点\n\n\n\n自动求使代价函数最小的参数，使用代码将其实现\n\n\n\n写一个函数，他能返回代价函数值以及梯度值\n\n\n07 多元分类：一对多使用逻辑回归来解决多类别分类问题\n\n\n训练一个逻辑回归分类器，预测i类别y &#x3D; i的概率。在三个分类器中输入x，在其中选择h(x)最大的那个类别。也就是选择出三个里面可信度最高，效果最好的的哪个分类器。\n\n\n\n无论i是多少，我们都能得到一个最高的概率值，我们预测y就是那个值。\n\n\n","tags":["机器学习"]},{"title":"机器学习 day07正则化","url":"/2021/07/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day07%E6%AD%A3%E5%88%99%E5%8C%96/","content":"01 过拟合问题正则化可以减少过度拟合问题\n\n1.1  线性回归过拟合问题\n欠拟合 | 刚好合适 | 过拟合\n\n\n\n过度拟合问题将会在变量过多的时候出现，这时训练出的假设能够很好的拟合训练集（所以代价函数实际上可能非常接近于0。或者恰好等于0），但是可能会得到图三这样的曲线，去拟合训练集，以至于它无法泛化到新的样本中。\n泛化是指一个假设模型应用到新样本的能力\n\n1.2  逻辑回归过拟合问题\n欠拟合 | 刚好合适 | 过拟合\n\n\n\n如果我们有过多的特征变量而只有少量的训练集就会出现过拟合问题。\n有两种方法解决过拟合问题：\n尽量减少特征变量的数量（模型选择算法会自动选择哪些变量保留，哪些舍弃）\n正则化：减少量级或者参数的大小\n\n\n\n02 代价函数\n正则化将多阶函数变成二阶函数（将参数尽可能减小），这些参数越小，我们得到的图像也就越圆滑越简单。\n\n\n\n一般来说我们只对参数1以及1之后的进行正则化\n在对代价函数进行修改，添加正则化项的目的是为了缩小参数的值。\n正则化参数是为了控制两个不同目标之间的取舍\n正则化参数如果过大，那么参数都会接近于0，这样就相当于把假设函数的全部项都忽略了，最终变成了欠拟合。\n\n\n03 线性回归的正则化\n线性回归正则化的梯度下降法\n\n\n\n线性回归正则化的正规方程法\n\n\n\nm&lt;&#x3D;n，说明矩阵是不可逆的，但是当正则参数&gt;0，算出来的矩阵一定是可逆的。\n\n\n04 Logistic 回归的正则化\nLogistic 回归添加正则化项\n\n\n\nLogistic 回归的正则化的梯度下降法\n\n\n\n如何在更高级的算法中使用正则化：定义一个costFunction函数，以theta作为输入。在fminunc函数中括号里写上@cosFunction。\nfminunc的意思是函数在无约束条件下的最小值，fminunc函数会将costFunction函数最小化，\n\n\n","tags":["机器学习"]},{"title":"机器学习 day08神经网络学习","url":"/2021/07/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day08%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/","content":"01 非线性假设为什么已经有线性回归和逻辑回归算法了，还要学习神经网络？\n\n\n因为有特别多的特征，许多机器学习都需要学习复杂的非线性假设。如果使用逻辑回归算法，由于项数过多，可以能会导致过拟合问题，此外也存在运算量过大的问题。如果项数只包括二次项的的子集，这样将二次项的数量减少到100个，但是最有可能拟合出右下角椭圆而拟合不出左上角复杂的分界线。\n\n\n\n下图车子例子所示：如果是一张50 * 50 像素的图像， 则会有 50 * 50 &#x3D; 2500个像素单位（如果是彩色，每个像素又有0-255的RGB取值。即有 2500 * 3 &#x3D; 7500），特征数量则有约 n^2 &#x2F; 2 约 3000000 个特征数量。\n\n\n02 神经元与大脑神经网络能够很好的解决不同的机器学习问题\n\n\n神经网络的起源及发展\n\n\n\n神经元是一个计算单元，它从输入通道接受一定数量的信息，并做一些计算，然后将结果通过它的轴突传送到其他节点，或者大脑中其他神经元。\n\n\n03 模型展示\n神经网络模拟了大脑中的神经元或者神经网络。\n在神经网络里我们将使用一个很简单的模型来模拟神经元工作，我们将神经元模拟成一个逻辑单元。黄色代表类似于神经元细胞体的东西，经过“输入”-&gt;“计算”-&gt;“输出”三个步骤，因为X0（偏置单元或偏置神经元）总是1，会根据实际情况判断时候加上X0。\n在神经网络中激活函数是指非线性函数g(z)。单个神经元图如下：\n\n\n\n在神经网络中第一层叫做输入层，因为我们在这一层输入特征；第二层叫做隐藏层（任何一个非输入层和非输出层），隐藏层的值在训练中是看不到的；最后一层叫输出层，因为在这一层输出假设的最终计算结果；\n\n\n\nai(j)代表第j层第i个神经元或者单元的激活项，激活项是由一个具体神经元计算并输出的值。参数(j)就是权重矩阵，它控制从某一层到另外一层的映射。计算三个隐藏单位的值及输出如下：\n\n\n\n如何高效进行计算，并展示一个向量化的实现方法。\n\n前向传播方法\n\n\n\n下面这个神经网络所作的事情就像是逻辑回归，它不是以原本的X1、X2、X3作为特征，而是用a1、a2、a3作为新的特征\n\n\n04 例子与直觉理解神经网络计算复杂非线性函数的输入\n\n\nX1 AND X2运算\n\n\n\nX1 OR X2运算\n\n\n\nNOT X1\n\n\n\nX1 XNOR X2\n\n\n05 多元分类\n要是在神经网络中实现多类别分类，采用的方法本质是一对多法的拓展（其中Xi代表图像，Yi代表那些向量）\n\n\n","tags":["机器学习"]},{"title":"机器学习 day09神经网络参数的反向传播算法","url":"/2021/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day09%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/","content":"01 代价函数\n有m组训练样本，L代表神经网络结构的总层数，S_l代表第L层的单元数也就是神经元的数量（不包括第L层的偏差单元）。其中二元分类与多类别分类问题如下：\n\n\n\n应用于神经网络的代价函数：h(x)是一个k维向量，h(x)_i代表第i个输出；k的求和符号应用于y_k和h_K,是因为我们主要是将第k个输出单元的值和y_k的值的大小作比较；y_k的值就是这些向量中其应属于哪个类的量。\n\n\n02 反向传播算法反向传播算法是计算代价函数关于所有参数的导数或者偏导数的一种有效方法。\n\n\n使用前向传播方法来计算的顺序，计算一下在给定输入的时候，假设函数是否会真的输出结果。\n\n\n\n反向传播算法中，下图上方下标j上标（l)代表了第l层的第j个结点的误差，下图上方下标j上标（l)实际上就是假设的输出值和训练集y值之间的差。反向传播算法类似于把输出层的误差反向传播给了第三层，然后再传播给第二层，注意没有第一层（第一层可以直观的观察到，没有误差）。\n\n\n\n如何实现反向传播算法来计算这些参数的偏导数：\n\n首先将每一个i和j对应的三角形（三角形是上图上方下标j上标（l)的大写）置0\n接下来遍历整个训练集，将输入层的激活函数设定他为第i个训练样本的输入值\n接下来用正向传播来计算第二层的激活值，然后第三层，最后到最后一层\n使用输出值来计算这个输出值对应的误差项（假设输出-目标输出）\n再通过反向传播算法计算前几层的误差项，一直到第二层\n最后通过三角形来累计我们再前面写好的偏导数项\n\n\n跳出循环后，通过下面的式子计算D(j等于0和j不等于0的情况)，计算出来的D正好就是关于每个参数的偏导数，然后可以用梯度下降法或者一些其他的高级优化算法。\n\n\n\n03 理解反向传播\n理解前向传播\n\n\n\n代价函数应用在只有一个输出单元的情况\n\n\n\n理解反向传播：代价函数是一个关于标签y和神经网络中h(x)的输出值的函数，只要稍微将z(l)j改一下，就会影响神经网络的h(x)，最终改变代价函数的值。\n\n\n04 使用注意：展开参数把参数从矩阵展开向量，以便在高级最优化步骤中的使用需要\n\n\n高级最优化算法都假定theta和initialTheta初始值都是参数向量，也许是n或者n+1维，同时假定这个代价函数的第二个返回值(梯度值)也是n维或者n+1维向量。但是现在在神经网络，参数不再是向量而是矩阵，三个参数在Octave表达如下；梯度矩阵在Octave表达也如下：\n\n\n\n取出矩阵，并将其展开成向量传入theta中，并得到梯度返回值。\nthetaVec就是将这些矩阵全部展开成为一个很长的向量；DVec同理。reshape将相应元素组合起来成相应矩阵。\n\n\n\n上面步骤通过Octave实现如下：\n\n&lt;&lt;Theta1 = ones(10,11)Theta1 =   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1&lt;&lt;Theta2 = 2*ones(10,11)Theta2 =   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2&lt;&lt;Theta3 = 3*ones(1,11)Theta3 =   3   3   3   3   3   3   3   3   3   3   3&lt;&lt;thetaVec = [ Theta1(:);Theta2(:);Theta3(:)];&lt;&lt;size(thetaVec)ans =   231     1&lt;&lt;reshape(thetaVec(1:110),10,11)ans =   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1&lt;&lt;reshape(thetaVec(111:220),10,11)ans =   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2   2&lt;&lt;reshape(thetaVec(221:231),1,11)ans =   3   3   3   3   3   3   3   3   3   3   3\n\n\n将这一方法应用于我们的学习算法\n\n\n05 梯度检测因为反向传播使用时会出现一些bug，而梯度检测可以很好的解决这些问题，确保前向传播及反向传播都百分百正确。\n\n\n求出该点导数的近似值（参数是实数的情况）\n\n\n\n当参数维向量参数的时候\n\n\n\n在Octave中为了估算导数所要实现的\n\n\n\n总结下如何实现数值上的梯度检验：（注意反向传播算法比梯度检测效率高，检测完一定要关闭梯度检测）\n\n\n06 随机初始化\n在神经网络中将所有参数初始为0，没有任何意义，所有输入都是一样，也就意味这最后输出就输出一个特征，阻挡了神经网络学习任何有趣的东西，我们称之为高度冗余。\n\n\n\n因此就应该使用随机初始化方法。值得注意的是这里的EPSILON与梯度检测中的完全没有关系。\n\n\n\n为了训练神经网络首先将权重随机初始化为一个接近0范围在-EPSILON到EPSILON之间，然后进行反向传播，在进行梯度检测，最后梯度下降算法或其他高级优化算法来最小化代价函数（关于参数sita的函数）。\n\n07 组合到一起\n训练神经网络做的第一件事就是选择一种合适的网络架构（神经元之间的连接模式），注意输出时是输出一个向量y。\n\n\n\n训练神经网络所需要的步骤\n\n\n\n\n反向传播算法是为了算出梯度下降算法的下降方向\n\n","tags":["机器学习"]},{"title":"机器学习 day10应用机器学习的建议","url":"/2021/07/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day10%E5%BA%94%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%BB%BA%E8%AE%AE/","content":"01 决定下一步做什么\n开发一个机器学习系统，或者想试着改进一个机器学习系统的性能，应如何决定选择哪条路。不要随意选择。\n\n\n\n机器学习诊断法能够提前发现某些方法是无效的。\n\n\n02 评估假设\n将所有数据分为训练集和测试集，最经典的分割方法就是按照7:3的比例。\n\n\n\n线性回归算法和平方误差标准学习和测试学习算法，从训练集学习获得参数，在将参数带入测试集得到测试误差。\n\n\n\n训练和测试逻辑回归的步骤及用错误分类（0&#x2F;1分类错误）来定义测试误差。0&#x2F;1表示了你预测的分类是正确或错误的情况。\n\n\n03 模型选择和训练、验证、测试集\n模型选择问题（想要确定对于一个数据集最合适的多项式次数，怎样选用正确的特征来构造学习算法或者假如你需要选择学习算法中的正则化参数）\n\n模型选择问题：用不同的模型拟合数据集得到参数，接着对所有这些模型求出测试集误差，然后根据哪个模型有最小的测试误差来选择使用哪个模型。\n\n\n\n\n为了解决模型选择出现的问题，我们通常会采用如下的方法来评估一个假设。我们把数据分为三个部分，分别是训练集、验证集、测试集。分配比例分别是6:2:2。\n\n\n\n定义训练误差、交叉验证误差和测试误差\n\n\n\n用验证集选择模型而不是原来的测试集。省下来的测试集可以用它来衡量或者估算算法选择出的模型的泛化误差了。\n\n\n04 诊断偏差与方差如果一个算法表现得不理想，要么是偏差比较大，要么是方差比较大。换句话说要么欠拟合要么过拟合。\n\n\n训练误差随着我们增大多项式的次数而减小；随着我们增大多项式的次数，我们对训练集拟合的也就越好。对于验证误差来说，如果d为1，会有较大误差；如果d为中等次数大小，能够更好的拟合；当d为4时，也就可能过拟合。\n\n\n\n对于验证误差来说，左边这一端对应的就是高偏差问题；右边这一端对应的就是高方差问题。如果训练误差很小，并且验证误差远大于训练误差说明出现过拟合问题（高方差）。如果是高偏差，则训练误差和验证误差都很大。\n\n\n05  正则化和偏差、方差\n第一个图是高偏差，欠拟合；中间正合适；最后一个图是高方差，过拟合。\n\n\n\n我们对训练、验证、测试误差的定义都是平均的误差平方和，或者是不使用正则化项时，训练集、验证集和测试集的平均的误差平方和的一半。\n\n\n\n自动选择正则化参数的方法：首先选取一系列想要试用的步长，通常来说步长设为2倍速增长，直到一个比较大的值。这样就选取了12个对应的正则化参数。然后对这12个模型分别最小化代价函数，得到完全不同的参数向量。可以把这些模型用不同的正则化参数来进行拟合，然后我们可以用验证集来评价这些参数sita在验证集上的平均的误差平方和，最终选择误差最小的模型。\n\n\n\n当我们改变正则化参数时，我们的假设在训练集和验证集上的表现（对应本节第一个图）\n\n\n06 学习曲线学习曲线可以判断某一学习算法是否处于偏差或者方差问题，还是二者都有。\n\n\n当训练集个数很少的时候，能够十分完美的拟合数据，训练集误差基本为0，但是随着训练集越来越多，训练集误差也就会越来越大，逐渐趋于水平。而验证集误差，随着训练集的个数增加而减小，最终趋于水平。\n\n\n\n在高偏差的情况下，训练集误差和验证集误差最终将十分接近，再增加训练集数量将毫无意义。\n\n\n\n在高方差的情况下，总体来说随着训练集数量的增多，训练集误差将会增加，但是增加的很小。而验证集误差一直都比较高，虽然会有所下降，但是不多。所以增加训练集数量还是很有用的。\n\n\n07 决定接下来做什么\n接下来回到第一节的第一个图，1和2和6对应着高方差的情况，3和4和5对应高偏差的情况（个人理解：高方差就是在多项式的形式下出现的，高偏差就是在项数少的情况下出现的）。\n\n\n\n小型神经网络计算量少，大型神经网络比较容易出现过拟合问题（但是可以用正则化来进行解决），相对来说大型神经网络性能更好。\n还有就是选择隐含层层数的问题，可以将数据分为训练集、验证集还有测试集。用训练集分别训练一层、两层、三层的隐含层，最终用验证集来测试，选出合适的层数。\n\n\n","tags":["机器学习"]},{"title":"机器学习 day11机器学习系统设计","url":"/2021/07/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day11%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","content":"01 确定执行的优先级在实际工作过程中，我们应该优先处理哪些事情\n\n\n以邮件筛选为例，选择邮件的特征向量的方法。通常我们会挑选出在训练集中出现频率最多的n个单词，将其作为特征向量。\n\n\n\n如何在有限时间里让垃圾邮件分类器具有高精准度和低错误率。\n用更复杂的特征变量来描述邮件（可以在邮件标题中获取复杂的特征，来捕捉这封邮件的来源，以此判断是否为垃圾邮件）。\n关注邮件的正文，并构建更复杂的特征。\n来检测单词是否故意出现拼写的错误\n\n\n\n\n02 误差分析误差分析就是一种手动地去检查算法所出现的失误的过程，走向最有成效的道路。\n\n\n通过手动检查分类错误的邮件，来看哪一类分类错误的多，哪一个出现错的情况最多，就着重去构造这类特征，加以训练。\n\n\n\n交叉验证错误率：单一规则的数值评价指标。\n如果只是手动地去检查看看这些例子表现得好不好，会让你很难去决定到底应不应该做出某种决定；但是通过交叉验证错误率就可以直观的看误差率是变大还是变小了，他能告诉你你的想法是提高了还是降低。\n\n\n\n一旦有了一个初始的算法实现，我们就能使用一个强有力的工具，来帮助决定下一步应该做什么：\n看看他所造成的错误：通过误差分析来看看它出现了什么失误，然后以此决定之后的优化方法。\n如果已经有了一个简单粗暴算法实现，又有一个数值评价指标，这些能帮助来试验新的想法，能够快速观察是否能够提高算法的表现，决定应该包含什么，应该舍弃什么。\n\n\n\n03 不对称性分类的误差评估当有倾斜类问题时，使用准确率与召回率来评价学习算法要比用分类误差或者分类准确率好得多。\n\n\n偏斜类：一个类中的样本数与另一个类中的数据相比多很多（比如，没有肿瘤的比有肿瘤的要多得多）。所以说恒把y&#x3D;0算出来的误差将会很小，因为有肿瘤的人很少。\n\n\n\n所以我们想要一个不同的评估度量值：查准率和召回率。其中查准率是指对于所有我们的预测，患有癌症的病人，有多大比率的病人是真正患有癌症的。召回率是指假设如果测试集或者验证集中的病人确实得了癌症，有多大比率正确预测他们得了癌症。也就是如果所有病人都得了癌症，有多少人我们能够正确告诉他们你需要治疗。查准率和召回率越高越好。算法预测值与实际值分别是：1&#x2F;1（真阳性）、0&#x2F;0（真阴性）、1&#x2F;0（假阳性）、0&#x2F;1（假阴性）。\n\n\n04 精确度和召回率的权衡\n在逻辑回归中逻辑输出在0到1之间，其中0.5是个分界值，但是我们想在十分确定得情况下告诉病人真实信息，因此分界值为0.7，甚至0.9（是一个高查准率的模型，但是召回率会变低）。现在我们将分界值设置到较低（有30%几率得病），会得到高召回率，较低得查准率。\n\n\n\n有没有办法自动选取临界值？或者说有不同的算法，我们如何比较不同的查准率和召回率？或者临界值不同，我们怎样决定哪个更好？–如果使用平均值来计算是不可行的，因为如果假设y &#x3D; 1和y &#x3D; 0这两种极端的情况（要么很高召回率、很低查准率，要么很低召回率、很高查准率），他们俩不是好的模型。再此我们使用F值的公式，因为它同时结合召回率及查准率。\n\n\n\n自动选择临界值来决定你希望预测y&#x3D;1还是y&#x3D;0合理的方法：试一试不同的临界值，在检验集进行测试，看哪个临界值可以在检验集得到最高的F。这就是为分类器自动选择临界值的合理方法。\n\n05 机器学习数据在一定条件下，得到大量的数据并在某种类型的学习算法中进行训练，可以是一种有效的方法来获取具有良好性能的学习算法。这种情况一般出现在这些条件对于你的问题都成立，并且可以得到大量数据。\n\n\n并不是拥有最好算法的人能成功，而是拥有最多数据的人能成功。\n\n\n\n如果让一个英语好的选词填空，它可以通过特征x让我们能够准确的预测y，相反的，我们让一个房地产专家预测一个房价，而只告诉它房子的面积，其他特征不告诉，他会很难预测。因此如果这个假设正确可以看出大量数据是很有意义的。\n\n\n\n得到一个低偏差（一个强大的具有很多参数的学习算法，可以很好的拟合复杂的函数）和低方差（如果训练集远大于参数的数量，就不大可能会过拟合）的学习算法（特征值足够并且训练集很庞大）\n\n\n","tags":["机器学习"]},{"title":"机器学习 day12支持向量机","url":"/2021/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day12%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/","content":"01 优化目标支持向量机（SVM）在学习复杂的非线性方程时，能够提供一种更为清晰和更加强大的方式。\n\n\n从逻辑回归开始，稍作改动成为支持向量机\n观察下逻辑回归的假设函数和sigmoid激活函数\n\n\n\n\n\n观察逻辑回归的代价函数，当把整个假设函数的定义代入其中，得到的就是每个样本对总体函数的具体贡献。\n\n\n\n为了构建支持向量机，我们从这个代价函数开始进行少量修改，我们取z&#x3D;1，画出要使用的代价函数，右边都是平的，左边画出一条和最开始的幅度相似的直线，这就是y&#x3D;1时使用的代价函数。同样的做出y&#x3D;0时使用的代价函数。\n\n\n\n有了这些定义后，就可以开始构造支持向量机了，将修改后的代价函数定义带入到原始的逻辑回归代价函数中。支持向量机的代价函数将1&#x2F;m去掉，因为1&#x2F;m是一个常数，不影响得到参数的最优值。对于SVM来说我们将用一个不同的参数来控制第一项A与第二项B的相对权重，如果把C设置的很小，那么B就比A占有更大的权重。于是就得到了支持向量机的总体优化目标\n\n\n\n最后和逻辑回归不同的是，支持向量机并不会输出概率，相对的我们得到的是通过优化这个代价函数得到参数sita，支持向量机它是进行了一个直接的预测y&#x3D;0&#x2F;y&#x3D;1,学习得到参数sita后，这就是支持向量机的假设函数的形式。\n\n\n02 直观上对大间隔的理解\n下面是SVM代价函数，支持向量机不是恰好能正确分类就行，因此需要比0大或者小很多（也就是1或者-1）。\n\n\n\n如果C非常的大，那么当最小化最优目标的时候，将迫切的希望找到一个值使得第一项等于0。在两种情况下，通过选择参数sita使得第一项为0。\n\n\n\n支持向量机会选择尽量把正样本和负样本以最大的间距分开的假设模型。可以看出黑色的决策边界和训练样本的最小距离要更大一些。\n\n\n\n下面的大间距分类器是在常数C被设的非常大情况下得出的，平常情况下会得到黑色线，但是如果在一侧加入异常样本，那么就可能会是粉色的线。如果C不是很大，那么就算是加入异常点也会是黑色线。\n\n\n03 大间隔分类器的数学原理\n向量内积\n\n\n\n支持向量机的优化目标函数，当n&#x3D;2时我们只有两个特征量（也就是只有两个参数sita）。因此对于优化目标函数来说支持向量机做的是最小化参数向量sita的范数的平方。（为了简便都令sita0&#x3D;0）\n\n\n\n将sita转置x(i)替换后的结果写入我们的优化目标函数。令sita0&#x3D;0意味着决策边界必须通过原点(0,0)。下图是支持向量机选择不同的决策边界的情况。（向量sita一定是垂直于决策边界的），支持向量机通过让间距变大，使得p(i)变大，以至于输出一个较小的sita的范数。（为了简便都令sita0&#x3D;0，即使不为0，效果也不变。支持向量机仍然会找出正样本和负样本之间大间距分隔）\n\n\n04 核函数1改造支持向量机算法来构造复杂的非线性分类器。\n\n\n希望拟合一个非线性的判别边界来区分正负实例。一种方法是构造一个复杂多项式特征的集合，在这里我们用f1、f2、f3来表示这些我们将要计算的新的特征变量。\n\n\n\n构造新特征f1、f2、f3的方法：首先手动选取三个点（标记），接着将新特征定义为一种相似度的度量即度量训练样本x与标记的相似度（用下面公式表达）。相似度函数就是一个核函数（这里是高斯核函数）。\n\n\n\n对于这个核函数取两种情况：一种是x与标记点很近，一种是x与标记点很远。\n\n\n\n下面是核函数参数大小不同时的表现：\n\n\n\n选择不同的点，来预测y值是1还是0。可以看出离l_1和l_2近的点预测y值为1（带入下面的预测函数中如果&gt;&#x3D;0说明y&#x3D;1;&lt;0说明y&#x3D;0)。\n\n\n05 核函数2\n特征函数基本上是在描述每一个样本距离样本集中其他样本的距离，下面是这个过程的大纲。\n\n\n\n当已知参数sita时，怎样做出预测的过程。因为标记点的个数等于训练点的个数（m），所以参数向量sita为m+1维\n\n\n\n但是怎样得到参数sita？通过解决最小化的问题，你就得到了支持向量机的参数sita。\n\n\n\n在使用支持向量机时，怎么选择支持向量机中的参数C？–C相当于正则化参数的倒数，根据需求选择C。高斯核函数中的参数？–当高斯核函数中的参数相对较大时，图像将会倾向于变得相对平滑，可能会带来较高的偏差和较低的方差；当高斯核函数中的参数相对较小时，图像弧度将会相对大，可能会带来低偏差和较高的方差。（图像跟第四节倒数第二个相配套）\n\n\n06 使用SVM高度优化好的软件库：liblinear、libsvm\n\n\n我们虽然不用自己写SVM优化库，但是还是有几件事需要我们做：\n参数C的选择\n选择内核参数或者想要使用的相似函数\n\n\n对于内核函数其中第一个选择是不需要任何内核参数，没有内核参数的理念又叫线性核函数。为什么想要做这件事呢？如果有大量的特征n，而训练集m很小，也许就想拟合一条线性的判定边界，而不去拟合一条复杂的非线性函数。因此选择线性核函数可能很合适。\n对于内核函数其中第二个选择是可以构造个高斯内核函数。n很少，m很多，使用高斯内核函数可能很合适。\n\n\n\n如果选择要用高斯核函数，接下来要做的事：\n根据使用的支持向量机软件包可能需要实现一个核函数或者相似函数。因此如果使用Octave来实现支持向量机的话，那么就需要提供一个函数来计算核函数的特征值，它将自动的生成所有特征变量。因此对应一个i需要计算f_i。\n如果有大小很不一样的特征变量，要在使用高斯核函数之前，将这些特征变量的大小按比例归一化。下面以计算x与l之间的范数为例，如果第一特征房子面积特别大，第二特征房间个数在1到5之间，那么间距可能都是由特征一所决定，所以需要归一化。\n\n\n\n\n\n默塞尔定理是确保所有的SVM包能够用大类的优化方法并可以快速得到参数sita。其他核函数也都满足默塞尔定理，如下所示：多项式核函数（一个是自己添加的值可以是0、1、3…，还有一个是指数可以修改）。\n\n\n\n在多类分类中，输出在多个类别中恰当的判定边界。如果有k个类别用以将每个类别从其他的类别中区分开来。例如第一个参数sita_1,y&#x3D;1作为正类别，其他作为负类别得到的，以此类推。\n\n\n\n逻辑回归开始构造了SVM，然后更改下代价函数。如果n相对于m足够大，那么我通常使用逻辑回归或者线性核函数；如果n很小，m适中，通常使用高斯核函数的SVM比较好；当n很小m很大，建议手动地创建拥有更多的特征变量，然后用逻辑回归或者不带核函数的支持向量机。这种情况不适用神经网络，因为运行会很慢，而且SVM不用去考虑局部最优的问题。\n\n\n","tags":["机器学习"]},{"title":"机器学习 day13无监督学习","url":"/2021/07/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day13%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/","content":"01 无监督学习\n无监督学习：训练集没有标签，也就是图上的点没有任何标签信息。我们要将这系列无标签的数据，输入到算法中，然后我们要让算法找到一些隐含在数据中的结构，这个图中数据集中的点两组分开的簇，这种能够找到这些簇的算法叫做聚类算法。\n\n\n02 K-Means算法K均值算法是现在最为广泛运用的聚类算法\n\n\n通过K均值算法将下图分为两个簇的具体操作：\n随机生成两点（聚类中心），选取两点的原因是想将数据聚成两类。\n\n\nK均值算法是个迭代算法，可以做两件事：簇分配和移动聚类中心。\nK均值算法每次内循环的第一步是要进行簇分配，观察图中的绿点，是接近哪个聚类中心，距离哪个近就分配给哪个。\n\n\n\n根据离红色或者蓝色聚类中心的远近，将每个点染成红色或者蓝色。\n\n\n\nK均值算法每次内循环的第二步是移动聚类中心，将两个聚类中心移动到同色点的均值处。\n\n\n\n接着我们进入下一个簇分配步骤：再次检查所有的无标签样本，然后根据这些点离红色或者蓝色聚类中心的远近，将其染成红色或者蓝色。\n\n\n\n再一次移动聚类中心，将两个聚类中心移动到同色点的均值处。\n\n\n\n以此类推，不断重复上面操作，得到最终结果。\n\n\n\nX^(i)是一个n维实数向量，这也就是训练样本是n维向量而不是n+1维向量的原因。\n\n\n\n以更加规范的格式写出K均值算法。\n\n\n\n假设u_k是某个簇的均值，那么如果存在一个没有点的聚类中心，会怎么样？–直接移除那个聚类中心，这样会得到k-1个簇而不是k个簇；如果你确实必须要k个簇，那么就随机初始化这个聚类中心。\nK均值算法最常还应用在分离不佳的簇的问题（右图），如果想把衣服根据体重身高分为小中大三个号，这时就可以使用k均值算法。\n\n\n03 优化目标\n当运行k均值算法时，我们会对两组变量进行跟踪。\n\nc^(i)代表的是当前样本x^(i)所属的那个簇的索引。\n用u_k表示第k个聚类中心的位置（K表示聚类中心的数量，k表示聚类中心的下标）。\n\n\nk均值算法的优化目标即最小化代价函数，代价函数有时也叫失真代价函数或者K均值算法的失真：\n\n\n\n\n簇分配实际上就是，不改变聚类中心的位置，而是选出c^(1)到c^(m)来最小化这个代价函数；而移动聚类中心实际上就是选择u值来最小化J。然后保持迭代。\n\n\n04 随机初始化如何初始化K均值聚类算法？引导讨论如何使算法避开局部最优。\n\n\n初始化聚类中心的比较好的方法，通常随机挑选K个训练样本，然后设定u_1到u_k，由于随机初始化状态不同，所以K均值最后可能会得到不同的结果。（最好使用这种方法）\n\n\n\n随机化得到结果比较好（右上图），也可能得到不好的局部最优值（右下图）。局部最优值指的是畸变函数J的局部最优，相对来说左下角图的这些局部最优所对应的情况，其实是K均值算法落在了局部最优，因而不能很好的最小化J。如果想要K均值算法找到最有可能的聚类（右上图），我们可以尝试多次随机初始化，并且运行多次。\n\n\n\n具体步骤如下：典型运行K均值算法的次数在50到1000次，需要在最后选取代价最小的一个。如果你运行K均值算法时，所用的聚类数相当小（2到10之间），那么多次随机初始化通常能保证找到较好的局部最优解，保证能找到更好的聚类，很好的最小化J；如果K非常大的话，多次初始化也不会有太大的改善。更有可能第一次初始化就会有很好的结果。\n\n\n05 选取聚类数量K均值如何去选择聚类数量？–最常用还是根据观察可视化的图，或通过观察聚类算法的输出去手动选择。\n\n\n当谈到选择聚类数量的方法时，可能谈到的一种方法叫“肘部法则”。我们所要做的是改变K，我们先用一个类来聚类，然后计算代价函数，接着用两个、三个…..（其中可能会多次初始化），可能会得到一个图像（随着K增多J下降），选择K&#x3D;3可能是正确的，因为K&#x3D;3之前下降很快，而之后就下降很慢。但是实际上好多时候都是右图，比较平滑没有拐点，从而不能准确选择K。不能期望它能解决任何问题。\n\n\n\n如果后续目的如市场分割能给一个评估标准，那么决定K更好的方法是看哪个聚类数量能更好地应用于后续目的。从商业角度看，例如如果K&#x3D;5是否我的衣服能够很好的满足顾客需求，还是K&#x3D;3时更加符合利益。\n\n\n","tags":["机器学习"]},{"title":"机器学习 day14降维","url":"/2021/07/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day14%E9%99%8D%E7%BB%B4/","content":"01 目标 I：数据压缩\n想要使用降维的的原因：\n数据压缩，数据压缩不仅能使数据占用少量的内存或硬盘空间，还能对算法进行加速。\n\n\n如果特征高度相关，那么真的可能需要降低维数。\n将二维降到一维：两个特征变成一个特征，把每个样本都保持为一个数字，这样就能把内存需求（数据空间需求）减半。\n\n\n\n从三维降到二维：\n\n\n02 目标 II：可视化\n想要使用降维的的原因：\n\n可视化数据：将数据从50维或者更高维降到三维或者两维，这样就可以将其在图中画出来更好的理解他。\n\n\n50维数据：\n\n\n\n\n从50维降到2维，通常我们要了解z特征大致意味着什么。\n\n\n\n并画出2维图像\n\n\n03 主成分分析问题规划1对于降维问题最常用的一种算法叫主成分分析方法(PCA)的算法，本节课会试着用公式准确的表述PCA的用途。\n\n\nPCA所做的就是试图寻找一个投影平面对数据进行投影，使得能最小化这个距离。（PCA所作的是找到一个低维平面也就是图中的线，然后将数据投影到上面，使得蓝色的小线段（投影误差）长度平方最小）。对比可得选择橘色的而不选择粉色的。\n\n\n\n在应用PCA之前最常规的做法是先进行均值归一化和特征规范化使得特征量x_1和x_2其均值为0，并且其数值在可比较的范围之内。\n\nPCA与线性回归的区别：左图为线性回归，右图为PCA。线性回归的点是垂直横轴的（最小化蓝线之和的平方），而PCA的点是垂直那条线的（最小化蓝线的长度）。线性回归是通过输入x来预测y，PCA的特征值x之间都是平级关系。\n\n\n\n04 主成分分析问题规划2\n在使用PCA之前首先要做的的就是对数据进行预处理。\n给定一个训练集一定要做的是执行均值标准化：我们首先计算每个特征的均值，我们用减去它的均值取代每个特征x，这将使每个特征的均值正好为0\n根据数据也有可能需要进行特征缩放，缩放每个特征到一个相对的价值范围。\n\n\n\n\n\nPCA要做的是：计算这些向量例如u^(1)（即投影平面）；计算这些数字z\n\n\n\n用公式求解的过程：我们想把n维数据降到k维度，我们首先要做的是计算协方差（通常用大写的Sigma表示，是表示矩阵而不是求和），然后运用Octave中的svd()(奇异值分解)，也可以用eig()，不过svd()在数值上更加稳定。输出的将是三个U,S,V矩阵，我们真正需要的是U矩阵，可以发现U矩阵的列正是我们想要的u^(1)、u^()….。把n维数据降到k维度，就提取前k个向量。\n\n\n\n接下来我们要做的是获取我们的原始实数域数据集x找到一个低维的表示z。然后运用公式求解z\n\n\n\n协方差矩阵sigma的一个向量化实现：sigma &#x3D; (1&#x2F;m)X^TX,类似于K均值这里的X_0不能为1.\n\n\n05 主成分数量选择n维特征减少为k维特征，k为PCA算法的一个参数，也被称为主成分的数字，人们如何考虑选取k？\n\n\nPCA试图去减小投影误差平方的平均值，也就是试图减小x和x在低维面的投影的距离的差的平方。\n数据的总方差为样本x的平方和的平均值，也就是我们训练集中每个样本的平均长度（我们样本距离全零向量（原点）的距离）。\n选择k一个常用的经验方法是选择较小的值，使得这两者之间的比值小于0.01：让平均投影误差平方&#x2F;数据的总方差（数据的波动程度）。我们希望这个比例小于0.01或者小于1%，用PCA语言来说就是99%的方差性会被保留。当然0.01也可以换成其他值。为了保留99%的方差可以减少数据维数，但仍保留大部分的方差。\n\n\n\n下面的算法不断尝试从1开始修改k的值，然后进行PCA运算，最终使99%的方差性会被保留。这是一种方式来选择最小的k从而使99%的方差被保留。另一种方法是：通过SVD()计算出S矩阵（只有对角才有值，剩下的值为0），然后通过公式直接将k从1开始带进去，取前k个对角线的值相加&#x2F;整个对角线的值相加，看是否大于0.99.如果大于就选择这个k。对比可以看出第二种算法效率高，因为只需调用一次SVD()，而第一种需要多次调用PCA算法，相对来说效率低。\n\n\n06 压缩重现如何从低维的z^(i)变回原来的高维x^(i)?\n\n\n原始数据的重构：从压缩之后的低维的z^(i)变回原来未压缩的高维x^(i)：应用如下公式：\n\n\n07 应用 PCA 的建议\n使用PCA算法对监督学习算法进行加速的步骤：\n检查已经被标记的训练集，并抽取输入x，我们就得到了一个无标签的训练集x^(1)….x^(m)。\n用PCA得到原始数据的低维表示z，得到新的训练集。\n我们可以把这个低维的训练集输入到一个学习算法中，可以是神经网络、逻辑回归算法进行预测。\n注意PCA运算只能在训练集拟合这些参数，而不能在验证集或者测试集。定义x到z的映射后才能应用验证集和测试集中\n\n\n\n\n\n对PCA错误的使用就是尝试使用PCA来减少数据维度去防止过拟合，正确方法就是使用正则化。PCA运算是不使用标签的，只是针对输入x^(i)变为低维z^(i)，而不关心y，如果有99%的方差得以保留可以防止过拟合，但是也可能舍弃一些重要的信息，使得方差保留过低。\n\n\n\n在写下一个包含PCA的项目计划之前，应该问一问这个问题：如果我们直接去做而不使用PCA会怎样？一般直接建议：首先使用最原始的数据x^(i)，只有这么做达不到目的的情况下才考虑使用PCA和z^(i)，不要一开始就花大量的时间去应用PCA，计算k等等。\n\n\n","tags":["机器学习"]},{"title":"机器学习 day15异常检测","url":"/2021/07/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day15%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/","content":"01 问题动机异常检测主要用在非监督学习，但从某些角度看，跟有监督学习问题是非常相似的。\n\n\n异常检测问题就是我们希望知道新的测试数据是否有某种异常，换句话说新的测试数据是否需要进一步测试。如下面这个图（飞机引擎的例子），其中x_1、x_2是飞机引擎的特征。通过测试发现如果x_test在对应点里面，那么他就不存在异常，如果在对应的外面，那么就存在异常。\n\n\n\n我们通常认定这m个数据都是异常或者都不是异常的，我们需要一个算法告诉我们一个新的样本数据是否异常。因此我们要做的就是给定无标签训练集，我们对数据建模即p(x)，也就是对x的分布概率建模。如果测试集的概率p低于阈值那么就将其标为异常，否则正常。越中心的点概率越高。\n\n\n\n异常检测最常见的应用是欺诈检测，例如许多购物网站常用来识别异常用户。可以针对不同的用户活动计算特征变量x^(i)，于是建立一个模型来表示用户表现出各种行为的可能性。x_1也许是用户登陆的频率，x_2也许是用户访问某个页面的次数……，然后根据这些数据建立一个模型p(x),就可以用这个模型发现网站上行为可疑的人。\n另一个例子就是上面的飞机引擎例子。\n第三个是数据中心的计算机监控，这种技术被各大数据中心来监测大量的计算机可能发生的异常。\n\n\n02 高斯分布（正态分布）\n假设x是一个实数的随机变量，如果x的概率分布服从高斯分布，那么记作X~N(均值，方差（标准差的平方）)。高斯分布的概率密度绘制出来是一个钟形，均值控制中心位置，标准差控制宽度。\n\n\n\n下面是参数不同画出来的图像，不管怎么样阴影部分的积分一定是1。\n\n\n\n参数估计问题：给定数据集希望能找到能够估算出均值和方差的值。下面是公式：\n\n\n03 算法\n我们处理异常检测的方法是：我们我们要用数据集建立起模型概率p(x)，我们要试图解决出哪些特征量出现的概率较高，哪些出现的概率较低。分布项p(x)的估计问题有时也称为密度估计问题，我们列出p(x)的计算公式（x_1到x_n连乘）如下：\n\n\n\n异常检测算法：\n选择特征量（能够描述所收集数据的一般特性的特征），能够帮助我们指出那些反常的样本。\n给出m个未作标记的样本的训练集。\n进行参数拟合u_1到u_n，(sita_1)^2到(sita_n)^2,运用公式来求解这些参数。\n给一个测试样本，根据p(x)的公式来测量是否异常。\n\n\n\n\n\n如何对这些数据拟合出参数值，通过第一个图的数据求出第二个图（概率图），然后将第二个图两个数据进行相乘画出第三个图（三维图）。如果一个想要检测一个样本是否异常，可以直接看三维图，异常的都在图像下围显示（概率低），而正常都在图像上围（概率高），其中上下围以一个值（伊克塞了吗）作为分界线。\n\n\n04 开发和评估异常检测系统\n实数评估的重要思想：当你为某一个应用开发学习算法时，你需要进行一系列的选择，比如选择使用什么特征。如果有一个方法通过返回一个实数来评估算法，那么就将变得容易多。如果有一个特征要考虑该不该将其纳入，就可以将其带入算法中返回一个实数来告诉你纳入前后对算法的影响。\n能够评估异常检测算法的标准方法：用一些带标签的数据来指明哪些是异常样本，哪些是正常样本。\n我们首先假设一些训练集看作是无标签的，他们是很大的正常样本的集合，即使其中掺杂了少许的异常样本也没关系。接下来在定义一些验证集和测试集（包含了已知是异常的样本即y&#x3D;1）用来评估这个异常检测算法。\n\n\n\n举一个例子：飞机成产了一万个正常飞机，2到50个异常飞机。把这些数据分配给训练集、验证集和测试集的经典方法是：分配正常样本是6：2：2。异常样本只分给验证集和测试集一人一半。按照道理来说验证集和测试集应该是完全不同的两种数据。\n\n\n\n得到训练集、验证集和测试集后推导和评估算法：\n使用训练集拟合模型p(x)，也就是将这m个无标签（实际上都是正常的）样本都用高斯函数来拟合。\n在验证集和测试集给出x的值，算法将预测出y的值，y&#x3D;1对应异常样本，y&#x3D;0代表正常样本。\n\n\n对于这个问题如果数据是倾斜数据（绝大多数数据都是正常的），我们就应该采用原来学过的真阳性、假阳性、真阴性、假阴性来计算召回率和准确率来预测算法的好坏。\n如果有一个验证集一个选择参数（伊克塞了吗）的方法就是尝试去使用许多不同的值，然后选择一个能够最大化F_1-score这样的实数，或者有其他好表现的。\n\n\n05 异常检测 VS 监督学习\n什么情况下很可能使用异常检测算法以及什么时候使用监督学习算法？\n\n第一种–&gt;对于异常检测算法：它有很少的正样本和很多的负样本，当我们在处理估计p(x)的值来拟合所有的高斯参数的过程中，我们只需要负样本就够了；相反对于监督学习算法：在合理的范围内会有大量的正样本和负样本\n第二种–&gt;对于异常检测算法：经常会有许多不同类型的异常，因此如果是这种情况你会有很少量的正样本，对于一个算法就很难从少量的正样本去学习异常，尤其是未来可能出现的异常可能会和已有的异常截然不同。比如你在正样本中已经了解到5个或者更多发生故障的情况，但是可能到了明天你就需要检测一个全新的集合（新的异常），这种情况就可以对负样本用高斯分布模型来建模；相反对于监督学习算法：有一个足够多的正样本或者一个能识别正样本的算法（未来可能出现的正样本与你当前训练集中的正样本类似），他能观察大量的正样本和大量负样本来学习相应的特征，可以正确区分正负样本。（例如垃圾分类）\n\n\n\n下面是一些异常检测和监督学习的例子，对于欺诈行为&#x2F;飞机引擎&#x2F;计算机检测，如果有大量的欺诈行为&#x2F;引擎异常&#x2F;计算机运行异常的情况，就可以转化为监督学习，但是一般都是异常检测；对于垃圾分类，天气预报、癌症分类等问题有大量的同量级正负样本这些情况就使用监督学习。\n\n\n\n\n总结一句话就是异常检测以正常（负样本）来建模，监督学习以不正常（正样本）来训练。\n\n06 选择要使用的功能你使用什么特征来实现异常检测算法将会运用产生很大的影响\n\n\n在异常检测中我们要做的其中一件事就是使用高斯分布来对特征建模，所以我们经常做的一件事就是画出数据或者用直方图来表示数据，以确保这些数据在进入异常检测算法前看上去比较接近高斯分布。当然即使数据不是高斯分布也是可以运行的，就是运行好坏的问题。例如下图所示，图一是比较理想的，如果得到图二，我希望对数据进行一些如下不同的转换使得它看上去更接近高斯分布。\n\n\nhist(x.^0.05,50)\n\n\n你如何得到异常检测算法的特征：通常用的方法就是通过一个误差分析步骤（跟我们之前讨论监督学习算法时误差分析的步骤是类似的）。我们先完整地训练出一个算法，然后在一组验证集上运行算法，然后找出那些预测出错的样本，并看看我们能否找到一些其他的特征来帮助学习算法，让那些在验证集中判断出错的样本表现得更好。下面通过一个例子来解释这个过程。一些大众的问题就是正负样本的概率都很高，以一个特征为例，x&#x3D;2.5时的一个测试样本是异常的，但是混在了正常样本里，这时就需要找到一个新的特征来使算法可以很好的将x&#x3D;2.5的测试样本进行分离。（绿色的代表异常）。\n\n\n\n下面是一些对异常检测算法选择特征变量时的一些思考：对于那些可能异常的样本即不选择那些特别特别大，也不选择特别特别小的特征。以监控数据中心的计算机的例子，如果一个计算机出现了故障，下面给出了一些可选的特征包括占用内存、磁盘每秒访问的次数、CPU负载和网络流量，现在假如说我怀疑某个出错的情况，在我的数据集中我的CPU负载和网络流量应该是线性关系，比如说检测服务器，一个服务器在运行多台电脑，这时x_3和x_4都很高；如果在运行任务时出现了死循环（x_3升高，x_4正常），这时要检测就可以建立一个新的特征x_5或者x_6。通过建立新的特征就可以捕捉到这些特殊的特征组合所出现的异常值。\n\n\n07 多变量高斯分布这节课将会学习目前为止学习的异常检测算法的一种可能的延伸，这个延伸会用到多元高斯分布。他有一些优势也有一些劣势，他能捕捉到之前的算法检测不出来的异常。\n\n\n异常检测算法给x_1和x_2建模的方法如下，给出一个样本(绿色的)，可以从大体上看出x_1和x_2是线性的，而绿色的可以看出x_1很少，而x_2很多是不符合线性的。该图认为同一个圈的概率是一样的，但是实际上从图可以看出其实是不一样的。\n\n\n\n为了解决这个问题，我们要开发一个改良版的异常检测算法，要用到多元高斯分布或者叫多元正态分布。有一个特征向量x，我们不要对x_1和x_2分别建模，而是要建立一个整体的p(x)模型。它的参数是n维向量(u)和n×n的协方差矩阵。\ndet(Sigma)--&gt;用来计算行列式\n\n\n\n我们来看下这里的p(x)是什么样的。其中Sigma衡量的是方差或者说是x_1和x_2的变化量。缩小方差相当于缩小(Sigma)^2，下面是同时改变Sigma的两个值。\n\n\n\n\n接下来我们只改变特征向量x_1的方差，展示如下：\n\n\n\n同样的们只改变特征向量x_2的方差，展示如下：\n\n\n\n多元高斯分布一件很棒的事是你可以用它给数据的相关性建立模型（可以用它来给x_1和x_2高度相关的情况建立模型），如果改变非对角线上的元素你会得到一种不同的高斯分布，随着非对角线上的值不断增加可以看出x接近y（大部分数据落到了x_1&#x3D;x_2），变得更窄。当把其设为正值时如下：\n\n\n\n当把其设为负值时（x_1&#x3D;-x_2）如下：\n\n\n\n当然还可以改变平均参数u，即中心点所在位置。\n\n\n08 使用多变量高斯分布的异常检测\n给定参数集来进行参数拟合或者说是参数估计问题（其中Sigma和PCA中写的是一样的）。\n\n\n\n把这些结合起来开发一个异常检测算法：\n用我们的数据集来拟合模型\n有一个测试样本，用多元高斯分布的公式来计算p(x)\n比较p(x)与伊克塞了吗的大小来得出结果。\n\n\n\n\n\n原始模型对比多元高斯模型，多元高斯模型的轮廓都是轴对齐的。其实原始的模型就是多元高斯模型的特殊形式，，当多元高斯模型Sigma的非对角线都为0的情况下，将原始的方差放入到Sigma中，这时两个模型就会完全相同，也就是说这个用了多元高斯分布的新模型，比起之前的旧模型，这个新模型对应的分布方程的轮廓就是轴对齐的，所以不能用不同的特征之间的关系进行建模。\n\n\n\n那么什么时候用原始模型（比较常用），什么时候用多元高斯模型呢？比如之前计算机检测的例子，原始模型可能就需要建立一个新的特征，而多元高斯模型就能自动捕捉这种不同特征值之间的关系。\n原始模型的一个巨大的优势就是计算成本比较低（能适应数量巨大的特征），而多元高斯模型需要计算Sigma的逆矩阵也就意味着计算成本非常高。原始模型还有个优势是即使你有一个较小的有一定相关性的训练集也能顺利运行，而多元高斯分布模型需要样本的数量大于特征的数量（因为需要求逆矩阵）。我们使用多元高斯分布模型当且仅当m&gt;&gt;n（如果不满足这一点那么多元高斯分布模型就会有很多参数，因为协方差矩阵是一个n*n的，所以协方差矩阵有n^2个参数，同样因为是一个对称矩阵所以更接近n^2&#x2F;2），所以需要确保有一个很大的m值，确保有足够的数据来拟合变量。\n如果你需要捕捉一些具有相关性的特征，通常是手动设计新的特征，但是当m很大或者是n不是很大时这时多元高斯模型更好。\n如果在实际操作中发现Sigma是奇异的不可逆的那么有两种情况：\n没有满足m大于n的条件\n存在冗余特征（比如x_1&#x3D;x_2、x_3&#x3D;x_4+x_5）\n\n\n\n\n\n总结下使用多元高斯分布来做异常检测，可以自动地捕捉正负样本各特征之间地关系。如果发现某些特征的组合值是异常的他就会标为异常样本。\n\n","tags":["机器学习"]},{"title":"机器学习 day16推荐系统","url":"/2021/07/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day16%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/","content":"01 问题规划特征对于机器学习来说是十分重要的，机器学习领域有一个伟大的想法，对于某些问题有一些算法可以自动的学习一系列合适的特征。\n\n\n我们为什么要谈论推荐系统？\n它是机器学习中的一个重要的应用，比如说亚马逊会根据你之前所买的书来给你推荐一些书。\n有一些环境能让你开发某个算法来学习使用哪些特征，而推荐系统就是那些环境中的一个例子，通过推荐系统我们能领悟一些特征学习的思想。\n\n\n推荐系统问题的组成：以电影评分为例，先说下这些符号的意思。n_u表示用户的数量、n_m表示电影的数量、r(i,j)代表用户j是否对电影i进行评价（&#x3D;1代表评价了），当用户对电影进行评分后会得到一个值y(i,j)，它代表用户j对电影i所给出的评分（0~5星表示）。\n因此推荐系统的问题是给出r(i,j)和y(i,j)数据然后去查找那些没有评分的电影，并试图预测这些电影的评价星级。\n\n\n\n总结：如果我们想开发一个推荐系统，那我们应该想出一个学习算法，一个能自动为我们填补那些缺失值的算法，这样就可以知道用户还有哪些电影没看过并推荐新电影给用户。\n\n02 基于内容的推荐算法\n我们用x_1（一部电影为爱情片的程度）和x_2（一部电影为动作片的程度）来表示电影的特征。为了做出预测我们把每个用户的评价预测值看做成一个线性回归问题。预测值就是用户j所学参数的转置与电影特征的内积。\n\n\n\n我们要m^(j)表示评价了电影j的用户数量，为了学习用户参数向量（sita）^(j)我们应该怎么做呢？这是一个基本的线性回归问题，我们可以直接选择一个参数向量，那么这里的预测值会尽可能接近我们在训练集中观察的值。为了学习参数向量我们来最小化参数向量（我们对所有用户j评价的所有电影的(预测值-实际观测值)的平方求和）再除以m。这就像是线性回归我们选择参数向量来最小化这种方差项，并且也可以加入正则化项。如果将这个公式最小化，你可以得到一个很好的对参数向量的估计值，用来对用户j的电影评价做预测。\n\n\n\n当构建推荐系统时，我们不仅是要学习单个用户的参数，我们要学习的是所有用户的参数向量，这时就要用到下面这个式子：\n\n\n\n总结一下：图片上面是我们的优化目标函数，换一种写法J依旧是优化目标函数也是我们试图最小化的项。如果去推到梯度下降更新的话，将会得到下面公式（分别是k&#x3D;0和k!&#x3D;0的情况，因为上面的公式k是不等于0的），用梯度下降算法进行参数更新，最小化J来学习所有的参数。\n\n\n\n基于内容的推荐算法，因为我们假设变量是已有的即我们有描述电影内容的特征量（电影中爱情成分和动作成分有多少），同时用这些特征量来进行预测。\n\n03 协同过滤\n协同过滤有一个很有意思的特性叫特征学习，这种算法能自行学习所要使用的特征。\n我们假设已经知道了每个用户的参数，那么通过每个用户的评分就可以算出一个电影包含爱情和动作的程度。（右下角)\n\n\n\n我们将这一学习问题标准化到任意特征x^(i)，求出x^(i)让预测值尽可能的接近真实值。\n\n\n\n基于内容的推荐算法是给特征求参数，第二个是给参数求特征。实际上我们可以随机地猜取一些参数，然后就能得到特征，再根据特征求参数不断地迭代得到更好地参数和特征，最终将会收敛到一组合理的特征和参数。这个过程就是协同过滤算法。\n\n\n\n对于推荐系统问题，仅建立在每位用户都对数个电影进行了评价，并且每部电影都经过数位用户评价的情况下，这样才能重复这个迭代过程，才能求出参数和特征。\n总结下：协同过滤算法是指当你执行算法时，要观察大量的用户及用户的实际行为来协同得到每个人对电影更佳的评分值。协同的另一层的意思就是说每一位用户都在帮助算法更好的进行特征学习。如果每一个用户都对一部分电影做出了评价，那么每个用户都在帮助算法学习出更适合的特征，然后这些被学习出来的特征又可以更好的预测其他用户的评分。\n\n04 协同过滤算法\n存在一种算法不需要不停的计算特征和参数，而是能够将特征和参数同时计算出来。下面就是这种算法，需要将前两个优化目标函数结合为一个。第一个平方误差项（所有用户j的总和及所有被该用户评分过的电影总和）和第二个平方误差项（与上面那个是相反的运算：对每部电影i，将所有对它评分过的用户j求和）相加得到新的平方误差项（对所有有评分的用户和电影进行求和），剩下两项拖下来。\n新的优化目标函数J有一个特性，你将x作为常数并关于参数（sita）最优化其实就是在计算第一个式子，反过来你将参数（sita）作为常数并关于x求J的最小值的话，其实就是在计算第二个式子。\n当我们以这样的方法学习特征量时我们不再遵循原来的惯例（x_0&#x3D;1），理由是我们现在是在学习所有的特征，没有必要将一个特征值硬编码为1，因为如果算法真的需要一个特征值为1，那么它可以选择靠自己去获取1这个数值，比如将x_1设为1.\n\n\n\n协同过滤算法步骤：\n将特征和参数初始为小的随机值（这有点像神经网络）\n用梯度下降或者其他的高级优化算法将代价函数最小化（这里没有分出k&#x3D;0的情况是因为不存在x_0&#x3D;1这一项了）\n如果给你参数和特征，就可以预测评分了\n\n\n\n\n\n这个算法可以学习几乎所有电影的特征和所有用户参数，能对不同用户会如何对他们尚未评分的电影做出评价，给出相当准确的预测。\n\n05 矢量化：低轶矩阵分解将介绍协同过滤算法向量化的实现及使用算法可以实现的一些功能（比如说给定一个商品，可以找到与之相关的一些产品）。\n\n\n将数据的预测值写成矩阵形式：\n\n\n\n用另一种方法低轶矩阵分解（矩阵X乘以sita的转置）写出这个算法的所有预测评分：\n\n\n\n利用学习到的属性来找到相关的电影，通常算法会学到一些有意义的特征。我们可以衡量两个电影的相似度（两个电影的特征距离很接近）来找到相关影片。\n\n\n06 实施细节：均值规范化\n下面增加了一个用户，这个用户之前没有给任何电影评过分，将其带入协同过滤算法中。因为用户对电影没有评分，所以算法的第一项对用户参数的选择是没有影响的，只有最后一项可以影响参数的选择，又因为最后一项是正则化，所以说得出来的参数是二维的零向量。二维零向量与哪个二维向量内积都为0，这样的结果不是我们想要的。\n\n\n\n均值归一化的思想可以帮助我们解决这个问题，下面介绍它是如何工作的：把每个电影评分都归一化使得均分为0\n\n将所有的评分都放到Y矩阵中\n计算每个电影所得评分的均值，并将其存放在一个叫u的向量中\n将Y中所有元素-均值\n对新的评分数据集使用协同过滤算法来学习用户参数及电影特征\n最后来计算电影评分：用户参数的转置与电影特征的内积+u（因为训练集中减去了均值，因此在这里需要加上）\n\n\n之前用户参数为二维零向量的问题依然存在，但是第五个用户的预测评分变了，变成了电影评分的均值。选择一个大众比较喜欢的推荐给第五个用户，当然如果一个电影没有评分（就不应该推荐，因为关心没有评价电影的人比关系没有被评价过电影更有意义），也可以对Y的每一列进行均值归一化。\n\n\n\n\n总结一下：均值归一化的实现作为协同过滤算法的预处理步骤，根据不同的数据集，有时可以让你的算法表现得更好一些。\n\n","tags":["机器学习"]},{"title":"机器学习 day17大规模机器学习","url":"/2021/07/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day17%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","content":"01 学习大数据集大规模机器学习就是处理大数据集的算法\n\n\n一种获取高性能的机器学习系统的途径是采用低偏差的学习算法并用大数据进行训练。\n大数据集学习的特有问题是计算问题。\n在训练一亿个样本之前，我们可以随机选择一亿个样本中的一千个样本，然后用这一千个样本来训练我们的算法。如果用一千个样本训练效果也是一样的话，在训练大量的模型前预先检查往往也是一个明智的选择。如果效果相同的话，可以根据这一千个样本绘制学习曲线，如果画出左图高方差的曲线那么增加训练集还是有作用的，如果是右边高偏差的算法，样本也不会比训练1000个更好了，如果是右图那么自然而然地会添加额外地特征项或在神经网络中添加额外地隐藏单元，这样最终可能得到左边的图。\n\n\n02 随机梯度下降当我们训练集很大时，梯度下降算法的计算量会变得非常大，因此对普通的梯度下降法进行改良为随机梯度下降法，使得算法能够应用于大规模的数据训练。\n\n\n先来回顾下线性回归：第一个式子是假设函数，第二个式子是代价函数，第三个式子是不断地更新参数sita来使得代价函数趋于最小，右图是构建的三维函数可以看出是弓形。\n\n\n\n在参数初始值，运行梯度下降算法，将会不断迭代，最终得到参数的全局最小值。如果m的值非常的大，那么单单是计算微分项就需要很大的计算量，更何况还要一次次的迭代。这个梯度下降算法又叫批量梯度下降，其中批量是指每次都需要同时考虑全部的训练样本。\n\n\n\n随机梯度下降算法每次迭代不需要每次都同时考虑全部的训练样本，仅仅只考虑一个训练样本。为了更好的描述随机梯度下降算法，我们将代价函数定义为右侧的第一个式子，这个代价函数实际上是衡量我的假设函数在某个样本(x(i),y(i))上的表现。而左图第一个总体代价函数可以写成右图第二个式子（假设函数在m个训练样本中每一个样本(x(i),y(i))上的代价函数的平均值），随机梯度下降的步骤如下：\n将所有的m个训练样本重新随机排列。(这保证了遍历时对训练集样本的访问是以随机顺序排列的，这一步能让随机梯度下降在收敛时能够更快一点)\n对所有的训练样本进行遍历，然后做如下参数更新.（就是不断地对参数进行调整来依次适应第一个参数、第二个参数……..）\n\n\n随机梯度下降和批量梯度下降相比不需要对全部的m个样本求和来得到梯度项，而只需要对单个样本就可求出梯度项（黄色框画出来的就是梯度项）。在随机梯度下降过程中我们已经开始一点点把参数向全局最小值的方向进行修改了。\n\n\n\n随机梯度下降每一次迭代都会更快，因此我们不需要对所有训练样本进行求和，每一次迭代只要保证能拟合某一个训练样本即可。虽然它的参数走的线不是一条曲线，但是它是随机而迂回的路径朝着全局最小值的方向移动的。随机梯度下降和批量梯度下降相比收敛形式是不同的，他就是连续不断的在某个区域中朝着全局最小值的方向徘徊，而不是直接打到全局最小值（在实际应用中，只要能接近全局最小值就能得到一个很好的效果）。\n在随机梯度下降法中其实还有一个外层循环（1到10次，通常一次就可，还是取决于数据集m的大小）来决定内层循环的次数\n\n\n\n总结下：批量梯度下降算法是一次就需要遍历全部的训练集，然后在进行迭代（迭代一次就相当于遍历两次全部训练集）才有可能得到全局最小值，而随机梯度下降算法有可能只需要遍历一次就可以的到全局最小值。所以说将随机梯度下降法的思想应用到学习算法中来适应更大的数据集从而提升算法的性能。\n\n03 Mini-Batch 梯度下降Mini-Batch 梯度下降有时甚至比随机梯度下降还要快一些。\n\n\n总结下我们迄今为止学的梯度下降算法：\n批量梯度下降算法每次迭代都要用到所有的m个样本\n随机梯度下降算法每次迭代只需要使用一个样本\n而Mini-Batch 梯度下降算法每次迭代会使用b个样本（b是一个称为Mini-Batch大小的参数，通常选择b&#x3D;10，b的范围是2~100），它是介于批量梯度下降算法和随机梯度下降算法之间的算法。\n\n\n\n\n\nMini-Batch 梯度下降完整算法如下：以步长为10增长为例，仅用前十个样本就能运行算法来更新参数，这也是为什么Mini-Batch 梯度下降比批量梯度下降算法要快的原因。为什么Mini-Batch 梯度下降不像随机梯度下降算法一样每次只使用一个样本呢？–&gt;因为在向量化过程中Mini-Batch 梯度下降比随机梯度下降更快（仅当有好的向量化方法）。\nMini-Batch 梯度下降算法的缺点之一是当有一个额外的参数b时，你需要确定Mini-Batch大小，这需要额外的时间，当然如果有好的向量化算法Mini-Batch 梯度下降比随机梯度下降更快。\n\n\n\n如果有一个合适的向量化的方法，蓝框的求和公式将在10个样本中实现部分并行计算，换句话来说通过合适的向量化方法计算余下的样本，可以部分使用好的数值代数库，然后对b个样本并行进行梯度计算，随机梯度下降算法每次只针对一个样本肯定没有太多的并行计算。\n\n04 随机梯度下降收敛当你运行随机梯度下降算法时如何确保调试过程已经完成，并且已收敛到合适的位置呢？怎样调整随机梯度下降算法中的学习速率a的值呢？\n\n\n批量梯度下降算法确保梯度下降已经收敛的一个标准方法就是绘制优化代价函数（关于迭代次数的函数），我们要确保代价函数J每一次迭代都是下降的。当m教小时使用这个还算可以，但是当训练集m特别大时，你肯定不希望得定期的暂停这个算法来计算蓝色框中的式子，因为每次计算都会遍历整个数据集。\n对于随机梯度下降算法为了检查算法是否收敛可以进行下面的工作：当随机梯度下降法对训练集进行扫描时，在我们使用某个样本(x(i),y(i))来更新参数sita之前，让我们来计算出这个训练样本假设的表现有多好即cost()函数。最后为了检查是否收敛，每1000次迭代就画出前一步骤所计算出来的cost()函数前一千个样本的的平均值，这样通过观察图就可以看是否下降收敛，可以看出算法在你前一千个样本中表现得有多好。\n\n\n\n下面第一个图中红色线代表更小的学习速率a，可以看出更加得平缓但是能得到更好的效果。（因为随机梯度下降不是直接达到全局最小值，而是在这个区域不断震荡，学习速率越小震荡幅度也就越小。）第二个图中得红色线代表样本从一千增加到五千，可以看出得到的曲线比较平滑，但是得到的关于算法表现有多好的反馈就有一点延迟，因为图中每一个数据点是从五千个样本中得到，而不是从之前的1000个样本得到。第三个图由于样本太少所以表现得好像没有下降收敛一样，红线代表样本增加到5000，可以看出比最开始显得下降了。而粉色线也代表样本增加到了五千但是没有啥变化，这就说明算法基本就没有学习，这时需要调整学习速率或者特征或者其他东西。第四个图是上升的趋势，这时算法发散了，这时就需要更小的学习速率。\n\n\n\n总结：如果出现噪声太大或者图像老是上下振动，就可以试着增加求均值的样本的数量，如果图像上升那么就用一个更小的学习速率。\n如果你想要将随机梯度下降到更好的收敛到全局最小值（也是接近哈），那么就需要让学习速率的值随时间变化而逐渐减小。经典的做法就是让a&#x3D;某个常数1&#x2F;（迭代次数+某个常数2），但是很少用，原因有二：一是收敛得到的值已经很满意了，二是还需要确定两个常数，无形中又增加了算法的复杂性还有计算量。\n\n\n05 在线学习在线学习机制可以让我们模型化一些问题，就是我们有连续一波数据，想要用算法从中学习的这类问题。\n\n\n以提供运输服务为例，y&#x3D;1是购买运输服务，y&#x3D;0是不购买，我们想要用（出发地、目的地、我们提供的价格等）特征来学习他们选择我们来运输包裹的概率。如果我们可以估计出每种价格下用户选择使用服务的概率，我们就可以选择一个价格即可能使用户选择我们，我们还会有回报。算法如下：当用户访问我们时，我们会得到与其对应的（x，y）对，在线学习算法就会利用刚得到的（x，y）(因为我们不使用固定的训练集，所以这里不是（x^(i),y^(i)）)来更新参数theta。我们使用完这个样本就会将其丢弃不在使用，这也就是为什么一次只处理一个样本。\n\n\n\n在比如说搜索的例子（又叫点击率预测学习问题 -CTR），当你搜索手机时，他会从100个手机里给你推送10个，提供了特征x(与你搜索的手机关联度)，y&#x3D;1是点击进入。运行此类网站的一个方法就是不停的给用户展示你对他们可能会喜欢的十个手机的预测，每一次用户访问你将会得到十个样本即十个对应的（x，y）对，然后运行在线学习算法来更新参数，对这十个样本利用10步梯度下降法来更新参数。\n\n\n\n在线学习的一个优点就是如果有一个变化的用户群又或者是你在预测的事情在缓慢的变化，在线学习算法可以慢慢地调试你所学习到的假设，将其调节到最新的用户行为。\n总结：在线学习算法与随机梯度下降算法的唯一的区别就是我们不会使用一个固定的数据集，而是获取一个用户样本从那个样本中学习，然后丢弃那个样本继续处理下一个。如果某一个应用有一个连续的数据流，这样的算法是非常值得考虑的。\n\n06 减少映射与数据并行MapReduce思想可以将学习算法应用于随机梯度下降不能解决的规模更大的问题。\n\n\n根据MapReduce思想我们把训练集分为不同的子集，有几台电脑或者机器并行处理训练集数据就分为几个子集。每台机器使用相对应的子集来处理梯度下降算法中的求和部分，这样每个机器都进行工作，效率就提高了好几倍。最后我们将这些temp变量发送给一个中心服务器，中心服务器会整合这些结果，尤其是将更新我的参数theta。可以说这个公式完全等同于批量梯度下降法，只是不需要在一台机器上处理这400个数据。\n\n\n\n就例子而言，四台电脑各自承担四分之一的计算量，你可以加速到四倍速，如果没有网络延迟和忽略传输数据所有时间，那么就是四倍的速度，当然现实中的网络延迟及汇总所需要额外的时间，实际速度比四倍小。\n\n\n\n使用MapReduce思想还需要考虑学习算法是否可以表示成对训练集的一种求和。如果可以就能将学习算法的适用范围扩充到非常非常大的数据集。下面一个例子：高级优化算法需要计算优化目标的代价函数的计算过程和这些偏导项的计算过程，电脑把他们发送给中心服务器，然后将各部分和（temp^(i)_j）加起来，获得总的代价函数获得总的偏导项，接着将这两个值发送给高级优化算法。\n\n\n\n现在也可以在单机上使用MapReduce，因为电脑有多个处理核心CPU，CPU又有多个核心。这样的好处是可以不用担心网络延迟问题。如果你有一个多核机器，同时你有某些线性代数库（可以自动在一台电脑不同核心上进行并行代数运算），并且你的学习算法有非常好的向量化表示，你就可以直接以向量化的形式应用标准学习算法，不用担心并行（线性代数库就可以处理好）。\n\n\n","tags":["机器学习"]},{"title":"机器学习 day18应用举例：照片OCR（光学字符识别）","url":"/2021/07/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20day18%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B%EF%BC%9A%E7%85%A7%E7%89%87OCR%EF%BC%88%E5%85%89%E5%AD%A6%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB%EF%BC%89/","content":"01 问题描述与 OCR pipeline照片OCR问题注重的是如何让计算机读出照片中的文字信息（照片OCR对于读取文档来说很简单，但是对于数码照片来说还是很难的）\n\n\n照片OCR当你输入文字时，计算机就能自动的帮你找到相册里带有这些文字的照片，它有如下几个步骤：\n给定某个照片，将其图像扫描一遍。\n找出照片中的文字信息\n找出照片中的文字信息之后，将重点关注这些文字区域，并对区域中的文字进行识别，当它正确读出这些文字之后，他会将这些文字内容显示并记录下来。\n\n\n\n\n\n总体来说步骤分为三类：文字检测、字符分割以及字符分类（其实还有个拼写校正）。\n\n\n\n像这样的系统，我们把它称为机器学习流水线：首先有一个照片，然后把它传给文字检测系统，识别出文字区域后，将文字区域中的单个字符分割出来，最后对这些单个字母进行识别。\n\n\n02 滑动窗口关于流水线中每个独立的组件的工作原理，主要讲一个叫滑动窗口分类器。\n\n\n照片OCR问题难在文字区域对应的矩形具有不同的长宽比例，而对于行人检测来说，人们的长宽比基本相同。\n\n\n\n建立一个行人检测系统，我们可以这么做：假如决定要把比例标准定为82 * 36（当然其他比例也可以），然后从数据集中收集一些正样本和负样本（都是82 * 36的照片），在你的网络中训练或者使用其他学习算法向其中输入一个82 * 36的图块来对y进行分类，来划分每个图块是否包括一个行人\n\n\n\n下图相当于一个训练集，首先在图片中选取一个矩形块（比如是左上角绿框），然后将图块传送给我们的分类器，来检查图块中是否有行人，然后每次以一定的步长（也称滑动参数）来移动图块，传送给分类器不断地判断图块中是否有行人。然后再以更大窗口移动来判断是否有行人，这样算法便能检测出图中各个地方是否出现行人。这就是一个监督学习分类器，然后使用一个滑动窗口分类器来找出图中所有行人。\n\n\n\n接下来看一下在图片OCR中如何找出图中的文字区域：\n\n首先也是拿出一系列的包括正样本和负样本的训练集。\n\n\n\n训练完后将其应用在一个新的测试集中的图片，在此使用固定比例的滑动窗口，会得到左下角的图片（白色表示文本检查系统发现了文本，而深浅不同的灰色对应的是分类器认为该处有文字的概率），然后将分类器的输出应用到一种叫放大算子（就是扩大白色区域，如何扩大呢？就是通过检查像素附近是否存在白色像素，然后把这一范围内都变成白色）的东西上得到右下角的图，然后需要在右下角图中白色周围绘制边框，文本周围的框宽度应该远大于高度，通过这个特性就可以筛选出正常的文字区域。\n\n\n\n接下来进入识别文本阶段也就是字符分割，在此我们再次使用监督学习算法用一些正样本（可以进行分割）和负样本（不可以进行分割），对分类器进行训练完就可以将其运行在文字检测系统输出的这些文本中，最终可以将图像全部分成单独的字符。\n\n\n\n\n03 获取大量数据和人工数据一个最可靠得到高性能机器学习系统的方法是使用一个低偏差机器学习算法并且使用庞大的训练集去训练他。其中人工数据合成可以为合适的机器学习问题轻松得到大规模的训练集。\n\n\n人工数据合成主要有两种形式：\n\n自己创造数据（从0开始创造新数据）\n已经有小的标签训练集，然后以某种方法扩充训练集（引入失真）\n\n\n假如我们收集到了一个大的标签数据集如左图所示，我们的目标是输入一个图像块然后识别出图像块中央的字符。为了简化操作我们将图片处理成灰度图像而不是彩色图像。如果想要更多的训练样本一个方法就是用不同的字体生成字符，然后将其粘贴到任意不同的背景中，然后可以应用一点模糊算子或者仿射变换（仿射的意思是进行等分、缩放和一些旋转操作），完成这些操作就会得到一个人工合成训练集如右图所示。这个就是自己创造数据。\n\n\n\n\n使用现有的样本生成训练集。可以对图片进行人工拉伸或者人工扭曲（必须要合理的，具有代表性），这样就可以将一个样本变成16个新样本了。通过这种方法就能将一个小的标签训练集扩充为一个更大的训练集。当然不同的机器学习应用，可能其他类型的失真将更合理。以语音识别为例，目的是从对话中获取内容，可以通过人工添加失真引入不同背景音乐，得到大量的训练集。生成的新样本一定要具有代表性是有可能在测试集中见到的样本。\n\n\n\n\n在生成大量人工训练集之前最好画一个学习曲线保证你有一个低偏差高方差的分类器。如果你的偏差太高，可以尝试持续增加分类器的特征数量或者增加神经网络隐藏单元的数量，然后在花精力在生成大量人工训练集，这样就避免了花费大量的时间来收集数据却发现没有多大作用。用学习曲线做一个合理的检验看更多的数据是否真的有用。\n\n获得目前训练集十倍的量需要花费多少工作量（方法）？\n\n人工合成数据\n自己收集数量或者添加标签\n众包数据标记：从花钱网上找人来帮你标记训练集\n\n\n\n\n04 天花板分析：下一步工作的 pipeline上线分析：当你自己或者跟你的团队在设计某个机器学习系统工作流时，这种方法能够提供一个很有价值的信号，知道你工作流中哪一部分最值得花费时间去研究。\n\n\n为了决定如何开发系统一个有效的方法就是对学习系统使用一个数值评价量度，假如我们用字符准确度作为这个量度，给定一个测试样本图像，那么这个数值就表示我们对测试图像中的文本识别正确的比例。如图所示：不管你用什么度量值来度量，整个系统的总的准确率为72%。\n下面是上线分析的主要思想：还是以图片OCR流水线为例，首先我们先关注文本检测，对于每一个测试样本都给一个正确的文本检测结果，换句话说就是要100%正确检测出图片中的文本信息。只需要找到对应图像，然后人为的识别出测试集图像中出现文本的区域，让这个模块人为的输出正确的结果，将结果传送给字符分割模块，然后运行后面两个模块，使用之前一样的评价量度指标算出整个系统总的准确率89%，同样的在上一个处理的基础上，字符分割模块也用全部正确的结果去输出，得到了90%的准确率，字符分类也一样（全都是正确的当然是100%）。\n使用上限分析就可以看出每个模块进行改善后各自的成长空间是多少，可以看出完美的文本检测得到的增益最大。\n\n\n\n人脸识别也是一样：\n\n\n","tags":["机器学习"]},{"title":"机器学习总结","url":"/2021/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"\n监督学习算法：线性回归、逻辑回归、神经网络、支持向量机（在这些问题中会有带标签的数据和样本）\n无监督学习：K-均值聚类算法、主成分分析法（进行降维）、异常检测算法（对算法进行评估）\n特定的应用和话题：推荐系统、大规模机器学习系统（包括并行和映射-化简算法）\n其他的应用：滑动窗口分类器（计算机视觉问题）\n从各个不同的方面给出了如何构建机器学习系统的建议：偏差和方差（尝试了是什么使得机器学习算法工作或者是不工作）、正则化（解决一些方差问题）、学习算法的评估方法：召回率和F1分数这样的评价指标和实践方面的评测方法：训练集-交叉验证集-测试集（当你开发一个机器学习系统时如何合理分配你的时间）、诊断方法：学习曲线和误差分析及上限分析（如何调试算法确保学习算法能够正常工作）。所有这些工具都能帮助你决定下一步该做什么以及怎么分配时间。\n\n\n","tags":["机器学习"]},{"title":"注解之什么是注解？","url":"/2022/04/30/%E6%B3%A8%E8%A7%A3%E4%B9%8B%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%A8%E8%A7%A3%EF%BC%9F/","content":"\nAnnotation 是从JDK5.0开始引入的新技术 .\n\nAnnotation的作用 ：\n\n不是程序本身 , 可以对程序作出解释.(这一点和注释(comment)没什么区别) \n\n可以被其他程序(比如:编译器等)读取.\n\nAnnotation的格式 \n\n注解是以”@注释名”在代码中存在的 \n还可以添加一些参数值 , 例如:@SuppressWarnings(value&#x3D;”unchecked”)\n\n\nAnnotation在哪里使用?\n\n可以附加在package , class , method , field 等上面 , 相当于给他们添加了额外的辅助信息\n\n我们可以通过反射机制实现对这些元数据的访问\n\n\n\n\n","tags":["注解"]},{"title":"注解之元注解","url":"/2022/04/30/%E6%B3%A8%E8%A7%A3%E4%B9%8B%E5%85%83%E6%B3%A8%E8%A7%A3/","content":"\n元注解的作用就是负责注解其他注解 , Java定义了4个标准的meta-annotation类型,他们被用来提供 对其他annotation类型作说明 .\n\n这些类型和它们所支持的类在java.lang.annotation包中可以找到 .( @Target , @Retention , @Documented , @Inherited )\n\n@Target : 用于描述注解的使用范围(即:被描述的注解可以用在什么地方) \n\n@Retention : 表示需要在什么级别保存该注释信息 , 用于描述注解的生命周期 (SOURCE &lt; CLASS &lt; RUNTIME) \n\n@Document：说明该注解将被包含在javadoc中\n\n@Inherited：说明子类可以继承父类中的该注解\n\n\nimport java.lang.annotation.*;public class demo1  &#123;    @MyAnnotation    public void run()&#123;    &#125;&#125;//定义一个注解@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(value = RetentionPolicy.RUNTIME)@Inherited@Documented@interface MyAnnotation&#123;&#125;\n\n","tags":["注解"]},{"title":"注解之内置注解","url":"/2022/04/30/%E6%B3%A8%E8%A7%A3%E4%B9%8B%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3/","content":"\n@Override\n定义在 java.lang.Override 中 , 此注释只适用于修辞方法 , 表示一个方法声明打算重写超类中 的另一个方法声明.\n\n\n@Deprecated \n定义在java.lang.Deprecated中 , 此注释可以用于修辞方法 , 属性 , 类 , 表示不鼓励程序员使用这样的元素 , 通常是因为它很危险或者存在更好的选择 .\n\n\n@SuppressWarnings \n定义在java.lang.SuppressWarnings中,用来抑制编译时的警告信息.\n与前两个注释有所不同,你需要添加一个参数才能正确使用,这些参数都是已经定义好了的,我们 选择性的使用就好了 .- @SuppressWarnings(“all”)- @SuppressWarnings(“unchecked”)- @SuppressWarnings(value&#x3D;{“unchecked”,”deprecation”}) 等等 …..\n\nimport java.util.ArrayList;import java.util.List;public class Test1 extends Object&#123;    //@Override 表示方法重写    //--&gt; 查看JDK帮助文档    //--&gt; 测试名字不同产生的效果    @Override    public String toString() &#123;        return super.toString();    &#125;    //方法过时了, 不建议使用 , 可能存在问题 , 并不是不能使用!    //--&gt; 查看JDK帮助文档    @Deprecated    public static void stop()&#123;        System.out.println(&quot;测试 @Deprecated&quot;);    &#125;    //@SuppressWarnings 抑制警告 , 可以传参数    //--&gt; 查看JDK帮助文档    //查看源码:发现 参数类型 和 参数名称 , 并不是方法!    @SuppressWarnings(&quot;all&quot;)    public void sw()&#123;        List list = new ArrayList();    &#125;    public static void main(String[] args) &#123;        stop();    &#125;&#125;\n","tags":["注解"]},{"title":"注解之自定义注解","url":"/2022/05/01/%E6%B3%A8%E8%A7%A3%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/","content":"\n使用 @interface自定义注解时 , 自动继承了java.lang.annotation.Annotation接口 \n分析 :\n@ interface用来声明一个注解 , 格式 : public @ interface 注解名 { 定义内容 }\n其中的每一个方法实际上是声明了一个配置参数. \n方法的名称就是参数的名称. \n返回值类型就是参数的类型 ( 返回值只能是基本类型,Class , String , enum ).\n可以通过default来声明参数的默认值 \n如果只有一个参数成员 , 一般参数名为value \n注解元素必须要有值 , 我们定义注解元素时 , 经常使用空字符串,0作为默认值 .\n\nimport java.lang.annotation.*;public class demo1  &#123;    @MyAnnotation    public void run()&#123;    &#125;    //只有一个参数, 默认名字一般是value.使用可省略不写    @MyAnnotation1(&quot;aaa&quot;)    public void stop()&#123;    &#125;&#125;//定义一个注解@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(value = RetentionPolicy.RUNTIME)@Inherited@Documented@interface MyAnnotation&#123;    String name() default &quot;&quot;;    int age() default 0;    int id() default  -1;    String[] school() default &#123;&quot;xiao&quot;&#125;;&#125;@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)@Retention(value = RetentionPolicy.RUNTIME)@Inherited@Documented@interface MyAnnotation1&#123;    String value();    &#125;\n","tags":["注解"]},{"title":"深度学习 day01 深度学习概论","url":"/2021/07/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20day01%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/","content":"01 什么是神经网络深度学习指的是训练神经网络\n\n\nReLU（修正线性单元）函数：修正指的是取不小于0的值。下图就是根据这个函数画的单神经元网络。\n\n\n\n下面是有更多特征时的神经网络：神经网络的一部分神奇之处在于不管训练集多大，只要输入x就能得到输出y，所有的中间过程都是自己完成的。神经网络你自己决定中间这个节点是什么，我们只给你四个输入特征随便你怎么计算，因此在神经网络中，输入层在中间层连接数是很高的。\n\n\n02 用神经网络进行监督学习\n下面是神经网络创造价值的一些案例：对于图像领域一般使用CNN（卷积神经网络）；对于序列数据经常使用RNN（循环神经网络），其中语言最自然的表示方式也是序列；而对于复杂的应用就需要更加复杂的混合神经网络结构\n\n\n\n下图分别是：标准神经网络、卷积神经网络、循环神经网络\n\n\n\n机器学习被应用于结构化数据和非结构化数据：结构化数据是数据的数据库；非结构化数据就好比语音、图像、自然语言。\n\n\n03 为什么深度学习会兴起？\n下面是训练带有标签样本的不同的算法，随着数据量的增加各个算法的表现变化。可以看出神经网络比其他算法要好得多。\n\n\n\n提升计算速度：左图通过改变算法使得代码运行更快。比如说下图机器学习中的sigma函数在两端的区域梯度会接近于0，这样学习将会变得特别缓慢（梯度下降算法中参数更新的慢当然学习也就慢）。通过改变激活函数，神经网络用ReLU函数，它的梯度对于所有为正值的输入，输出都为1。右图通过加快计算速度从而加快迭代的速度（转一圈需要的时间）来使效率提升。\n\n\n","tags":["深度学习"]},{"title":"深度学习 day02 03 神经网络基础","url":"/2021/07/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20day02%2003%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","content":"01 二分分类\n逻辑回归是一个用于二分分类的算法\n计算机保存一张图片就需要保存三个独立矩阵，分别对应图片中的红、绿、蓝三个颜色通道，如果照片是64×64像素的就有三个64×64的矩阵。然后需要将这三个矩阵所有元素都存放在特征x向量中（x向量就是64×64×3&#x3D;12288维）。\n\n\n\n输入X用矩阵表示：python中用来输出矩阵的维度代码是X.shape&#x3D;(n,m)，表示X是一个n×m的矩阵。\n\n02 逻辑回归\n当你实现逻辑回归时，你要做的就是学习参数w和b。因为要求输出y帽是在0到1之间，所以我们将输入x的线性函数w^T+b带入到sigma函数中，得到sigma函数。当z很大时输出接近于1，当z很小时输出接近于0。\n\n\n03 逻辑回归损失函数\n损失函数又叫误差函数可以用来衡量算法在单个训练样本运行情况，在这里我们不用第一个式子，我们用第二个损失函数，因为在逻辑回归中如果使用第一个式子，最终会得到很多个局部最优解，梯度下降法可能找不到局部最优值（非凸），而使用第二个就会给我们一个凸的优化问题。\n\n\n\n成本函数基于参数的总成本，衡量的是w和b在全体训练样本上的表现\n\n\n04 梯度下降法\n我们想要找到参数w和b来使成本函数最小，我们可以随机初始化参数，梯度下降法就是从初始点开始沿着最陡的下坡方向走一步，不断地进行迭代最终达到全局最小点。\n\n\n\n下面是参数更新的过程，无论参数w在哪一边，他都会向成本函数最小值方向前进，并且可以看出随着w的的变化，函数的斜率也是不断地减小，随着斜率的减小，w变化幅度也就随之减小（也就是朝着成本函数最小值方向移动的越慢）。\n\n\n05 计算图\n一个神经网络的计算都是按照前向或者反向传播过程来实现的，首先计算出神将网络的输出，紧接着进行一个反向传输操作（我们用来计算出对应的梯度或者导数）。\n从左到右的过程，可以计算出J的值。\n\n\n06 计算图的导数计算\n当计算所有这些导数时，最有效率的办法就是从右到左计算，跟着红色的箭头走，我们第一次计算对v的导数在之后计算对a的导数就可以用到，同样的对u的导数的计算在之后计算b的导数时就可以用到。他这个计算导数是，计算哪个导数就对那个值进行一些增加，看看他对J是如何影响的，使用微积分的链式法则就可以算出其导数。\n\n\n\n07 逻辑回归中的梯度下降法\n该样本的偏导数流程图：\n\n\n\n单个样本实例的一次梯度更新步骤：想要计算损失函数L的导数，首先我们要向前一步先计算损失函数关于变量a的导数（da），再向后一步计算出损失函数关于z的导数（dz），最后就是计算出dw、db了，就可以进行更新参数更新了。（更新w&#x2F;b为b减去学习率乘以dw&#x2F;db）\n\n\n08 m个样本的梯度下降\n全局成本函数是从1到m项损失函数和的平均&#x3D;&#x3D;&gt;根据这个我们可以推导出全局成本函数对w1的导数也同样是各项损失函数对w1导数的平均。所以真正需要做的就是计算这些导数并且求平均，这样会得到全局梯度值，能够直接将其应用到梯度下降算法中。\n\n\n\n首先让我们初始化，接着我们要使用for循环来遍历训练集，并计算相应的每个训练样本的导数，然后将他们加起来。（这里有两个循环：第一个是遍历训练集，第二个是遍历所有特征）\n\n\n09 向量化\n向量化技术可以使代码摆脱这些显式的for循环，会帮助处理更大的数据集。\n可扩展深度学习实现是在GPU（图像处理单元）上做的，但是课程是在Jupyter Notebook做的，仅用CPU。CPU和GPU都有并行化的指令有时候也叫做SIMD指令（单指令流多数据流，这个意思是如果你使用了能去掉显式for循环的函数，这样python的numpy能充分利用并行化去更快的计算）\n下图是一个非向量化与向量化实现的对比：\n\n\n\n下面是通过python来实际进行操作，对比非向量化与向量化实现：\n\n\n10 向量化更多的例子\n依旧是非向量化与向量化前后对比：往往python中一个内置函数就搞定\n\n\n\n式子进行去掉一个for循环的写法：\n\n\n11 向量化逻辑回归向量化是如何实现在逻辑回归的上面的。这样可以同时处理整个训练集来实现梯度下降法的一步迭代，不需要任何显示的for循环。\n\n\n不需要显式的for循环就可以从m个训练样本中一次性计算出z和a，这就是正向传播一步迭代的向量化实现（同时处理所有M个训练样本）。\n\n\n12 向量化逻辑回归的梯度输出用向量化同时计算m个训练数据的梯度\n\n\n不使用for循环来计算参数的更新\n\n\n\n用高度向量化实现一个逻辑回归\n\n\n13 python中的广播广播技术是一种能使python和Numpy部分代码更高效的技术\n\n\n用两行代码求出每个元素所占列的百分比：第一行代码求出列的总和，第二行代码求出百分比。其实reshape有些多余，因为已经知道了cal是一行四列的向量了，但是为了确保正确还是用了。\n\n\n\n\n在实现神经网络算法时主要用到的广播形式\n\n\n\n14 关于python&#x2F;numpy向量的说明\n当你实现神经网络的逻辑回归时就不要用这些秩为1的数组\n每次创建数组时，要将其定义为列向量或者行向量\n如果不确定一个向量的具体维度是多少，就用assert()进行声明，确保这是一个向量\n如果由于某种原因得到了一个秩为1的数组就用reshape转换成一个列向量和行向量行为的数组\n\n\n15 逻辑回归损失函数的解释\n损失函数的表达式：\n\n\n\n总体成本函数表达式：\n\n\n","tags":["深度学习"]},{"title":"深度学习 day04 浅层神经网络","url":"/2021/08/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20day04%E6%B5%85%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","content":"01 神经网络概览\n在这里用[ l ]来表示神经网络的第l层，用来跟( i )表示的第几个训练样本做区分。神经网络需要反复的计算z和a。\n\n\n02 神经网络表示\n只有一个隐藏层的神经网络：分为输入层、隐藏层、输出层。其中输入层和输出层的值都是在训练集中能看到的，隐藏层的值不能看到。在计算神经网络层数时是不算输入层的，同时我们使用a^[ l ]表示符号，a也代表激活的意思，它意味着网络中不同层的值会传递给后面的层，即每一层都会产生激活值，我们将这些激活值用a^[ l ]_i表示（l表示第几层，下标i表示层中的第几个节点）。在本例中w参数是（4，3）维的，其中4代表四个隐藏单元，3代表有三个输入特征\n\n\n03 计算神经网络的输出神经网络的输出究竟是如何算出来的\n\n\n这里的圆圈代表逻辑回归计算的两个步骤，神经网络只不过是计算这些步骤很多次（隐藏层的每一个节点都计算一次）。\n\n\n\n下面把这四个等式向量化：向量化时的一条经验法则就是当我们在一层中有不同的节点，那就纵向的堆叠起来（例如a^[1]就是a^[1] _1~a^[4] _ 4这些激活值的堆叠）。\n\n\n\n计算出四个隐藏层中的逻辑回归单元使用的是前两个等式，计算出输出层的逻辑回归用的是后两个等式\n\n\n04 多个例子中的向量化\n对于新的符号a^[2] (i)：这个i表示训练样本i。下面是没有向量化的实现并且想要计算所有训练样本的预测：\n\n\n\n下面将for循环变成向量化实现：将这些向量横向堆叠起来。\n\n\n\n总结一下就是横向堆叠对应的是不同的训练样本，竖向堆叠的是不同的输入特征（也就是一层中不同的节点）。\n\n05 向量化实现的解释\n为什么z^[1]&#x3D;w^[1]x+b^[1]?\n\n\n\n如果将输入成列向量堆叠，那么在方程运算之后，也能得到成列对堆叠的输出。右上图是在单个训练样本中实现正向传播算法就是从1循环到m，右下图第一行代码可以对所有m个例子同时向量化，类似的右下图这四行代码都是上面四行代码正确的向量化形式。\n\n\n06 激活函数搭建神经网络，你可以选择在隐藏层用哪个激活函数，在输出层用哪个激活函数。\n\n\n一些其他的激活函数：【1】tanh函数（双曲正切函数）范围在-1到1之间。如果让函数g(z)&#x3D;tanh(z)，这几乎总比sigma函数效果好，因为现在函数输出介于-1和1之间，激活函数的平均值就更接近0。使用tanh也有类似数据中心化的效果，使得数据的平均值接近0而不是0.5，这使得下一层的学习更方便。几乎tanh函数在所有场合都适用，但是在输出层例外，因为如果输出层y是0或1，那么肯定要介于0和1之间，于此同时在二元分类就可以使用sigma函数作为输出层了。tanh函数和sigma函数都有一个缺点：当z特别大或者特别小时，函数的斜率可能就很小，这样会拖慢梯度下降算法。【2】ReLU函数（修正线性单元），ReLU的好处在于对很多z空间激活函数的斜率和0差很远。在实践中使用ReLU函数，你的神经网络的学习速度通常会比使用tanh或者sigma激活函数快很多，主要是ReLU没有这种斜率接近0时减慢学习速度的效应。\n\n\n\n选择激活函数的经验：如果在做二元分类，输出值是0和1，那么选择sigma函数作为输出层的激活函数，然后其他所有单元都用ReLU。一般不使用sigma函数，因为tanh函数比他更适用，ReLU是默认的激活函数，不知道选谁就选它。如果实在不知道选择哪个激活函数，就在验证集或者开发集上跑跑，看看哪个效果好就选择哪个。\n下面是四种激活函数（最后一个是ReLU的特殊形式叫做带泄露的ReLU）\n\n\n07 为什么需要非线性激活函数？要让你的神经网络能够计算出有趣的函数就必须使用非线性激活函数。\n\n\n如果使用线性激活函数或者叫恒等激活函数，那么神经网络只是把输入线性组合再输出。线性隐层一点用都没有，只有一个地方可以使用线性激活函数g(z)&#x3D;z，就是你的机器学习是回归问题的输出层。\n\n\n08 激活函数的导数当对神经网络使用反向传播的时候，你需要计算激活函数的斜率或者说导数\n\n\nsigma激活函数的导数\n\n\n\ntanh激活函数的导数\n\n\n\nReLU和带泄露的ReLU激活函数的导数\n\n\n09 神经网络的梯度下降法\n输入层有n^[0]个，隐层有n^[1]个，输出层有n^[2]个，还有一个神经网络的成本函数，在二元分类的情况下，成本函数就是1&#x2F;m对损失函数求平均。要训练参数，算法就需要做梯度下降，在训练神经网络时随机初始化参数很重要，而不是全部初始化为0。\n\n\n\n针对于所有样本的前向传播和后向传播：keepdims就是防止python直接输出秩为1的数组（(n,)），确保python输出的是矩阵（(n,1)）。*代表逐个元素乘积。\n\n\n10 直观理解反向传播\n单层神经网络：\n\n\n\n双层神经网络：实现后向传播算法有个技巧，你必须确保矩阵的维度互相匹配。\n\n\n\n反向传播公式小总结：单个样本 | 总样本\n\n\n11 随机初始化对于逻辑回归可以将权重初始化为0，但是如果将神经网络的各参数数组全部初始化为0，再使用梯度下降算法将会完全无效\n\n\n如果将w所有值初始化为0，那么因为两个隐藏单元最开始就在做同样的计算，对输出单元的影响也一样大。那么一次迭代之后，同样的对称性依然存在，两个隐藏单元依然是对称的。无论你神经网络训练多久，两个隐藏单元依然在计算完全一样的函数，所以这种情况多个隐藏单元是没有意义的。当然对多个隐藏单元也适用。\n\n\n\n因此解决这个问题就要随机初始化，通常喜欢将权重初始化成很小的数，因此乘一个0.01（深层就要乘一个0.01以外的数）。因为当使用tanh和sigma激活函数时，如果权重过大就会落到斜率平缓处，导致学习缓慢。\n\n\n","tags":["深度学习"]},{"title":"深度学习 day05 深层神经网络","url":"/2021/08/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20day05%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","content":"01 深度神经网络\nL代表的深度神经网络的层数，n^ [l]代表的是l层有多少个节点，a^ [l]代表l层的激活函数，w^ [l]表示在a^ [l]中计算z^ [l]值的权重。\n\n\n02 深层网络中的前向传播\n在深层网络中应用前向传播，图中左侧是针对单个样本的，左侧最后一行a的上标应该是3；右上角就是前向传播的总结公式，右下角是用向量化的方法训练整个训练集。在我们实现前向传播时用for循环，没有比它更好的方法，可以计算1到L层的激活函数。\n\n\n03 核对矩阵的维度\n图的右上角的公式可以帮助检查w和b的维度，反向传播时dw和w具有相同的维度，db和b的维度一样。因为a^ [l] &#x3D; g^ [l] (z^ [l])，所以z和a的维度应该相等。（只针对于没有向量化的）\n\n\n\n向量化后的dw和w，db和b的维度同向量化前的一样，但是Z、A、X的维度会发生变化，右侧是发生的变化。\n\n\n04 为什么使用深层表示\n例如人脸识别，将第一层当成一个特征探测器（边缘探测器），然后将探测到的边缘组合成面部的不同部分（第二层），然后将这些部分组合到一起就可以识别或者探测不同的人脸了。边缘探测器相对来说都是针对照片中非常小块的面积，面部探测器就会针对于大一些的区域，就是从简单到复杂。这种从简单到复杂的金字塔状网络还可以应用于语音识别等领域。\n\n\n\n电路理论：在非正式情况下，能够用电路元件计算的函数可以用相对较小但很深的神经网络来计算（小指的是隐藏单元的数量相对比较少），但是如果用浅一些的神经网络计算同样的函数，会需要呈指数增长的单元数量才能到到同样的计算结果。如下图所示右侧就是单层神经网络，而左侧就是相对较小但很深的神经网络。\n\n\n05 搭建深层网络块\n用作前向传播的正向函数，输入是a^ [l-1]，输出是a^ [l]以及输出到缓存的z^ [l]，用作反向传播的反向函数，输入da^ [l]及之前缓存的z^ [l]，输出da^ [l-1]和dw^ [l]和db^ [l]。\n\n\n\n下面是前向传播和后向传播的流程图，在编程过程中缓存z、w、b可以将这些参数复制到计算反向传播所需要的地方。\n\n\n06 前向和反向传播\n前向传播的步骤：非向量化 | 向量化\n\n\n\n反向传播的步骤：非向量化 | 向量化，右侧第二个不是l-1是l\n\n\n\n总结：初始一个向量化反向传播的方法（右下角那个）\n\n\n07 参数 VS 超参数\n超参数是实际上控制了最后的参数w和b的值，比如说：学习率a、梯度下降法循环的数量、隐层数L、隐藏单元数n^ [l]、以及各种激活函数。这些超参数某种程度上决定了最终得到的w和b。\n\n\n\n不断地尝试超参数的设置，这样才能找到个好的值来完成学习。随着时间的推移，一些电脑硬件或者其他的改变，之前设置好的超参数的值到现在不一定适用，因此一定要勤快点，多试试。\n\n\n08 这和大脑有什么关系\n没啥关系\n\n\n","tags":["深度学习"]},{"title":"深度学习 day06 深度学习的实用层面","url":"/2021/08/08/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20day06%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B1%82%E9%9D%A2/","content":"01 训练 &#x2F; 开发 &#x2F; 测试集\n应用型机器学习是一个高度迭代的过程（想法-&gt;代码-&gt;实现），循环该过程的效率是决定项目进展速度的一个关键因素，创建高质量的训练集、验证集、测试集也有助于提高循环效率。\n\n\n\n随着数据量的不断增加（从1000个样本到1000000个样本），那么验证集和测试集占数据总量的比例会趋向于变得更小。如果数据有一百万，那么就可以选择一万条作验证集，一万条作测试集。因为验证集的目的就是验证不同的算法，检验哪种算法最有效，同样的根据最终选择的分类器，测试集的主要目的是正确评估分类器的性能，选择这么多数据就足够了。（训练集98%，验证集1%，测试集1%）\n\n\n\n总结：现代深度学习的一个趋势：在训练和测试集分布不匹配的情况下进行训练（比如说训练集数据是从网上整下来的，验证集和测试集是用户上传的），针对于这种情况要确保验证集和测试集的数据来自同一分布。最后一点就是没有测试集也没关系（如果不需要无偏估计），如果只有验证集没有测试集，就应该在训练集上训练尝试不同的模型框架，在验证集上评估这些模型，然后迭代并选出合适的模型 。\n\n\n02 偏差 &#x2F; 方差关于深度学习的误差问题就是要对偏差、方差的权衡。\n\n\n分为欠拟合（高偏差） | 适度拟合 | 过度拟合（高方差）\n\n\n\n理解偏差和方差的两个关键数据是训练集误差和验证集误差。下面分别是基于人眼误差为0的情况下，高方差 | 高偏差 | 高偏差+高方差 | 低偏差+低方差。（以上分析的前提都是假设基本误差很小，训练集和验证集来自相同分布）如果最优误差（贝叶斯误差）为15%，那么第二组数据就是低偏差+低方差。\n\n\n\n下面用紫色线画出的分类器具有高偏差和高方差，高偏差是因为它几乎是一条线性分类器，并未拟合数据，高方差是因为采用曲线函数或二次函数，灵活性太高以致拟合了这两个错误样本。\n\n\n\n总结：通过分析训练集和验证集验证算法产生的误差来诊断算法是否存在高偏差或者高方差，以此来决定接下来你要做什么\n\n03 机器学习基础\n首先检查偏差，如果偏差过高，甚至无法拟合训练集，那么就需要选择一个新网络（含有更多的隐层或者隐藏单元）；或者花费更多的时间来训练网络（花费更多的时间训练算法或者尝试更先进的优化算法）；或者从多种神经网络架构中选择一种，通常采用规模更大的网络都会有所帮助。不断地重复这些步骤，直到偏差降低到可接受范围。\n一旦偏差降低到可接受的范围，检查下方差有没有问题（评估方差要查看验证集性能），如果方差过高，需要采用更多的数据也许会有帮助；或者通过正则化来减少过拟合；找到更合适的网络架构。\n\n\n04 正则化\n逻辑回归函数中的正则化：L2正则化是最常见的，还有L1正则化，如果使用L1正则化，w最终会是稀疏的（w向量中有很多0）。在python中我们使用lambd来代替lambda正则化参数。\n\n\n\n神经网络实现L2正则化：字母L代表神经网络的层数\n\n\n05 为什么正则化可以减少过拟合？\n直观的理解就是lambda增加到足够大，w会接近于0，在这个过程中她会出现拟合正合适的情况，逐渐的会变成高偏差。直觉上我们会认为大量的隐藏单元被完全消除了，实际上依然存在，只是他们的影响变得更小了。\n\n\n\n假设我们用的是tanh()函数，z在很小的范围内，图像是呈线性的，如果z变得更大或者更小，图像将呈非线性。如果神经网络每层都是线性的，那么整个网络就是线性网络，最终我们只能计算线性函数，因此它不适合非常复杂的决策。总结：如果正则化参数变得很大，参数w很小，z也会相对变小，整个神经网络会计算离线性函数近的值，这个线性函数非常简单不会发生过拟合。\n还有一点值得注意：为了调试梯度下降，一定要使用新定义的J函数，它包含了第二个正则化项，否则函数J可能不会在所有调幅范围内都单调递减。\n\n\n06 Dropout正则化\nDropout（随机失活）工作流程：假设左图存在过拟合，dropout会遍历网络的每一层，并设置消除神经网络中节点的概率（每一个节点都以抛硬币的方式设置概率即每个节点得以保留和消除的概率都是0.5），我们在消除一些节点的同时也会删除该节点进出的连线，最后得到一个节点更少、规模更小的网络。\n\n\n\n如何实施dropout：inverted dropout（反向随机失活）-&gt;首先定义一个向量d，d^ 3表示一个三层的dropout向量；然后看它是否小于某个数（keep-prob），keep-prob表示保留某个隐藏单元的概率，它的作用就是生成随机矩阵，这个d3就是个布尔类型的数组，值为1或者0；接下来是从第三层中获取激活函数（a3），a3等于上面的a3与d3元素相乘，它的作用就是过滤d3中所有等于0的元素，而各个元素等于0的概率只有20%；最后向外扩展a3，通过除以keep-prob来确保a3的期望值不变，假设预期a^ [3]预期减少20%，为了不影响z^ [4]的期望值，就需要用w^ [4]*a^ [3]除以0.8，它将会修正我们所需的那20%。\n\n\n\n我们在测试阶段不使用dropout，因为在测试阶段我们不期望输出的结果是随机的。测试阶段不同于训练阶段，即使在测试阶段不执行dropout来调整数值范围，激活函数的预期结果也不会发生变化。\n\n\n07 理解Dropout\n左图中用紫色圈起来的单元，它不能依靠任何特征，因为特征（该单元的输入）都有可能被随机清除。通过为单元的四个输入增加一点权重，Dropout将产生收缩权重的平方范数的效果。实施Dropout的结果是会压缩权重并完成一些预防过拟合的外层正则化。Dropout的功能类似于L2正则化，与L2正则化不同的是：被应用的方式不同，Dropout也会有所不同，甚至更适用于不同的输入范围。为了预防矩阵的过拟合，对权重最大的矩阵（例如右图的w^ [2]&#x3D;7×7）的那一层，keep-prob值应该相对较低，而且每一层的keep-prob值都有可能不同，如果某一层keep-prob为1，那么就不对这层使用Dropout。\n在计算机视觉领域由于通常没有足够的数据，所以一直存在过拟合，所以Dropout在这是很热门的。Dropout的一个大缺点就是代价函数J不被明确定义，为了绘制学习曲线确保每次迭代都是呈下降趋势，通常会关闭Dropout函数，然后运行代码确保J函数单调递减，最后在打开Dropout。\n\n\n\n总结：如果你担心某些层比其他层更加容易过拟合，那么就将某些层的keep-prob值设置相对较低，缺点是为了使用交叉验证，需要搜索更多的超级参数。另一种方案是一些层用Dropout，一些层不用，应用的层只含有一个超级参数就是keep-prob\n\n08 其他正则化方法\n数据扩增可以作为正则化方法使用：对图片进行水平翻转，扩大裁剪，对数字进行扭曲等操作。\n\n\n\nearly stopping代表提前停止训练神经网络。我们在绘制验证集误差时会发现。验证集误差通常会呈下降趋势，然后在某一节点开始上升，因此在迭代的过程中选择中间w的值（就是那个拐点），early stopping的优点是只运行一次坡度下降，就可以找到w的较小值、中间值和较大值，而无需尝试L2正则化超级参数lambda的很多值。\n\n\n09 正则化输入训练神经网络，其中一个加速训练的方法就是归一化输入：归一化的目的就是让特征值保持在相似的范围内\n\n\n归一化输入有两个步骤：第一步是零均值化（左下公式）变为第二个图，第二步是归一化方差（右下公式）变为第三个图，第二个图的x_1的方差明显比x_2的方差要大-&gt;第三个图x_1的方差和x_2的方差一样大。我们希望不论是训练数据还是测试数据都是通过相同的u和sita^ 2定义的相同数据转换，其中u和sita^ 2是由训练集数据计算得出的。\n\n\n\n如果使用非归一化特征（特征值不在一个相似的范围内），会得到一个非常细长狭窄的代价函数（左图）并且需要的学习率也要小，如果归一化特征后（特征值处于相似范围内），代价函数看起来更加的对称（右图）而且设置的学习率可以较大。如果特征的范围都很相似，那么将对优化算法很有利（下方x的取值），否则不利（上方x的取值）。\n\n\n\n总结：如果特征值不在一个相似的范围内，那么归一化将会显得格外重要，如果特征值处于相似范围内，那么归一化就不是很重要了。\n\n10 梯度消失与梯度爆炸当你训练神经网络时，导数或者坡度有时会变得非常大或者非常小，甚至以指数方式变小，这加大了训练难度。我们应更加明智的选择随机初始化权重，从而避免这个问题。\n\n\n该例子中g（z）&#x3D;z，b^ [l]&#x3D;0。当权重w只比1略大一点或者说比单位矩阵大一点，深度神经网络的激活函数将爆炸式增长，如果w比1略小一点，在神经网络中激活函数将以指数级递减。\n\n\n11 神经网络的权重初始化\n神经单元权重初始化：为了防止z值过大或过小，当n越大你希望w_i越小，最合理的方法就是设置w_i&#x3D;1&#x2F;n，其中这里的n代表神经元的输入特征数量，实际上就是设置某层权重矩阵w。如果用的是Relu激活函数而不是1&#x2F;n，方差设置为2&#x2F;n更好。这里用n^ [l-1]是因为一般情况下l层的每个神经元都有n^ [l-1]个输入。\n其他变体函数的公式：Tanh激活函数为右边第一个式子；Relu激活函数是左边画框的；有时也用右边第二个\n\n\n12 梯度的数值逼近梯度检验的作用是确保backprop正确实施\n\n\n单边计算：\n\n\n\n使用双边误差的方法更逼近导数，双边计算出来是3.0001，而单边计算出来是3.0301，可以看出双边更加接近3。\n\n\n13 梯度检验\n首先做些处理：\n\n\n\n为了实施梯度检验，要做的就是循环执行。先将J展开，然后进行循环，我们要验证的就是dsita_approx与dsita这两个向量是否真的接近，一般做下列运算：计算这两个向量的距离（dsita_approx-dsita的欧几里得范数，注意没有平方，它是误差平方之和，然后求平方根得到欧式距离），然后用向量长度做归一化，结果为||dsita_approx-dsita||&#x2F;||dsita_approx||+||dsita||。分母只是用来预防这些向量太小或太大，分母使这个方程式变成比率。如果计算方程式得到的值为10的-7次方甚至更小，这就很好；如果在10的-5次方就要小心了，检查这个向量所有的项确保没有一项误差过大；如果是10的-3那么就要担心是否存在bug了，看看是否有个具体的i值使得dsita_approx与dsita大不相同。\n\n\n14 关于梯度检验实现的注记如何在神经网络实现梯度检验的适用技巧和注意事项\n\n\n不要在训练中适用梯度检验，它只用于调试\n如果算法的梯度检验失败，要检查所有项，并试图找出bug：如果两个向量的值相差很大 ，我们要查找不同的i值，看看是哪个导致的。\n在实施梯度检验时，如果使用正则化，请注意正则项\n梯度检验不能与dropout同时使用：因为每次迭代过程中dropout会随机消除隐层单元的不同子集，难以计算dropout在梯度下降上的代价函数J\n在随机初始化过程中，当w和b接近0时，梯度下降&#x2F;backprop的实施是正确的；但在运行梯度下降时w和b变得更大，也就越来越不准确。这时要做的就是在随机初始化过程中运行梯度检验，然后训练网络，w和b会有一段时间远离0，如果随机初始化值比较小，反复训练网络之后再重新运行梯度检验。\n\n\n","tags":["深度学习"]},{"title":"深度学习 day07 08 优化算法","url":"/2021/08/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20day07%2008%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/","content":"01 Mini-batch 梯度下降法\nX代表训练样本的集合，向量化能够相对较快地处理所有m个样本，但是如果m过大，处理速度仍然缓慢。在对整个训练集执行梯度下降法时，原本是需要处理完所有样本，才能进行一步梯度下降法，然后再重新处理所有样本，才能进行下一步梯度下降，但是如果在处理完所有样本之前，先让梯度下降法处理一部分，那么算法速度将会更快。因此我们可以将训练集分割为小一点地子集（子集就叫Mini-batch ），我们用X^ {t}代表第t个子集，当然Y也需要分割。\n\n\n\n在使用Mini-batch 梯度下降法时，同样要设有一个循环，这个循环是遍历所有的子训练集，同样的也要计算前向传播、代价函数J及执行后向传播来计算J^ {t}的梯度，只使用X^ {t}和Y^ {t}，然后更新权值。这只是遍历了一次训练集，如果还想多次遍历需要使用for或者while。\n\n\n02 理解 mini-batch 梯度下降法\nBatch梯度下降法：成本函数J会随着每次迭代而减小；mini-batch 梯度下降法：由于每次迭代都在训练不同的样本集（X^ {t}和Y^ {t}），所以成本函数J会产生波动，但是总体趋势是下降的。\n\n\n\n决定mini-batch的大小有两种极端的情况：\n\nmini-batch &#x3D; m（整个训练集）–&gt;Batch梯度下降法（如果m很大，则单次迭代耗时太长）\nmini-batch &#x3D; 1–&gt;随机梯度下降法（会失去所有向量化带来的加速，效率过于低下，并且结果永远都不会收敛，会一直在最小值附近徘徊）\n\n\n在这两种极端情况下，成本函数的优化情况：蓝色（Batch梯度下降法），紫色（随机梯度下降法）\n\n所以要选择不大不小的mini-batch尺寸，实际上学习速率达到最快：一方面得到大量向量化，另一方面不需要等待整个训练集被处理完，就可以开始进行后续工作了。当然mini-batch 梯度下降法的结果也都不会收敛，会一直在最小值附近徘徊，这时可以慢慢减小学习率。\n\n\n\n\n那么该如何选择mini-batch尺寸呢：如果训练集较小，直接使用batch梯度下降（m&lt;2000）；如果训练集较大，mini-batch尺寸一般选择在64~512，经常将mini-batch尺寸设成2次方，这样代码会运行的比较快。最后要注意的是在mini-batch中X^ {t}和Y^ {t}要符合CPU&#x2F;GPU内存，如果不相符无论使用什么方法，算法都会表现得急转直下。\n\n\n03 指数加权平均\n计算下面温度散点图的趋势或者是温度的局部平均值或者说移动平均值：首先V_0&#x3D;0，然后运用公式：某天的V等于前一天的V的0.9倍加上当日温度的0.1倍，这样计算后用红线作图就得到了移动平均值&#x2F;每日温度的指数加权平均值。\n\n\n\n大体公式如下所示：在计算平均多少天温度时用1&#x2F;(1-b)来计算，如果b&#x3D;0.9将其带入该式子，可得10也就是十天的平均值，如果b为0.98就是绿色的线为50（平均过去50天的温度），如果b为0.5得到黄色线。b这个参数的大小决定了上一个值得权重。\n\n\n04 理解指数加权平均\n我们首先画一个每天温度得图（右上第一个），然后构建一个指数衰减函数（右上第二个）看sita的系数，sita99就是0.1×0.9、sita98就是0.1×(0.9)^ 2，以此类推画出图。计算V_100就是讲两个图对应的元素相乘然后求和。sita的系数加起来为1或者逼近1，我们称之为偏差修正，正是因为有偏差修正，这才是指数加权平均数。\n\n那么到底需要平均多少天数呢：就是看几天后权重下降到不到当日权重的三分之一（设b等于一个数，他需要多少次方才能达到1&#x2F;e，多少次方用1&#x2F;(1-b)来计算）\n\n\n\n\n如何在实际中执行：看右图就是初始化v，然后直接讲这个v带入公式来更新新的v，不断地更新。注意：左图是&#x3D;，右图是：&#x3D;\n\n\n05 指数加权平均的偏差修正\n如果你在设置b为0.98时不是绿色的线而是起点低的紫色的曲线，那么我们就不要用V_t，而是用V_t&#x2F;(1-b^t)。假如t&#x3D;2，经过计算就是1号和2号数据的加权平均数并除去偏差，随着t的增加，b的t次方接近0，所以当t很大时，偏差修正几乎没有作用，因此当t很大时紫色线基本和绿色线重合了。如果关心初始时期的偏差，那么在刚开始计算指数加权移动平均数的时候，偏差修正能帮助在早期获得更好的估测。\n\n\n06 动量梯度下降法还有一种算法叫Momentum梯度下降法，运行速度几乎总是快于标准的梯度下降算法。基本思想是：计算梯度的指数加权平均数，并用该梯度更新权重。\n\n\nMomentum梯度下降法在第t次迭代过程中，用现有的Mini-batch计算dW、db 。然后通过指数加权平均计算得到dw及db的移动平均数，最后重新赋值权重，这样就可以减缓梯度下降的幅度（即纵轴方向的摆动小了），也可以增加横轴方向的运动速度（红色线）。如果要最小化碗装函数，其中dW、db相当于为你从山上往下滚的球提供了加速度，V_dW、V_db相当于速度。由于β稍小于1，相当于有摩擦力，所以球不会无限的加速下去。\n\n\n\n最后我们看看具体如何计算：就用左边的公式包含1-β，因为右边的公式，如果你最后要调整超参数β，那么就会影响V_dW、V_db，也许还要修改学习率α（α要根据1&#x2F;(1-β)相应变化）。\n\n\n07 RMSprop（均方根）RMSprop也可以加速梯度下降，因为将微分进行平方，最后还使用了平方根所以叫均方根\n\n\n分析这个纵轴幅度大，横轴向前推进的例子，假设纵轴代表参数b，横轴代表参数w，想要减缓b方向的学习同时推进横轴方向的学习，RMSprop算法可以将其实现。同样的RMSprop也会在第t次迭代中计算当下mini-batch的微分dW、db，接着通过计算得到(dw)^ 2及(db)^ 2的加权平均数，在更新参数时也做了些许改动，公式如下：从斜率可以看出纵轴的斜率比横轴的大（dW&gt;db）结果就变为绿色线。同样还可以用一个较大的学习率α来加快学习，而无须在纵轴上垂直方向偏离。为了保证数值能稳定一些，需要确保分母不为0，就要在分母上加一个很小很小的ε。\n\n\n08 Adam算法Adam算法基本就是将Momentum和RMSprop结合在一起\n\n\n使用Adam算法，首先要初始化，接着在第t次迭代中用当前的mini-batch计算dW、db，接下来计算momentum指数加权平均数，然后用RMSprop进行更新，相当于momentum更新了超参数β_1，RMSprop更新了β_2。一般使用Adam算法时要计算偏差修正，最后就可以更新权重了。\n\n\n\n其中有几个超参数：\n学习率α可以尝试一系列的值看哪个有效\nβ_1常用值为0.9，这是dW &#x2F; db的移动平均值也就是加权平均数\nβ_2常用值为0.999，这是(dW)^ 2 &#x2F; (db)^ 2的移动平均值也就是加权平均数\nε建议是10^ -8，但是没有必要设置\n\n\n\n\n09 学习率衰退加快学习算法的一个办法就是随着时间慢慢减小学习率，我们称之为学习率衰退\n\n\n蓝色的是使用同一学习率，而绿色的是随着时间慢慢减小学习率。慢慢减小学习率的本质在于：在学习初期你能承受较大的步伐，但当开始收敛时，小的学习率能让步伐小一些，不必在最小值范围内大幅度摆动。\n\n\n\n可以这样来进行学习率衰退：第一次遍历训练集叫做一代，第二次就是二代。可以将学习率设为（1&#x2F;(1+衰退率* 第几代）*α_0，α_0为初始学习率。如果想使用学习率衰退就需要不断地尝试参数α及超参数衰退率，找到合适的值。\n\n\n\n除了学习率衰减的公式，人们还使用指数衰减等其他公式：其中t代表mini-batch的数字。还会用离散下降，学习率一会减一半一会减一半。当然还可以手动调试学习率（在训练集小的时候）\n\n\n10 局部最优的问题\n在高维度空间更有可能碰到右图的鞍点（导数为0的点），而不会碰到局部最优。\n\n\n\n平稳段会减缓学习。慢慢下降到平稳段，然后在走出平稳段。\n在训练较大的神经网络存在大量参数并且成本函数J被定义在较高的维度空间时，不大可能困在极差的局部最优中。\n平稳段是一个问题，这样使得学习十分缓慢，这也是像Momentum或者是RMSprop或者是Adam这样的算法加快学习算法的地方，让你尽早走出平稳段。\n\n\n","tags":["深度学习"]},{"title":"深度学习 day09 超参数调试、Batch 正则化和程序框架","url":"/2021/08/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20day09%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E8%AF%95%E3%80%81Batch%20%E6%AD%A3%E5%88%99%E5%8C%96%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/","content":"01 调试处理系统地组织超参调试过程的技巧\n\n\n学习速率是需要调试的最重要的超参数（红色），其次是momentum、mini-batch的大小及隐藏单元（黄色），重要性拍第三位的就是层数、学习率衰减、Adam算法（其余都是）\n\n\n\n如果要调整一些超参数，该如何选择调试值呢？\n在早一代的机器学习算法中（左图），如果有两个超参数，常见的作法是在网格中取样点，然后系统的研究这些数值，然后选择哪个参数效果最好。（参数的数量相对较少时）\n在深度学习领域中（右图）推荐下面做法：随机选择点，然后用随机取的点试验超参数的效果，之所以这么做是因为你 很难提前知道哪个超参数最重要。\n\n\n就举两个极端的超参数，α和ε，无论ε取何值，结果基本都是一样的。对于左边的图来说25个样点，但是α只能尝试五个值，而对于右图，每个样点都是独立的也就是α可以取25个值。\n\n\n\n当你给超参数取值时，另一个惯例就是采用由粗糙到精细的策略，也就是在整个的方格中进行粗略搜索后，发现某个点的效果最好，周围的点效果也不错，这时就可以聚集到这个点周围更小的方格中，在更小的方格中，更加密集的随机取点。\n\n\n02 为超参数选择合适的范围随机取值并不是在有效范围内的随机均匀取值，而是选择合适的标尺用于探究这些超参数。\n\n\n假设选取隐藏单元的数量n^ [l]，选择范围是从50到100中某点；如果要选取神经网络的层数L，选择范围是从2到4。\n\n\n\n假设你在搜索超参数学习率α，取值范围是0.0001到1，如果沿其随机均匀取值那么90%的数值会落在0.1到1，这样看起来不对，反而用对数标尺搜索超参数的方式会更合理，因此这里不使用线性轴，而是分别依次取0.0001、0.001、0.01、0.1、1，在对数轴上随机均匀取点，这样每个数值之间都有更多的搜索资源可用。用python实现如下：将超参数设置为10^ r，r取值在a到b之间，其中a与b是通过对最小值和最大值进行对数运算得出。\n\n\n\n另一个棘手的例子就是给β取值，用来计算指数的加权平均值，取0.9就相当于在10个值中取平均值，取0.999相当于在1000个值中取平均，如果想要在0.9到0.999之间进行搜索就不能用线性轴取值，我们要探究的应该是1-β，值在0.001到0.1区间，要做的就是在[-3,-1]里随即均匀的给r取值，就相当于给β取值。为什么不能用线性轴呢？因为β接近1时，任何细微的变化都会产生大影响（1-β），所以在β趋近于1的范围内需要密集的取值。\n\n\n\n即使标尺没有选对也没关系，只要数据足够就影响不大。\n\n03 超参数训练的实践：Pandas VS Caviar组织超参数搜索过程的建议和技巧\n\n\n由于某些情况你的原来设定的超参数不好用了，建议就是每隔几个月至少一次重新测试或评估你的超参数来确保你对数值依然很满意。\n关于如何搜索超参数的问题：\n照看一个模型，对其细心照料（通常是有庞大的数据组，但是没有许多计算资源或者足够的CPU和GPU的情况下），即使它在试验时也可以进行改良。因为没有足够的计算能力，不能在同一时间试验大量的模型，所以要观察它的表现，不断调整学习率。\n同时试验多种模型，一视同仁：你设置一些超参数，就让他自己运行（蓝线），也可以开始一个有着不同超参数设定的不同模型，第二个模型（紫线），第三个模型（红色）等等，最后选择工作效果最好的那个。\n\n\n\n\n04 正则化网络的激活函数Batch归一化会使你的参数搜索问题变得很容易，使神经网络对超参数的选择更稳定，超参数的范围会更庞大，工作效果也很好，也会很容易的训练深层网络。\n\n\n对于逻辑回归和神经网络的归一化输入特征值来说，归一化输入特征是可以加速学习过程的。\n对于深层网络来说：Batch归一化的作用是：对于任何一个隐藏层而言，能够归一化a值以更快速的训练w和b。严格的来说，我们真正归一化的不是a而是z。\n\n\n\n单一隐含层Batch归一化的使用方法：网络中已知有些中间值，如假设有一些隐藏单元值z^ (1)到z^ (m)，接下来要计算平均值，然后计算方差，然后取每个z^ (i)规范化，化为含平均值0和方差1（**(z^ (i)-均值)&#x2F;标准偏差**），为了确保数值稳定这里我们依旧加一个ε。因为隐藏单元有不同的分布可能会有意义（例如在sigmoid激活函数，我们不希望值都集中在线性那），因此我们不想隐藏单元总是含有平均值0和方差1，所以我们开始接下来计算ztilde，其中这里的γ和β是模型的学习参数，然后使用梯度下降算法等方法更新γ和β。如果γ&#x3D;z的分母、β&#x3D;u，那么他就可以精准的转化公式使得z&#x3D;ztilde。\n\n\n\nBatch归一化的作用是它适用的归一化过程不只是输入层，也适用于神经网络中的深度隐藏层。\n\n05 将Batch Norm拟合进神经网络\nBatch归一化是发生在计算z和a之间的，与其应用没有规范过的z^ [i]，不如用经方差和均值归一后的ztilde^ [i]。而且这里的β与用在momentum、Adam、RMSprop里的β不同。可以用任何优化算法来更新参数β和γ，在TensorFlow框架中可以用右下角的函数来实现Batch归一化。\n\n\n\n在实践中，Batch归一化通常和训练集的mini-batch一起使用，应用Batch归一化的方式就是：用第一个mini-batch计算z^ [1]，然后在经Batch归一化得到ztilde^ [1]，再应用激活函数得到a^ [1]，然后再一直运行下去。再用第二个mini-batch，直到用完。值得注意的一点：使用Batch归一化可以消除参数b，因为mini-batch中增加任何常数，数值都不会变，加上的任何常数都会被均值减法所抵消。\n\n\n\n用Batch归一化来应用梯度下降法-&gt;假设你在使用mini-batch梯度下降法：\n\n\n06 Batch Norm为什么奏效？\nbatch归一化有效的第一个原因是它不仅仅针对输入值，还针对隐藏单元的值，将那一层所有的值通过归一化得到类似范围的值，可加速学习。第二个原因是它可以使权重比你的神经网络更滞后或者更深层（比如第十层相比于第一层的权重更能经受得住变化）。即使存在运行都很好的同一个函数，但你不会希望你的学习算法去发现绿色的决策边界，只看左边的数据的话，可能使得你产生数据改变分布的想法（covariate shift），正如x到y的映射一样，改变下，y也随之改变。\n\n\n\nbatch归一化做的是它减小了这些隐藏值分布变化的数量，就以z^ [2] _1与z^ [2] _1为例，即使它的值改变了，至少他们的均值和方差也会是均值0和方差1，亦或者是由β和γ决定的其他均值与方差。直观来说batch归一化减弱了前层参数的作用与后层参数的作用之间的联系，它使得网络每层都可以自己学习，稍稍独立于其他层，有利于加速整个网络的学习。\n\n\n\nbatch归一化另一个作用就是他有轻微的正则化效果，因为在mini-batch上计算的均值和方差，均值和方差都会有一些小噪音；缩放过程从z^ [l]到ztilde^ [l]也会有些噪音，因为它是用有噪音的均值和方差计算得出的，所以和dropout相似，他往每个隐藏层的激活值上增加了噪音，dropout含几重噪音是因为它以一定概率乘以0或1，batch归一化含几重噪音是因为标准差的缩放和减去均值带来的额外噪音。因为给隐藏单元添加了噪音，迫使后面单元不过分依赖任何一个隐藏单元，因为噪音很小，所以不是巨大的正则化效果，可以将batch归一化和dropout一块使用；dropout的一个特性是mini-batch越大，正则化效果越弱。\n\n\n\n注意：batch归一化一次只能处理一个mini-batch数据\n\n07 测试时的 Batch NormBatch归一化将数据以mini-batch的形式逐一处理，但是在测试时，需要对每一个样本逐一处理\n\n\n我们用m来表示一个mini-batch中的样本数量，在测试过程中不可能将一个mini-batch中所有样本同时处理，所以需要用其他方法得到u和σ^ 2。为了将神经网络应用于测试就需要单独估算u和σ^ 2。在这里我们用指数加权平均来估算（这个平均数涵盖了所有mini-batch），训练l层的每一个mini-batch都会得到一个u值。可以用指数加权平均来追踪在这一层所有mini-batch中所见的σ^ 2的值，也可以用来追踪均值向量的最新平均值，因此在用不同的mini-batch训练神经网络的同时，能够得到你所查看的每一层的u和σ^ 2的平均数的实时数值。\n\n\n\n总结：在训练时u和σ^ 2是在整个mini-batch上计算出来的，但在测试时需要逐一处理样本，方法是根据你的训练集通过运用指数加权平均估算出u和σ^ 2，然后用测试中的u和σ^ 2来进行你所需的隐藏单元z值得调整。\n\n08 Softmax回归Softmax回归能让你在试图识别某一分类时做出预测（识别多种分类）\n\n\n我们用C来表示有几个种类，我们想要输出层单元的数字告诉我们这四种类型中每一个的概率有多大，最后输出一个4*1矩阵。\n\n\n\n让网络做到这一点的标准模型要用到Softmax层以及输出层来生成输出。算出z之后就需要应用Softmax激活函数（这个激活函数对于Softmax层而言有些不同）：首先计算一个适用于每个元素的临时变量t&#x3D;e的z^ [l]次方,然后经过计算得到a^ [l]（t经过归一化使和为1），举例右边：之前我们的激活函数都是接受单行数值输入（例如Sigmoid和ReLU激活函数输入一个实数输出一个实数），Softmax激活函数因为需要将所有可能的输出归一化，所以就需要输入一个向量，最后再输出一个向量。\n\n\n\nSoftmax分类器在没有隐藏层的情况下能后做到的事–线性决策边界，更深层的网络可以学习更复杂的非线性决策边界。\n\n\n09 训练一个Softmax分类器\nhard max函数将概率最大的变为1，其他变为0。soft max函数相对比较柔和，该是多少概率就是多少。值得注意的是：如果C&#x3D;2，那么Softmax实际就变回了逻辑回归。\n\n\n\n怎样训练带有Softmax输出层的神经网络？我们应首先定义损失函数（左边是单个训练样本的损失，右边是整个训练集的损失J），下方是使用向量化实现矩阵大写Y。\n\n\n\n在有Softmax输出层时实现梯度下降法：输出层会计算出z^ [l] ( C * 1维)，然后用Softmax激活函数得到a^ [l]，然后由此算出损失。初始化反向传播所需的关键步骤或者说关键方程是dz那个表达式\n\n\n10 深度学习框架\n深度学习的一些框架及选择框架的标准：一个重要的标准就是便于编程（神经网络的开发、迭代、为产品进行配置），第二个标准是运行速度（特别是训练大数据集），第三个标准是这个框架是否真的开放(长时间开源)。\n\n\n11 TensorFlow\n假设有一个J需要最小化，来使用TensorFlow将其最小化：第一行和第二行是引入库，接下来是将w初始化为0，然后定义损失函数，然后定义train为学习算法（用梯度下降优化器使损失函数最小化），下面的两行是惯用的表达，开启了一个TensorFlow session，接下来是初始化全局变量，然后用TensorFlow评估一个变量，然后运行梯度下降法再输出w。\n\n\n\n现在我们运行梯度下降1000次迭代，然后输出w\n\n\n\nTensorFlow中的placeholder是之后会赋值的变量，这种方法便于将训练数据加入损失方程（feed_dict函数）\n\n\n\nTensorFlow已经内置了所有必要的反向函数，通过内置函数来计算前向函数，它就能自动用反向函数实现反向传播。\n\n\n","tags":["深度学习"]},{"title":"深度学习 day10 机器学习（ML）策略","url":"/2021/08/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20day10%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5/","content":"01 为什么是ML策略\n当你尝试优化一个深度学习系统时，通常有很多想法可以去试。一些策略或者一些分析机器学习问题的方法可以指引你朝着最有希望的方向前进。\n\n\n02 正交化搭建机器学习系统的挑战之一是可以尝试和改变的东西太多太多（比如：有那么多超参数需要调整）\n\n\n以左边电视为例，正交化指的是电视设计师设置不同的旋钮，使得每个旋钮只能调整一个性质，这样就可以将画面调整到合适的位置。又如右边的车，有方向盘、油门、刹车来分别控制性质，正交化就是这些控制互不影响，能够相互独立。\n\n\n\n要弄好一个监督学习系统，通常需要调节系统的旋钮来确保四件事：\n系统在训练集上得到的结果不错，训练集上 的表现必须通过某种评估达到能接受的程度。（如果你的算法在成本函数上不能很好的拟合训练集，你需要一个旋钮来确保可以调整你的算法，让他更好的拟合训练集，用来调试的旋钮可以训练更大的网络，或者切换到更好的优化算法。）\n系统在开发集上有好的表现（如果发现算法对训练集很好，对开发集的拟合很差，那么就需要一个旋钮，在不影响训练集的同时，使算法更好的拟合开发集，增大训练集可以是另一个可用旋钮。）\n系统在测试集上有好的表现（如果算法对开发集很好，对测试集很差，这就可能意味着对开发集过拟合了，需要往回退一步使用更大的开发集，增大开发集可以是另一个可用旋钮。）\n系统在测试集上系统的成本函数在实际使用中表现令人满意（如果在测试集做的很好，但是无法给客户好的体验，这需要回去改变开发集或成本函数）\n\n\n\n\n03 单一数字评估标准无论是调整超参数或者是尝试不同的学习算法亦或者是在搭建机器学习系统时尝试不同的手段，如果有一个单实数评估标准，它可以快速的告诉你新尝试的手段比之前的手段是好还是坏。\n\n\n比如说识别猫的例子：如果我们用查准率和查全率来评估分类器（查准率：就是这个图是猫的可能性，查全率：实际为猫的图片中有多少被系统识别出来），那么将很难选择出哪个好，哪个不好，因此需要找到一个结合了查准率和查全率新的评估指标F1调和平均数。\n\n\n\n在有个例子就是各个地方的上传误差，最终使用一个平均值来衡量多个分类器，误差越小越好。\n\n\n04 满足和优化指标\n在该例子中，即看重查准率也看重运行时间，这时就可以将查准率和运行时间组合成一个整体评估指标；你也可以选择一个分类器，能够最大限度提升准确度，但必须满足运行时间小于等于100ms，在这种情况下我们说准确度是一个优化指标（想让准确度最大化），运行时间是满足指标（只要达到要求就行，要求以内都一样），这时B就是很好的分类器；如果你要考虑N个指标，有时候选择其中一个指标作为优化指标是合理的，剩下的均为满足指标。右边就是个例子懂了就不用看。\n\n\n05 训练 &#x2F; 开发 &#x2F; 测试集划分\ndev集也叫开发集有时称为保留交叉验证集。机器学习的工作流程是：你尝试很多思路，用训练集训练不同的模型，然后使用开发集来评估不同的思路，然后选择一个去不断地迭代来改善开发集的性能，得到一个满意的成本，然后用测试集去评估。开发集和优化指标构成了靶心，训练的目的就是向靶心靠拢，而设立训练集是加速靠近靶心的速度。\n以一个猫分类器为例，在下面这些区域内运营：\n不推荐：你选择其中4个区域（可随机选取）的数据构成开发集，其他四个区域的数据构成测试集，因为开发集和测试集不在一个分布\n推荐：让二者来源一个分布，将所有数据随机洗牌将其放入开发集和测试集，这样开发集和测试集都有来自八个地区的数据。\n\n\n\n\n\n在设置开发集和测试集，要选择能够反映你未来会得到的数据、认为很重要的数据、必须得到好结果的数据这样的。\n\n06 开发集合测试集的大小\n前两个是早期数据少的时候划分，最后一个是现在数据多的时候划分。\n\n\n\n测试集的目的是完成系统开发之后，测试集可以帮你评估投产系统的性能。方针就是令你的测试集足够大以至于能够以高置信度评估系统整体性能。对于某些应用也许不需要对系统性能有置信度很高的评估，这时不单独分出一个测试集也是可以的，但是不建议，因为你可以使用这组不带偏差的数据来测量系统的性能。\n\n\n07 什么时候该改变开发 &#x2F; 测试集和指标设置开发集和评估指标就像把目标定在某个位置，让你的团队瞄准\n\n\n假设在构建一个猫分类器，使用的指标是分类误差，从图中看是A效果比较好，但是如果A会将色情图片看成猫的图片，用户是不接受的，而B不会将色情图片看成猫的图片，用户比较倾向于B，在这种情况下（原本的错误指标错误的预测算法A是更好的算法）就应该改变评估指标了或者改变开发集和测试集。可以将分类误差指标写成下面Error的形式，这个评估指标的问题是他对色情图片和非色情图片一视同仁，其中修改评估指标的方法是添加个权重w，图片x不是的话w为1，否则为10甚至100，如果希望归一化常数就是w(i)对所有i求和，这样误差仍然在0和1之间。在开发集和测试集中需要你自己将色情图片标记才能使用这个加权函数。评估指标的意义在于准确告诉你已知两个分类器哪一个更适合你的应用。\n\n\n\n这实际上就是个正交化的例子，你想处理机器学习问题时，应该把它切分成独立的步骤：第一步是弄清楚如何定义一个指标来衡量你想要做的事情的表现（就是设置目标），第二步也许就是学习算法针对某个成本函数优化，加入权重还可能要修改归一化常数（如何精确瞄准，命中目标）。\n\n\n\n如果你当前的指标和当前用来评估数据和你真正关心必须做好的事情关系不大，那就应该改变指标或者你的开发测试集。（就好比下面这个图，你一直用网上下载下来的高质量图片训练，结果使用用户上传的质量层次不齐的图片，实际测试你就发现B比A效果好）\n\n\n\n总结：不建议在没有评估指标和开发集时跑太久\n\n08 为什么是人的表现\n当你开始往人类水平努力时，进展很快；但过了一段时间，这个算法表现比人类更好时，那么进展和精确度的提升就变得更慢了，也许它还会越来越好，但是斜率也就越来越平缓。\n\n贝叶斯最优误差一般认为理论上可能达到的最优误差：随着时间的推移，当您继续训练算法时，可能模型越来越大、数据越来越多，但性能无法超过某个理论上限。就是说没有任何办法设计出一个x到y的函数，让他能够超过一定的准确度。\n\n为什么当超越人类表现后，进展就缓慢了？\n\n当超越人类表现后没有太多的空间继续改善了。\n没超越之前可以使用一些工具提升性能，超越之后就没那么好用了。\n\n\n\n\n\n对于人类擅长的任务，只要你的机器学习算法比人类差，你就可以：让人帮助你标记数据，这样就有更多的数据可以给学习算法；人工误差分析：让人类看算法处理的例子，知道错误出在哪，并尝试了解为什么人能作对，算法做错；更好分析偏差和误差。\n\n\n09 可避免偏差可避免偏差：贝叶斯误差或者对贝叶斯误差的估计和训练误差之间的差值\n\n\n你的算法在训练集上的表现和人类水平的表现有很大差距的话，说明你的算法对训练集的拟合并不好，所以从减小偏差和方差的工具来看，重点是减小偏差，你需要做的是比如训练更大的神经网络或者跑久一点梯度下降。你的算法在训练集上的表现和人类水平的表现相近的话，但是开发集和训练集相差较大，就将重心放到减小方差上。\n\n\n10 理解人的表现人类水平误差用来估计贝叶斯误差也就是理论上最低的误差，任何函数不管是现在还是将来能够到达的最低值。\n\n\n医学图像分类的例子：下面是四个不同人的观察的误差值，那么应该如何界定人类水平误差呢？就是那个到达最低的值0.5。\n在定义人类水平误差时，要弄清楚你的目标所在，如果要表明你可以超越单个人类，那么就有理由在某些场合使用1%部署你的系统，如果你的目标是代替贝叶斯误差，那么就使用0.5的比较合适。\n\n\n\n误差分析的例子：第一个无论以哪个为目标，都要减少偏差，技术可以培训更大的网络；第二个无论以哪个为目标，都要减少方差，技术可以使用正则化或者去获得更大的训练集；第三个就是接近人类水平误差，改善空间就比较小了。\n\n\n11 超过人的表现\n如果你的误差已经比一群充分讨论辩论后的人类专家更低，那么依靠人类直觉来判断你的算法还能往什么方向优化就很难了（比如右边的，如果都已经过拟合了，这咋判断）。\n\n\n\n下面的结构化数据都是系统比人做的好的，都有一个数据库。\n\n\n12  改善模型表现\n提高学习算法性能的指导方针：想让一个监督学习算法达到适用要做到：\n你的算法对训练集的拟合很好（可避免偏差很低），可以训练更大的网络或者训练更长时间、使用更好的优化算法、寻找更好的新神经网络架构或者更好的超参数、改变激活函数或者层数或者隐藏单位数。\n在训练集做的好推广到开发集和测试集也要好（方差不是太大），可以正则化或者收集更多训练数据、寻找更好的新神经网络架构\n\n\n\n\n\n","tags":["深度学习"]},{"title":"深度学习 day11 机器学习（ML）策略","url":"/2021/08/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20day11%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5/","content":"01 进行误差分析人工检查你的算法错误，也许可以让你了解接下来应该做什么，这个过程就叫误差分析\n\n\n同样是一个猫分类器，但是它的准确度只有90%，它会将一些狗的图片识别成猫，如果花费几个月的时间来开发专门研究狗的项目，那是大可不必，因为可能取不到效果。所以我们推荐使用误差分析：我们自己手动的观察100个错误标记的开发集例子，如果只有其中5个是狗的图片，那么就算把识别狗做的很好，误差也高达9.5%，如果其中有50个是狗的图片，这时我们在对识别狗进行完善就可以将误差减半到5%。\n\n\n\n有时在做误差分析时，也可以同时并行评估几个想法，例如猫分类器：\n\n改善针对狗图的性能\n解决针对于猫科动物看做成家猫的错误\n提高画质\n\n\n针对于上面这三个想法我们可以将其记录成下面的表，统计出每个想法占的百分比，在以此判断是否应该提升哪个的性能，提升哪个性能上限比较高。\n\n\n\n\n总结：进行误差分析应该找一组错误标记的例子，可能在开发集或者测试集里，观察错误标记的例子，看看假阳性和假阴性，统计属于不同错误类型的错误数量，可以帮助你发现哪些问题需要优先处理。\n\n02 清楚标注错误的数据  监督学习问题的数据是由输入x和输出标签y组成，通过发现，得知有些输出标签y是错误的，是否值得花时间去修正这些标签呢？\n\n\ny为1是猫，为0不是猫，这时发现倒数第二个是错误标签，该怎么办？\n\n如果是训练集，深度学习算法对于训练集中的随机误差是很宽容的，只要这些错误例子离随机误差不太远，误差足够随机，那么放着这些误差不管可能也没问题。只要总数据集足够大，实际误差可能不会太高。\n如果担心开发集和测试集上标记出错的例子带来的影响，一般建议在误差分析的时候，添加一个额外的列来统计标签y错误的例子数。是否值得修正这6%标记出错的例子呢？如果这些错误标签严重影响了你在开发集上评估算法的能力，那么就应该花费时间去修正错误标签，反之不用。\n建议看三个数字来确定是否值得去人工修正标记出错的数据：整体的开发集误差10%；错误标记引起的错误的数量或者百分比0.6%（10%的6%）；其他原因导致错误的百分比9.4%（10%-0.6%）。对于左边的错误标签没有严重影响了你在开发集上评估算法的能力，而左边的错误标签严重影响了你在开发集上评估算法的能力。\n\n\n\n\n\n\n修正的建议：首先无论使用什么修正手段，都要同时作用到开发集和测试集上（开发集和测试集必须来自相同的分布，因为开发集确定了你的目标，当你击中目标后将算法推广到测试集中，这样你的团队才能更高效）来确保他们继续来自同一分布；其次要同时检验算法判断正确和判断错误的例子，如果你只修正算法出错的例子，你对算法的偏差估计可能会变大，修正错误的例子之后，一些改变可能使原本正确的例子也变成错误的了。但是我们通常不会这么做，因为如果你的分类器很准确，那么判断错的次数比判断正确的次数要小得多；如果你进入到一个开发集和测试集去修正部分标签，你不大可能去修正训练集的，因为训练集数据比开发集和测试集多的多，需要花费的时间也就多。\n\n\n\n总结：在构造实际系统时，通常需要更多的人工误差分析和人类见解，我们要看下犯错误的例子，这样可以帮助找到需要优先处理的任务。\n\n03 快速搭建你的第一个系统，并进行迭代\n一般来说，对于几乎所有的机器学习程序，可能会有50个不同的方向可以前进，并且都是相对合理的可以改善系统，但挑战在于你如何选择一个方向集中精力处理。\n如果你像搭建一个全新的机器学习程序，建议：首先快速设立开发集和测试集还有指标，决定了你的目标所在，如果错了可以在改，但是一定要设立；然后建议马上搭好一个机器学习系统原型（初始系统的全部意义在于有一个训练过的系统可以让你确定偏差和方差的范围，就知道下一步应该优先做什么，能够进行误差分析），然后找训练集进行训练，看效果。开始理解你的算法表现如何，在开发集测试集你的评估指标上表现如何；当你建立第一个系统后，你就可以马上用到偏差方差分析和误差分析。\n\n\n04 在不同的划分上进行训练并测试\n如果你有两个数据来源，一个较小，一个较大，那么该怎么分布？\n第一条路：我们可以将来自互联网和用户的图片结合到一块，然后随机分配到训练、开发和测试集中，这样三个集的数据都来自同一分布，但是坏处在于，对于2500个开发集数据，其中很多图片都是来自网页下载，并不是真正关心的数据分布，真正要处理的是用户上传的，这样设立开发集导致团队针对不同于你实际关心的数据分布去优化。（不要用）\n推荐第二条路：我们训练集是来自互联网的图片，如果需要的话，再加上5000张来自手机上传的图片，对于开发集和测试集都是手机图片，这样的好处在于你现在瞄准的目标就是你想要处理的目标。开发集全部数据都来自用户，可以告诉你的团队这是你真正关心的图片分布，试着搭建一个学习系统，让系统在处理用户图片分布时效果良好。缺点在于你的训练集和开发集、测试集不在一个分布\n\n\n\n以语音激活后视镜为例，对于训练集你可以使用你所拥有的所有语音数据；对于开发集和测试集来说可能要小的多，比如实际上来自语音激活后视镜的数据。按照上面推荐第二条路进行分配。\n\n\n05 不匹配数据划分的偏差和方差当你的训练集和你的开发集、测试集来自不同的分布时，分析偏差和方差的方式可能不一样\n\n\n训练集误差为1，开发集误差为10。如果训练集和开发集来自同一分布，这就存在很大的方差问题，算法不能很好的从训练集出发泛化；但如果你的训练集和开发集来自不同的分布，这时就不能轻易下结论，可能没有方差问题，只不过反映了开发集包括更难准确分类的图片。\n分析的问题在于当你看训练误差再看开发误差有有两件事变了：\n算法只见过训练集数据，没见过开发集数据\n开发集数据来自不同的分布\n\n\n我们设置一个新的数据子集叫训练-开发集，从训练集的分布里随机打散训练集，但是不会用来训练网络。为了进行误差分析，你应该做的是看看分类器在训练集上的误差1%、训练-开发集上的误差9%还有开发集上的误差10%。而训练集和训练-开发集上的差异在于你的神经网络能看到第一部分数据（红色部分）并在上面做训练，但没有在训练-开发集上直接训练，这就告诉算法存在方差。因为训练集上和训练-开发集来自同一分布的数据测得，所以尽管你的神经网络在训练集中表现良好，但无法泛化到来自相同分布的训练-开发集中；又如这三个误差分别是1%、1.5%、10%，这时方差问题就很小了。因为从训练集到训练-开发集误差只上升了一点点，但转到开发集时误差就大了很多，所以这是数据不匹配问题；又如这三个误差分别是10%、11%、12%，这时就存在偏差问题了；又如这三个误差分别是10%、11%、20%，这就有两个问题了：可避免偏差相当高还有数据不匹配问题很大。\n\n\n\n一般的原则，我们要看的关键数据是人类水平误差、训练集误差、训练开发集误差、开发集误差。如果再加一个测试误差，那么测试误差和开发集误差的间距就是你对开发集过拟合的程度。当然也可能出现右边的情况，是因为开发测试集分布比你应用实际处理的数据要容易得多，那么误差可能真的就下降。\n\n\n\n我们以语音激活后视镜为例子，横轴是不同的数据集，竖轴是我们要标记处理数据不同的方式或算法，最后一行放不开了，所以放到了右边。\n\n\n06 定位数据不匹配\n如果发现数据不匹配问题，通常会做误差分析。还是以语音激活后视镜为例，可能要听一下来自开发集的样本，尝试弄清楚开发集和训练集到底有什么不同（比如说开发集的噪音很多）。你可以尝试把训练数据变得更像开发集一点，或者也可以收集更多类似开发集和测试集的数据（比如说发现车辆背景噪音是主要的误差来源，那么就有意识的收集这些数据加到训练集中）。\n\n\n\n如果你的目的是把训练数据变得更像开发集一点，可以使用人工合成数据技术，通过人工合成你可以快速制造更多的训练集。但是人工合成有一个潜在的问题，比如说你在安静的环境下录制了1000小时音频，在移动的车上只录制了1一个小时，当你重复的将这1小时的音频叠加到1000小时音频时，可能你的学习算法对这一小时汽车噪声过拟合。人工数据合成的挑战在于人耳对于1000小时听起来和1小时噪音听起来没什么区别，所以最后可能制造出这个原始数据很少的，在一个小得多的空间子集合成的训练数据。\n\n\n\n总结：如果你认为存在数据不匹配问题，建议做误差分析或者看看训练集和开发集，这两个数据分布到底有什么不同，然后尝试收集看起来像开发集数据做训练。当使用人工合成数据一定要谨慎，你有可能从所有可能性的空间只选了很小一部分去模拟数据。\n\n07 迁移学习深度学习中最强大的理念之一就是有时候神经网络可以从一个任务习得知识，并将这些知识应用到另一个独立的任务中，这就是迁移学习。\n\n\n假设你已经训练好一个图像识别神经网络，然后将这个神经网络拿来让他适应不同的任务（比如放射科诊断），可以做的就是把神经网络最后的输出层和进入到最后一层的权重删掉，然后加上一层或者几层新层，然后为最后一层或几层重新赋予随机权重，然后让它在放射诊断数据上训练。在进行图像识别的训练阶段，可以训练神经网络的所有常用参数、所有权重、所有层，然后就得到了一个能够做图像识别的神经网络，这时要实现迁移学习你要做的就是把数据集换成放射科的（x,y）训练集，而y就是你想要预测的诊断。然后我们随机初始化最后一层的权重w和b。已有语音识别系统神经网络，然后搭建一个触发词（可以唤醒智能设备）的神经网络，过程都同上。\n要用新的数据集重新训练神经网络有几种做法：\n如果你有一个小的数据集，就只训练输出层前的最后一层或者最后两层。\n如果你有很多数据集，那么也许你可以重新训练网络中的所有参数。在图像识别数据的初期训练阶段（预训练），你在用图像识别数据预初始化，然后以后更新所有权重，在放射科数据上训练，有时这个过程叫微调。\n\n\n迁移学习起作用的场合是：迁移来源问题你有很多数据，但迁移目标问题你没有那么多数据。（例如图像识别有一百万样本，可以学习低层次特征，可以在神经网络的前几层学到如何识别有用的特征，放射科数据有一万样本，在已经学习特征的基础上加以训练）数据量反着来的话（例如图像识别有50样本，放射科数据有300样本），就没有太大的意义了。\n\n\n\n假设从任务A学习并迁移一些知识到任务B，那么什么时候迁移学习有意义？\n当任务A和任务B都有同样的输入x（例如A和B输入都为图像）\n当任务A数据比任务B数据多得多的时候\n任务A的低层次特征可以帮助任务B的学习\n\n\n\n\n08 多任务学习在迁移学习中，你的步骤是串行的（从A到B）；在多任务学习中，你可以同时开始学习，试图让单个神经网络同时做几件事，然后希望每个任务都能帮到其他所有任务\n\n\n以无人驾驶为例，需要同时识别多个不同的物体，比如行人、车辆、停车标志还有交通灯，以这四个为例设计出Y。\n\n\n\n现在就可以训练一个神经网络来预测这些y值，输入x，输出的是一个四维向量y。要训练这个神经网络，需要定义神经网络的损失函数，和之前分类猫的例子主要区别在于需要对j&#x3D;1到4求和；这与softmax回归的主要区别在于softmax将单个标签分配给单个样本，而这个例子一张图可以有很多不同标签（行人、车辆、停车标志还有交通灯），所以在该例中你不是只给图片一个标签，而是需要遍历不同类型，然后看看每个类型是否出现在图中。\n如果你训练一个神经网络，并试图最小化这个成本函数，你做的就是多任务学习，由于神经网络早期的一些特征，在识别不同物体时都会用到，你发现训练一个神经网络做四件事会比训练四个完全独立的神经网络分别做四件事性能要更好。\n多任务学习也可以处理图像只有部分物体被标记的情况（右下角Y的情况，不清楚标记？），你就只对带0和1标签的j值求和，如果有？你就在求和时忽略那个项。\n\n\n\n多任务学习什么时候有意义？当三件事为真时，他就是有意义的：\n如果你训练的一组任务可以共用低层次特征，比如无人驾驶例子，同时识别四个标签，因为这些都是道路上的特征。\n不一定对哈，如果你专注于单项任务，想要从多任务学习得到很大性能提升，那么其他任务加起来必须要有比单个任务大得多的数据量或者每个任务的数据量很接近。\n当你可以训练一个足够大的神经网络，同时做好所有的工作。多任务学习的替代方法是训练四个完全独立的神经网络，一个任务对应一个神经网络，如果神经网络足够大，就不用替代。\n\n\n\n\n\n总结：迁移学习用的多\n\n09 什么是端对端的深度学习深度学习中最令人振奋的最新动态之一就是端对端深度学习的兴起，以前有一些数据处理系统或者学习系统，他们需要多个阶段的处理，那么端对端深度学习就是忽略所有这些不同的阶段，用单个神经网络替代它\n\n\n以语音识别为例，需要很多阶段的处理，首先会提取一些特征（MFCC用来从音频中提取一组特定的人工设计的特征），提取完低层次的特征后就可以应用机器学习算法在音频片段中找到音位，然后将音位串在一起构成独立的词，然后将这些词串起来构成音频片段的听写文本；端对端深度学习就是训练一个巨大的神经网络，输入一段音频，输出直接是听写文本。\n端对端深度学习的挑战之一是你可能需要大量数据才能让系统表现良好。小数据集用传统的比较好（3000h）；大的数据集用端对端才好（10000h）；数据量适中也可以用中间件方法。\n\n\n\n搭建人脸识别门禁系统：第一件事是看看相机拍到的照片，你可以直接学习图像x到人物y身份的函数映射（这不是最好的方法，因为人可以从很多不同的角度接近门禁）；迄今为止最好的方法是多步方法，首先运行一个软件来检查人脸，所以第一个检测器找的是人脸位置，找到后裁剪图像使人脸居中，再喂到神经网络里去学习，将现拍的图片跟已存的图片进行对比。为什么两步法更好呢？一是你解决的两个问题，每个问题实际上要简单得多，二是两个子任务的训练数据都很多\n\n\n\n更多的例子：机器翻译，X扫描\n\n\n10 是否要使用端对端的深度学习\n端对端学习的好处：\n只是让数据说话，让你的学习算法学习它想学习的任意表示方法，而不是强迫它使用特定的某种(音位)作为表示方法，其整体表现可能会更好。\n所需手工设计的组件更少，不需要花太多时间去手工设计功能。\n\n\n端对端学习的缺点：\n要直接学x到y的映射，它可能需要大量的数据。\n排除了可能有用的手工设计组件，当没办法从很小的训练集数据中获得洞察力，这时手工设计组件就可以把人类知识直接注入到算法。\n\n\n学习算法有两个主要知识来源：如果数据少就需要用组件，如果数据多就可能不需要\n数据\n手工设计的任何东西（也可能强迫学习算法使用特定的某种(音位)作为表示方法）\n\n\n\n\n\n决定是否使用端对端的深度学习关键的问题是你有足够的数据能够直接学从x映射到y足够复杂的函数吗？\n\n\n\n总之需要大量数据\n\n","tags":["深度学习"]},{"title":"深度学习 day12卷积神经网络","url":"/2021/08/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20day12%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","content":"01 计算机视觉即使你在计算机视觉方面没有做出成果，希望你可以将所学的知识应用到其他算法和结构\n\n\n计算机视觉的一些例子：图片识别（给出一张图片让计算机去分辨出这是一只猫）、目标检测（首先算出有哪些物体，然后用一些技术识别出他们在图片的位置）、图片风格迁移（就是你有一张满意的图片和一张风格图，你可以用神经网络将他们融合在一起，描绘出一张新的图片，整体轮廓来自左边，风格却是右边的）。\n\n\n\n在应用计算机视觉还有一个很大的挑战就是数据的输入可能会非常大，例如像素是1000×1000的，那么输入的数据就是三百万的数据量，你也许会有1000个隐藏单元，而所有的权值W，如果你使用的是标准的全连接网络，矩阵的大小也是（1000，三百万）也就是会有三十亿个参数。在参数量如此之大的情况下难以获取足够的数据来防止过拟合。如果想要也能计算大型图片就可以使用卷积运算。\n\n\n02 边缘检测示例卷积运算是卷积神经网络最基本的组成部分\n\n\n给一张图片让电脑检测是什么物体，可能做的第一件事是检测图片中的垂直边缘，也可能想检测水平边缘。\n\n\n\n那么如何在图像中检测这些边缘呢？下面是一个6×6的灰度图像，为了检测一个图像的垂直边缘可以构造一个3×3的矩阵（过滤器），卷积运算用*表示，该例中用3×3的过滤器对其进行卷积，输出4×4的矩阵（另一张图片）。4×4的矩阵的元素是将3×3的过滤器覆盖到6×6的灰度图像中，不断地平移得到。不同的语言使用不同的函数代表卷积。\n\n\n\n在下面例子中输出图像中间区域的亮处，表示在图像中间有一个很明显的垂直边缘。\n\n\n03 更多边缘检测内容\n通过不同的过滤器可以找出垂直或者水平的边缘。之前的图里面30是由10过渡到0得到的，所以就是由亮转暗；之前的 30 翻转成了-30，表明是由暗向亮过渡， 而不是由亮向暗过渡，因为看原图是从0到10，所以是从暗到亮的转化。\n\n\n\n水平边缘过滤器如下：\n\n\n\n有多种过滤器：Sobel过滤器（增加了中间一行元素的权重）、Scharr过滤器、还有一种将九个数字都当成参数的思想（已经成为计算机视觉最为有效的思想之一）。\n\n\n04 Padding为了构建深度神经网络，需要学会使用卷积的基本操作Padding\n\n\n可以用公式计算为什么输出是4×4，公式为（n-f+1）×（n-f+1），其中n×n代表原图大小，f×f代表过滤器大小。这样的话会有两个缺点：一是每次做卷积操作，你的图像就会缩小，二是那些在角落或者边缘区域的像素点在输出中采用较少，意味着丢掉了图像边缘位置的许多信息。为了解决这些问题，可以在卷积操作之前填充这幅画（沿着图像边缘再填充一层像素），习惯上可以用0来填充，如果p是填充的数量（该例中p&#x3D;1，因为周围都填充了一个像素点），输出就变成了（n+2p-f+1）×（n+2p-f+1）。\n\n\n\n填充多少像素通常有两个选择：分别叫Valid卷积（不填充）和Same卷积（填充后你的输出大小和输入大小是一样的）。在计算机视觉中过滤器一般都是奇数维，因为如果f为偶数，那么你只能使用一些不对称填充，只有f为奇数时才会有自然填充；还有就是在奇数维中会有一个中心像素点，便于指出过滤器的位置。\n\n\n05 卷积步长\n步长为2，说明过滤器执行完一次后，平移两个格。输出格子公式：[(n+2p-f)&#x2F;s]+1 × [(n+2p-f)&#x2F;s]+1，如果不是一个整数的话就向下取整。按照惯例，过滤器必须完全处于图像中或者填充之后的图像区域内，才输出相应结果。\n\n\n\n总结下维度情况：\n\n\n\n在有些定义中还有镜像翻转，对着对角线翻转，咱们这不用奥。\n\n\n06 卷积为何有效\n假设我们想检测彩色图像的特征，那么对应的过滤器也应该有三层，对应红绿蓝三个通道。定义一下6×6×3这个形式：分别代表高、宽和通道数，并且图像的通道数必须和过滤器的通道数相等。\n\n\n\n下面来看下计算立体图像的细节：首先我们的过滤器画成一个三维的立方体，然后把这个过滤器放到最左上角的位置，最后把27个对应数相乘相加就得到了输出的第一个数。依次平移得到剩下的数字。通过设置过滤器每层不同的参数，就可以检测不同颜色通道里的边界（右下角那两个例子）。\n\n\n\n我们想同时检测垂直和水平边缘还有45度倾斜的边缘还有70度倾斜的边缘该怎么做？（换句话说就是想同时用多个过滤器怎么办）就是用两个不同的过滤器，然后得到的结果依次进行叠加，得到一个立方体。\n\n\n07 单层卷积网络\n通过不同的过滤器得到不同的输出后，通过python的广播机制给第一个矩阵这些元素都加上同一偏差，然后应用一个非线性激活函数ReLU；然后给第二个输出矩阵加上不同的偏差，同样也使用非线性激活函数ReLU，最后得到另一个4×4的矩阵，然后将两个矩阵叠加起来，就得到一个4×4×2的矩阵。\na[0]到a[1]的演变过程：首先执行线性函数，然后将所有元素相乘做卷积，再加上偏差，然后应用激活函数ReLU，最后通过神经网络的一层，将6×6×3的维度a[0]演化为一个4×4×2维度的a[1],这就是卷积神经网络的一层。\n\n\n\n举个例子，有十个过滤器，每个过滤器是3×3×3的，问这一层有多少参数？因为过滤器是3×3×3的，所以有27个参数，然后加一个偏差就是28个，然后是10个过滤器也就是一共280个参数。无论输入的图片有多大，参数始终是280个，这是卷积神经网络的一个特征叫做“避免过拟合”。\n\n\n\n总结下用于描述卷积神经网络中的一层的各种标记：\n\n\n08 简单卷积网络示例\n想做一个图像识别，输入x，然后判别图片中有没有猫（0&#x2F;1表示）。通过下面的不同卷积不断地进行，最终为图片提取出7×7×40个特征，然后对该卷积层进行处理处理，可以将其平滑或展开成1960个单元，平滑处理后输出一个向量，其填充内容是逻辑回归单元还是softmax回归单元完全取决于我们是想识别图片上有没有猫还是想识别K种不同对象中的一种用y^表示最终神经网络的预测输出。\n随着神经网络计算深度不断加深，通常开始时的图像也要更大一些，高度和宽度会在一段时间内保持一致，然后随着深度的加深而逐渐减小，而信道数量在增加。\n\n\n\n一个典型的卷积神经网络通常有三层：卷积层（CONV）、池化层（POOL）、全连接层（FC）\n\n\n09 池化层使用池化层来缩减模型的大小，提高计算速度，同时提高所提取特征的鲁棒性\n\n\n在此用到的池化类型是最大池化，下面的例子相当于我们选用了一个规模为2、步幅为2的过滤器，然后选择其中最大值。最大化操作的功能就是只要在任何一个象限内提取到某个特征，他都会保留在最大池化的输出中，最大池化的实际作用就是在过滤器中提取某个特征，然后保留其最大值。\n\n\n\n再看一个有若干超级参数的例子，每个信道都独立执行最大池化计算。\n\n\n\n平均池化——就是取平均值\n\n\n\n总结：池化的超级参数包括过滤器大小f和步幅s，大部分情况下p&#x3D;0\n\n\n10 卷积神经网络示例\n在卷积文献中，卷积有两种分类，一类卷积是一个卷积层和一个池化层一起作为一层（人们在计算神经网络有多少层时，通常只是统计具有权重和参数的层，因为池化层没有权重和参数，只有一些超参数，所以将两者当着一层Layer1）；另一类卷积是把卷积层作为一层，池化层单独作为一层。\n我们针对识别数字例子，首先输入一个数字图片，通过两个神经网络的组合（卷积层+池化层），然后得到一个输出，将输出水平展开成向量，通过两个全连接层，最后用FC4的单元填充一个softmax单元，softmax会有十个输出。关于如何选定超级参数，常规做法是尽量不要自己设置，而是参考别人的文献采用了哪些超级参数，选择一个效果好的框架。在神经网络中另一种常见的模式是一个或多个卷积层后跟随一个池化层，然后一个或多个卷积层后再跟随一个池化层，然后是几个全连接层，最后是一个softmax。\n\n\n\n神经网络激活值形状、激活值大小和参数数量。有几点注意：第一池化层和最大池化层没有参数；第二卷积层的参数相对较少，许多参数都存在于神经网络中的全连接层；第三随着神经网络的加深，激活值会逐渐减小（如果下降太快也会有所影响）。\n\n\n11为什么使用卷积？\n和只用全连接层相比卷积层的两个主要优势在于参数共享和稀疏连接。两个神经元相连会得到一个非常多的参数数量3072×4704，而使用卷积的话，一共才156个参数。\n\n\n\n卷积网络映射这么少参数有两个原因：一是参数共享，一个特征检测器如垂直边缘检测器，用于检测图片左上角区域的特征，这个特征很可能也适用于右下角区域，因此在计算图片的左上和右下角区域时，不需要添加其他的特征检测器，假如有一个左上角和右下角可能有不同分布，但也可能很相似的数据集，整张图片共享特征检测器，提取效果也很好；二是稀疏连接，右图的输出单元仅与36个输入特征中的9个相连接，而其他像素值都不会对输出产生任何影响。神经网络通过这两种机制减少参数，以便我们用更小的训练集训练它，从而防止过拟合。\n\n\n\n要训练神经网络要做的就是使用梯度下降法，来优化神经网络中的所有参数，以及减小代价函数J的值。\n\n\n","tags":["深度学习"]},{"title":"深度学习 day13深度卷积网络：实例探究","url":"/2021/08/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20day13%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%EF%BC%9A%E5%AE%9E%E4%BE%8B%E6%8E%A2%E7%A9%B6/","content":"01 为什么要进行实例探究？如果有人训练出擅长识别猫狗人的神经网络或者神经网络框架，而你的计算机视觉识别任务是构建一个自动驾驶汽车，你完全可以借鉴别人的神经网络框架来解决自己问题。\n\n\n非常有效的神经网络范例：\n\n\n02 经典网络\nLeNet - 5的网络结构：大约有6万个参数\n\n\n\nAlexNet网络结构：大约有6000万个参数，AlexNet表现出色的原因有两个：一是当用于训练图像和数据集时，AlexNet能够处理非常相似的基本构造模块，这些模块往往包含大量的隐藏单元或数据；二是它使用了ReLU激活函数。\n\n\n\nVGG - 16的网络结构：没有那么多超参数，这是一种只需要专注于卷积层的简单网络。16这个数字代表这个网络包含16个卷积层和全连接层，是个很大的网络，总共包含约1.38亿个参数\n\n\n03 残差网络非常深的网络是很难训练的，因为存在梯度消失和梯度爆炸问题。跳远连接，它可以从某一网络层获取激活，然后迅速反馈给另外一层，甚至是神经网络的更深层，可以用跳远连接构建能够训练深度网络的ResNets。\n\n\nResNets是由残差块构建的。信息流从a[l]到a[l+2]需要经过线性激活-&gt;非线性ReLU激活-&gt;性激活-&gt;非线性ReLU激活这组神经网络的主路径。而在残差网络中有一点变化，我们将a[l]直接向后拷贝到神经网络深层（在线性激活之后，非线性ReLU激活前），这就意味这原来主路经的最后的等式去掉，用另一个ReLU非线性函数来代替。\n\n\n\n把下面普通网络变成ResNets的方法是加上所有的跳远连接，每两层增加一个捷径构成一个残差块。该图就是5个残差块。我们用一个优化算法来训练普通网络的话，训练误差实际上是先减小后增加，随着深度的增加用优化算法越难训练；但是有ResNets的话训练误差就是不断减小。对于x的激活或者这些中间的激活，能够达到网络的更深层，这种方法能有助于解决梯度消失和梯度爆炸问题。\n\n\n04 残差网络为什么有用？通常一个网络深度越深，它在训练集上训练网络的效率会有所减弱\n\n\n如果使用L2正则化或权重衰减，那么它会压缩W[l+2]的值，同样对b应用权重衰退也一样。如果W[l+2]和b都为0，那么a[l+2] &#x3D; a[l]，所以给大型神经网络增加两层，无论是把残差块添加到神经网络的中间还是末端位置，都不会影响网络的表现。\n残差网络起作用的主要原因是这些残差块学习恒等函数非常容易，能确定网络性能不会受到影响，甚至有时还会提高效率。\n假设z[l+2]与a[l]具有相同维度，所以ResNets使用了许多相同卷积，使得a[l]的维度等于输出层的维度，因而实现了这个跳远连接，因为同一卷积保留了维度，所以很容易得出这个短连接，并输出这两个相同维度的向量；如果输入和输出有不同维度，假设输入是128维度，输出是256维度，就需要增加一个Ws（256×128），不需要对Ws做任何操作，它是网络通过学习得到的矩阵或参数，是一个固定矩阵，p&#x3D;0，用0填充a[l]，其维度为256。\n\n\n\n图片识别的普通和ResNet神经网络：\n\n\n\nResNet类似于其他很多神经网络，也会有很多卷积层，其中偶尔会有池化层或者类似池化层的层，不论这些层是什么类型，都需要调整矩阵Ws的维度。\n\n05 网络中的网络以及1 × 1卷积\n从图中可以看出对6×6×1的图使用1×1过滤器进行卷积效果不是很好，就是乘一个数；但是对6×6×32的使用1×1的过滤器进行卷积效果更好，具体来说1×1的过滤器的作用是遍历这36个单元格，计算左图中32个数字和过滤器中32个数字的元素智能乘积，然后应用ReLU非线性函数。\n\n\n\n1×1的卷积层实现一些重要功能：它给神经网络添加了一个非线性函数从而减小或保持输入层中的信道数量不变，当然也可以增加信道。\n\n\n06 谷歌 Inception 网络简介Inception 网络的作用就是代替你来做决定：构建卷积层时，过滤器的大小或者要不要添加池化层\n\n\nInception 网络的核心内容：\n5×5过滤器在该块中的计算成本：乘法运算的总次数为每个输出值所需的乘法运算次数乘以输出值的个数&#x3D;1.2亿。\n1×1卷积的应用：为了降低计算成本，我们用计算成本除以因子10，将它从1.2亿减小到原来的十分之一\n\n","tags":["深度学习"]},{"title":"神经网络和深度学习第一周检测","url":"/2021/07/31/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%91%A8%E6%A3%80%E6%B5%8B/","content":"第一周测验 - 深度学习简介\n1.和“AI是新电力”相类似的说法是什么？A: AI为我们的家庭和办公室的个人设备供电，类似于电力。B: 通过“智能电网”，AI提供新的电能。C: AI在计算机上运行，并由电力驱动，但是它正在让以前的计算机不能做的事情变为可能。D: 就像100年前产生电能一样，AI正在改变很多的行业。\n2.哪些是深度学习快速发展的原因？ (两个选项)A:  现在我们有了更好更快的计算能力。B: 神经网络是一个全新的领域。C: 我们现在可以获得更多的数据。D: 深度学习已经取得了重大的进展，比如在在线广告、语音识别和图像识别方面有了很多的应用。\n3.回想一下关于不同的机器学习思想的迭代图。下面哪些陈述是正确的？A: 能够让深度学习工程师快速地实现自己的想法。B: 在更好更快的计算机上能够帮助一个团队减少迭代(训练)的时间。C:在数据量很多的数据集上训练上的时间要快于小数据集。D:使用更新的深度学习算法可以使我们能够更快地训练好模型（即使更换CPU &#x2F; GPU硬件）。\n4.当一个经验丰富的深度学习工程师在处理一个新的问题的时候，他们通常可以利用先前的经验来在第一次尝试中训练一个表现很好的模型，而不需要通过不同的模型迭代多次从而选择一个较好的模型，这个说法是正确的吗？A. 正确B. 错误\n5.用于识别猫的图像是“结构化”数据的一个例子，因为它在计算机中被表示为结构化矩阵，是真的吗？A. 正确B. 错误\n6.统计不同城市人口、人均GDP、经济增长的人口统计数据集是“非结构化”数据的一个例子，因为它包含来自不同来源的数据，是真的吗？A. 正确B. 错误\n7.为什么在RNN（循环神经网络）可以应用机器翻译将英语翻译成法语？A. 因为它可以被用做监督学习。B. 严格意义上它比卷积神经网络（CNN）效果更好。C. 它比较适合用于当输入&#x2F;输出是一个序列的时候（例如：一个单词序列）D. RNN代表递归过程：想法-&gt;编码-&gt;实验-&gt;想法-&gt;…\n8.在我们手绘的这张图中，横轴（x轴）和纵轴（y轴）代表什么?\nx轴是:                       y轴是:\n9.假设上一个问题图中描述的是准确的（并且希望您的轴标签正确），以下哪一项是正确的?A. 增加训练集的大小通常不会影响算法的性能，这可能会有很大的帮助。B. 增加神经网络的大小通常不会影响算法的性能，这可能会有很大的帮助。C. 减小训练集的大小通常不会影响算法的性能，这可能会有很大的帮助。D. 减小神经网络的大小通常不会影响算法的性能，这可能会有很大的帮助。\n答案 1. D 2. AC 3. ACD 4. B(不可能每次都很准确呀) 5. B（看过都知道图片、语音、自然语言都是非结构化的数据） 6. B（注意关键词数据集，可以看出是结构化数据） 7.AC 8. 数据量 算法的性能 9.AB(A是针对一个算法来说，B是针对所有算法并且在同一训练集上而言)\n","tags":["深度学习"]},{"title":"神经网络和深度学习第三周检测","url":"/2021/08/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%91%A8%E6%A3%80%E6%B5%8B/","content":"答案见下方\n1.以下哪一项是正确的？A. X是一个矩阵，其中每个列都是一个训练示例。B. a^[2]_4 是第二层第四层神经元的激活的输出。C. a^[2] (12)表示第二层的第12个样本的激活向量。D. a^[2] 表示第二层的激活向量。\n2.tanh激活函数通常比隐藏层单元的sigmoid激活函数效果更好，因为其输出的平均值更接近于零，因此它将数据集中在下一层是更好的选择，请问正确吗？A. TrueB. False\n3.其中哪一个是第l层向前传播的正确向量化实现，其中1≤ l ≤LA. Z^ [l]&#x3D;W^ [l]A^ [l−1]+b[l]B. A^ [l]&#x3D;g^ [l] (Z^ [l])\n4.您正在构建一个识别黄瓜（y &#x3D; 1）与西瓜（y &#x3D; 0）的二元分类器。 你会推荐哪一种激活函数用于输出层？A. ReLUB. Leaky ReLUC. sigmoidD. tanh\n5.看一下下面的代码：请问B.shape的值是多少?A = np.random.randn(4,3)B = np.sum(A, axis = 1, keepdims = True)\n\n6.假设你已经建立了一个神经网络。 您决定将权重和偏差初始化为零。 以下哪项陈述是正确的？A. 第一个隐藏层中的每个神经元节点将执行相同的计算。 所以即使经过多次梯度下降迭代后，层中的每个神经元节点都会计算出与其他神经元节点相同的东西。B. 第一个隐藏层中的每个神经元将在第一次迭代中执行相同的计算。 但经过一次梯度下降迭代后，他们将学会计算不同的东西，因为我们已经“破坏了对称性”。C. 第一个隐藏层中的每一个神经元都会计算出相同的东西，但是不同层的神经元会计算不同的东西，因此我们已经完成了“对称破坏”。D. 即使在第一次迭代中，第一个隐藏层的神经元也会执行不同的计算， 他们的参数将以自己的方式不断发展。\n7.Logistic回归的权重w应该随机初始化，而不是全零，因为如果初始化为全零，那么逻辑回归将无法学习到有用的决策边界，因为它将无法“破坏对称性”，是正确的吗？A. TrueB. False\n8.您已经为所有隐藏单元使用tanh激活建立了一个网络。 使用np.random.randn（..，..）* 1000将权重初始化为相对较大的值。 会发生什么？A. 这没关系。只要随机初始化权重，梯度下降不受权重大小的影响。B. 这将导致tanh的输入也非常大，因此导致梯度也变大。因此，您必须将α设置得非常小以防止发散; 这会减慢学习速度。C. 这会导致tanh的输入也非常大，导致单位被“高度激活”，从而加快了学习速度，而权重必须从小数值开始。D. 这将导致tanh的输入也很大，因此导致梯度接近于零， 优化算法将因此变得缓慢。\n9.看一下下面的单隐层神经网络：\nA. b^[1] 的维度是(4, 1)B. W^[1] 的维度是 (4, 2)C. W^[2] 的维度是 (1, 4)D. b^[2] 的维度是 (1, 1)\n10.I在和上一个相同的网络中，Z^ [1] 和 A^ [1]的维度是多少？答：\n\n答案：\nABCD\n\nA\n\nAD\n\nC\n\nB.shape = (4, 1) #keepdims = True）来确保A.shape是（4,1）\n\n\nA\n\nA\n\nD\n\nACD（B应该是（4，3））\n\nZ^ [1] 和 A^ [1]的维度都是 (4,m)(注意z和Z的区别：z表示单个样本，Z表示所有样本)\n\n\n","tags":["深度学习"]},{"title":"神经网络和深度学习第二周检测","url":"/2021/08/01/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%91%A8%E6%A3%80%E6%B5%8B/","content":"1.神经元节点计算什么？A. 神经元节点先计算激活函数，再计算线性函数(z &#x3D; Wx + b)\nB. 神经元节点先计算线性函数（z &#x3D; Wx + b），再计算激活。\nC. 神经元节点计算函数g，函数g计算(Wx + b)。\nD. 在 将输出应用于激活函数之前，神经元节点计算所有特征的平均值\n2.Logistic损失函数表达式的形式？答：\n3.假设img是一个（32,32,3）数组，具有3个颜色通道：红色、绿色和蓝色的32x32像素的图像。 如何将其重新转换为列向量？代码答：\n4.看一下下面的这两个随机数组“a”和“b”：请问数组c的维度是多少？a = np.random.randn(2, 3) # a.shape = (2, 3)b = np.random.randn(2, 1) # b.shape = (2, 1)c = a + b\n\n答： \n5.看一下下面的这两个随机数组“a”和“b”：请问数组“c”的维度是多少？a = np.random.randn(4, 3) # a.shape = (4, 3)b = np.random.randn(3, 2) # b.shape = (3, 2)c = a * b\n\n答： \n6.假设你的每一个实例有n_x个输入特征，想一下在X&#x3D;[x^(1), x^(2)…x^(m)]中，X的维度是多少？答：\n7.看一下下面的这两个随机数组“a”和“b”：请问c的维度是多少？a = np.random.randn(12288, 150) # a.shape = (12288, 150)b = np.random.randn(150, 45) # b.shape = (150, 45)c = np.dot(a, b)\n\n答： \n8.看一下下面的这个代码片段：请问要怎么把它们向量化？# a.shape = (3,4)# b.shape = (4,1)for i in range(3):  for j in range(4):    c[i][j] = a[i][j] + b[j]\n\n答：\n9.看一下下面的代码：请问c的维度会是多少？a = np.random.randn(3, 3)b = np.random.randn(3, 1)c = a * b\n\n答：\n\n答案：\nB（神经元输出的是g(Wx + b)，根据前向传播应该是先计算(Wx + b)，再将其带入到激活函数g中）\n针对于单个训练集的：（误差函数）\n\n![image-20210730152607594](C:\\Users\\1\\Desktop\\深度学习\\深度学习 day02神经网络基础\\image-20210730152607594.png)\n针对于整个训练集的：（成本函数）\n![image-20210730152655792](C:\\Users\\1\\Desktop\\深度学习\\深度学习 day02神经网络基础\\image-20210730152655792.png)3. &#96;&#96;&#96;python   x &#x3D; img.reshape((32323,1))#reshape的作用是重塑数组      4. ```python   c.shape = (2, 3)#根据python的广播原理（B的列向量复制三次与A相加）\n\n直接报错，想广播都广播不了，行和列向量都没有办法复制\n\nX.shape = (n_x,m)\n#这个形式的\nX=[[x_1^(1), x_1^(2)…x_1^(m)]\n   [x_2^(1), x_2^(2)…x_2^(m)]\n   ........................\n   [x_n^(1), x_n^(2)…x_n^(m)]]\n7. ```python   c.shape = (12288, 45)#就是简单的矩阵乘法，dot(n×m , m×v) = n×v \n\n\n&#96;&#96;&#96;pythonc&#x3D; a+b.T#这个就相当于是a的所有元素加上b转置的广播\n9. ```python   c.shape = (3, 3)#这题跟第五题一样，但是这题中b的行数跟a的行数一样，就可以将b的列广播\n\n","tags":["深度学习"]},{"title":"神经网络和深度学习第四周检测","url":"/2021/08/03/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E5%91%A8%E6%A3%80%E6%B5%8B/","content":"答案见下方\n1.在实现前向传播和反向传播中使用的“cache”是什么？A. 用于在训练期间缓存成本函数的中间值。B. 我们用它传递前向传播中计算的变量到相应的反向传播步骤，它包含用于计算导数的反向传播的有用值。C. 它用于跟踪我们正在搜索的超参数，以加速计算。D. 我们使用它将向后传播计算的变量传递给相应的正向传播步骤，它包含用于计算计算激活的正向传播的有用值。\n2.以下哪些是“超参数”？A. 隐藏层的大小n^ [l]B. 学习率αC. 迭代次数D. 神经网络中的层数L\n3.下列哪个说法是正确的？A. 神经网络的更深层通常比前面的层计算更复杂的输入特征。B. 神经网络的前面的层通常比更深层计算输入的更复杂的特性。\n4.向量化允许您在L层神经网络中计算前向传播，而不需要在层(l &#x3D; 1,2，…，L)上显式的使用for-loop（或任何其他显式迭代循环），正确吗？A. 正确B.  错误\n5. 假设我们将n^ [l]的值存储在名为layers的数组中，如下所示：layer_dims &#x3D; [n_x,4,3,2,1]。 因此，第1层有四个隐藏单元，第2层有三个隐藏单元，依此类推。 您可以使用哪个for循环初始化模型参数？答：\n6.下面关于神经网络的说法正确的是：A. 层数L为4，隐藏层数为3\n7.在前向传播期间，在层l的前向传播函数中，您需要知道层l中的激活函数（Sigmoid，tanh，ReLU等）是什么， 在反向传播期间，相应的反向传播函数也需要知道第l层的激活函数是什么，因为梯度是根据它来计算的，正确吗？A. 正确B. 错误\n8.有一些功能具有以下属性：(i) 使用浅网络电路计算函数时，需要一个大网络（我们通过网络中的逻辑门数量来度量大小），但是（ii）使用深网络电路来计算它，只需要一个指数较小的网络。真&#x2F;假？A. 正确B. 错误\n9.前面的问题使用了一个特定的网络，与层l有关的权重矩阵在一般情况下，W^ [l]的维数是多少?答：\n\n答案：\nB\n\nABCD\n\nA\n\nB\n\nfor(i in range(1, len(layer_dims))):\n    parameter[‘W’ + str(i)] = np.random.randn(layers[i], layers[i - 1])) * 0.01\n    parameter[‘b’ + str(i)] = np.random.randn(layers[i], 1) * 0.01\n\n\nA\n\nA(在反向传播期间，您需要知道正向传播中使用哪种激活函数才能计算正确的导数。)\n\nA\n\nw^ [l]的维度是（n^ [l]，n^ [l-1]）\n\n\n","tags":["深度学习"]},{"title":"遇到的问题之maven由于他的约定大于配置，可能会导致配置文件，无法被导出或者生效的问题","url":"/2022/04/15/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B9%8Bmaven%E7%94%B1%E4%BA%8E%E4%BB%96%E7%9A%84%E7%BA%A6%E5%AE%9A%E5%A4%A7%E4%BA%8E%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E6%97%A0%E6%B3%95%E8%A2%AB%E5%AF%BC%E5%87%BA%E6%88%96%E8%80%85%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/","content":"&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt;&lt;build&gt;\t&lt;resources&gt;\t\t&lt;resource&gt;\t\t\t&lt;directory&gt;src/main/resources&lt;/directory&gt;\t\t\t&lt;includes&gt;\t\t\t\t&lt;include&gt;**/*.properties&lt;/include&gt;\t\t\t\t&lt;include&gt;**/*.xml&lt;/include&gt;\t\t\t&lt;/includes&gt;\t\t\t&lt;filtering&gt;true&lt;/filtering&gt;\t\t&lt;/resource&gt;\t&lt;resource&gt;\t\t\t&lt;directory&gt;src/main/java&lt;/directory&gt;\t\t\t&lt;includes&gt;\t\t\t\t&lt;include&gt;**/*.properties&lt;/include&gt;\t\t\t\t&lt;include&gt;**/*.xml&lt;/include&gt;\t\t\t&lt;/includes&gt;\t\t\t&lt;filtering&gt;true&lt;/filtering&gt;\t\t&lt;/resource&gt;\t&lt;/resources&gt;&lt;/build&gt;\n\n","tags":["遇到的问题"]},{"title":"遇到的问题之org.apache.catalina.startup.HostConfig.deployDirectory","url":"/2022/05/22/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B9%8Borg-apache-catalina-startup-HostConfig-deployDirectory/","content":"\n解决方法\n\n\n在工件下的WEB-INF下创建一个lib目录，然后将库文件添加进去就行了\n\n\n","tags":["遇到的问题"]},{"title":"遇到的问题之请求的资源不可用解决方法","url":"/2022/04/20/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B9%8B%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B5%84%E6%BA%90-r-7BpageContext-request-contextPath-7D-login-%E4%B8%8D%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"问题描述类型 状态报告消息 请求的资源[&#x2F;r&#x2F;$%7BpageContext.request.contextPath%7D&#x2F;login]不可用解决方法描述 源服务器未能找到目标资源的表示或者是不愿公开一个已经存在的资源表示。\n&lt;%--这里提交的路径，需要寻找到项目的路径--%&gt;&lt;%--$&#123;pageContext.request.contextPath&#125;代表当前的项目--%&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/login&quot; method=&quot;get&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt;    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt;    &lt;input type=&quot;submit&quot;&gt;\n\n原因分析：原因就是${}没有解析当成了字符串，这时我们只需要将这行加入就可以了（最主要就是isELIgnored）\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;\n","tags":["遇到的问题"]},{"title":"面试题之请你聊聊重定向和转发的区别？","url":"/2022/04/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E8%AF%B7%E4%BD%A0%E8%81%8A%E8%81%8A%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/","content":"相同点 ：\n\n页面都会实现跳转\n\n不同点 ：\n\n请求转发的时候，url不会产生变化 ；307\n重定向时候，url地址栏会发生变化；302\n\n","tags":["面试题"]},{"title":"当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？","url":"/2022/04/12/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%BD%93%E4%BD%A0%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5%E5%9C%B0%E5%9D%80%E5%B9%B6%E5%9B%9E%E8%BD%A6%E7%9A%84%E4%B8%80%E7%9E%AC%E9%97%B4%E5%88%B0%E9%A1%B5%E9%9D%A2%E8%83%BD%E5%A4%9F%E5%B1%95%E7%A4%BA%E5%9B%9E%E6%9D%A5%EF%BC%8C%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/","content":"（1）浏览器本身是一个客户端，当你输入URL的时候，首先浏览器会去请求DNS服务器，通过DNS获取相应的域名对应的IP（2）然后通过IP地址找到IP对应的服务器后，要求建立TCP连接（3）浏览器发送完HTTP Request（请求）包后，服务器接收到请求包之后才开始处理请求包（4）在服务器收到请求之后，服务器调用自身服务，返回HTTP Response（响应）包（5）客户端收到来自服务器的响应后开始渲染这个Response包里的主体（body），等收到全部的内容随后断开与该服务器之间的TCP连接。\n","tags":["面试题"]},{"title":"请你谈谈网站是如何进行访问的","url":"/2022/04/12/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%AF%B7%E4%BD%A0%E8%B0%88%E8%B0%88%E7%BD%91%E7%AB%99%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E7%9A%84/","content":"\n输入一个域名；回车 \n检查本机的 C:\\Windows\\System32\\drivers\\etc\\hosts配置文件下有没有这个域名映射；\n\n\n有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问\n没有：去DNS服务器找，找到的话就返回，找不到就返回找不到；\n\n\n","tags":["面试题"]},{"title":"SpringBoot开发实用篇之ES下载与安装","url":"/2022/06/21/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BES%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85/","content":"windows版安装包下载地址：https://www.elastic.co/cn/downloads/elasticsearch\n​\t\t下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件\n\n\nbin目录：包含所有的可执行命令\nconfig目录：包含ES服务器使用的配置文件\njdk目录：此目录中包含了一个完整的jdk工具包，版本17，当ES升级时，使用最新版本的jdk确保不会出现版本支持性不足的问题\nlib目录：包含ES运行的依赖jar文件\nlogs目录：包含ES运行后产生的所有日志文件\nmodules目录：包含ES软件中所有的功能模块，也是一个一个的jar包。和jar目录不同，jar目录是ES运行期间依赖的jar包，modules是ES软件自己的功能jar包\nplugins目录：包含ES软件安装的插件，默认为空\n\n启动服务器\nelasticsearch.bat\n\n​\t\t双击elasticsearch.bat文件即可启动ES服务器，默认服务端口9200。通过浏览器访问http://localhost:9200看到如下信息视为ES服务器正常启动\n&#123;  &quot;name&quot; : &quot;CZBK-**********&quot;,  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,  &quot;cluster_uuid&quot; : &quot;j137DSswTPG8U4Yb-0T1Mg&quot;,  &quot;version&quot; : &#123;    &quot;number&quot; : &quot;7.16.2&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;zip&quot;,    &quot;build_hash&quot; : &quot;2b937c44140b6559905130a8650c64dbd0879cfb&quot;,    &quot;build_date&quot; : &quot;2021-12-18T19:42:46.604893745Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;8.10.1&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;  &#125;,  &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之ES文档操作","url":"/2022/06/21/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BES%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/","content":"目前我们已经有了索引了，但是索引中还没有数据，所以要先添加数据，ES中称数据为文档，下面进行文档操作。\n\n添加文档，有三种方式\nPOST请求\thttp://localhost:9200/books/_doc\t\t#使用系统生成idPOST请求\thttp://localhost:9200/books/_create/1\t#使用指定idPOST请求\thttp://localhost:9200/books/_doc/1\t\t#使用指定id，不存在创建，存在更新（版本递增）文档通过请求参数传递，数据格式json&#123;    &quot;name&quot;:&quot;springboot&quot;,    &quot;type&quot;:&quot;springboot&quot;,    &quot;description&quot;:&quot;springboot&quot;&#125;  \n\n查询文档\nGET请求\thttp://localhost:9200/books/_doc/1\t\t #查询单个文档 \t\tGET请求\thttp://localhost:9200/books/_search\t\t #查询全部文档\n\n条件查询\nGET请求\thttp://localhost:9200/books/_search?q=name:springboot\t# q=查询属性名:查询属性值\n\n删除文档\nDELETE请求\thttp://localhost:9200/books/_doc/1\n\n修改文档（全量更新）\nPUT请求\thttp://localhost:9200/books/_doc/1文档通过请求参数传递，数据格式json&#123;    &quot;name&quot;:&quot;springboot&quot;,    &quot;type&quot;:&quot;springboot&quot;,    &quot;description&quot;:&quot;springboot&quot;&#125;\n\n修改文档（部分更新）\nPOST请求\thttp://localhost:9200/books/_update/1文档通过请求参数传递，数据格式json&#123;\t\t\t    &quot;doc&quot;:&#123;\t\t\t\t\t\t#部分更新并不是对原始文档进行更新，而是对原始文档对象中的doc属性中的指定属性更新        &quot;name&quot;:&quot;springboot&quot;\t\t#仅更新提供的属性值，未提供的属性值不参与更新操作    &#125;&#125;\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之ES查询文档","url":"/2022/06/22/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BES%E6%9F%A5%E8%AF%A2%E6%96%87%E6%A1%A3/","content":"按id查询文档：\n@Test//按id查询void testGet() throws IOException &#123;    GetRequest request = new GetRequest(&quot;books&quot;,&quot;1&quot;);    GetResponse response = client.get(request, RequestOptions.DEFAULT);    String json = response.getSourceAsString();    System.out.println(json);&#125;\n\n​\t\t根据id查询文档使用的请求对象是GetRequest。\n按条件查询文档：\n@Test//按条件查询void testSearch() throws IOException &#123;    SearchRequest request = new SearchRequest(&quot;books&quot;);    SearchSourceBuilder builder = new SearchSourceBuilder();    builder.query(QueryBuilders.termQuery(&quot;all&quot;,&quot;spring&quot;));    request.source(builder);    SearchResponse response = client.search(request, RequestOptions.DEFAULT);    SearchHits hits = response.getHits();    for (SearchHit hit : hits) &#123;        String source = hit.getSourceAsString();        //System.out.println(source);        Book book = JSON.parseObject(source, Book.class);        System.out.println(book);    &#125;&#125;\n\n​\t\t按条件查询文档使用的请求对象是SearchRequest，查询时调用SearchRequest对象的termQuery方法，需要给出查询属性名，此处支持使用合并字段，也就是前面定义索引属性时添加的all属性。\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之ES添加文档","url":"/2022/06/22/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BES%E6%B7%BB%E5%8A%A0%E6%96%87%E6%A1%A3/","content":"创建索引（IK分词器）：\n@Testvoid testCreateIndexByIK() throws IOException &#123;    CreateIndexRequest request = new CreateIndexRequest(&quot;books&quot;);    String json = &quot;&#123;\\n&quot; +            &quot;    \\&quot;mappings\\&quot;:&#123;\\n&quot; +            &quot;        \\&quot;properties\\&quot;:&#123;\\n&quot; +            &quot;            \\&quot;id\\&quot;:&#123;\\n&quot; +            &quot;                \\&quot;type\\&quot;:\\&quot;keyword\\&quot;\\n&quot; +            &quot;            &#125;,\\n&quot; +            &quot;            \\&quot;name\\&quot;:&#123;\\n&quot; +            &quot;                \\&quot;type\\&quot;:\\&quot;text\\&quot;,\\n&quot; +            &quot;                \\&quot;analyzer\\&quot;:\\&quot;ik_max_word\\&quot;,\\n&quot; +            &quot;                \\&quot;copy_to\\&quot;:\\&quot;all\\&quot;\\n&quot; +            &quot;            &#125;,\\n&quot; +            &quot;            \\&quot;type\\&quot;:&#123;\\n&quot; +            &quot;                \\&quot;type\\&quot;:\\&quot;keyword\\&quot;\\n&quot; +            &quot;            &#125;,\\n&quot; +            &quot;            \\&quot;description\\&quot;:&#123;\\n&quot; +            &quot;                \\&quot;type\\&quot;:\\&quot;text\\&quot;,\\n&quot; +            &quot;                \\&quot;analyzer\\&quot;:\\&quot;ik_max_word\\&quot;,\\n&quot; +            &quot;                \\&quot;copy_to\\&quot;:\\&quot;all\\&quot;\\n&quot; +            &quot;            &#125;,\\n&quot; +            &quot;            \\&quot;all\\&quot;:&#123;\\n&quot; +            &quot;                \\&quot;type\\&quot;:\\&quot;text\\&quot;,\\n&quot; +            &quot;                \\&quot;analyzer\\&quot;:\\&quot;ik_max_word\\&quot;\\n&quot; +            &quot;            &#125;\\n&quot; +            &quot;        &#125;\\n&quot; +            &quot;    &#125;\\n&quot; +            &quot;&#125;&quot;;    //设置请求中的参数    request.source(json, XContentType.JSON);    client.indices().create(request, RequestOptions.DEFAULT);&#125;\n\n​\t\tIK分词器是通过请求参数的形式进行设置的，设置请求参数使用request对象中的source方法进行设置，至于参数是什么，取决于你的操作种类。当请求中需要参数时，均可使用当前形式进行参数设置。\t\n添加文档：\n@Test//添加文档void testCreateDoc() throws IOException &#123;    Book book = bookDao.selectById(1);    IndexRequest request = new IndexRequest(&quot;books&quot;).id(book.getId().toString());    String json = JSON.toJSONString(book);    request.source(json,XContentType.JSON);    client.index(request,RequestOptions.DEFAULT);&#125;\n\n​\t\t添加文档使用的请求对象是IndexRequest，与创建索引使用的请求对象不同。\t\n批量添加文档：\n@Test//批量添加文档void testCreateDocAll() throws IOException &#123;    List&lt;Book&gt; bookList = bookDao.selectList(null);    BulkRequest bulk = new BulkRequest();    for (Book book : bookList) &#123;        IndexRequest request = new IndexRequest(&quot;books&quot;).id(book.getId().toString());        String json = JSON.toJSONString(book);        request.source(json,XContentType.JSON);        bulk.add(request);    &#125;    client.bulk(bulk,RequestOptions.DEFAULT);&#125;\n\n​\t\t批量做时，先创建一个BulkRequest的对象，可以将该对象理解为是一个保存request对象的容器，将所有的请求都初始化好后，添加到BulkRequest对象中，再使用BulkRequest对象的bulk方法，一次性执行完毕。\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之ES简介","url":"/2022/06/21/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BES%E7%AE%80%E4%BB%8B/","content":"​\t\tNoSQL解决方案已经讲完了两种技术的整合了，Redis可以使用内存加载数据并实现数据快速访问，MongoDB可以在内存中存储类似对象的数据并实现数据的快速访问，在企业级开发中对于速度的追求是永无止境的。下面要讲的内容也是一款NoSQL解决方案，只不过他的作用不是为了直接加速数据的读写，而是加速数据的查询的，叫做ES技术。\n​\t\tES（Elasticsearch）是一个分布式全文搜索引擎，重点是全文搜索。\n​\t\t那什么是全文搜索呢？比如用户要买一本书，以Java为关键字进行搜索，不管是书名中还是书的介绍中，甚至是书的作者名字，只要包含java就作为查询结果返回给用户查看，上述过程就使用了全文搜索技术。搜索的条件不再是仅用于对某一个字段进行比对，而是在一条数据中使用搜索条件去比对更多的字段，只要能匹配上就列入查询结果，这就是全文搜索的目的。而ES技术就是一种可以实现上述效果的技术。\n​\t\t要实现全文搜索的效果，不可能使用数据库中like操作去进行比对，这种效率太低了。ES设计了一种全新的思想，来实现全文搜索。具体操作过程如下：\n\n将被查询的字段的数据全部文本信息进行查分，分成若干个词\n\n例如“中华人民共和国”就会被拆分成三个词，分别是“中华”、“人民”、“共和国”，此过程有专业术语叫做分词。分词的策略不同，分出的效果不一样，不同的分词策略称为分词器。\n\n\n将分词得到的结果存储起来，对应每条数据的id\n\n例如id为1的数据中名称这一项的值是“中华人民共和国”，那么分词结束后，就会出现“中华”对应id为1，“人民”对应id为1，“共和国”对应id为1\n\n例如id为2的数据中名称这一项的值是“人民代表大会“，那么分词结束后，就会出现“人民”对应id为2，“代表”对应id为2，“大会”对应id为2\n\n此时就会出现如下对应结果，按照上述形式可以对所有文档进行分词。需要注意分词的过程不是仅对一个字段进行，而是对每一个参与查询的字段都执行，最终结果汇总到一个表格中\n\n\n\n分词结果关键字\n对应id\n\n\n\n中华\n1\n\n\n人民\n1,2\n\n\n共和国\n1\n\n\n代表\n2\n\n\n大会\n2\n\n\n\n\n\n当进行查询时，如果输入“人民”作为查询条件，可以通过上述表格数据进行比对，得到id值1,2，然后根据id值就可以得到查询的结果数据了。\n\n\n​\t\t上述过程中分词结果关键字内容每一个都不相同，作用有点类似于数据库中的索引，是用来加速数据查询的。但是数据库中的索引是对某一个字段进行添加索引，而这里的分词结果关键字不是一个完整的字段值，只是一个字段中的其中的一部分内容。并且索引使用时是根据索引内容查找整条数据，全文搜索中的分词结果关键字查询后得到的并不是整条的数据，而是数据的id，要想获得具体数据还要再次查询，因此这里为这种分词结果关键字起了一个全新的名称，叫做倒排索引。\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之ES索引操作","url":"/2022/06/21/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BES%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/","content":"​\t\tES中保存有我们要查询的数据，只不过格式和数据库存储数据格式不同而已。在ES中我们要先创建倒排索引，这个索引的功能又点类似于数据库的表，然后将数据添加到倒排索引中，添加的数据称为文档。所以要进行ES的操作要先创建索引，再添加文档，这样才能进行后续的查询操作。\n​\t\t要操作ES可以通过Rest风格的请求来进行，也就是说发送一个请求就可以执行一个操作。比如新建索引，删除索引这些操作都可以使用发送请求的形式来进行。\n\n创建索引，books是索引名称，下同\nPUT请求\t\thttp://localhost:9200/books\n\n发送请求后，看到如下信息即索引创建成功\n&#123;    &quot;acknowledged&quot;: true,    &quot;shards_acknowledged&quot;: true,    &quot;index&quot;: &quot;books&quot;&#125;\n\n重复创建已经存在的索引会出现错误信息，reason属性中描述错误原因\n&#123;    &quot;error&quot;: &#123;        &quot;root_cause&quot;: [            &#123;                &quot;type&quot;: &quot;resource_already_exists_exception&quot;,                &quot;reason&quot;: &quot;index [books/VgC_XMVAQmedaiBNSgO2-w] already exists&quot;,                &quot;index_uuid&quot;: &quot;VgC_XMVAQmedaiBNSgO2-w&quot;,                &quot;index&quot;: &quot;books&quot;            &#125;        ],        &quot;type&quot;: &quot;resource_already_exists_exception&quot;,        &quot;reason&quot;: &quot;index [books/VgC_XMVAQmedaiBNSgO2-w] already exists&quot;,\t# books索引已经存在        &quot;index_uuid&quot;: &quot;VgC_XMVAQmedaiBNSgO2-w&quot;,        &quot;index&quot;: &quot;book&quot;    &#125;,    &quot;status&quot;: 400&#125;\n\n查询索引\nGET请求\t\thttp://localhost:9200/books\n\n查询索引得到索引相关信息，如下\n&#123;    &quot;book&quot;: &#123;        &quot;aliases&quot;: &#123;&#125;,        &quot;mappings&quot;: &#123;&#125;,        &quot;settings&quot;: &#123;            &quot;index&quot;: &#123;                &quot;routing&quot;: &#123;                    &quot;allocation&quot;: &#123;                        &quot;include&quot;: &#123;                            &quot;_tier_preference&quot;: &quot;data_content&quot;                        &#125;                    &#125;                &#125;,                &quot;number_of_shards&quot;: &quot;1&quot;,                &quot;provided_name&quot;: &quot;books&quot;,                &quot;creation_date&quot;: &quot;1645768584849&quot;,                &quot;number_of_replicas&quot;: &quot;1&quot;,                &quot;uuid&quot;: &quot;VgC_XMVAQmedaiBNSgO2-w&quot;,                &quot;version&quot;: &#123;                    &quot;created&quot;: &quot;7160299&quot;                &#125;            &#125;        &#125;    &#125;&#125;\n\n如果查询了不存在的索引，会返回错误信息，例如查询名称为book的索引后信息如下\n&#123;    &quot;error&quot;: &#123;        &quot;root_cause&quot;: [            &#123;                &quot;type&quot;: &quot;index_not_found_exception&quot;,                &quot;reason&quot;: &quot;no such index [book]&quot;,                &quot;resource.type&quot;: &quot;index_or_alias&quot;,                &quot;resource.id&quot;: &quot;book&quot;,                &quot;index_uuid&quot;: &quot;_na_&quot;,                &quot;index&quot;: &quot;book&quot;            &#125;        ],        &quot;type&quot;: &quot;index_not_found_exception&quot;,        &quot;reason&quot;: &quot;no such index [book]&quot;,\t\t# 没有book索引        &quot;resource.type&quot;: &quot;index_or_alias&quot;,        &quot;resource.id&quot;: &quot;book&quot;,        &quot;index_uuid&quot;: &quot;_na_&quot;,        &quot;index&quot;: &quot;book&quot;    &#125;,    &quot;status&quot;: 404&#125;\n\n删除索引\nDELETE请求\thttp://localhost:9200/books\n\n删除所有后，给出删除结果\n&#123;    &quot;acknowledged&quot;: true&#125;\n\n如果重复删除，会给出错误信息，同样在reason属性中描述具体的错误原因\n&#123;    &quot;error&quot;: &#123;        &quot;root_cause&quot;: [            &#123;                &quot;type&quot;: &quot;index_not_found_exception&quot;,                &quot;reason&quot;: &quot;no such index [books]&quot;,                &quot;resource.type&quot;: &quot;index_or_alias&quot;,                &quot;resource.id&quot;: &quot;book&quot;,                &quot;index_uuid&quot;: &quot;_na_&quot;,                &quot;index&quot;: &quot;book&quot;            &#125;        ],        &quot;type&quot;: &quot;index_not_found_exception&quot;,        &quot;reason&quot;: &quot;no such index [books]&quot;,\t\t# 没有books索引        &quot;resource.type&quot;: &quot;index_or_alias&quot;,        &quot;resource.id&quot;: &quot;book&quot;,        &quot;index_uuid&quot;: &quot;_na_&quot;,        &quot;index&quot;: &quot;book&quot;    &#125;,    &quot;status&quot;: 404&#125;\n\n创建索引并指定分词器\n​\t\t前面创建的索引是未指定分词器的，可以在创建索引时添加请求参数，设置分词器。目前国内较为流行的分词器是IK分词器，使用前先在下对应的分词器，然后使用。IK分词器下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases\n​\t\t分词器下载后解压到ES安装目录的plugins目录中即可，安装分词器后需要重新启动ES服务器。使用IK分词器创建索引格式：\nPUT请求\t\thttp://localhost:9200/books请求参数如下（注意是json格式的参数）&#123;    &quot;mappings&quot;:&#123;\t\t\t\t\t\t\t#定义mappings属性，替换创建索引时对应的mappings属性\t\t        &quot;properties&quot;:&#123;\t\t\t\t\t\t#定义索引中包含的属性设置            &quot;id&quot;:&#123;\t\t\t\t\t\t\t#设置索引中包含id属性                &quot;type&quot;:&quot;keyword&quot;\t\t\t#当前属性可以被直接搜索            &#125;,            &quot;name&quot;:&#123;\t\t\t\t\t\t#设置索引中包含name属性                &quot;type&quot;:&quot;text&quot;,              #当前属性是文本信息，参与分词                  &quot;analyzer&quot;:&quot;ik_max_word&quot;,   #使用IK分词器进行分词                             &quot;copy_to&quot;:&quot;all&quot;\t\t\t\t#分词结果拷贝到all属性中            &#125;,            &quot;type&quot;:&#123;                &quot;type&quot;:&quot;keyword&quot;            &#125;,            &quot;description&quot;:&#123;                &quot;type&quot;:&quot;text&quot;,\t                                &quot;analyzer&quot;:&quot;ik_max_word&quot;,                                &quot;copy_to&quot;:&quot;all&quot;            &#125;,            &quot;all&quot;:&#123;\t\t\t\t\t\t\t#定义属性，用来描述多个字段的分词结果集合，当前属性可以参与查询                &quot;type&quot;:&quot;text&quot;,\t                                &quot;analyzer&quot;:&quot;ik_max_word&quot;            &#125;        &#125;    &#125;&#125;\n\n​\t\t创建完毕后返回结果和不使用分词器创建索引的结果是一样的，此时可以通过查看索引信息观察到添加的请求参数mappings已经进入到了索引属性中\n&#123;    &quot;books&quot;: &#123;        &quot;aliases&quot;: &#123;&#125;,        &quot;mappings&quot;: &#123;\t\t\t\t\t\t#mappings属性已经被替换            &quot;properties&quot;: &#123;                &quot;all&quot;: &#123;                    &quot;type&quot;: &quot;text&quot;,                    &quot;analyzer&quot;: &quot;ik_max_word&quot;                &#125;,                &quot;description&quot;: &#123;                    &quot;type&quot;: &quot;text&quot;,                    &quot;copy_to&quot;: [                        &quot;all&quot;                    ],                    &quot;analyzer&quot;: &quot;ik_max_word&quot;                &#125;,                &quot;id&quot;: &#123;                    &quot;type&quot;: &quot;keyword&quot;                &#125;,                &quot;name&quot;: &#123;                    &quot;type&quot;: &quot;text&quot;,                    &quot;copy_to&quot;: [                        &quot;all&quot;                    ],                    &quot;analyzer&quot;: &quot;ik_max_word&quot;                &#125;,                &quot;type&quot;: &#123;                    &quot;type&quot;: &quot;keyword&quot;                &#125;            &#125;        &#125;,        &quot;settings&quot;: &#123;            &quot;index&quot;: &#123;                &quot;routing&quot;: &#123;                    &quot;allocation&quot;: &#123;                        &quot;include&quot;: &#123;                            &quot;_tier_preference&quot;: &quot;data_content&quot;                        &#125;                    &#125;                &#125;,                &quot;number_of_shards&quot;: &quot;1&quot;,                &quot;provided_name&quot;: &quot;books&quot;,                &quot;creation_date&quot;: &quot;1645769809521&quot;,                &quot;number_of_replicas&quot;: &quot;1&quot;,                &quot;uuid&quot;: &quot;DohYKvr_SZO4KRGmbZYmTQ&quot;,                &quot;version&quot;: &#123;                    &quot;created&quot;: &quot;7160299&quot;                &#125;            &#125;        &#125;    &#125;&#125;\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之H2数据库","url":"/2022/06/20/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BH2%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"​\t\t截止到目前，springboot给开发者提供了内置的数据源解决方案和持久化解决方案，在数据层解决方案三件套中还剩下一个数据库，莫非springboot也提供有内置的解决方案？还真有，还不是一个，三个，这一节就来说说内置的数据库解决方案。\n​\t\tspringboot提供了3款内置的数据库，分别是\n\nH2\nHSQL\nDerby\n\n​\t\t以上三款数据库除了可以独立安装之外，还可以像是tomcat服务器一样，采用内嵌的形式运行在spirngboot容器中。内嵌在容器中运行，那必须是java对象啊，对，这三款数据库底层都是使用java语言开发的。\n​\t\t我们一直使用MySQL数据库就挺好的，为什么有需求用这个呢？原因就在于这三个数据库都可以采用内嵌容器的形式运行，在应用程序运行后，如果我们进行测试工作，此时测试的数据无需存储在磁盘上，但是又要测试使用，内嵌数据库就方便了，运行在内存中，该测试测试，该运行运行，等服务器关闭后，一切烟消云散，多好，省得你维护外部数据库了。这也是内嵌数据库的最大优点，方便进行功能测试。\n​\t\t下面以H2数据库为例讲解如何使用这些内嵌数据库，操作步骤也非常简单，简单才好用嘛\n步骤①：导入H2数据库对应的坐标，一共2个\n&lt;dependency&gt;    &lt;groupId&gt;com.h2database&lt;/groupId&gt;    &lt;artifactId&gt;h2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;\n\n步骤②：将工程设置为web工程，启动工程时启动H2数据库\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\n\n步骤③：通过配置开启H2数据库控制台访问程序，也可以使用其他的数据库连接软件操作\nspring:  h2:    console:      enabled: true      path: /h2\n\n​\t\tweb端访问路径&#x2F;h2，访问密码123456，如果访问失败，先配置下列数据源，启动程序运行后再次访问&#x2F;h2路径就可以正常访问了\ndatasource:  url: jdbc:h2:~/test  hikari:    driver-class-name: org.h2.Driver    username: sa    password: 123456\n\n步骤④：使用JdbcTemplate或MyBatisPlus技术操作数据库\n（略）\n​\t\t其实我们只是换了一个数据库而已，其他的东西都不受影响。一个重要提醒，别忘了，上线时，把内存级数据库关闭，采用MySQL数据库作为数据持久化方案，关闭方式就是设置enabled属性为false即可。\n总结\n\nH2内嵌式数据库启动方式，添加坐标，添加配置\nH2数据库线上运行时请务必关闭\n\n​\t\t到这里SQL相关的数据层解决方案就讲完了，现在的可选技术就丰富的多了。\n\n数据源技术：Druid、Hikari、tomcat DataSource、DBCP\n持久化技术：MyBatisPlus、MyBatis、JdbcTemplate\n数据库技术：MySQL、H2、HSQL、Derby\n\n​\t\t现在开发程序时就可以在以上技术中任选一种组织成一套数据库解决方案了。\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之JdbcTemplate","url":"/2022/06/20/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BJdbcTemplate/","content":"持久化技术​\t\t说完数据源解决方案，再来说一下持久化解决方案。springboot充分发挥其最强辅助的特征，给开发者提供了一套现成的数据层技术，叫做JdbcTemplate。其实这个技术不能说是springboot提供的，因为不使用springboot技术，一样能使用它，谁提供的呢？spring技术提供的，所以在springboot技术范畴中，这个技术也是存在的，毕竟springboot技术是加速spring程序开发而创建的。\n​\t\t这个技术其实就是回归到jdbc最原始的编程形式来进行数据层的开发，下面直接上操作步骤：\n步骤①：导入jdbc对应的坐标，记得是starter\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency\n\n步骤②：自动装配JdbcTemplate对象\n@SpringBootTestclass Springboot15SqlApplicationTests &#123;    @Test    void testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate)&#123;    &#125;&#125;\n\n步骤③：使用JdbcTemplate实现查询操作（非实体类封装数据的查询操作）\n@Testvoid testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate)&#123;    String sql = &quot;select * from tbl_book&quot;;    List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql);    System.out.println(maps);&#125;\n\n步骤④：使用JdbcTemplate实现查询操作（实体类封装数据的查询操作）\n@Testvoid testJdbcTemplate(@Autowired JdbcTemplate jdbcTemplate)&#123;    String sql = &quot;select * from tbl_book&quot;;    RowMapper&lt;Book&gt; rm = new RowMapper&lt;Book&gt;() &#123;        @Override        public Book mapRow(ResultSet rs, int rowNum) throws SQLException &#123;            Book temp = new Book();            temp.setId(rs.getInt(&quot;id&quot;));            temp.setName(rs.getString(&quot;name&quot;));            temp.setType(rs.getString(&quot;type&quot;));            temp.setDescription(rs.getString(&quot;description&quot;));            return temp;        &#125;    &#125;;    List&lt;Book&gt; list = jdbcTemplate.query(sql, rm);    System.out.println(list);&#125;\n\n步骤⑤：使用JdbcTemplate实现增删改操作\n@Testvoid testJdbcTemplateSave(@Autowired JdbcTemplate jdbcTemplate)&#123;    String sql = &quot;insert into tbl_book values(3,&#x27;springboot1&#x27;,&#x27;springboot2&#x27;,&#x27;springboot3&#x27;)&quot;;    jdbcTemplate.update(sql);&#125;\n\n​\t\t如果想对JdbcTemplate对象进行相关配置，可以在yml文件中进行设定，具体如下：\nspring:  jdbc:    template:      query-timeout: -1   # 查询超时时间      max-rows: 500       # 最大行数      fetch-size: -1      # 缓存行数\n\n总结\nSpringBoot内置JdbcTemplate持久化解决方案\n使用JdbcTemplate需要导入spring-boot-starter-jdbc的坐标\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之Mongodb下载与安装","url":"/2022/06/21/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BMongodb%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85/","content":"​\t\twindows版安装包下载地址：https://www.mongodb.com/try/download\n​\t\t下载的安装包也有两种形式，一种是一键安装的msi文件，还有一种是解压缩就能使用的zip文件，哪种形式都行，本课程采用解压缩zip文件进行安装。\n​\t\t解压缩完毕后会得到如下文件，其中bin目录包含了所有mongodb的可执行命令\n\n​\t\tmongodb在运行时需要指定一个数据存储的目录，所以创建一个数据存储目录，通常放置在安装目录中，此处创建data的目录用来存储数据，具体如下\n\n​\t\t如果在安装的过程中出现了如下警告信息，就是告诉你，你当前的操作系统缺少了一些系统文件，这个不用担心。\n\n​\t\t根据下列方案即可解决，在浏览器中搜索提示缺少的名称对应的文件，并下载，将下载的文件拷贝到windows安装目录的system32目录下，然后在命令行中执行regsvr32命令注册此文件。根据下载的文件名不同，执行命令前更改对应名称。\nregsvr32 vcruntime140_1.dll\n\n启动服务器\nmongod --dbpath=..\\data\\db\n\n​\t\t启动服务器时需要指定数据存储位置，通过参数–dbpath进行设置，可以根据需要自行设置数据存储路径。默认服务端口27017。\n启动客户端\nmongo --host=127.0.0.1 --port=27017\n\n基本操作​\t\tMongoDB虽然是一款数据库，但是它的操作并不是使用SQL语句进行的，因此操作方式各位小伙伴可能比较陌生，好在有一些类似于Navicat的数据库客户端软件，能够便捷的操作MongoDB，先安装一个客户端，再来操作MongoDB。\n​\t\t同类型的软件较多，本次安装的软件是Robo3t，Robot3t是一款绿色软件，无需安装，解压缩即可。解压缩完毕后进入安装目录双击robot3t.exe即可使用。\n\n​\t\t打开软件首先要连接MongoDB服务器，选择【File】菜单，选择【Connect…】\n\n​\t\t进入连接管理界面后，选择左上角的【Create】链接，创建新的连接设置\n\n​\t如果输入设置值即可连接（默认不修改即可连接本机27017端口）\n\n​\t\t连接成功后在命令输入区域输入命令即可操作MongoDB。\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之Mongodb基础操作","url":"/2022/06/21/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BMongodb%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","content":"​\t\t创建数据库：在左侧菜单中使用右键创建，输入数据库名称即可\n​\t\t创建集合：在Collections上使用右键创建，输入集合名称即可，集合等同于数据库中的表的作用\n​\t\t新增文档：（文档是一种类似json格式的数据，初学者可以先把数据理解为就是json数据）\t\ndb.集合名称.insert/save/insertOne(文档)\n\n​\t\t删除文档：\ndb.集合名称.remove(条件)\n\n​\t\t修改文档：\ndb.集合名称.update(条件，&#123;操作种类:&#123;文档&#125;&#125;)\n\n​\t\t查询文档：\n基础查询查询全部：\t\t   db.集合.find();查第一条：\t\t   db.集合.findOne()查询指定数量文档：\tdb.集合.find().limit(10)\t\t\t\t\t//查10条文档跳过指定数量文档：\tdb.集合.find().skip(20)\t\t\t\t\t//跳过20条文档统计：\t\t\t  \tdb.集合.count()排序：\t\t\t\tdb.集合.sort(&#123;age:1&#125;)\t\t\t\t\t\t//按age升序排序投影：\t\t\t\tdb.集合名称.find(条件,&#123;name:1,age:1&#125;)\t\t //仅保留name与age域条件查询基本格式：\t\t\tdb.集合.find(&#123;条件&#125;)模糊查询：\t\t\tdb.集合.find(&#123;域名:/正则表达式/&#125;)\t\t  //等同SQL中的like，比like强大，可以执行正则所有规则条件比较运算：\t\t   db.集合.find(&#123;域名:&#123;$gt:值&#125;&#125;)\t\t\t\t//等同SQL中的数值比较操作，例如：name&gt;18包含查询：\t\t\tdb.集合.find(&#123;域名:&#123;$in:[值1，值2]&#125;&#125;)\t\t//等同于SQL中的in条件连接查询：\t\t   db.集合.find(&#123;$and:[&#123;条件1&#125;,&#123;条件2&#125;]&#125;)\t   //等同于SQL中的and、or\n\n​\t\t\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之Mongodb简介","url":"/2022/06/21/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BMongodb%E7%AE%80%E4%BB%8B/","content":"​\t\t使用Redis技术可以有效的提高数据访问速度，但是由于Redis的数据格式单一性，无法操作结构化数据，当操作对象型的数据时，Redis就显得捉襟见肘。在保障访问速度的情况下，如果想操作结构化数据，看来Redis无法满足要求了，此时需要使用全新的数据存储结束来解决此问题，本节讲解springboot如何整合MongoDB技术。\n​\t\tMongoDB是一个开源、高性能、无模式的文档型数据库，它是NoSQL数据库产品中的一种，是最像关系型数据库的非关系型数据库。\n​\t\t上述描述中几个词，其中对于我们最陌生的词是无模式的。什么叫无模式呢？简单说就是作为一款数据库，没有固定的数据存储结构，第一条数据可能有A、B、C一共3个字段，第二条数据可能有D、E、F也是3个字段，第三条数据可能是A、C、E3个字段，也就是说数据的结构不固定，这就是无模式。有人会说这有什么用啊？灵活，随时变更，不受约束。基于上述特点，MongoDB的应用面也会产生一些变化。以下列出了一些可以使用MongoDB作为数据存储的场景，但是并不是必须使用MongoDB的场景：\n\n淘宝用户数据\n存储位置：数据库\n特征：永久性存储，修改频度极低\n\n\n游戏装备数据、游戏道具数据\n存储位置：数据库、Mongodb\n特征：永久性存储与临时存储相结合、修改频度较高\n\n\n直播数据、打赏数据、粉丝数据\n存储位置：数据库、Mongodb\n特征：永久性存储与临时存储相结合，修改频度极高\n\n\n物联网数据\n存储位置：Mongodb\n特征：临时存储，修改频度飞速\n\n\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之SpringBoot整合Redis","url":"/2022/06/20/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BSpringBoot%E6%95%B4%E5%90%88Redis/","content":"​\t\t在进行整合之前先梳理一下整合的思想，springboot整合任何技术其实就是在springboot中使用对应技术的API。如果两个技术没有交集，就不存在整合的概念了。所谓整合其实就是使用springboot技术去管理其他技术，几个问题是躲不掉的。\n​\t\t第一，需要先导入对应技术的坐标，而整合之后，这些坐标都有了一些变化\n​\t\t第二，任何技术通常都会有一些相关的设置信息，整合之后，这些信息如何写，写在哪是一个问题\n​\t\t第三，没有整合之前操作如果是模式A的话，整合之后如果没有给开发者带来一些便捷操作，那整合将毫无意义，所以整合后操作肯定要简化一些，那对应的操作方式自然也有所不同\n​\t\t按照上面的三个问题去思考springboot整合所有技术是一种通用思想，在整合的过程中会逐步摸索出整合的套路，而且适用性非常强，经过若干种技术的整合后基本上可以总结出一套固定思维。\n​\t\t下面就开始springboot整合redis，操作步骤如下：\n步骤①：导入springboot整合redis的starter坐标\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n​\t\t上述坐标可以在创建模块的时候通过勾选的形式进行选择，归属NoSQL分类中\n\n步骤②：进行基础配置\nspring:  redis:    host: localhost    port: 6379\n\n​\t\t操作redis，最基本的信息就是操作哪一台redis服务器，所以服务器地址属于基础配置信息，不可缺少。但是即便你不配置，目前也是可以用的。因为以上两组信息都有默认配置，刚好就是上述配置值。\n步骤③：使用springboot整合redis的专用客户端接口操作，此处使用的是RedisTemplate\n@SpringBootTestclass Springboot16RedisApplicationTests &#123;    @Autowired    private RedisTemplate redisTemplate;    @Test    void set() &#123;        ValueOperations ops = redisTemplate.opsForValue();        ops.set(&quot;age&quot;,41);    &#125;    @Test    void get() &#123;        ValueOperations ops = redisTemplate.opsForValue();        Object age = ops.get(&quot;name&quot;);        System.out.println(age);    &#125;    @Test    void hset() &#123;        HashOperations ops = redisTemplate.opsForHash();        ops.put(&quot;info&quot;,&quot;b&quot;,&quot;bb&quot;);    &#125;    @Test    void hget() &#123;        HashOperations ops = redisTemplate.opsForHash();        Object val = ops.get(&quot;info&quot;, &quot;b&quot;);        System.out.println(val);    &#125;&#125;\n\n​\t\t在操作redis时，需要先确认操作何种数据，根据数据种类得到操作接口。例如使用opsForValue()获取string类型的数据操作接口，使用opsForHash()获取hash类型的数据操作接口，剩下的就是调用对应api操作了。各种类型的数据操作接口如下：\n\n总结\n\nspringboot整合redis步骤\n导入springboot整合redis的starter坐标\n进行基础配置\n使用springboot整合redis的专用客户端接口RedisTemplate操作\n\n\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之Spring缓存使用方式","url":"/2022/06/22/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BSpring%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/","content":"​\t\tspringboot技术提供有内置的缓存解决方案，可以帮助开发者快速开启缓存技术，并使用缓存技术进行数据的快速操作，例如读取缓存数据和写入数据到缓存。\n步骤①：导入springboot提供的缓存技术对应的starter\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;\n\n步骤②：启用缓存，在引导类上方标注注解@EnableCaching配置springboot程序中可以使用缓存\n@SpringBootApplication//开启缓存功能@EnableCachingpublic class Springboot19CacheApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Springboot19CacheApplication.class, args);    &#125;&#125;\n\n步骤③：设置操作的数据是否使用缓存\n@Servicepublic class BookServiceImpl implements BookService &#123;    @Autowired    private BookDao bookDao;    @Cacheable(value=&quot;cacheSpace&quot;,key=&quot;#id&quot;)    public Book getById(Integer id) &#123;        return bookDao.selectById(id);    &#125;&#125;\n\n​\t\t在业务方法上面使用注解@Cacheable声明当前方法的返回值放入缓存中，其中要指定缓存的存储位置，以及缓存中保存当前方法返回值对应的名称。上例中value属性描述缓存的存储位置，可以理解为是一个存储空间名，key属性描述了缓存中保存数据的名称，使用#id读取形参中的id值作为缓存名称。\n​\t\t使用@Cacheable注解后，执行当前操作，如果发现对应名称在缓存中没有数据，就正常读取数据，然后放入缓存；如果对应名称在缓存中有数据，就终止当前业务方法执行，直接返回缓存中的数据。\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之StringRedisTemplate","url":"/2022/06/20/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BStringRedisTemplate/","content":"​\t由于redis内部不提供java对象的存储格式，因此当操作的数据以对象的形式存在时，会进行转码，转换成字符串格式后进行操作。为了方便开发者使用基于字符串为数据的操作，springboot整合redis时提供了专用的API接口StringRedisTemplate，你可以理解为这是RedisTemplate的一种指定数据泛型的操作API。\n@SpringBootTestpublic class StringRedisTemplateTest &#123;    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Test    void get()&#123;        ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();        String name = ops.get(&quot;name&quot;);        System.out.println(name);    &#125;&#125;\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之bean属性校验","url":"/2022/06/19/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8Bbean%E5%B1%9E%E6%80%A7%E6%A0%A1%E9%AA%8C/","content":"​\t\t目前我们在进行属性绑定时可以通过松散绑定规则在书写时放飞自我了，但是在书写时由于无法感知模型类中的数据类型，就会出现类型不匹配的问题，比如代码中需要int类型，配置中给了非法的数值，例如写一个“a”，这种数据肯定无法有效的绑定，还会引发错误。\t\tSpringBoot给出了强大的数据校验功能，可以有效的避免此类问题的发生。在JAVAEE的JSR303规范中给出了具体的数据校验标准，开发者可以根据自己的需要选择对应的校验框架，此处使用Hibernate提供的校验框架来作为实现进行数据校验。书写应用格式非常固定，话不多说，直接上步骤\n步骤①：开启校验框架\n&lt;!--1.导入JSR303规范--&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.validation&lt;/groupId&gt;    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--使用hibernate框架提供的校验器做实现--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n步骤②：在需要开启校验功能的类上使用注解@Validated开启校验功能\n@Component@Data@ConfigurationProperties(prefix = &quot;servers&quot;)//开启对当前bean的属性注入校验@Validatedpublic class ServerConfig &#123;&#125;\n\n步骤③：对具体的字段设置校验规则\n@Component@Data@ConfigurationProperties(prefix = &quot;servers&quot;)//开启对当前bean的属性注入校验@Validatedpublic class ServerConfig &#123;    //设置具体的规则    @Max(value = 8888,message = &quot;最大值不能超过8888&quot;)    @Min(value = 202,message = &quot;最小值不能低于202&quot;)    private int port;&#125;\n\n​\t\t通过设置数据格式校验，就可以有效避免非法数据加载，其实使用起来还是挺轻松的，基本上就是一个格式。\n总结\n开启Bean属性校验功能一共3步：导入JSR303与Hibernate校验框架坐标、使用@Validated注解启用校验功能、使用具体校验规则规范数据校验格式\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之redis下载安装与基本使用","url":"/2022/06/20/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8Bredis%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"​\t\tSQL数据层解决方案说完了，下面来说收NoSQL数据层解决方案。这个NoSQL是什么意思呢？从字面来看，No表示否定，NoSQL就是非关系型数据库解决方案，意思就是数据该存存该取取，只是这些数据不放在关系型数据库中了，那放在哪里？自然是一些能够存储数据的其他相关技术中了，比如Redis等。在springboot官方文档中提供了10种相关技术的整合方案，我们将讲解国内市场上最流行的几款NoSQL数据库整合方案，分别是Redis、MongoDB、ES。\n​\t\tRedis是一款采用key-value数据存储格式的内存级NoSQL数据库，重点关注数据存储格式，是key-value格式，也就是键值对的存储形式。与MySQL数据库不同，MySQL数据库有表、有字段、有记录，Redis没有这些东西，就是一个名称对应一个值，并且数据以存储在内存中使用为主。什么叫以存储在内存中为主？其实Redis有它的数据持久化方案，分别是RDB和AOF，但是Redis自身并不是为了数据持久化而生的，主要是在内存中保存数据，加速数据访问的，所以说是一款内存级数据库。\n​\t\tRedis支持多种数据存储格式，比如可以直接存字符串，也可以存一个map集合，list集合，后面会涉及到一些不同格式的数据操作，这个需要先学习一下才能进行整合，所以在基本操作中会介绍一些相关操作。下面就先安装，再操作，最后说整合\n安装​\t\twindows版安装包下载地址：https://github.com/tporadowski/redis/releases\n​\t\t下载的安装包有两种形式，一种是一键安装的msi文件，还有一种是解压缩就能使用的zip文件，哪种形式都行，这里就不介绍安装过程了，本课程采用的是msi一键安装的msi文件进行安装的。\n​\t\t啥是msi，其实就是一个文件安装包，不仅安装软件，还帮你把安装软件时需要的功能关联在一起，打包操作。比如如安装序列、创建和设置安装路径、设置系统依赖项、默认设定安装选项和控制安装过程的属性。说简单点就是一站式服务，安装过程一条龙操作一气呵成，就是为小白用户提供的软件安装程序。\n​\t\t安装完毕后会得到如下文件，其中有两个文件对应两个命令，是启动Redis的核心命令，需要再CMD命令行模式执行。\n\n启动服务器\nredis-server.exe redis.windows.conf\n\n​\t\t初学者无需调整服务器对外服务端口，默认6379。\n启动客户端\nredis-cli.exe\n\n​\t\t如果启动redis服务器失败，可以先启动客户端，然后执行shutdown操作后退出，此时redis服务器就可以正常执行了。\n基本操作​\t\t服务器启动后，使用客户端就可以连接服务器，类似于启动完MySQL数据库，然后启动SQL命令行操作数据库。\t\t\n​\t\t放置一个字符串数据到redis中，先为数据定义一个名称，比如name,age等，然后使用命令set设置数据到redis服务器中即可\nset name itheimaset age 12\n\n​\t\t从redis中取出已经放入的数据，根据名称取，就可以得到对应数据。如果没有对应数据就会得到(nil)\nget nameget age\n\n​\t\t以上使用的数据存储是一个名称对应一个值，如果要维护的数据过多，可以使用别的数据存储结构。例如hash，它是一种一个名称下可以存储多个数据的存储模型，并且每个数据也可以有自己的二级存储名称。向hash结构中存储数据格式如下：\nhset a a1 aa1\t\t#对外key名称是a，在名称为a的存储模型中，a1这个key中保存了数据aa1hset a a2 aa2\n\n​\t\t获取hash结构中的数据命令如下\nhget a a1\t\t\t#得到aa1hget a a2\t\t\t#得到aa2\n\n​\t\t有关redis的基础操作就普及到这里，需要全面掌握redis技术，请参看相关教程学习。\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之redis客户端选择","url":"/2022/06/20/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8Bredis%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%89%E6%8B%A9/","content":"     springboot整合redis技术提供了多种客户端兼容模式，默认提供的是lettucs客户端技术，也可以根据需要切换成指定客户端技术，例如jedis客户端技术，切换成jedis客户端技术操作步骤如下：\n\n步骤①：导入jedis坐标\n&lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;/groupId&gt;    &lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n​\t\tjedis坐标受springboot管理，无需提供版本号\n步骤②：配置客户端技术类型，设置为jedis\nspring:  redis:    host: localhost    port: 6379    client-type: jedis\n\n步骤③：根据需要设置对应的配置\nspring:  redis:    host: localhost    port: 6379    client-type: jedis    lettuce:      pool:        max-active: 16    jedis:      pool:        max-active: 16\n\nlettcus与jedis区别\n\njedis连接Redis服务器是直连模式，当多线程模式下使用jedis会存在线程安全问题，解决方案可以通过配置连接池使每个连接专用，这样整体性能就大受影响\nlettcus基于Netty框架进行与Redis服务器连接，底层设计中采用StatefulRedisConnection。 StatefulRedisConnection自身是线程安全的，可以保障并发访问安全问题，所以一个连接可以被多线程复用。当然lettcus也支持多连接实例一起工作\n\n总结\nspringboot整合redis提供了StringRedisTemplate对象，以字符串的数据格式操作redis\n如果需要切换redis客户端实现技术，可以通过配置的形式进行\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之web测试类中发送请求","url":"/2022/06/19/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8Bweb%E6%B5%8B%E8%AF%95%E7%B1%BB%E4%B8%AD%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/","content":"​\t\t对于测试类中发送请求，其实java的API就提供对应的功能，只不过平时各位小伙伴接触的比较少，所以较为陌生。springboot为了便于开发者进行对应的功能开发，对其又进行了包装，简化了开发步骤，具体操作如下：\n步骤①：在测试类中开启web虚拟调用功能，通过注解@AutoConfigureMockMvc实现此功能的开启\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)//开启虚拟MVC调用@AutoConfigureMockMvcpublic class WebTest &#123;&#125;\n\n步骤②：定义发起虚拟调用的对象MockMVC，通过自动装配的形式初始化对象\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)//开启虚拟MVC调用@AutoConfigureMockMvcpublic class WebTest &#123;    @Test    void testWeb(@Autowired MockMvc mvc) &#123;    &#125;&#125;\n\n步骤③：创建一个虚拟请求对象，封装请求的路径，并使用MockMVC对象发送对应请求\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)//开启虚拟MVC调用@AutoConfigureMockMvcpublic class WebTest &#123;    @Test    void testWeb(@Autowired MockMvc mvc) throws Exception &#123;        //http://localhost:8080/books        //创建虚拟请求，当前访问/books        MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/books&quot;);        //执行对应的请求        mvc.perform(builder);    &#125;&#125;\n\n​\t\t执行测试程序，现在就可以正常的发送&#x2F;books对应的请求了，注意访问路径不要写http://localhost:8080/books，因为前面的服务器IP地址和端口使用的是当前虚拟的web环境，无需指定，仅指定请求的具体路径即可。\n总结\n在测试类中测试web层接口要保障测试类启动时启动web容器，使用@SpringBootTest注解的webEnvironment属性可以虚拟web环境用于测试\n为测试方法注入MockMvc对象，通过MockMvc对象可以发送虚拟请求，模拟web请求调用过程\n\n思考​\t\t目前已经成功的发送了请求，但是还没有起到测试的效果，测试过程必须出现预计值与真实值的比对结果才能确认测试结果是否通过，虚拟请求中能对哪些请求结果进行比对呢？\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之web环境请求结果比对","url":"/2022/06/20/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8Bweb%E7%8E%AF%E5%A2%83%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9E%9C%E6%AF%94%E5%AF%B9/","content":"​\t\t上一节已经在测试用例中成功的模拟出了web环境，并成功的发送了web请求，本节就来解决发送请求后如何比对发送结果的问题。其实发完请求得到的信息只有一种，就是响应对象。至于响应对象中包含什么，就可以比对什么。常见的比对内容如下：\n\n响应状态匹配\n\n@Testvoid testStatus(@Autowired MockMvc mvc) throws Exception &#123;    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/books&quot;);    ResultActions action = mvc.perform(builder);    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败    //定义本次调用的预期值    StatusResultMatchers status = MockMvcResultMatchers.status();    //预计本次调用时成功的：状态200    ResultMatcher ok = status.isOk();    //添加预计值到本次调用过程中进行匹配    action.andExpect(ok);&#125;\n\n\n响应体匹配（非json数据格式）\n\n@Testvoid testBody(@Autowired MockMvc mvc) throws Exception &#123;    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/books&quot;);    ResultActions action = mvc.perform(builder);    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败    //定义本次调用的预期值    ContentResultMatchers content = MockMvcResultMatchers.content();    ResultMatcher result = content.string(&quot;springboot2&quot;);    //添加预计值到本次调用过程中进行匹配    action.andExpect(result);&#125;\n\n\n响应体匹配（json数据格式，开发中的主流使用方式）\n\n@Testvoid testJson(@Autowired MockMvc mvc) throws Exception &#123;    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/books&quot;);    ResultActions action = mvc.perform(builder);    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败    //定义本次调用的预期值    ContentResultMatchers content = MockMvcResultMatchers.content();    ResultMatcher result = content.json(&quot;&#123;\\&quot;id\\&quot;:1,\\&quot;name\\&quot;:\\&quot;springboot2\\&quot;,\\&quot;type\\&quot;:\\&quot;springboot\\&quot;&#125;&quot;);    //添加预计值到本次调用过程中进行匹配    action.andExpect(result);&#125;\n\n\n响应头信息匹配\n\n@Testvoid testContentType(@Autowired MockMvc mvc) throws Exception &#123;    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/books&quot;);    ResultActions action = mvc.perform(builder);    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败    //定义本次调用的预期值    HeaderResultMatchers header = MockMvcResultMatchers.header();    ResultMatcher contentType = header.string(&quot;Content-Type&quot;, &quot;application/json&quot;);    //添加预计值到本次调用过程中进行匹配    action.andExpect(contentType);&#125;\n\n​\t\t基本上齐了，头信息，正文信息，状态信息都有了，就可以组合出一个完美的响应结果比对结果了。以下范例就是三种信息同时进行匹配校验，也是一个完整的信息匹配过程。\n@Testvoid testGetById(@Autowired MockMvc mvc) throws Exception &#123;    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get(&quot;/books&quot;);    ResultActions action = mvc.perform(builder);    StatusResultMatchers status = MockMvcResultMatchers.status();    ResultMatcher ok = status.isOk();    action.andExpect(ok);    HeaderResultMatchers header = MockMvcResultMatchers.header();    ResultMatcher contentType = header.string(&quot;Content-Type&quot;, &quot;application/json&quot;);    action.andExpect(contentType);    ContentResultMatchers content = MockMvcResultMatchers.content();    ResultMatcher result = content.json(&quot;&#123;\\&quot;id\\&quot;:1,\\&quot;name\\&quot;:\\&quot;springboot\\&quot;,\\&quot;type\\&quot;:\\&quot;springboot\\&quot;&#125;&quot;);    action.andExpect(result);&#125;\n\n总结\nweb虚拟调用可以对本地虚拟请求的返回响应信息进行比对，分为响应头信息比对、响应体信息比对、响应状态信息比对\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之关闭热部署","url":"/2022/06/18/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E5%85%B3%E9%97%AD%E7%83%AD%E9%83%A8%E7%BD%B2/","content":"​\t\t线上环境运行时是不可能使用热部署功能的，所以需要强制关闭此功能，通过配置可以关闭此功能。\nspring:  devtools:    restart:      enabled: false\n\n​\t\t如果当心配置文件层级过多导致相符覆盖最终引起配置失效，可以提高配置的层级，在更高层级中配置关闭热部署。例如在启动容器前通过系统属性设置关闭热部署功能。\n@SpringBootApplicationpublic class SSMPApplication &#123;    public static void main(String[] args) &#123;        System.setProperty(&quot;spring.devtools.restart.enabled&quot;,&quot;false&quot;);        SpringApplication.run(SSMPApplication.class);    &#125;&#125;\n\n​\t\t其实上述担心略微有点多余，因为线上环境的维护是不可能出现修改代码的操作的，这么做唯一的作用是降低资源消耗，毕竟那双盯着你项目是不是产生变化的眼睛只要闭上了，就不具有热部署功能了，这个开关的作用就是禁用对应功能。\n总结\n\n通过配置可以关闭热部署功能降低线上程序的资源消耗\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之内置数据源","url":"/2022/06/20/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90/","content":"​\t\t回忆一下之前做SSMP整合的时候数据层解决方案涉及到了哪些技术？MySQL数据库与MyBatisPlus框架，后面又学了Druid数据源的配置，所以现在数据层解决方案可以说是Mysql+Druid+MyBatisPlus。而三个技术分别对应了数据层操作的三个层面：\n\n数据源技术：Druid\n持久化技术：MyBatisPlus\n数据库技术：MySQL\n\n​\t\t下面的研究就分为三个层面进行研究，对应上面列出的三个方面，咱们就从第一个数据源技术开始说起。\n数据源技术​\t\t目前我们使用的数据源技术是Druid，运行时可以在日志中看到对应的数据源初始化信息，具体如下：\nINFO 28600 --- [           main] c.a.d.s.b.a.DruidDataSourceAutoConfigure : Init DruidDataSourceINFO 28600 --- [           main] com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-1&#125; inited\n\n​\t\t如果不使用Druid数据源，程序运行后是什么样子呢？是独立的数据库连接对象还是有其他的连接池技术支持呢？将Druid技术对应的starter去掉再次运行程序可以在日志中找到如下初始化信息：\nINFO 31820 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...INFO 31820 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n\n​\t\t虽然没有DruidDataSource相关的信息了，但是我们发现日志中有HikariDataSource这个信息，就算不懂这是个什么技术，看名字也能看出来，以DataSource结尾的名称，这一定是一个数据源技术。我们又没有手工添加这个技术，这个技术哪里来的呢？这就是这一节要讲的知识，springboot内嵌数据源。\n​\t\t数据层技术是每一个企业级应用程序都会用到的，而其中必定会进行数据库连接的管理。springboot根据开发者的习惯出发，开发者提供了数据源技术，就用你提供的，开发者没有提供，那总不能手工管理一个一个的数据库连接对象啊，怎么办？我给你一个默认的就好了，这样省心又省事，大家都方便。\n​\t\tspringboot提供了3款内嵌数据源技术，分别如下：\n\nHikariCP\nTomcat提供DataSource\nCommons DBCP\n\n​\t\t第一种，HikartCP，这是springboot官方推荐的数据源技术，作为默认内置数据源使用。啥意思？你不配置数据源，那就用这个。\n​\t\t第二种，Tomcat提供的DataSource，如果不想用HikartCP，并且使用tomcat作为web服务器进行web程序的开发，使用这个。为什么是Tomcat，不是其他web服务器呢？因为web技术导入starter后，默认使用内嵌tomcat，既然都是默认使用的技术了，那就一用到底，数据源也用它的。有人就提出怎么才能不使用HikartCP用tomcat提供的默认数据源对象呢？把HikartCP技术的坐标排除掉就OK了。\n​\t\t第三种，DBCP，这个使用的条件就更苛刻了，既不使用HikartCP也不使用tomcat的DataSource时，默认给你用这个。\n​\t怎么配置使用这些东西呢？之前我们配置druid时使用druid的starter对应的配置如下：\nspring:  datasource:    druid:\t   \t  url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC      driver-class-name: com.mysql.cj.jdbc.Driver      username: root      password: root\n\n​\t\t换成是默认的数据源HikariCP后，直接吧druid删掉就行了，如下：\nspring:  datasource:    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    driver-class-name: com.mysql.cj.jdbc.Driver    username: root    password: root\n\n​\t\t 当然，也可以写上是对hikari做的配置，但是url地址要单独配置，如下：\nspring:  datasource:    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    hikari:      driver-class-name: com.mysql.cj.jdbc.Driver      username: root      password: root\n\n​\t\t这就是配置hikari数据源的方式。如果想对hikari做进一步的配置，可以继续配置其独立的属性。例如：\nspring:  datasource:    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    hikari:      driver-class-name: com.mysql.cj.jdbc.Driver      username: root      password: root      maximum-pool-size: 50\n\n​\t\t如果不想使用hikari数据源，使用tomcat的数据源或者DBCP配置格式也是一样的。学习到这里，以后我们做数据层时，数据源对象的选择就不再是单一的使用druid数据源技术了，可以根据需要自行选择。\n总结\nspringboot技术提供了3种内置的数据源技术，分别是Hikari、tomcat内置数据源、DBCP\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之加载测试专用属性","url":"/2022/06/19/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%95%E4%B8%93%E7%94%A8%E5%B1%9E%E6%80%A7/","content":"​\t\t测试过程本身并不是一个复杂的过程，但是很多情况下测试时需要模拟一些线上情况，或者模拟一些特殊情况。如果当前环境按照线上环境已经设定好了，例如是下面的配置\nenv:  maxMemory: 32GB  minMemory: 16GB\n\n​\t\t但是你现在想测试对应的兼容性，需要测试如下配置\nenv:  maxMemory: 16GB  minMemory: 8GB\n\n​\t\t这个时候我们能不能每次测试的时候都去修改源码application.yml中的配置进行测试呢？显然是不行的。每次测试前改过来，每次测试后改回去，这太麻烦了。于是我们就想，需要在测试环境中创建一组临时属性，去覆盖我们源码中设定的属性，这样测试用例就相当于是一个独立的环境，能够独立测试，这样就方便多了。\n临时属性\n​\t\tspringboot已经为我们开发者早就想好了这种问题该如何解决，并且提供了对应的功能入口。在测试用例程序中，可以通过对注解@SpringBootTest添加属性来模拟临时属性，具体如下：\n//properties属性可以为当前测试用例添加临时的属性配置@SpringBootTest(properties = &#123;&quot;test.prop=testValue1&quot;&#125;)public class PropertiesAndArgsTest &#123;    @Value(&quot;$&#123;test.prop&#125;&quot;)    private String msg;        @Test    void testProperties()&#123;        System.out.println(msg);    &#125;&#125;\n\n​\t\t使用注解@SpringBootTest的properties属性就可以为当前测试用例添加临时的属性，覆盖源码配置文件中对应的属性值进行测试。\n临时参数\n​\t\t除了上述这种情况，在前面讲解使用命令行启动springboot程序时讲过，通过命令行参数也可以设置属性值。而且线上启动程序时，通常都会添加一些专用的配置信息。作为运维人员他们才不懂java，更不懂这些配置的信息具体格式该怎么写，那如果我们作为开发者提供了对应的书写内容后，能否提前测试一下这些配置信息是否有效呢？当时是可以的，还是通过注解@SpringBootTest的另一个属性来进行设定。\n//args属性可以为当前测试用例添加临时的命令行参数@SpringBootTest(args=&#123;&quot;--test.prop=testValue2&quot;&#125;)public class PropertiesAndArgsTest &#123;        @Value(&quot;$&#123;test.prop&#125;&quot;)    private String msg;        @Test    void testProperties()&#123;        System.out.println(msg);    &#125;&#125;\n\n​\t\t使用注解@SpringBootTest的args属性就可以为当前测试用例模拟命令行参数并进行测试。\n​\t\t说到这里，好奇宝宝们肯定就有新问题了，如果两者共存呢？其实如果思考一下配置属性与命令行参数的加载优先级，这个结果就不言而喻了。在属性加载的优先级设定中，有明确的优先级设定顺序，还记得下面这个顺序吗？\n\n​\t\t在这个属性加载优先级的顺序中，明确规定了命令行参数的优先级排序是11，而配置属性的优先级是3，结果不言而喻了，args属性配置优先于properties属性配置加载。\n​\t\t到这里我们就掌握了如果在测试用例中去模拟临时属性的设定。\n总结\n加载测试临时属性可以通过注解@SpringBootTest的properties和args属性进行设定，此设定应用范围仅适用于当前测试用例\n\n思考​\t\t应用于测试环境的临时属性解决了，如果想在测试的时候临时加载一些bean能不做呢？也就是说我测试时，想搞一些独立的bean出来，专门应用于测试环境，能否实现呢？\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之加载测试专用配置","url":"/2022/06/19/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%95%E4%B8%93%E7%94%A8%E9%85%8D%E7%BD%AE/","content":"​\t\t学习过Spring的知识，我们都知道，其实一个spring环境中可以设置若干个配置文件或配置类，若干个配置信息可以同时生效。现在我们的需求就是在测试环境中再添加一个配置类，然后启动测试环境时，生效此配置就行了。其实做法和spring环境中加载多个配置信息的方式完全一样。具体操作步骤如下：\n步骤①：在测试包test中创建专用的测试环境配置类\n@Configurationpublic class MsgConfig &#123;    @Bean    public String msg()&#123;        return &quot;bean msg&quot;;    &#125;&#125;\n\n​\t\t上述配置仅用于演示当前实验效果，实际开发可不能这么注入String类型的数据\n步骤②：在启动测试环境时，导入测试环境专用的配置类，使用@Import注解即可实现\n@SpringBootTest@Import(&#123;MsgConfig.class&#125;)public class ConfigurationTest &#123;    @Autowired    private String msg;    @Test    void testConfiguration()&#123;        System.out.println(msg);    &#125;&#125;\n\n​\t\t到这里就通过@Import属性实现了基于开发环境的配置基础上，对配置进行测试环境的追加操作，实现了1+1的配置环境效果。这样我们就可以实现每一个不同的测试用例加载不同的bean的效果，丰富测试用例的编写，同时不影响开发环境的配置。\n总结\n定义测试环境专用的配置类，然后通过@Import注解在具体的测试中导入临时的配置，例如测试用例，方便测试过程，且上述配置不影响其他的测试类环境\n\n思考​\t\t当前我们已经可以实现业务层和数据层的测试，并且通过临时配置，控制每个测试用例加载不同的测试数据。但是实际企业开发不仅要保障业务层与数据层的功能安全有效，也要保障表现层的功能正常。但是我们目的对表现层的测试都是通过postman手工测试的，并没有在打包过程中体现表现层功能被测试通过。能否在测试用例中对表现层进行功能测试呢？\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之宽松绑定/松散绑定","url":"/2022/06/19/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E5%AE%BD%E6%9D%BE%E7%BB%91%E5%AE%9A-%E6%9D%BE%E6%95%A3%E7%BB%91%E5%AE%9A/","content":"​\t\t在进行属性绑定时，可能会遇到如下情况，为了进行标准命名，开发者会将属性名严格按照驼峰命名法书写，在yml配置文件中将datasource修改为dataSource，如下：\ndataSource:  driverClassName: com.mysql.jdbc.Driver\n\n​\t\t此时程序可以正常运行，然后又将代码中的前缀datasource修改为dataSource，如下：\n@Bean@ConfigurationProperties(prefix = &quot;dataSource&quot;)public DruidDataSource datasource()&#123;    DruidDataSource ds = new DruidDataSource();    return ds;&#125;\n\n​\t\t此时就发生了编译错误，而且并不是idea工具导致的，运行后依然会出现问题，配置属性名dataSource是无效的\nConfiguration property name &#x27;dataSource&#x27; is not valid:    Invalid characters: &#x27;S&#x27;    Bean: datasource    Reason: Canonical names should be kebab-case (&#x27;-&#x27; separated), lowercase alpha-numeric characters and must start with a letterAction:Modify &#x27;dataSource&#x27; so that it conforms to the canonical names requirements.\n\n​\t\t为什么会出现这种问题，这就要来说一说springboot进行属性绑定时的一个重要知识点了，有关属性名称的宽松绑定，也可以称为宽松绑定。\n​\t\t什么是宽松绑定？实际上是springboot进行编程时人性化设计的一种体现，即配置文件中的命名格式与变量名的命名格式可以进行格式上的最大化兼容。兼容到什么程度呢？几乎主流的命名格式都支持，例如：\n​\t\t在ServerConfig中的ipAddress属性名\n@Component@Data@ConfigurationProperties(prefix = &quot;servers&quot;)public class ServerConfig &#123;    private String ipAddress;&#125;\n\n​\t\t可以与下面的配置属性名规则全兼容\nservers:  ipAddress: 192.168.0.2       # 驼峰模式  ip_address: 192.168.0.2      # 下划线模式  ip-address: 192.168.0.2      # 烤肉串模式  IP_ADDRESS: 192.168.0.2      # 常量模式\n\n​\t\t也可以说，以上4种模式最终都可以匹配到ipAddress这个属性名。为什么这样呢？原因就是在进行匹配时，配置中的名称要去掉中划线和下划线后，忽略大小写的情况下去与java代码中的属性名进行忽略大小写的等值匹配，以上4种命名去掉下划线中划线忽略大小写后都是一个词ipaddress，java代码中的属性名忽略大小写后也是ipaddress，这样就可以进行等值匹配了，这就是为什么这4种格式都能匹配成功的原因。不过springboot官方推荐使用烤肉串模式，也就是中划线模式。\n​\t\t到这里我们掌握了一个知识点，就是命名的规范问题。再来看开始出现的编程错误信息\nConfiguration property name &#x27;dataSource&#x27; is not valid:    Invalid characters: &#x27;S&#x27;    Bean: datasource    Reason: Canonical names should be kebab-case (&#x27;-&#x27; separated), lowercase alpha-numeric characters and must start with a letterAction:Modify &#x27;dataSource&#x27; so that it conforms to the canonical names requirements.\n\n​\t\t其中Reason描述了报错的原因，规范的名称应该是烤肉串(kebab)模式(case)，即使用-分隔，使用小写字母数字作为标准字符，且必须以字母开头。然后再看我们写的名称dataSource，就不满足上述要求。闹了半天，在书写前缀时，这个词不是随意支持的，必须使用上述标准。编程写了这么久，基本上编程习惯都养成了，到这里又被springboot教育了，没辙，谁让人家东西好用呢，按照人家的要求写吧。\n​\t\t最后说一句，以上规则仅针对springboot中@ConfigurationProperties注解进行属性绑定时有效，对@Value注解进行属性映射无效。\n总结\n@ConfigurationProperties绑定属性时支持属性名宽松绑定，这个宽松体现在属性名的命名规则上\n@Value注解不支持松散绑定规则\n绑定前缀名推荐采用烤肉串命名规则，即使用中划线做分隔符\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之常用计量单位绑定","url":"/2022/06/19/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E5%B8%B8%E7%94%A8%E8%AE%A1%E9%87%8F%E5%8D%95%E4%BD%8D%E7%BB%91%E5%AE%9A/","content":"​\t\t在前面的配置中，我们书写了如下配置值，其中第三项超时时间timeout描述了服务器操作超时时间，当前值是-1表示永不超时。\nservers:  ip-address: 192.168.0.1   port: 2345  timeout: -1\n\n​\t\t但是每个人都这个值的理解会产生不同，比如线上服务器完成一次主从备份，配置超时时间240，这个240如果单位是秒就是超时时间4分钟，如果单位是分钟就是超时时间4小时。面对一次线上服务器的主从备份，设置4分钟，简直是开玩笑，别说拷贝过程，备份之前的压缩过程4分钟也搞不定，这个时候问题就来了，怎么解决这个误会？\n​\t\t除了加强约定之外，springboot充分利用了JDK8中提供的全新的用来表示计量单位的新数据类型，从根本上解决这个问题。以下模型类中添加了两个JDK8中新增的类，分别是Duration和DataSize\n@Component@Data@ConfigurationProperties(prefix = &quot;servers&quot;)public class ServerConfig &#123;    @DurationUnit(ChronoUnit.HOURS)    private Duration serverTimeOut;    @DataSizeUnit(DataUnit.MEGABYTES)    private DataSize dataSize;&#125;\n\nDuration：表示时间间隔，可以通过@DurationUnit注解描述时间单位，例如上例中描述的单位为小时（ChronoUnit.HOURS）\nDataSize：表示存储空间，可以通过@DataSizeUnit注解描述存储空间单位，例如上例中描述的单位为MB（DataUnit.MEGABYTES）\n​\t\t使用上述两个单位就可以有效避免因沟通不同步或文档不健全导致的信息不对称问题，从根本上解决了问题，避免产生误读。\nDruation常用单位如下：\n\nDataSize常用单位如下：\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之手工启动热部署","url":"/2022/06/17/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%89%8B%E5%B7%A5%E5%90%AF%E5%8A%A8%E7%83%AD%E9%83%A8%E7%BD%B2/","content":"什么是热部署？简单说就是你程序改了，现在要重新启动服务器，嫌麻烦？不用重启，服务器会自己悄悄的把更新后的程序给重新加载一遍，这就是热部署。\n​\t\t热部署的功能是如何实现的呢？这就要分两种情况来说了，非springboot工程和springboot工程的热部署实现方式完全不一样。先说一下原始的非springboot项目是如何实现热部署的。\n非springboot项目热部署实现原理​\t\t开发非springboot项目时，我们要制作一个web工程并通过tomcat启动，通常需要先安装tomcat服务器到磁盘中，开发的程序配置发布到安装的tomcat服务器上。如果想实现热部署的效果，这种情况其实有两种做法，一种是在tomcat服务器的配置文件中进行配置，这种做法与你使用什么IDE工具无关，不管你使用eclipse还是idea都行。还有一种做法是通过IDE工具进行配置，比如在idea工具中进行设置，这种形式需要依赖IDE工具，每款IDE工具不同，对应的配置也不太一样。但是核心思想是一样的，就是使用服务器去监控其中加载的应用，发现产生了变化就重新加载一次。\n​\t\t上面所说的非springboot项目实现热部署看上去是一个非常简单的过程，几乎每个小伙伴都能自己写出来。如果你不会写，我给你个最简单的思路，但是实际设计要比这复杂一些。例如启动一个定时任务，任务启动时记录每个文件的大小，以后每5秒比对一下每个文件的大小是否有改变，或者是否有新文件。如果没有改变，放行，如果有改变，刷新当前记录的文件信息，然后重新启动服务器，这就可以实现热部署了。当然，这个过程肯定不能这么做，比如我把一个打印输出的字符串”abc”改成”cba”，比对大小是没有变化的，但是内容缺实变了，所以这么做肯定不行，只是给大家打个比方，而且重启服务器这就是冷启动了，不能算热部署.\nspringboot项目热部署实现原理​\t\t基于springboot开发的web工程其实有一个显著的特征，就是tomcat服务器内置了，还记得内嵌服务器吗？服务器是以一个对象的形式在spring容器中运行的。本来我们期望于tomcat服务器加载程序后由tomcat服务器盯着程序，你变化后我就重新启动重新加载，但是现在tomcat和我们的程序是平级的了，都是spring容器中的组件，这下就麻烦了，缺乏了一个直接的管理权，那该怎么做呢？简单，再搞一个程序X在spring容器中盯着你原始开发的程序A不就行了吗？确实，搞一个盯着程序A的程序X就行了，如果你自己开发的程序A变化了，那么程序X就命令tomcat容器重新加载程序A就OK了。并且这样做有一个好处，spring容器中东西不用全部重新加载一遍，只需要重新加载你开发的程序那一部分就可以了，这下效率又高了，挺好。\n​\t下面就说说，怎么搞出来这么一个程序X，肯定不是我们自己手写了，springboot早就做好了，搞一个坐标导入进去就行了。\n手动启动热部署步骤①：导入开发者工具对应的坐标\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\n\n步骤②：构建项目，可以使用快捷键激活此功能\n\n​\t\t对应的快捷键一定要记得\n&lt;CTRL&gt;+&lt;F9&gt;\n\n​\t\t以上过程就实现了springboot工程的热部署，是不是挺简单的。不过这里需要把底层的工作工程给普及一下。\n重启与重载​\t\t一个springboot项目在运行时实际上是分两个过程进行的，根据加载的东西不同，划分成base类加载器与restart类加载器。\n\nbase类加载器：用来加载jar包中的类，jar包中的类和配置文件由于不会发生变化，因此不管加载多少次，加载的内容不会发生变化\nrestart类加载器：用来加载开发者自己开发的类、配置文件、页面等信息，这一类文件受开发者影响\n\n​\t\t当springboot项目启动时，base类加载器执行，加载jar包中的信息后，restart类加载器执行，加载开发者制作的内容。当执行构建项目后，由于jar中的信息不会变化，因此base类加载器无需再次执行，所以仅仅运行restart类加载即可，也就是将开发者自己制作的内容重新加载就行了，这就完成了一次热部署的过程，也可以说热部署的过程实际上是重新加载restart类加载器中的信息。\n总结\n使用开发者工具可以为当前项目开启热部署功能\n使用构建项目操作对工程进行热部署\n\n思考​\t\t上述过程每次进行热部署都需要开发者手工操作，不管是点击按钮还是快捷键都需要开发者手工执行。这种操作的应用场景主要是在开发调试期，并且调试的代码处于不同的文件中，比如服务器启动了，我需要改4个文件中的内容，然后重启，等4个文件都改完了再执行热部署，使用一个快捷键就OK了。但是如果现在开发者要修改的内容就只有一个文件中的少量代码，这个时候代码修改完毕如果能够让程序自己执行热部署功能，就可以减少开发者的操作，也就是自动进行热部署，能这么做吗\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之手机验证码案例","url":"/2022/06/22/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A1%88%E4%BE%8B/","content":"​\t\t为了便于下面演示各种各样的缓存技术，我们创建一个手机验证码的案例环境，模拟使用缓存保存手机验证码的过程。\n​\t\t手机验证码案例需求如下：\n\n输入手机号获取验证码，组织文档以短信形式发送给用户（页面模拟）\n输入手机号和验证码验证结果\n\n​\t\t为了描述上述操作，我们制作两个表现层接口，一个用来模拟发送短信的过程，其实就是根据用户提供的手机号生成一个验证码，然后放入缓存，另一个用来模拟验证码校验的过程，其实就是使用传入的手机号和验证码进行匹配，并返回最终匹配结果。下面直接制作本案例的模拟代码，先以上例中springboot提供的内置缓存技术来完成当前案例的制作。\n步骤①：导入springboot提供的缓存技术对应的starter\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;\n\n步骤②：启用缓存，在引导类上方标注注解@EnableCaching配置springboot程序中可以使用缓存\n@SpringBootApplication//开启缓存功能@EnableCachingpublic class Springboot19CacheApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Springboot19CacheApplication.class, args);    &#125;&#125;\n\n步骤③：定义验证码对应的实体类，封装手机号与验证码两个属性\n@Datapublic class SMSCode &#123;    private String tele;    private String code;&#125;\n\n步骤④：定义验证码功能的业务层接口与实现类\npublic interface SMSCodeService &#123;    public String sendCodeToSMS(String tele);    public boolean checkCode(SMSCode smsCode);&#125;@Servicepublic class SMSCodeServiceImpl implements SMSCodeService &#123;    @Autowired    private CodeUtils codeUtils;    @CachePut(value = &quot;smsCode&quot;, key = &quot;#tele&quot;)    public String sendCodeToSMS(String tele) &#123;        String code = codeUtils.generator(tele);        return code;    &#125;    public boolean checkCode(SMSCode smsCode) &#123;        //取出内存中的验证码与传递过来的验证码比对，如果相同，返回true        String code = smsCode.getCode();        String cacheCode = codeUtils.get(smsCode.getTele());        return code.equals(cacheCode);    &#125;&#125;\n\n​\t\t获取验证码后，当验证码失效时必须重新获取验证码，因此在获取验证码的功能上不能使用@Cacheable注解，@Cacheable注解是缓存中没有值则放入值，缓存中有值则取值。此处的功能仅仅是生成验证码并放入缓存，并不具有从缓存中取值的功能，因此不能使用@Cacheable注解，应该使用仅具有向缓存中保存数据的功能，使用@CachePut注解即可。\n​\t\t对于校验验证码的功能建议放入工具类中进行。\n步骤⑤：定义验证码的生成策略与根据手机号读取验证码的功能\n@Componentpublic class CodeUtils &#123;    private String [] patch = &#123;&quot;000000&quot;,&quot;00000&quot;,&quot;0000&quot;,&quot;000&quot;,&quot;00&quot;,&quot;0&quot;,&quot;&quot;&#125;;    public String generator(String tele)&#123;        int hash = tele.hashCode();        int encryption = 20206666;        long result = hash ^ encryption;        long nowTime = System.currentTimeMillis();        result = result ^ nowTime;        long code = result % 1000000;        code = code &lt; 0 ? -code : code;        String codeStr = code + &quot;&quot;;        int len = codeStr.length();        return patch[len] + codeStr;    &#125;    @Cacheable(value = &quot;smsCode&quot;,key=&quot;#tele&quot;)    public String get(String tele)&#123;        return null;    &#125;&#125;\n\n步骤⑥：定义验证码功能的web层接口，一个方法用于提供手机号获取验证码，一个方法用于提供手机号和验证码进行校验\n@RestController@RequestMapping(&quot;/sms&quot;)public class SMSCodeController &#123;    @Autowired    private SMSCodeService smsCodeService;        @GetMapping    public String getCode(String tele)&#123;        String code = smsCodeService.sendCodeToSMS(tele);        return code;    &#125;        @PostMapping    public boolean checkCode(SMSCode smsCode)&#123;        return smsCodeService.checkCode(smsCode);    &#125;&#125;\n\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之数据层测试回滚","url":"/2022/06/20/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%B1%82%E6%B5%8B%E8%AF%95%E5%9B%9E%E6%BB%9A/","content":"​\t\t当前我们的测试程序可以完美的进行表现层、业务层、数据层接口对应的功能测试了，但是测试用例开发完成后，在打包的阶段由于test生命周期属于必须被运行的生命周期，如果跳过会给系统带来极高的安全隐患，所以测试用例必须执行。但是新的问题就呈现了，测试用例如果测试时产生了事务提交就会在测试过程中对数据库数据产生影响，进而产生垃圾数据。这个过程不是我们希望发生的，作为开发者测试用例该运行运行，但是过程中产生的数据不要在我的系统中留痕，这样该如何处理呢？\n​\t\tspringboot早就为开发者想到了这个问题，并且针对此问题给出了最简解决方案，在原始测试用例中添加注解@Transactional即可实现当前测试用例的事务不提交。当程序运行后，只要注解@Transactional出现的位置存在注解@SpringBootTest，springboot就会认为这是一个测试程序，无需提交事务，所以也就可以避免事务的提交。\n@SpringBootTest@Transactional@Rollback(true)public class DaoTest &#123;    @Autowired    private BookService bookService;    @Test    void testSave()&#123;        Book book = new Book();        book.setName(&quot;springboot3&quot;);        book.setType(&quot;springboot3&quot;);        book.setDescription(&quot;springboot3&quot;);        bookService.save(book);    &#125;&#125;\n\n​\t\t如果开发者想提交事务，也可以，再添加一个@RollBack的注解，设置回滚状态为false即可正常提交事务，是不是很方便？springboot在辅助开发者日常工作这一块展现出了惊人的能力，实在太贴心了。\n总结\n\n在springboot的测试类中通过添加注解@Transactional来阻止测试用例提交事务\n通过注解@Rollback控制springboot测试类执行结果是否提交事务，需要配合注解@Transactional使用\n\n思考\n​\t\t当前测试程序已经近乎完美了，但是由于测试用例中书写的测试数据属于固定数据，往往失去了测试的意义，开发者可以针对测试用例进行针对性开发，这样就有可能出现测试用例不能完美呈现业务逻辑代码是否真实有效的达成业务目标的现象，解决方案其实很容易想，测试用例的数据只要随机产生就可以了，能实现吗？\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之整合ES客户端操作","url":"/2022/06/22/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88ES%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%93%8D%E4%BD%9C/","content":"​\t\t使用springboot整合ES该如何进行呢？老规矩，导入坐标，做配置，使用API接口操作。整合Redis如此，整合MongoDB如此，整合ES依然如此。太没有新意了，其实不是没有新意，这就是springboot的强大之处，所有东西都做成相同规则，对开发者来说非常友好。\n​\t\t下面就开始springboot整合ES，操作步骤如下：\n步骤①：导入springboot整合ES的starter坐标\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;\n\n步骤②：进行基础配置\nspring:  elasticsearch:    rest:      uris: http://localhost:9200\n\n​\t\t配置ES服务器地址，端口9200\n步骤③：使用springboot整合ES的专用客户端接口ElasticsearchRestTemplate来进行操作\n@SpringBootTestclass Springboot18EsApplicationTests &#123;    @Autowired    private ElasticsearchRestTemplate template;&#125;\n\n​\t\t上述操作形式是ES早期的操作方式，使用的客户端被称为Low Level Client，这种客户端操作方式性能方面略显不足，于是ES开发了全新的客户端操作方式，称为High Level Client。高级别客户端与ES版本同步更新，但是springboot最初整合ES的时候使用的是低级别客户端，所以企业开发需要更换成高级别的客户端模式。\n​\t\t下面使用高级别客户端方式进行springboot整合ES，操作步骤如下：\n步骤①：导入springboot整合ES高级别客户端的坐标，此种形式目前没有对应的starter\n&lt;dependency&gt;    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;&lt;/dependency&gt;\n\n步骤②：使用编程的形式设置连接的ES服务器，并获取客户端对象\n@SpringBootTestclass Springboot18EsApplicationTests &#123;    private RestHighLevelClient client;      @Test      void testCreateClient() throws IOException &#123;          HttpHost host = HttpHost.create(&quot;http://localhost:9200&quot;);          RestClientBuilder builder = RestClient.builder(host);          client = new RestHighLevelClient(builder);            client.close();      &#125;&#125;\n\n​\t\t配置ES服务器地址与端口9200，记得客户端使用完毕需要手工关闭。由于当前客户端是手工维护的，因此不能通过自动装配的形式加载对象。\n步骤③：使用客户端对象操作ES，例如创建索引\n@SpringBootTestclass Springboot18EsApplicationTests &#123;    private RestHighLevelClient client;      @Test      void testCreateIndex() throws IOException &#123;          HttpHost host = HttpHost.create(&quot;http://localhost:9200&quot;);          RestClientBuilder builder = RestClient.builder(host);          client = new RestHighLevelClient(builder);                    CreateIndexRequest request = new CreateIndexRequest(&quot;books&quot;);          client.indices().create(request, RequestOptions.DEFAULT);                     client.close();      &#125;&#125;\n\n​\t\t高级别客户端操作是通过发送请求的方式完成所有操作的，ES针对各种不同的操作，设定了各式各样的请求对象，上例中创建索引的对象是CreateIndexRequest，其他操作也会有自己专用的Request对象。\n​\t\t当前操作我们发现，无论进行ES何种操作，第一步永远是获取RestHighLevelClient对象，最后一步永远是关闭该对象的连接。在测试中可以使用测试类的特性去帮助开发者一次性的完成上述操作，但是在业务书写时，还需要自行管理。将上述代码格式转换成使用测试类的初始化方法和销毁方法进行客户端对象的维护。\n@SpringBootTestclass Springboot18EsApplicationTests &#123;    @BeforeEach\t\t//在测试类中每个操作运行前运行的方法    void setUp() &#123;        HttpHost host = HttpHost.create(&quot;http://localhost:9200&quot;);        RestClientBuilder builder = RestClient.builder(host);        client = new RestHighLevelClient(builder);    &#125;    @AfterEach\t\t//在测试类中每个操作运行后运行的方法    void tearDown() throws IOException &#123;        client.close();    &#125;    private RestHighLevelClient client;    @Test    void testCreateIndex() throws IOException &#123;        CreateIndexRequest request = new CreateIndexRequest(&quot;books&quot;);        client.indices().create(request, RequestOptions.DEFAULT);    &#125;&#125;\n\n​\t\t现在的书写简化了很多，也更合理。下面使用上述模式将所有的ES操作执行一遍，测试结果\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之整合Ehcache缓存","url":"/2022/06/22/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88Ehcache%E7%BC%93%E5%AD%98/","content":"Ehcache是一种缓存技术，使用springboot整合Ehcache其实就是变更一下缓存技术的实现方式，话不多说，直接开整\n步骤①：导入Ehcache的坐标\n&lt;dependency&gt;    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;&lt;/dependency&gt;\n\n​\t\t此处为什么不是导入Ehcache的starter，而是导入技术坐标呢？其实springboot整合缓存技术做的是通用格式，不管你整合哪种缓存技术，只是实现变化了，操作方式一样。这也体现出springboot技术的优点，统一同类技术的整合方式。\n步骤②：配置缓存技术实现使用Ehcache\nspring:  cache:    type: ehcache    ehcache:      config: ehcache.xml\n\n​\t\t配置缓存的类型type为ehcache，此处需要说明一下，当前springboot可以整合的缓存技术中包含有ehcach，所以可以这样书写。其实这个type不可以随便写的，不是随便写一个名称就可以整合的。\n​\t\t由于ehcache的配置有独立的配置文件格式，因此还需要指定ehcache的配置文件，以便于读取相应配置\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;         updateCheck=&quot;false&quot;&gt;    &lt;diskStore path=&quot;D:\\ehcache&quot; /&gt;    &lt;!--默认缓存策略 --&gt;    &lt;!-- external：是否永久存在，设置为true则不会被清除，此时与timeout冲突，通常设置为false--&gt;    &lt;!-- diskPersistent：是否启用磁盘持久化--&gt;    &lt;!-- maxElementsInMemory：最大缓存数量--&gt;    &lt;!-- overflowToDisk：超过最大缓存数量是否持久化到磁盘--&gt;    &lt;!-- timeToIdleSeconds：最大不活动间隔，设置过长缓存容易溢出，设置过短无效果，可用于记录时效性数据，例如验证码--&gt;    &lt;!-- timeToLiveSeconds：最大存活时间--&gt;    &lt;!-- memoryStoreEvictionPolicy：缓存清除策略--&gt;    &lt;defaultCache        eternal=&quot;false&quot;        diskPersistent=&quot;false&quot;        maxElementsInMemory=&quot;1000&quot;        overflowToDisk=&quot;false&quot;        timeToIdleSeconds=&quot;60&quot;        timeToLiveSeconds=&quot;60&quot;        memoryStoreEvictionPolicy=&quot;LRU&quot; /&gt;    &lt;cache        name=&quot;smsCode&quot;        eternal=&quot;false&quot;        diskPersistent=&quot;false&quot;        maxElementsInMemory=&quot;1000&quot;        overflowToDisk=&quot;false&quot;        timeToIdleSeconds=&quot;10&quot;        timeToLiveSeconds=&quot;10&quot;        memoryStoreEvictionPolicy=&quot;LRU&quot; /&gt;&lt;/ehcache&gt;\n\n​\t\t注意前面的案例中，设置了数据保存的位置是smsCode\n@CachePut(value = &quot;smsCode&quot;, key = &quot;#tele&quot;)public String sendCodeToSMS(String tele) &#123;    String code = codeUtils.generator(tele);    return code;&#125;\t\n\n​\t\t这个设定需要保障ehcache中有一个缓存空间名称叫做smsCode的配置，前后要统一。在企业开发过程中，通过设置不同名称的cache来设定不同的缓存策略，应用于不同的缓存数据。\n​\t\t到这里springboot整合Ehcache就做完了，可以发现一点，原始代码没有任何修改，仅仅是加了一组配置就可以变更缓存供应商了，这也是springboot提供了统一的缓存操作接口的优势，变更实现并不影响原始代码的书写。\n总结\nspringboot使用Ehcache作为缓存实现需要导入Ehcache的坐标\n修改设置，配置缓存供应商为ehcache，并提供对应的缓存配置文件\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之整合Mongodb","url":"/2022/06/21/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88Mongodb/","content":"​\t\t使用springboot整合MongDB该如何进行呢？其实springboot为什么使用的开发者这么多，就是因为他的套路几乎完全一样。导入坐标，做配置，使用API接口操作。整合Redis如此，整合MongoDB同样如此。\n​\t\t第一，先导入对应技术的整合starter坐标\n​\t\t第二，配置必要信息\n​\t\t第三，使用提供的API操作即可\n​\t\t下面就开始springboot整合MongoDB，操作步骤如下：\n步骤①：导入springboot整合MongoDB的starter坐标\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt;\n\n​\t\t上述坐标也可以在创建模块的时候通过勾选的形式进行选择，同样归属NoSQL分类中\n\n步骤②：进行基础配置\nspring:  data:    mongodb:      uri: mongodb://localhost/itheima\n\n​\t\t操作MongoDB需要的配置与操作redis一样，最基本的信息都是操作哪一台服务器，区别就是连接的服务器IP地址和端口不同，书写格式不同而已。\n步骤③：使用springboot整合MongoDB的专用客户端接口MongoTemplate来进行操作\n@SpringBootTestclass Springboot17MongodbApplicationTests &#123;    @Autowired    private MongoTemplate mongoTemplate;    @Test    void contextLoads() &#123;        Book book = new Book();        book.setId(2);        book.setName(&quot;springboot2&quot;);        book.setType(&quot;springboot2&quot;);        book.setDescription(&quot;springboot2&quot;);        mongoTemplate.save(book);    &#125;    @Test    void find()&#123;        List&lt;Book&gt; all = mongoTemplate.findAll(Book.class);        System.out.println(all);    &#125;&#125;\n\n​\t\t整合工作到这里就做完了，感觉既熟悉也陌生。熟悉的是这个套路，三板斧，就这三招，导坐标做配置用API操作，陌生的是这个技术，里面具体的操作API可能会不熟悉。\n总结\nspringboot整合MongoDB步骤\n导入springboot整合MongoDB的starter坐标\n进行基础配置\n使用springboot整合MongoDB的专用客户端接口MongoTemplate操作\n\n\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之测试用例设置随机数据","url":"/2022/06/20/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E7%BD%AE%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE/","content":"​\t\t对于测试用例的数据固定书写肯定是不合理的，springboot提供了在配置中使用随机值的机制，确保每次运行程序加载的数据都是随机的。具体如下：\ntestcase:  book:    id: $&#123;random.int&#125;    id2: $&#123;random.int(10)&#125;    type: $&#123;random.int!5,10!&#125;    name: $&#123;random.value&#125;    uuid: $&#123;random.uuid&#125;    publishTime: $&#123;random.long&#125;\n\n​\t\t当前配置就可以在每次运行程序时创建一组随机数据，避免每次运行时数据都是固定值的尴尬现象发生，有助于测试功能的进行。数据的加载按照之前加载数据的形式，使用@ConfigurationProperties注解即可\n@Component@Data@ConfigurationProperties(prefix = &quot;testcase.book&quot;)public class BookCase &#123;    private int id;    private int id2;    private int type;    private String name;    private String uuid;    private long publishTime;&#125;\n\n​\t\t对于随机值的产生，还有一些小的限定规则，比如产生的数值性数据可以设置范围等，具体如下：\n\n\n${random.int}表示随机整数\n${random.int(10)}表示10以内的随机数\n${random.int(10,20)}表示10到20的随机数\n其中()可以是任意字符，例如[]，!!均可\n\n总结\n使用随机数据可以替换测试用例中书写的固定数据，提高测试用例中的测试数据有效性\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之测试类中启动web环境","url":"/2022/06/19/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%B5%8B%E8%AF%95%E7%B1%BB%E4%B8%AD%E5%90%AF%E5%8A%A8web%E7%8E%AF%E5%A2%83/","content":"​\t\t在测试中对表现层功能进行测试需要一个基础和一个功能。所谓的一个基础是运行测试程序时，必须启动web环境，不然没法测试web功能。一个功能是必须在测试程序中具备发送web请求的能力，不然无法实现web功能的测试。所以在测试用例中测试表现层接口这项工作就转换成了两件事，一，如何在测试类中启动web测试，二，如何在测试类中发送web请求。下面一件事一件事进行，先说第一个\n测试类中启动web环境\n​\t\t每一个springboot的测试类上方都会标准@SpringBootTest注解，而注解带有一个属性，叫做webEnvironment。通过该属性就可以设置在测试用例中启动web环境，具体如下：\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class WebTest &#123;\t&#125;\n\n​\t\t测试类中启动web环境时，可以指定启动的Web环境对应的端口，springboot提供了4种设置值，分别如下：\n\n\nMOCK：根据当前设置确认是否启动web环境，例如使用了Servlet的API就启动web环境，属于适配性的配置\nDEFINED_PORT：使用自定义的端口作为web服务器端口\nRANDOM_PORT：使用随机端口作为web服务器端口\nNONE：不启动web环境\n\n​\t\t通过上述配置，现在启动测试程序时就可以正常启用web环境了，建议大家测试时使用RANDOM_PORT，避免代码中因为写死设定引发线上功能打包测试时由于端口冲突导致意外现象的出现。就是说你程序中写了用8080端口，结果线上环境8080端口被占用了，结果你代码中所有写的东西都要改，这就是写死代码的代价。现在你用随机端口就可以测试出来你有没有这种问题的隐患了。\n​\t\t测试环境中的web环境已经搭建好了，下面就可以来解决第二个问题了，如何在程序代码中发送web请求。\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之热部署范围配置","url":"/2022/06/18/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E7%83%AD%E9%83%A8%E7%BD%B2%E8%8C%83%E5%9B%B4%E9%85%8D%E7%BD%AE/","content":"​\t\t通过修改项目中的文件，你可以发现其实并不是所有的文件修改都会激活热部署的，原因在于在开发者工具中有一组配置，当满足了配置中的条件后，才会启动热部署，配置中默认不参与热部署的目录信息如下\n\n&#x2F;META-INF&#x2F;maven\n&#x2F;META-INF&#x2F;resources\n&#x2F;resources\n&#x2F;static\n&#x2F;public\n&#x2F;templates\n\n​\t\t以上目录中的文件如果发生变化，是不参与热部署的。如果想修改配置，可以通过application.yml文件进行设定哪些文件不参与热部署操作\nspring:  devtools:    restart:      # 设置不参与热部署的文件或文件夹      exclude: static/**,public/**,config/application.yml\n\n总结\n\n通过配置可以修改不参与热部署的文件或目录\n\n思考\n​\t\t热部署功能是一个典型的开发阶段使用的功能，到了线上环境运行程序时，这个功能就没有意义了。能否关闭热部署功能呢？\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之第三方bean属性绑定","url":"/2022/06/18/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%96%B9bean%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A/","content":"@ConfigurationProperties​\t\t在基础篇学习了@ConfigurationProperties注解，此注解的作用是用来为bean绑定属性的。开发者可以在yml配置文件中以对象的格式添加若干属性\nservers:  ip-address: 192.168.0.1   port: 2345  timeout: -1\n\n​\t\t然后再开发一个用来封装数据的实体类，注意要提供属性对应的setter方法\n@Component@Datapublic class ServerConfig &#123;    private String ipAddress;    private int port;    private long timeout;&#125;\n\n​\t\t使用@ConfigurationProperties注解就可以将配置中的属性值关联到开发的模型类上\n@Component@Data@ConfigurationProperties(prefix = &quot;servers&quot;)public class ServerConfig &#123;    private String ipAddress;    private int port;    private long timeout;&#125;\n\n​\t\t这样加载对应bean的时候就可以直接加载配置属性值了。但是目前我们学的都是给自定义的bean使用这种形式加载属性值，如果是第三方的bean呢？能不能用这种形式加载属性值呢？为什么会提出这个疑问？原因就在于当前@ConfigurationProperties注解是写在类定义的上方，而第三方开发的bean源代码不是你自己书写的，你也不可能到源代码中去添加@ConfigurationProperties注解，这种问题该怎么解决呢？下面就来说说这个问题。\n​\t\t使用@ConfigurationProperties注解其实可以为第三方bean加载属性，格式特殊一点而已。\n步骤①：使用@Bean注解定义第三方bean\n@Beanpublic DruidDataSource datasource()&#123;    DruidDataSource ds = new DruidDataSource();    return ds;&#125;\n\n步骤②：在yml中定义要绑定的属性，注意datasource此时全小写\ndatasource:  driverClassName: com.mysql.jdbc.Driver\n\n步骤③：使用@ConfigurationProperties注解为第三方bean进行属性绑定，注意前缀是全小写的datasource\n@Bean@ConfigurationProperties(prefix = &quot;datasource&quot;)public DruidDataSource datasource()&#123;    DruidDataSource ds = new DruidDataSource();    return ds;&#125;\n\n​\t\t操作方式完全一样，只不过**@ConfigurationProperties注解不仅能添加到类上，还可以添加到方法上**，添加到类上是为spring容器管理的当前类的对象绑定属性，添加到方法上是为spring容器管理的当前方法的返回值对象绑定属性，其实本质上都一样。\n​\t\t做到这其实就出现了一个新的问题，目前我们定义bean不是通过类注解定义就是通过@Bean定义，使用@ConfigurationProperties注解可以为bean进行属性绑定，那在一个业务系统中，哪些bean通过注解@ConfigurationProperties去绑定属性了呢？因为这个注解不仅可以写在类上，还可以写在方法上，所以找起来就比较麻烦了。为了解决这个问题，spring给我们提供了一个全新的注解，专门标注使用@ConfigurationProperties注解绑定属性的bean是哪些。这个注解叫做@EnableConfigurationProperties。具体如何使用呢？\n步骤①：在配置类上开启@EnableConfigurationProperties注解，并标注要使用@ConfigurationProperties注解绑定属性的类\n@SpringBootApplication@EnableConfigurationProperties(ServerConfig.class)public class Springboot13ConfigurationApplication &#123;&#125;\n\n步骤②：在对应的类上直接使用@ConfigurationProperties进行属性绑定\n@Data@ConfigurationProperties(prefix = &quot;servers&quot;)public class ServerConfig &#123;    private String ipAddress;    private int port;    private long timeout;&#125;\n\n​\t\t有人感觉这没区别啊？注意观察，现在绑定属性的ServerConfig类并没有声明@Component注解。当使用@EnableConfigurationProperties注解时，spring会默认将其标注的类定义为bean，因此无需再次声明@Component注解了。\n​\t\t最后再说一个小技巧，使用@ConfigurationProperties注解时，会出现一个提示信息\n\n​\t\t出现这个提示后只需要添加一个坐标此提醒就消失了\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;&lt;/dependency&gt;\n\n总结\n使用@ConfigurationProperties可以为使用@Bean声明的第三方bean绑定属性\n当使用@EnableConfigurationProperties声明进行属性绑定的bean后，无需使用@Component注解再次进行bean声明\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之缓存的作用","url":"/2022/06/22/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%9C%E7%94%A8/","content":"​\t\t企业级应用主要作用是信息处理，当需要读取数据时，由于受限于数据库的访问效率，导致整体系统性能偏低。\n\n​\t \t应用程序直接与数据库打交道，访问效率低\n​\t\t为了改善上述现象，开发者通常会在应用程序与数据库之间建立一种临时的数据存储机制，该区域中的数据在内存中保存，读写速度较快，可以有效解决数据库访问效率低下的问题。这一块临时存储数据的区域就是缓存。\n\n​\t\t缓存是什么？缓存是一种介于数据永久存储介质与应用程序之间的数据临时存储介质，使用缓存可以有效的减少低速数据读取过程的次数（例如磁盘IO），提高系统性能。此外缓存不仅可以用于提高永久性存储介质的数据读取效率，还可以提供临时的数据存储空间。\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之自动启动热部署","url":"/2022/06/17/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%E7%83%AD%E9%83%A8%E7%BD%B2/","content":"​\t自动热部署其实就是设计一个开关，打开这个开关后，IDE工具就可以自动热部署。因此这个操作和IDE工具有关，以下以idea为例设置idea中启动热部署\n步骤①：设置自动构建项目\n​\t\t打开【File】，选择【settings…】,在面板左侧的菜单中找到【Compile】选项，然后勾选【Build project automatically】，意思是自动构建项目\n\n​\t自动构建项目选项勾选后\n步骤②：允许在程序运行时进行自动构建\n​\t\t\n​\t\t这样程序在运行的时候就可以进行自动构建了，实现了热部署的效果。\n关注：如果你每敲一个字母，服务器就重新构建一次，这未免有点太频繁了，所以idea设置当idea工具失去焦点5秒后进行热部署。其实就是你从idea工具中切换到其他工具时进行热部署，比如改完程序需要到浏览器上去调试，这个时候idea就自动进行热部署操作。\n总结\n自动热部署要开启自动构建项目\n自动热部署要开启在程序运行时自动构建项目\n\n思考​\t\t现在已经实现了热部署了，但是到企业开发的时候你会发现，为了便于管理，在你的程序目录中除了有代码，还有可能有文档，如果你修改了一下文档，这个时候会进行热部署吗？不管是否进行热部署，这个过程我们需要自己控制才比较合理，那这个东西能控制吗？\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之进制数据转换规则","url":"/2022/06/19/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99/","content":"​\t\t先把问题描述一下，这位开发者连接数据库正常操作，但是运行程序后显示的信息是密码错误。\njava.sql.SQLException: Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: YES)\n\n​\t\t其实看到这个报错，几乎所有的学习者都能分辨出来，这是用户名和密码不匹配，就就是密码输入错了，但是问题就在于密码并没有输入错误，这就比较讨厌了。给的报错信息无法帮助你有效的分析问题，甚至会给你带到沟里。如果是初学者，估计这会心态就崩了，我密码没错啊，你怎么能说我有错误呢？来看看用户名密码的配置是如何写的：\nspring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    username: root    password: 0127\n\n​\t\t这名开发者的生日是1月27日，所以密码就使用了0127，其实问题就出在这里了。\n​\t\t之前在基础篇讲属性注入时，提到过类型相关的知识，在整数相关知识中有这么一句话，支持二进制，八进制，十六进制\n\n​\t\t这个问题就处在这里了，因为0127在开发者眼中是一个字符串“0127”，但是在springboot看来，这就是一个数字，而且是一个八进制的数字。当后台使用String类型接收数据时，如果配置文件中配置了一个整数值，他是先安装整数进行处理，读取后再转换成字符串。巧了，0127撞上了八进制的格式，所以最终以十进制数字87的结果存在了。\n​\t\t这里提两个注意点，第一，字符串标准书写加上引号包裹，养成习惯，第二，遇到0开头的数据多注意吧。\n总结\nyaml文件中对于数字的定义支持进制书写格式，如需使用字符串请使用引号明确标注\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发原理篇之SpringBoot程序启动流程解析","url":"/2022/06/27/SpringBoot%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8BSpringBoot%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/","content":"对于springboot技术来说，它用于加速spring程序的开发，核心本质还是spring程序的运行，所以于其说是springboot程序的启动流程，不如说是springboot对spring程序的启动流程做了哪些更改。\n​\t\t其实不管是springboot程序还是spring程序，启动过程本质上都是在做容器的初始化，并将对应的bean初始化出来放入容器。在spring环境中，每个bean的初始化都要开发者自己添加设置，但是切换成springboot程序后，自动配置功能的添加帮助开发者提前预设了很多bean的初始化过程，加上各种各样的参数设置，使得整体初始化过程显得略微复杂，但是核心本质还是在做一件事，初始化容器。作为开发者只要搞清楚springboot提供了哪些参数设置的环节，同时初始化容器的过程中都做了哪些事情就行了。\n​\t\tspringboot初始化的参数根据参数的提供方，划分成如下3个大类，每个大类的参数又被封装了各种各样的对象，具体如下：\n\n环境属性（Environment）\n系统配置（spring.factories）\n参数（Arguments、application.properties）\n\n​\t\t以下通过代码流向介绍了springboot程序启动时每一环节做的具体事情。\nSpringboot30StartupApplication【10】-&gt;SpringApplication.run(Springboot30StartupApplication.class, args);    SpringApplication【1332】-&gt;return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);        SpringApplication【1343】-&gt;return new SpringApplication(primarySources).run(args);            SpringApplication【1343】-&gt;SpringApplication(primarySources)            # 加载各种配置信息，初始化各种配置对象                SpringApplication【266】-&gt;this(null, primarySources);                    SpringApplication【280】-&gt;public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)                        SpringApplication【281】-&gt;this.resourceLoader = resourceLoader;                        # 初始化资源加载器                        SpringApplication【283】-&gt;this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));                        # 初始化配置类的类名信息（格式转换）                        SpringApplication【284】-&gt;this.webApplicationType = WebApplicationType.deduceFromClasspath();                        # 确认当前容器加载的类型                        SpringApplication【285】-&gt;this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();                        # 获取系统配置引导信息                        SpringApplication【286】-&gt;setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));                        # 获取ApplicationContextInitializer.class对应的实例                        SpringApplication【287】-&gt;setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));                        # 初始化监听器，对初始化过程及运行过程进行干预                        SpringApplication【288】-&gt;this.mainApplicationClass = deduceMainApplicationClass();                        # 初始化了引导类类名信息，备用            SpringApplication【1343】-&gt;new SpringApplication(primarySources).run(args)            # 初始化容器，得到ApplicationContext对象                SpringApplication【323】-&gt;StopWatch stopWatch = new StopWatch();                # 设置计时器                SpringApplication【324】-&gt;stopWatch.start();                # 计时开始                SpringApplication【325】-&gt;DefaultBootstrapContext bootstrapContext = createBootstrapContext();                # 系统引导信息对应的上下文对象                SpringApplication【327】-&gt;configureHeadlessProperty();                # 模拟输入输出信号，避免出现因缺少外设导致的信号传输失败，进而引发错误（模拟显示器，键盘，鼠标...）                    java.awt.headless=true                SpringApplication【328】-&gt;SpringApplicationRunListeners listeners = getRunListeners(args);                # 获取当前注册的所有监听器                SpringApplication【329】-&gt;listeners.starting(bootstrapContext, this.mainApplicationClass);                # 监听器执行了对应的操作步骤                SpringApplication【331】-&gt;ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);                # 获取参数                SpringApplication【333】-&gt;ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);                # 将前期读取的数据加载成了一个环境对象，用来描述信息                SpringApplication【333】-&gt;configureIgnoreBeanInfo(environment);                # 做了一个配置，备用                SpringApplication【334】-&gt;Banner printedBanner = printBanner(environment);                # 初始化logo                SpringApplication【335】-&gt;context = createApplicationContext();                # 创建容器对象，根据前期配置的容器类型进行判定并创建                SpringApplication【363】-&gt;context.setApplicationStartup(this.applicationStartup);                # 设置启动模式                SpringApplication【337】-&gt;prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);                # 对容器进行设置，参数来源于前期的设定                SpringApplication【338】-&gt;refreshContext(context);                # 刷新容器环境                SpringApplication【339】-&gt;afterRefresh(context, applicationArguments);                # 刷新完毕后做后处理                SpringApplication【340】-&gt;stopWatch.stop();                # 计时结束                SpringApplication【341】-&gt;if (this.logStartupInfo) &#123;                # 判定是否记录启动时间的日志                SpringApplication【342】-&gt;    new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);                # 创建日志对应的对象，输出日志信息，包含启动时间                SpringApplication【344】-&gt;listeners.started(context);                # 监听器执行了对应的操作步骤                SpringApplication【345】-&gt;callRunners(context, applicationArguments);                # 调用运行器                SpringApplication【353】-&gt;listeners.running(context);                # 监听器执行了对应的操作步骤\n\n​\t\t上述过程描述了springboot程序启动过程中做的所有的事情，如果想干预springboot的启动过程，比如自定义一个数据库环境检测的程序，该如何将这个过程加入springboot的启动流程呢？\n​\t\t遇到这样的问题，大部分技术是这样设计的，设计若干个标准接口，对应程序中的所有标准过程。当你想干预某个过程时，实现接口就行了。例如spring技术中bean的生命周期管理就是采用标准接口进行的。\npublic class Abc implements InitializingBean, DisposableBean &#123;    public void destroy() throws Exception &#123;        //销毁操作    &#125;    public void afterPropertiesSet() throws Exception &#123;        //初始化操作    &#125;&#125;\n\n​\t\tspringboot启动过程由于存在着大量的过程阶段，如果设计接口就要设计十余个标准接口，这样对开发者不友好，同时整体过程管理分散，十余个过程各自为政，管理难度大，过程过于松散。那springboot如何解决这个问题呢？它采用了一种最原始的设计模式来解决这个问题，这就是监听器模式，使用监听器来解决这个问题。\n​\t\tspringboot将自身的启动过程比喻成一个大的事件，该事件是由若干个小的事件组成的。例如：\n\norg.springframework.boot.context.event.ApplicationStartingEvent\n应用启动事件，在应用运行但未进行任何处理时，将发送 ApplicationStartingEvent\n\n\norg.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent\n环境准备事件，当Environment被使用，且上下文创建之前，将发送 ApplicationEnvironmentPreparedEvent\n\n\norg.springframework.boot.context.event.ApplicationContextInitializedEvent\n上下文初始化事件\n\n\norg.springframework.boot.context.event.ApplicationPreparedEvent\n应用准备事件，在开始刷新之前，bean定义被加载之后发送 ApplicationPreparedEvent\n\n\norg.springframework.context.event.ContextRefreshedEvent\n上下文刷新事件\n\n\norg.springframework.boot.context.event.ApplicationStartedEvent\n应用启动完成事件，在上下文刷新之后且所有的应用和命令行运行器被调用之前发送 ApplicationStartedEvent\n\n\norg.springframework.boot.context.event.ApplicationReadyEvent\n应用准备就绪事件，在应用程序和命令行运行器被调用之后，将发出 ApplicationReadyEvent，用于通知应用已经准备处理请求\n\n\norg.springframework.context.event.ContextClosedEvent（上下文关闭事件，对应容器关闭）\n\n​\t\t上述列出的仅仅是部分事件，当应用启动后走到某一个过程点时，监听器监听到某个事件触发，就会执行对应的事件。除了系统内置的事件处理，用户还可以根据需要自定义开发当前事件触发时要做的其他动作。\n//设定监听器，在应用启动开始事件时进行功能追加public class MyListener implements ApplicationListener&lt;ApplicationStartingEvent&gt; &#123;    public void onApplicationEvent(ApplicationStartingEvent event) &#123;\t\t//自定义事件处理逻辑    &#125;&#125;\n\n​\t\t按照上述方案处理，用户就可以干预springboot启动过程的所有工作节点，设置自己的业务系统中独有的功能点。\n总结\n\nspringboot启动流程是先初始化容器需要的各种配置，并加载成各种对象，初始化容器时读取这些对象，创建容器\n整体流程采用事件监听的机制进行过程控制，开发者可以根据需要自行扩展，添加对应的监听器绑定具体事件，就可以在事件触发位置执行开发者的业务代码\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发原理篇之自动配置工作流程","url":"/2022/06/25/SpringBoot%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/","content":"​\t\t自动配置是springboot技术非常好用的核心因素，前面学习了这么多种技术的整合，每一个都离不开自动配置。不过在学习自动配置的时候，需要你对spring容器如何进行bean管理的过程非常熟悉才行，所以这里需要先复习一下有关spring技术中bean加载相关的知识。\n\n1、bean的加载方式​\t\t关于bean的加载方式，spring提供了各种各样的形式。因为spring管理bean整体上来说就是由spring维护对象的生命周期，所以bean的加载可以从大的方面划分成2种形式。已知类并交给spring管理，和已知类名并交给spring管理。有什么区别？一个给.class，一个给类名字符串。内部其实都一样，都是通过spring的BeanDefinition对象初始化spring的bean。\n方式一：配置文件+&lt;bean/&gt;标签​\t\t最初级的bean的加载方式其实可以直击spring管控bean的核心思想，就是提供类名，然后spring就可以管理了。所以第一种方式就是给出bean的类名，至于内部嘛就是反射机制加载成class，然后，就没有然后了，拿到了class你就可以搞定一切了。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--xml方式声明自己开发的bean--&gt;    &lt;bean id=&quot;cat&quot; class=&quot;Cat&quot;/&gt;    &lt;bean class=&quot;Dog&quot;/&gt;    &lt;!--xml方式声明第三方开发的bean--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;/&gt;    &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;/&gt;    &lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;/&gt;&lt;/beans&gt;\n\n方式二：配置文件扫描+注解定义bean​\t\t由于方式一种需要将spring管控的bean全部写在xml文件中，对于程序员来说非常不友好，所以就有了第二种方式。哪一个类要受到spring管控加载成bean，就在这个类的上面加一个注解，还可以顺带起一个bean的名字（id）。这里可以使用的注解有@Component以及三个衍生注解@Service、@Controller、@Repository。\n@Component(&quot;tom&quot;)public class Cat &#123;&#125;\n\n@Servicepublic class Mouse &#123;&#125;\n\n​\t\t当然，由于我们无法在第三方提供的技术源代码中去添加上述4个注解，因此当你需要加载第三方开发的bean的时候可以使用下列方式定义注解式的bean。@Bean定义在一个方法上方，当前方法的返回值就可以交给spring管控，记得这个方法所在的类一定要定义在@Component修饰的类中。\n@Componentpublic class DbConfig &#123;    @Bean    public DruidDataSource dataSource()&#123;        DruidDataSource ds = new DruidDataSource();        return ds;    &#125;&#125;\n\n​\t\t上面提供的仅仅是bean的声明，spring并没有感知到这些东西，像极了上课积极回答问题的你，手举的非常高，可惜老师都没有往你的方向看上一眼。想让spring感知到这些积极的小伙伴，必须设置spring去检查这些类，看他们是否贴标签，想当积极分子。可以通过下列xml配置设置spring去检查哪些包，发现定了对应注解，就将对应的类纳入spring管控范围，声明成bean。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd    &quot;&gt;    &lt;!--指定扫描加载bean的位置--&gt;    &lt;context:component-scan base-package=&quot;com.fang.bean,com.fang.config&quot;/&gt;&lt;/beans&gt;\n\n​\t\t方式二声明bean的方式是目前企业中较为常见的bean的声明方式，但是也有缺点。方式一中，通过一个配置文件，你可以查阅当前spring环境中定义了多少个或者说多少种bean，但是方式二没有任何一个地方可以查阅整体信息，只有当程序运行起来才能感知到加载了多少个bean。\n方式三：注解方式声明配置类​\t\t方式二已经完美的简化了bean的声明，以后再也不用写茫茫多的配置信息了。仔细观察xml配置文件，会发现这个文件中只剩了扫描包这句话，于是就有人提出，使用java类替换掉这种固定格式的配置，所以下面这种格式就出现了。严格意义上讲不能算全新的方式，但是由于此种开发形式是企业级开发中的主流形式，所以单独独立出来做成一种方式。\n​\t\t定义一个类并使用@ComponentScan替代原始xml配置中的包扫描这个动作，其实功能基本相同。\n@ComponentScan(&#123;&quot;com.fang.bean&quot;,&quot;com.fang.config&quot;&#125;)public class SpringConfig3 &#123;    @Bean    public DogFactoryBean dog()&#123;        return new DogFactoryBean();    &#125;&#125;\n\n使用FactroyBean接口​\t\t补充一个小知识，spring提供了一个接口FactoryBean，也可以用于声明bean，只不过实现了FactoryBean接口的类造出来的对象不是当前类的对象，而是FactoryBean接口泛型指定类型的对象。如下列，造出来的bean并不是DogFactoryBean，而是Dog。有什么用呢？可以在对象初始化前做一些事情，下例中的注释位置就是让你自己去扩展要做的其他事情的。\npublic class DogFactoryBean implements FactoryBean&lt;Dog&gt; &#123;    @Override    public Dog getObject() throws Exception &#123;        Dog d = new Dog();        //.........        return d;    &#125;    @Override    public Class&lt;?&gt; getObjectType() &#123;        return Dog.class;    &#125;    @Override    public boolean isSingleton() &#123;        return true;    &#125;&#125;\n\n​\t\t有人说，注释中的代码写入Dog的构造方法不就行了吗？干嘛这么费劲转一圈，还写个类，还要实现接口，多麻烦啊。还真不一样，你可以理解为Dog是一个抽象后剥离的特别干净的模型，但是实际使用的时候必须进行一系列的初始化动作。只不过根据情况不同，初始化动作不同而已。如果写入Dog，或许初始化动作A当前并不能满足你的需要，这个时候你就要做一个DogB的方案了。然后，就没有然后了，你就要做两个Dog类。当时使用FactoryBean接口就可以完美解决这个问题。\n​\t\t通常实现了FactoryBean接口的类使用@Bean的形式进行加载，当然你也可以使用@Component去声明DogFactoryBean，只要被扫描加载到即可，但是这种格式加载总觉得怪怪的，指向性不是很明确。\n@ComponentScan(&#123;&quot;com.fang.bean&quot;,&quot;com.fang.config&quot;&#125;)public class SpringConfig3 &#123;    @Bean    public DogFactoryBean dog()&#123;        return new DogFactoryBean();    &#125;&#125;\n\n注解格式导入XML格式配置的bean​\t再补充一个小知识，由于早起开发的系统大部分都是采用xml的形式配置bean，现在的企业级开发基本上不用这种模式了。但是如果你特别幸运，需要基于之前的系统进行二次开发，这就尴尬了。新开发的用注解格式，之前开发的是xml格式。这个时候可不是让你选择用哪种模式的，而是两种要同时使用。spring提供了一个注解可以解决这个问题，@ImportResource，在配置类上直接写上要被融合的xml配置文件名即可，算的上一种兼容性解决方案，没啥实际意义。\n@Configuration@ImportResource(&quot;applicationContext1.xml&quot;)public class SpringConfig32 &#123;&#125;\n\nproxyBeanMethods属性​\t\t前面的例子中用到了@Configuration这个注解，当我们使用AnnotationConfigApplicationContext加载配置类的时候，配置类可以不添加这个注解。但是这个注解有一个更加强大的功能，它可以保障配置类中使用方法创建的bean的唯一性。为@Configuration注解设置proxyBeanMethods属性值为true即可，由于此属性默认值为true，所以很少看见明确书写的，除非想放弃此功能。\n@Configuration(proxyBeanMethods = true)public class SpringConfig33 &#123;    @Bean    public Cat cat()&#123;        return new Cat();    &#125;&#125;\n\n​\t\t下面通过容器再调用上面的cat方法时，得到的就是同一个对象了。注意，必须使用spring容器对象调用此方法才有保持bean唯一性的特性。此特性在很多底层源码中有应用。\npublic class App33 &#123;    public static void main(String[] args) &#123;        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig33.class);        String[] names = ctx.getBeanDefinitionNames();        for (String name : names) &#123;            System.out.println(name);        &#125;        System.out.println(&quot;-------------------------&quot;);        SpringConfig33 springConfig33 = ctx.getBean(&quot;springConfig33&quot;, SpringConfig33.class);        System.out.println(springConfig33.cat());        System.out.println(springConfig33.cat());        System.out.println(springConfig33.cat());    &#125;&#125;\n\n方式四：使用@Import注解注入bean​\t\t使用扫描的方式加载bean是企业级开发中常见的bean的加载方式，但是由于扫描的时候不仅可以加载到你要的东西，还有可能加载到各种各样的乱七八糟的东西，万一没有控制好得不偿失了。\n​\t\t有人就会奇怪，会有什么问题呢？比如你扫描了com.fang.service包，后来因为业务需要，又扫描了com.fang.dao包，你发现com.fang包下面只有service和dao这两个包，这就简单了，直接扫描com.fang就行了。但是万万没想到，十天后你加入了一个外部依赖包，里面也有com.fang包，这下就热闹了，该来的不该来的全来了。\n​\t\t所以我们需要一种精准制导的加载方式，使用@Import注解就可以解决你的问题。它可以加载所有的一切，只需要在注解的参数中写上加载的类对应的.class即可。有人就会觉得，还要自己手写，多麻烦，不如扫描好用。对呀，但是他可以指定加载啊，好的命名规范配合@ComponentScan可以解决很多问题，但是@Import注解拥有其重要的应用场景。有没有想过假如你要加载的bean没有使用@Component修饰呢？这下就无解了，而@Import就无需考虑这个问题。这句话的意思就是import那个类可以没有注解修饰。\n@Import(&#123;Dog.class,DbConfig.class&#125;)public class SpringConfig4 &#123;&#125;\n\n使用@Import注解注入配置类​\t\t除了加载bean，还可以使用@Import注解加载配置类。其实本质上是一样的，不解释太多了。\n@Import(DogFactoryBean.class)public class SpringConfig4 &#123;&#125;\n\n方式五：编程形式注册bean​\t\t前面介绍的加载bean的方式都是在容器启动阶段完成bean的加载，下面这种方式就比较特殊了，可以在容器初始化完成后手动加载bean。通过这种方式可以实现编程式控制bean的加载。\npublic class App5 &#123;    public static void main(String[] args) &#123;        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        //上下文容器对象已经初始化完毕后，手工加载bean        ctx.register(Mouse.class);    &#125;&#125;\n\n​\t\t其实这种方式坑还是挺多的，比如容器中已经有了某种类型的bean，再加载会不会覆盖呢？这都是要思考和关注的问题。新手慎用。\npublic class App5 &#123;    public static void main(String[] args) &#123;        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        //上下文容器对象已经初始化完毕后，手工加载bean        ctx.registerBean(&quot;tom&quot;, Cat.class,0);        ctx.registerBean(&quot;tom&quot;, Cat.class,1);        ctx.registerBean(&quot;tom&quot;, Cat.class,2);        System.out.println(ctx.getBean(Cat.class));    &#125;&#125;\n\n方式六：导入实现了ImportSelector接口的类​\t\t在方式五种，我们感受了bean的加载可以进行编程化的控制，添加if语句就可以实现bean的加载控制了。但是毕竟是在容器初始化后实现bean的加载控制，那是否可以在容器初始化过程中进行控制呢？答案是必须的。实现ImportSelector接口的类可以设置加载的bean的全路径类名，记得一点，只要能编程就能判定，能判定意味着可以控制程序的运行走向，进而控制一切。哪个类import的MyImportSelector这个，MyImportSelector它的元数据就是那个类\n​\t\t现在又多了一种控制bean加载的方式，或者说是选择bean的方式。\npublic class MyImportSelector implements ImportSelector &#123;    @Override    public String[] selectImports(AnnotationMetadata metadata) &#123;        //各种条件的判定，判定完毕后，决定是否装载指定的bean        boolean flag = metadata.hasAnnotation(&quot;org.springframework.context.annotation.Configuration&quot;);//判断元数据那个类有没有注解Configuration        if(flag)&#123;            return new String[]&#123;&quot;com.fang.bean.Dog&quot;&#125;;        &#125;        return new String[]&#123;&quot;com.fang.bean.Cat&quot;&#125;;    &#125;&#125;\n\n方式七：导入实现了ImportBeanDefinitionRegistrar接口的类​\t\t方式六中提供了给定类全路径类名控制bean加载的形式，如果对spring的bean的加载原理比较熟悉的小伙伴知道，其实bean的加载不是一个简简单单的对象，spring中定义了一个叫做BeanDefinition的东西，它才是控制bean初始化加载的核心。BeanDefinition接口中给出了若干种方法，可以控制bean的相关属性。说个最简单的，创建的对象是单例还是非单例，在BeanDefinition中定义了scope属性就可以控制这个。如果你感觉方式六没有给你开放出足够的对bean的控制操作，那么方式七你值得拥有。我们可以通过定义一个类，然后实现ImportBeanDefinitionRegistrar接口的方式定义bean，并且还可以让你对bean的初始化进行更加细粒度的控制，不过对于新手并不是很友好。忽然给你开放了若干个操作，还真不知道如何下手。\npublic class MyRegistrar implements ImportBeanDefinitionRegistrar &#123;    @Override    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;        BeanDefinition beanDefinition = \t            BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl2.class).getBeanDefinition();        registry.registerBeanDefinition(&quot;bookService&quot;,beanDefinition);    &#125;&#125;\n\n方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类​\t\t上述七种方式都是在容器初始化过程中进行bean的加载或者声明，但是这里有一个bug。这么多种方式，它们之间如果有冲突怎么办？谁能有最终裁定权？这是个好问题，当某种类型的bean被接二连三的使用各种方式加载后，在你对所有加载方式的加载顺序没有完全理解清晰之前，你还真不知道最后谁说了算。即便你理清楚了，保不齐和你一起开发的猪队友又添加了一个bean，得嘞，这下就热闹了。\n​\t\tspring挥舞它仲裁者的大刀来了一个致命一击，都别哔哔了，我说了算，BeanDefinitionRegistryPostProcessor，看名字知道，BeanDefinition意思是bean定义，Registry注册的意思，Post后置，Processor处理器，全称bean定义后处理器，干啥的？在所有bean注册都折腾完后，它把最后一道关，说白了，它说了算，这下消停了，它是最后一个运行的。\npublic class MyPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;    @Override    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;        BeanDefinition beanDefinition =             BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl4.class).getBeanDefinition();        registry.registerBeanDefinition(&quot;bookService&quot;,beanDefinition);    &#125;&#125;\n\n​\t\t总体上来说，上面介绍了各种各样的bean的注册加载初始化方式，脑子里建立个概念吧，方式很多，spring源码中大量运用各种方式。\n总结\nbean的定义由前期xml配置逐步演化成注解配置，本质是一样的，都是通过反射机制加载类名后创建对象，对象就是spring管控的bean\n@Import注解可以指定加载某一个类作为spring管控的bean，如果被加载的类中还具有@Bean相关的定义，会被一同加载\nspring开放出了若干种可编程控制的bean的初始化方式，通过分支语句由固定的加载bean转成了可以选择bean是否加载或者选择加载哪一种bean\n\n2、bean的加载控制​\t前面复习bean的加载时，提出了有关加载控制的方式，其中手工注册bean，ImportSelector接口，ImportBeanDefinitionRegistrar接口，BeanDefinitionRegistryPostProcessor接口都可以控制bean的加载，这一节就来说说这些加载控制。\n​\t\t企业级开发中不可能在spring容器中进行bean的饱和式加载的。什么是饱和式加载，就是不管用不用，全部加载。比如jdk中有两万个类，那就加载两万个bean，显然是不合理的，因为你压根就不会使用其中大部分的bean。那合理的加载方式是什么？肯定是必要性加载，就是用什么加载什么。继续思考，加载哪些bean通常受什么影响呢？最容易想的就是你要用什么技术，就加载对应的bean。用什么技术意味着什么？就是加载对应技术的类。所以在spring容器中，通过判定是否加载了某个类来控制某些bean的加载是一种常见操作。下例给出了对应的代码实现，其实思想很简单，先判断一个类的全路径名是否能够成功加载，加载成功说明有这个类，那就干某项具体的工作，否则就干别的工作。\n\n编程式public class MyImportSelector implements ImportSelector &#123;    @Override    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(&quot;com.fang.bean.Mouse&quot;);            if(clazz != null) &#123;                return new String[]&#123;&quot;com.fang.bean.Cat&quot;&#125;;            &#125;        &#125; catch (ClassNotFoundException e) &#123;//            e.printStackTrace();            return new String[0];        &#125;        return null;    &#125;&#125;\n\n​\t\t通过上述的分析，可以看到此类操作将成为企业级开发中的常见操作，于是springboot将把这些常用操作给我们做了一次封装。\n注解式​\t\t下例使用@ConditionalOnClass注解实现了当虚拟机中加载了com.fang.bean.Wolf类时加载对应的bean。比较一下上面的代码和下面的代码，有没有感觉很清爽。其实此类注解还有很多。\n@Bean@ConditionalOnClass(name = &quot;com.fang.bean.Wolf&quot;)public Cat tom()&#123;    return new Cat();&#125;\n\n​\t\t@ConditionalOnMissingClass注解控制虚拟机中没有加载指定的类才加载对应的bean。\n@Bean@ConditionalOnMissingClass(&quot;com.fang.bean.Dog&quot;)public Cat tom()&#123;    return new Cat();&#125;\n\n​\t\t这种条件还可以做并且的逻辑关系，写2个就是2个条件都成立，写多个就是多个条件都成立。\n@Bean@ConditionalOnClass(name = &quot;com.fang.bean.Wolf&quot;)@ConditionalOnMissingClass(&quot;com.fang.bean.Mouse&quot;)public Cat tom()&#123;    return new Cat();&#125;\n\n​\t\t除了判定是否加载类，还可以对当前容器类型做判定，下例是判定当前容器环境是否是web环境。\n@Bean@ConditionalOnWebApplicationpublic Cat tom()&#123;    return new Cat();&#125;\n\n​\t\t下面是判定容器环境是否是非web环境。\n@Bean@ConditionalOnNotWebApplicationpublic Cat tom()&#123;    return new Cat();&#125;\n\n​\t\t当然还可以判定是否加载了指定名称的bean，这种有什么用呢？太有用了。比如当前容器中已经提供了jdbcTemplate对应的bean，你还需要再加载一个全新的jdbcTemplate的bean吗？没有必要了嘛。spring说，如果你自己写的话，我就不帮你操这份心了，如果你没写，我再给你提供。自适应，没有的话就提供给你，有的话就用你自己的\n@Bean@ConditionalOnBean(name=&quot;jerry&quot;)public Cat tom()&#123;    return new Cat();&#125;\n\n​\t\t以下就是判定当前是否加载了mysql的驱动类，如果加载了，我就给你搞一个Druid的数据源对象出来，完美！\npublic class SpringConfig &#123;    @Bean    @ConditionalOnClass(name=&quot;com.mysql.jdbc.Driver&quot;)    public DruidDataSource dataSource()&#123;        return new DruidDataSource();    &#125;&#125;\n\n​\t\t其中springboot的bean加载控制注解还有很多，这里就不一一列举了，最常用的判定条件就是根据类是否加载来进行控制。\n总结\nspringboot定义了若干种控制bean加载的条件设置注解，由spring固定加载bean变成了可以根据情况选择性的加载bean\n\n3、bean的依赖属性配置管理​\t\tbean的加载及加载控制已经搞完了，下面研究一下bean内部的事情。bean在运行的时候，实现对应的业务逻辑时有可能需要开发者提供一些设置值，有就是属性了。如果使用构造方法将参数固定，灵活性不足，这个时候就可以使用前期学习的bean的属性配置相关的知识进行灵活的配置了。先通过yml配置文件，设置bean运行需要使用的配置信息。\ncartoon:  cat:    name: &quot;图多盖洛&quot;    age: 5  mouse:    name: &quot;泰菲&quot;    age: 1\n\n​\t\t然后定义一个封装属性的专用类，加载配置属性，读取对应前缀相关的属性值。\n@ConfigurationProperties(prefix = &quot;cartoon&quot;)@Datapublic class CartoonProperties &#123;    private Cat cat;    private Mouse mouse;&#125;\n\n​\t\t最后在使用的位置注入对应的配置即可。\n@EnableConfigurationProperties(CartoonProperties.class)public class CartoonCatAndMouse&#123;    @Autowired    private CartoonProperties cartoonProperties;&#125;\n\n​\t\t建议在业务类上使用@EnableConfigurationProperties声明bean，这样在不使用这个类的时候，也不会无故加载专用的属性配置类CartoonProperties，减少spring管控的资源数量。也可以在启动类import这个CartoonCatAndMouse类。\n总结\nbean的运行如果需要外部设置值，建议将设置值封装成专用的属性类* * * * Properties\n设置属性类加载指定前缀的配置信息\n在需要使用属性类的位置通过注解@EnableConfigurationProperties加载bean，而不要直接在属性配置类上定义bean，减少资源加载的数量，因需加载而不要饱和式加载。\n\n4、自动配置原理（工作流程）​\t\t啥叫自动配置呢？简单说就是springboot根据我们开发者的行为猜测你要做什么事情，然后把你要用的bean都给你准备好。听上去是不是很神奇？其实非常简单，springboot咋做到的呢？就是看你导入了什么类，就知道你想干什么了。然后把你有可能要用的bean（注意是有可能）都给你加载好，你直接使用就行了，springboot把所需要的一切工作都做完了。\n​\t\t自动配置的意义就是加速开发效率，将开发者使用某种技术时需要使用的bean根据情况提前加载好，实现自动配置的效果。当然，开发者有可能需要提供必要的参数，比如你要用mysql技术，导入了mysql的坐标，springboot就知道了你要做数据库操作，一系列的数据库操作相关的bean都给你提前声明好，但是你要告诉springboot你到底用哪一个数据库，像什么IP地址啊，端口啊，你不告诉spirngboot，springboot就无法帮你把自动配置相关的工作做完。\n​\t\t而这种思想其实就是在日常的开发过程中根据开发者的习惯慢慢抽取得到了。整体过程分为2个阶段：\n​\t\t阶段一：准备阶段\n\nspringboot的开发人员先大量收集Spring开发者的编程习惯，整理开发过程每一个程序经常使用的技术列表，形成一个技术集A\n\n收集常用技术(技术集A)的使用参数，不管你用什么常用设置，我用什么常用设置，统统收集起来整理一下，得到开发过程中每一个技术的常用设置，形成每一个技术对应的设置集B\n阶段二：加载阶段\n\nspringboot初始化Spring容器基础环境，读取用户的配置信息，加载用户自定义的bean和导入的其他坐标，形成初始化环境\n\nspringboot将技术集A包含的所有技术在SpringBoot启动时默认全部加载，这时肯定加载的东西有一些是无效的，没有用的\n\nspringboot会对技术集A中每一个技术约定出启动这个技术对应的条件，并设置成按条件加载，由于开发者导入了一些bean和其他坐标，也就是与初始化环境，这个时候就可以根据这个初始化环境与springboot的技术集A进行比对了，哪个匹配上加载哪个\n\n因为有些技术不做配置就无法工作，所以springboot开始对设置集B下手了。它统计出各个国家各个行业的开发者使用某个技术时最常用的设置是什么，然后把这些设置作为默认值直接设置好，并告诉开发者当前设置我已经给你搞了一套，你要用可以直接用，这样可以减少开发者配置参数的工作量\n\n但是默认配置不一定能解决问题，于是springboot开放修改设置集B的接口，可以由开发者根据需要决定是否覆盖默认配置\n\n\n​\t\t以上这些仅仅是一个思想，落地到代码实现阶段就要好好思考一下怎么实现了。假定我们想自己实现自动配置的功能，都要做哪些工作呢？\n\n首先指定一个技术X，我们打算让技术X具备自动配置的功能，这个技术X可以是任意功能，这个技术隶属于上面描述的技术集A\n\npublic class CartoonCatAndMouse&#123;&#125;\n\n\n然后找出技术X使用过程中的常用配置Y，这个配置隶属于上面表述的设置集B\n\ncartoon:  cat:    name: &quot;图多盖洛&quot;    age: 5  mouse:    name: &quot;泰菲&quot;    age: 1\n\n\n将常用配置Y设计出对应的yml配置书写格式，然后定义一个属性类封装对应的配置属性，这个过程其实就是上一节咱们做的bean的依赖属性管理，一模一样\n\n@ConfigurationProperties(prefix = &quot;cartoon&quot;)@Datapublic class CartoonProperties &#123;    private Cat cat;    private Mouse mouse;&#125;\n\n\n最后做一个配置类，当这个类加载的时候就可以初始化对应的功能bean，并且可以加载到对应的配置\n\n@EnableConfigurationProperties(CartoonProperties.class)public class CartoonCatAndMouse implements ApplicationContextAware &#123;    private CartoonProperties cartoonProperties;&#125;\n\n\n当然，你也可以为当前自动配置类设置上激活条件，例如使用@CondtionOn* * * * 为其设置加载条件\n\n@ConditionalOnClass(name=&quot;org.springframework.data.redis.core.RedisOperations&quot;)@EnableConfigurationProperties(CartoonProperties.class)public class CartoonCatAndMouse implements ApplicationContextAware &#123;    private CartoonProperties cartoonProperties;&#125;\n\n​\t\t做到这里都已经做完了，但是遇到了一个全新的问题，如何让springboot启动的时候去加载这个类呢？如果不加载的话，我们做的条件判定，做的属性加载这些全部都失效了。springboot为我们开放了一个配置入口，在配置目录中创建META-INF目录，并创建spring.factories文件，在其中添加设置，说明哪些类要启动自动配置就可以了。\n# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.fang.bean.CartoonCatAndMouse\n\n​\t\t其实这个文件就做了一件事，通过这种配置的方式加载了指定的类。转了一圈，就是个普通的bean的加载，和最初使用xml格式加载bean几乎没有区别，格式变了而已。那自动配置的核心究竟是什么呢？自动配置其实是一个小的生态，可以按照如下思想理解：\n\n自动配置从根本上来说就是一个bean的加载\n通过bean加载条件的控制给开发者一种感觉，自动配置是自适应的，可以根据情况自己判定，但实际上就是最普通的分支语句的应用，这是蒙蔽我们双眼的第一层面纱\n使用bean的时候，如果不设置属性，就有默认值，如果不想用默认值，就可以自己设置，也就是可以修改部分或者全部参数，感觉这个过程好屌，也是一种自适应的形式，其实还是需要使用分支语句来做判断的，这是蒙蔽我们双眼的第二层面纱\nspringboot技术提前将大量开发者有可能使用的技术提前做好了，条件也写好了，用的时候你导入了一个坐标，对应技术就可以使用了，其实就是提前帮我们把spring.factories文件写好了，这是蒙蔽我们双眼的第三层面纱\n\n​\t\t你在不知道自动配置这个知识的情况下，经过上面这一二三，你当然觉得自动配置是一种特别牛的技术，但是一窥究竟后发现，也就那么回事。而且现在springboot程序启动时，在后台偷偷的做了这么多次检测，这么多种情况判定，不用问了，效率一定是非常低的，毕竟它要检测100余种技术是否在你程序中使用。\n​\t\t以上内容是自动配置的工作流程。\n总结\nspringboot启动时先加载spring.factories文件中的org.springframework.boot.autoconfigure.EnableAutoConfiguration配置项，将其中配置的所有的类都加载成bean\n在加载bean的时候，bean对应的类定义上都设置有加载条件，因此有可能加载成功，也可能条件检测失败不加载bean\n对于可以正常加载成bean的类，通常会通过@EnableConfigurationProperties注解初始化对应的配置属性类并加载对应的配置\n配置属性类上通常会通过@ConfigurationProperties加载指定前缀的配置，当然这些配置通常都有默认值。如果没有默认值，就强制你必须配置后使用了\n\n5、变更自动配置​\t\t知道了自动配置的执行过程，下面就可以根据这个自动配置的流程做一些高级定制了。例如系统默认会加载100多种自动配置的技术，如果我们先手工干预此工程，禁用自动配置是否可行呢？答案一定是可以的。方式还挺多：\n方式一：通过yaml配置设置排除指定的自动配置类\nspring:  autoconfigure:    exclude:      - org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration\n\n方式二：通过注解参数排除自动配置类\n@EnableAutoConfiguration(excludeName = &quot;&quot;,exclude = &#123;&#125;)\n\n方式三：排除坐标（应用面较窄）\n如果当前自动配置中包含有更多的自动配置功能，也就是一个套娃的效果。此时可以通过检测条件的控制来管理自动配置是否启动。例如web程序启动时会自动启动tomcat服务器，可以通过排除坐标的方式，让加载tomcat服务器的条件失效。不过需要提醒一点，你把tomcat排除掉，记得再加一种可以运行的服务器。\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;!--web起步依赖环境中，排除Tomcat起步依赖，匹配自动配置条件--&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;!--添加Jetty起步依赖，匹配自动配置条件--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n总结\nspringboot的自动配置并不是必然运行的，可以通过配置的形式干预是否启用对应的自动配置功能\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发原理篇之自定义starter开发","url":"/2022/06/26/SpringBoot%E5%BC%80%E5%8F%91%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89starter%E5%BC%80%E5%8F%91/","content":"1、案例：记录系统访客独立IP访问次数​\t\t本案例的功能是统计网站独立IP访问次数的功能，并将访问信息在后台持续输出。整体功能是在后台每10秒输出一次监控信息（格式：IP+访问次数） ，当用户访问网站时，对用户的访问行为进行统计。\n​\t\t例如：张三访问网站功能15次，IP地址：192.168.0.135，李四访问网站功能20次，IP地址：61.129.65.248。那么在网站后台就输出如下监控信息，此信息每10秒刷新一次。\n         IP访问监控+-----ip-address-----+--num--+|     192.168.0.135  |   15  ||     61.129.65.248  |   20  |+--------------------+-------+\n\n​\t\t在进行具体制作之前，先对功能做具体的分析\n\n数据记录在什么位置\n最终记录的数据是一个字符串（IP地址）对应一个数字（访问次数），此处可以选择的数据存储模型可以使用java提供的map模型，也就是key-value的键值对模型，或者具有key-value键值对模型的存储技术，例如redis技术。本案例使用map作为实现方案，有兴趣的小伙伴可以使用redis作为解决方案。\n\n统计功能运行位置，因为每次web请求都需要进行统计，因此使用拦截器会是比较好的方案，本案例使用拦截器来实现。不过在制作初期，先使用调用的形式进行测试，等功能完成了，再改成拦截器的实现方案。\n\n为了提升统计数据展示的灵活度，为统计功能添加配置项。输出频度，输出的数据格式，统计数据的显示模式均可以通过配置实现调整。\n\n输出频度，默认10秒\n数据特征：累计数据 &#x2F; 阶段数据，默认累计数据\n输出格式：详细模式 &#x2F; 极简模式\n\n\n\n​\t\t在下面的制作中，分成若干个步骤实现。先完成最基本的统计功能的制作，然后开发出统计报表，接下来把所有的配置都设置好，最后将拦截器功能实现，整体功能就做完了。\n2、IP计数业务功能开发（自定义starter）​\t\t本功能最终要实现的效果是在现有的项目中导入一个starter，对应的功能就添加上了，删除掉对应的starter，功能就消失了，要求功能要与原始项目完全解耦。因此需要开发一个独立的模块，制作对应功能。\n步骤一：创建全新的模块，定义业务功能类\n​\t\t功能类的制作并不复杂，定义一个业务类，声明一个Map对象，用于记录ip访问次数，key是ip地址，value是访问次数\npublic class IpCountService &#123;    private Map&lt;String,Integer&gt; ipCountMap = new HashMap&lt;String,Integer&gt;();&#125;\n\n​\t\t有些小伙伴可能会有疑问，不设置成静态的，如何在每次请求时进行数据共享呢？记得，当前类加载成bean以后是一个单例对象，对象都是单例的，哪里存在多个对象共享变量的问题。\n步骤二：制作统计功能\n​\t\t制作统计操作对应的方法，每次访问后对应ip的记录次数+1。需要分情况处理，如果当前没有对应ip的数据，新增一条数据，否则就修改对应key的值+1即可\npublic class IpCountService &#123;    private Map&lt;String,Integer&gt; ipCountMap = new HashMap&lt;String,Integer&gt;();    public void count()&#123;        //每次调用当前操作，就记录当前访问的IP，然后累加访问次数        //1.获取当前操作的IP地址        String ip = null;        //2.根据IP地址从Map取值，并递增        Integer count = ipCountMap.get(ip);        if(count == null)&#123;            ipCountMap.put(ip,1);        &#125;else&#123;            ipCountMap.put(ip,count + 1);        &#125;    &#125;&#125;\n\n​\t\t因为当前功能最终导入到其他项目中进行，而导入当前功能的项目是一个web项目，可以从容器中直接获取请求对象，因此获取IP地址的操作可以通过自动装配得到请求对象，然后获取对应的访问IP地址。\npublic class IpCountService &#123;    private Map&lt;String,Integer&gt; ipCountMap = new HashMap&lt;String,Integer&gt;();    @Autowired    //当前的request对象的注入工作由使用当前starter的工程提供自动装配    private HttpServletRequest httpServletRequest;    public void count()&#123;        //每次调用当前操作，就记录当前访问的IP，然后累加访问次数        //1.获取当前操作的IP地址        String ip = httpServletRequest.getRemoteAddr();        //2.根据IP地址从Map取值，并递增        Integer count = ipCountMap.get(ip);        if(count == null)&#123;            ipCountMap.put(ip,1);        &#125;else&#123;            ipCountMap.put(ip,count + 1);        &#125;    &#125;&#125;\n\n步骤三：定义自动配置类\n​\t\t我们需要做到的效果是导入当前模块即开启此功能，因此使用自动配置实现功能的自动装载，需要开发自动配置类在启动项目时加载当前功能。\npublic class IpAutoConfiguration &#123;    @Bean    public IpCountService ipCountService()&#123;        return new IpCountService();    &#125;&#125;\n\n​\t\t自动配置类需要在spring.factories文件中做配置方可自动运行。\n# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=cn.itcast.autoconfig.IpAutoConfiguration\n\n步骤四：在原始项目中模拟调用，测试功能\n​\t\t原始调用项目中导入当前开发的starter\n&lt;dependency&gt;    &lt;groupId&gt;cn.itcast&lt;/groupId&gt;    &lt;artifactId&gt;ip_spring_boot_starter&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;\n\n​\t\t推荐选择调用方便的功能做测试，推荐使用分页操作，当然也可以换其他功能位置进行测试。\n@RestController@RequestMapping(&quot;/books&quot;)public class BookController &#123;    @Autowired    private IpCountService ipCountService;    @GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)    public R getPage(@PathVariable int currentPage,@PathVariable int pageSize,Book book)&#123;        ipCountService.count();        IPage&lt;Book&gt; page = bookService.getPage(currentPage, pageSize,book);        if( currentPage &gt; page.getPages())&#123;            page = bookService.getPage((int)page.getPages(), pageSize,book);        &#125;        return new R(true, page);    &#125;&#125;\n\n温馨提示\n​\t\t由于当前制作的功能需要在对应的调用位置进行坐标导入，因此必须保障仓库中具有当前开发的功能，所以每次原始代码修改后，需要重新编译并安装到仓库中。为防止问题出现，建议每次安装之前先clean然后install，保障资源进行了更新。切记切记！！\n当前效果\n​\t\t每次调用分页操作后，可以在控制台输出当前访问的IP地址，此功能可以在count操作中添加日志或者输出语句进行测试。\n3、定时任务报表开发​\t\t当前已经实现了在业务功能类中记录访问数据，但是还没有输出监控的信息到控制台。由于监控信息需要每10秒输出1次，因此需要使用定时器功能。可以选取第三方技术Quartz实现，也可以选择Spring内置的task来完成此功能，此处选用Spring的task作为实现方案。\n步骤一：开启定时任务功能\n​\t\t定时任务功能开启需要在当前功能的总配置中设置，结合现有业务设定，比较合理的位置是设置在自动配置类上。加载自动配置类即启用定时任务功能。\n@EnableSchedulingpublic class IpAutoConfiguration &#123;    @Bean    public IpCountService ipCountService()&#123;        return new IpCountService();    &#125;&#125;\n\n步骤二：制作显示统计数据功能\n​\t\t定义显示统计功能的操作print()，并设置定时任务，当前设置每5秒运行一次统计数据。\npublic class IpCountService &#123;    private Map&lt;String,Integer&gt; ipCountMap = new HashMap&lt;String,Integer&gt;();    @Scheduled(cron = &quot;0/5 * * * * ?&quot;)    public void print()&#123;        System.out.println(&quot;         IP访问监控&quot;);        System.out.println(&quot;+-----ip-address-----+--num--+&quot;);        for (Map.Entry&lt;String, Integer&gt; entry : ipCountMap.entrySet()) &#123;            String key = entry.getKey();            Integer value = entry.getValue();            System.out.println(String.format(&quot;|%18s  |%5d  |&quot;,key,value));        &#125;        System.out.println(&quot;+--------------------+-------+&quot;);      &#125;&#125;\n\n​\t\t其中关于统计报表的显示信息拼接可以使用各种形式进行，此处使用String类中的格式化字符串操作进行，学习者可以根据自己的喜好调整实现方案。\n温馨提示\n​\t\t每次运行效果之前先clean然后install，切记切记！！\n当前效果\n​\t\t每次调用分页操作后，可以在控制台看到统计数据，到此基础功能已经开发完毕。\n4、使用属性配置设置功能参数​\t\t由于当前报表显示的信息格式固定，为提高报表信息显示的灵活性，需要通过yml文件设置参数，控制报表的显示格式。\n步骤一：定义参数格式\n​\t\t设置3个属性，分别用来控制显示周期（cycle），阶段数据是否清空（cycleReset），数据显示格式（model）\ntools:  ip:    cycle: 10    cycleReset: false    model: &quot;detail&quot;\n\n步骤二：定义封装参数的属性类，读取配置参数\n​\t\t为防止项目组定义的参数种类过多，产生冲突，通常设置属性前缀会至少使用两级属性作为前缀进行区分。\n​\t\t日志输出模式是在若干个类别选项中选择某一项，对于此种分类性数据建议制作枚举定义分类数据，当然使用字符串也可以。\n@ConfigurationProperties(prefix = &quot;tools.ip&quot;)public class IpProperties &#123;    /**     * 日志显示周期     */    private Long cycle = 5L;    /**     * 是否周期内重置数据     */    private Boolean cycleReset = false;    /**     * 日志输出模式  detail：详细模式  simple：极简模式     */    private String model = LogModel.DETAIL.value;    public enum LogModel&#123;        DETAIL(&quot;detail&quot;),        SIMPLE(&quot;simple&quot;);        private String value;        LogModel(String value) &#123;            this.value = value;        &#125;        public String getValue() &#123;            return value;        &#125;    &#125;&#125;\n\n步骤三：加载属性类\n@EnableScheduling@EnableConfigurationProperties(IpProperties.class)public class IpAutoConfiguration &#123;    @Bean    public IpCountService ipCountService()&#123;        return new IpCountService();    &#125;&#125;\n\n步骤四：应用配置属性\n​\t\t在应用配置属性的功能类中，使用自动装配加载对应的配置bean，然后使用配置信息做分支处理。\n​\t\t注意：清除数据的功能一定要在输出后运行，否则每次查阅的数据均为空白数据。\npublic class IpCountService &#123;    private Map&lt;String,Integer&gt; ipCountMap = new HashMap&lt;String,Integer&gt;();    @Autowired    private IpProperties ipProperties;    @Scheduled(cron = &quot;0/5 * * * * ?&quot;)    public void print()&#123;        if(ipProperties.getModel().equals(IpProperties.LogModel.DETAIL.getValue()))&#123;            System.out.println(&quot;         IP访问监控&quot;);            System.out.println(&quot;+-----ip-address-----+--num--+&quot;);            for (Map.Entry&lt;String, Integer&gt; entry : ipCountMap.entrySet()) &#123;                String key = entry.getKey();                Integer value = entry.getValue();                System.out.println(String.format(&quot;|%18s  |%5d  |&quot;,key,value));            &#125;            System.out.println(&quot;+--------------------+-------+&quot;);        &#125;else if(ipProperties.getModel().equals(IpProperties.LogModel.SIMPLE.getValue()))&#123;            System.out.println(&quot;     IP访问监控&quot;);            System.out.println(&quot;+-----ip-address-----+&quot;);            for (String key: ipCountMap.keySet()) &#123;                System.out.println(String.format(&quot;|%18s  |&quot;,key));            &#125;            System.out.println(&quot;+--------------------+&quot;);        &#125;        //阶段内统计数据归零        if(ipProperties.getCycleReset())&#123;            ipCountMap.clear();        &#125;    &#125;&#125;\n\n温馨提示\n​\t\t每次运行效果之前先clean然后install，切记切记！！\n当前效果\n​\t\t在web程序端可以通过控制yml文件中的配置参数对统计信息进行格式控制。但是数据显示周期还未进行控制。\n5、使用属性配置设置定时器参数​\t\t在使用属性配置中的显示周期数据时，遇到了一些问题。由于无法在@Scheduled注解上直接使用配置数据，改用曲线救国的方针，放弃使用@EnableConfigurationProperties注解对应的功能，改成最原始的bean定义格式。\n步骤一：@Scheduled注解使用#{}读取bean属性值\n​\t\t此处读取bean名称为ipProperties的bean的cycle属性值\n@Scheduled(cron = &quot;0/#&#123;ipProperties.cycle&#125; * * * * ?&quot;)public void print()&#123;&#125;\n\n步骤二：属性类定义bean并指定bean的访问名称\n​\t\t如果此处不设置bean的访问名称，spring会使用自己的命名生成器生成bean的长名称，无法实现属性的读取\n@Component(&quot;ipProperties&quot;)@ConfigurationProperties(prefix = &quot;tools.ip&quot;)public class IpProperties &#123;&#125;\n\n步骤三：弃用@EnableConfigurationProperties注解对应的功能，改为导入bean的形式加载配置属性类\n@EnableScheduling//@EnableConfigurationProperties(IpProperties.class)@Import(IpProperties.class)public class IpAutoConfiguration &#123;    @Bean    public IpCountService ipCountService()&#123;        return new IpCountService();    &#125;&#125;\n\n温馨提示\n​\t\t每次运行效果之前先clean然后install，切记切记！！\n当前效果\n​\t\t在web程序端可以通过控制yml文件中的配置参数对统计信息的显示周期进行控制\n6、拦截器开发​\t\t基础功能基本上已经完成了制作，下面进行拦截器的开发。开发时先在web工程中制作，然后将所有功能挪入starter模块中\n步骤一：开发拦截器\n​\t\t使用自动装配加载统计功能的业务类，并在拦截器中调用对应功能\npublic class IpCountInterceptor implements HandlerInterceptor &#123;    @Autowired    private IpCountService ipCountService;    @Override    public boolean preHandle(HttpServletRequest request,                              HttpServletResponse response, Object handler) throws Exception &#123;        ipCountService.count();        return true;    &#125;&#125;\n\n步骤二：配置拦截器\n​\t\t配置mvc拦截器，设置拦截对应的请求路径。此处拦截所有请求，用户可以根据使用需要设置要拦截的请求。甚至可以在此处加载IpCountProperties中的属性，通过配置设置拦截器拦截的请求。\n@Configurationpublic class SpringMvcConfig implements WebMvcConfigurer &#123;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(ipCountInterceptor()).addPathPatterns(&quot;/**&quot;);    &#125;    @Bean    public IpCountInterceptor ipCountInterceptor()&#123;        return new IpCountInterceptor();    &#125;&#125;\n\n温馨提示\n​\t\t每次运行效果之前先clean然后install，切记切记！！\n当前效果\n​\t\t在web程序端导入对应的starter后功能开启，去掉坐标后功能消失，实现自定义starter的效果。\n​\t\t到此当前案例全部完成，自定义stater的开发其实在第一轮开发中就已经完成了，就是创建独立模块导出独立功能，需要使用的位置导入对应的starter即可。如果是在企业中开发，记得不仅需要将开发完成的starter模块install到自己的本地仓库中，开发完毕后还要deploy到私服上，否则别人就无法使用了。\n7、功能性完善——开启yml提示功能​\t\t我们在使用springboot的配置属性时，都可以看到提示，尤其是导入了对应的starter后，也会有对应的提示信息出现。但是现在我们的starter没有对应的提示功能，这种设定就非常的不友好，本节解决自定义starter功能如何开启配置提示的问题。\n​\t\tspringboot提供有专用的工具实现此功能，仅需要导入下列坐标。\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\n\n​\t\t程序编译后，在META-INF目录中会生成对应的提示文件，然后拷贝生成出的文件到自己开发的META-INF目录中，并对其进行编辑。打开生成的文件，可以看到如下信息。其中groups属性定义了当前配置的提示信息总体描述，当前配置属于哪一个属性封装类，properties属性描述了当前配置中每一个属性的具体设置，包含名称、类型、描述、默认值等信息。hints属性默认是空白的，没有进行设置。hints属性可以参考springboot源码中的制作，设置当前属性封装类专用的提示信息，下例中为日志输出模式属性model设置了两种可选提示信息。\n&#123;  &quot;groups&quot;: [    &#123;      &quot;name&quot;: &quot;tools.ip&quot;,      &quot;type&quot;: &quot;cn.itcast.properties.IpProperties&quot;,      &quot;sourceType&quot;: &quot;cn.itcast.properties.IpProperties&quot;    &#125;  ],  &quot;properties&quot;: [    &#123;      &quot;name&quot;: &quot;tools.ip.cycle&quot;,      &quot;type&quot;: &quot;java.lang.Long&quot;,      &quot;description&quot;: &quot;日志显示周期&quot;,      &quot;sourceType&quot;: &quot;cn.itcast.properties.IpProperties&quot;,      &quot;defaultValue&quot;: 5    &#125;,    &#123;      &quot;name&quot;: &quot;tools.ip.cycle-reset&quot;,      &quot;type&quot;: &quot;java.lang.Boolean&quot;,      &quot;description&quot;: &quot;是否周期内重置数据&quot;,      &quot;sourceType&quot;: &quot;cn.itcast.properties.IpProperties&quot;,      &quot;defaultValue&quot;: false    &#125;,    &#123;      &quot;name&quot;: &quot;tools.ip.model&quot;,      &quot;type&quot;: &quot;java.lang.String&quot;,      &quot;description&quot;: &quot;日志输出模式  detail：详细模式  simple：极简模式&quot;,      &quot;sourceType&quot;: &quot;cn.itcast.properties.IpProperties&quot;    &#125;  ],  &quot;hints&quot;: [    &#123;      &quot;name&quot;: &quot;tools.ip.model&quot;,      &quot;values&quot;: [        &#123;          &quot;value&quot;: &quot;detail&quot;,          &quot;description&quot;: &quot;详细模式.&quot;        &#125;,        &#123;          &quot;value&quot;: &quot;simple&quot;,          &quot;description&quot;: &quot;极简模式.&quot;        &#125;      ]    &#125;  ]&#125;\n\n总结\n\n自定义starter其实就是做一个独立的功能模块，核心技术是利用自动配置的效果在加载模块后加载对应的功能\n通常会为自定义starter的自动配置功能添加足够的条件控制，而不会做成100%加载对功能的效果\n本例中使用map保存数据，如果换用redis方案，在starter开发模块中就要导入redis对应的starter\n对于配置属性务必开启提示功能，否则使用者无法感知配置应该如何书写\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之SpringBootAdmin可视化监控平台","url":"/2022/06/25/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8BSpringBootAdmin%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0/","content":"​\t\tspringboot抽取了大部分监控系统的常用指标，提出了监控的总思想。然后就有好心的同志根据监控的总思想，制作了一个通用性很强的监控系统，因为是基于springboot监控的核心思想制作的，所以这个程序被命名为Spring Boot Admin。\n​\t\tSpring Boot Admin，这是一个开源社区项目，用于管理和监控SpringBoot应用程序。这个项目中包含有客户端和服务端两部分，而监控平台指的就是服务端。我们做的程序如果需要被监控，将我们做的程序制作成客户端，然后配置服务端地址后，服务端就可以通过HTTP请求的方式从客户端获取对应的信息，并通过UI界面展示对应信息。\n​\t\t下面就来开发这套监控程序，先制作服务端，其实服务端可以理解为是一个web程序，收到一些信息后展示这些信息。\n服务端开发\n步骤①：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程\n&lt;dependency&gt;    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;    &lt;version&gt;2.5.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\n\n​\t\t上述过程可以通过创建项目时使用勾选的形式完成。\n\n步骤②：在引导类上添加注解@EnableAdminServer，声明当前应用启动后作为SpringBootAdmin的服务器使用\n@SpringBootApplication@EnableAdminServerpublic class Springboot25AdminServerApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Springboot25AdminServerApplication.class, args);    &#125;&#125;\n\n​\t\t做到这里，这个服务器就开发好了，启动后就可以访问当前程序了，界面如下。\n\n​\t由于目前没有启动任何被监控的程序，所以里面什么信息都没有。下面制作一个被监控的客户端程序。\n客户端开发\n​\t\t客户端程序开发其实和服务端开发思路基本相似，多了一些配置而已。\n步骤①：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程\n&lt;dependency&gt;    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;    &lt;version&gt;2.5.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\n\n​\t\t上述过程也可以通过创建项目时使用勾选的形式完成，不过一定要小心，端口配置成不一样的，否则会冲突。\n步骤②：设置当前客户端将信息上传到哪个服务器上，通过yml文件配置\nspring:  boot:    admin:      client:        url: http://localhost:8080\n\n​\t\t做到这里，这个客户端就可以启动了。启动后再次访问服务端程序，界面如下。\n\n\n​\t\t可以看到，当前监控了1个程序，点击进去查看详细信息。\n\n\n​\t\t由于当前没有设置开放哪些信息给监控服务器，所以目前看不到什么有效的信息。下面需要做两组配置就可以看到信息了。\n\n开放指定信息给服务器看\n\n允许服务器以HTTP请求的方式获取对应的信息\n配置如下：\n\n\nserver:  port: 80spring:  boot:    admin:      client:        url: http://localhost:8080management:  endpoint:    health:      show-details: always  endpoints:    web:      exposure:        include: &quot;*&quot;\n\n​\t\t上述配置对于初学者来说比较容易混淆。简单解释一下,springbootadmin的客户端默认开放了13组信息给服务器，但是这些信息除了一个之外，其他的信息都不让通过HTTP请求查看。所以你看到的信息基本上就没什么内容了，只能看到一个内容，就是下面的健康信息。\n\n​\t\t但是即便如此我们看到健康信息中也没什么内容，原因在于健康信息中有一些信息描述了你当前应用使用了什么技术等信息，如果无脑的对外暴露功能会有安全隐患。通过配置就可以开放所有的健康信息明细查看了。\nmanagement:  endpoint:    health:      show-details: always\n\n​\t\t健康明细信息如下：\n\n​\t\t目前除了健康信息，其他信息都查阅不了。原因在于其他12种信息是默认不提供给服务器通过HTTP请求查阅的，所以需要开启查阅的内容项，使用*表示查阅全部。记得带引号。\nendpoints:  web:    exposure:      include: &quot;*&quot;\n\n​\t\t配置后再刷新服务器页面，就可以看到所有的信息了。\n\n​\t\t以上界面中展示的信息量就非常大了，包含了13组信息，有性能指标监控，加载的bean列表，加载的系统属性，日志的显示控制等等。\n配置多个客户端\n​\t\t可以通过配置客户端的方式在其他的springboot程序中添加客户端坐标，这样当前服务器就可以监控多个客户端程序了。每个客户端展示不同的监控信息。\n\n​\t\t进入监控面板，如果你加载的应用具有功能，在监控面板中可以看到3组信息展示的与之前加载的空工程不一样。\n\n类加载面板中可以查阅到开发者自定义的类，如左图\n\n\n\n\n映射中可以查阅到当前应用配置的所有请求\n\n\n\n\n性能指标中可以查阅当前应用独有的请求路径统计数据\n\n\n\n总结\n开发监控服务端需要导入坐标，然后在引导类上添加注解@EnableAdminServer，并将其配置成web程序即可\n开发被监控的客户端需要导入坐标，然后配置服务端服务器地址，并做开放指标的设定即可\n在监控平台中可以查阅到各种各样被监控的指标，前提是客户端开放了被监控的指标\n\n思考​\t\t之前说过，服务端要想监控客户端，需要主动的获取到对应信息并展示出来。但是目前我们并没有在客户端开发任何新的功能，但是服务端确可以获取监控信息，谁帮我们做的这些功能呢？\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之jetcache方法缓存","url":"/2022/06/23/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8Bjetcache%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98/","content":"方法缓存​\t\tjetcache提供了方法缓存方案，只不过名称变更了而已。在对应的操作接口上方使用注解@Cached即可\n步骤①：导入springboot整合jetcache对应的坐标starter\n&lt;dependency&gt;    &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt;    &lt;artifactId&gt;jetcache-starter-redis&lt;/artifactId&gt;    &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;\n\n步骤②：配置缓存\njetcache:  local:    default:      type: linkedhashmap      keyConvertor: fastjson  remote:    default:      type: redis      host: localhost      port: 6379      keyConvertor: fastjson      valueEncode: java      valueDecode: java      poolConfig:        maxTotal: 50    sms:      type: redis      host: localhost      port: 6379      poolConfig:        maxTotal: 50\n\n​\t\t由于redis缓存中不支持保存对象，因此需要对redis设置当Object类型数据进入到redis中时如何进行类型转换。需要配置keyConvertor表示key的类型转换方式，同时标注value的转换类型方式，值进入redis时是java类型，标注valueEncode为java，值从redis中读取时转换成java，标注valueDecode为java。\n​\t\t注意，为了实现Object类型的值进出redis，需要保障进出redis的Object类型的数据必须实现序列化接口。\n@Datapublic class Book implements Serializable &#123;    private Integer id;    private String type;    private String name;    private String description;&#125;\n\n步骤③：启用缓存时开启方法缓存功能，并配置basePackages，说明在哪些包中开启方法缓存\n@SpringBootApplication//jetcache启用缓存的主开关@EnableCreateCacheAnnotation//开启方法注解缓存@EnableMethodCache(basePackages = &quot;com.fang&quot;)public class Springboot20JetCacheApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Springboot20JetCacheApplication.class, args);    &#125;&#125;\n\n步骤④：使用注解@Cached标注当前方法使用缓存\n@Servicepublic class BookServiceImpl implements BookService &#123;    @Autowired    private BookDao bookDao;        @Override    @Cached(name=&quot;book_&quot;,key=&quot;#id&quot;,expire = 3600,cacheType = CacheType.REMOTE)    public Book getById(Integer id) &#123;        return bookDao.selectById(id);    &#125;&#125;\n\n远程方案的数据同步​\t\t由于远程方案中redis保存的数据可以被多个客户端共享，这就存在了数据同步问题。jetcache提供了3个注解解决此问题，分别在更新、删除操作时同步缓存数据，和读取缓存时定时刷新数据\n更新缓存\n@CacheUpdate(name=&quot;book_&quot;,key=&quot;#book.id&quot;,value=&quot;#book&quot;)public boolean update(Book book) &#123;    return bookDao.updateById(book) &gt; 0;&#125;\n\n删除缓存\n@CacheInvalidate(name=&quot;book_&quot;,key = &quot;#id&quot;)public boolean delete(Integer id) &#123;    return bookDao.deleteById(id) &gt; 0;&#125;\n\n定时刷新缓存\n@Cached(name=&quot;book_&quot;,key=&quot;#id&quot;,expire = 3600,cacheType = CacheType.REMOTE)@CacheRefresh(refresh = 5)public Book getById(Integer id) &#123;    return bookDao.selectById(id);&#125;\n\n数据报表​\t\tjetcache还提供有简单的数据报表功能，帮助开发者快速查看缓存命中信息，只需要添加一个配置即可\njetcache:  statIntervalMinutes: 1\n\n​\t\t设置后，每1分钟在控制台输出缓存数据命中信息\n[DefaultExecutor] c.alicp.jetcache.support.StatInfoLogger  : jetcache stat from 2022-02-28 09:32:15,892 to 2022-02-28 09:33:00,003cache    |    qps|   rate|   get|    hit|   fail|   expire|   avgLoadTime|   maxLoadTime---------+-------+-------+------+-------+-------+---------+--------------+--------------book_    |   0.66| 75.86%|    29|     22|      0|        0|          28.0|           188---------+-------+-------+------+-------+-------+---------+--------------+--------------\n\n总结\njetcache是一个类似于springcache的缓存解决方案，自身不具有缓存功能，它提供有本地缓存与远程缓存多级共同使用的缓存解决方案\njetcache提供的缓存解决方案受限于目前支持的方案，本地缓存支持两种，远程缓存支持两种\n注意数据进入远程缓存时的类型转换问题\njetcache提供方法缓存，并提供了对应的缓存更新与刷新功能\njetcache提供有简单的缓存信息命中报表方便开发者即时监控缓存数据命中情况\n\n思考​\t\tjetcache解决了前期使用缓存方案单一的问题，但是仍然不能灵活的选择缓存进行搭配使用，是否存在一种技术可以灵活的搭配各种各样的缓存使用呢？\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之jetcache本地+远程方案","url":"/2022/06/23/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8Bjetcache%E6%9C%AC%E5%9C%B0-%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%A1%88/","content":"​\t\t本地和远程方法都有了，两种方案一起使用如何配置呢？其实就是将两种配置合并到一起就可以了。\njetcache:  local:    default:      type: linkedhashmap      keyConvertor: fastjson  remote:    default:      type: redis      host: localhost      port: 6379      poolConfig:        maxTotal: 50    sms:      type: redis      host: localhost      port: 6379      poolConfig:        maxTotal: 50\n\n​\t\t在创建缓存的时候，配置cacheType为BOTH即则本地缓存与远程缓存同时使用。\n@Servicepublic class SMSCodeServiceImpl implements SMSCodeService &#123;    @CreateCache(name=&quot;jetCache_&quot;,expire = 1000,timeUnit = TimeUnit.SECONDS,cacheType = CacheType.BOTH)    private Cache&lt;String ,String&gt; jetCache;&#125;\n\n​\t\tcacheType如果不进行配置，默认值是REMOTE，即仅使用远程缓存方案。关于jetcache的配置，参考以下信息\n\n\n\n属性\n默认值\n说明\n\n\n\njetcache.statIntervalMinutes\n0\n统计间隔，0表示不统计\n\n\njetcache.hiddenPackages\n无\n自动生成name时，隐藏指定的包名前缀\n\n\njetcache.[local|remote].${area}.type\n无\n缓存类型，本地支持linkedhashmap、caffeine，远程支持redis、tair\n\n\njetcache.[local|remote].${area}.keyConvertor\n无\nkey转换器，当前仅支持fastjson\n\n\njetcache.[local|remote].${area}.valueEncoder\njava\n仅remote类型的缓存需要指定，可选java和kryo\n\n\njetcache.[local|remote].${area}.valueDecoder\njava\n仅remote类型的缓存需要指定，可选java和kryo\n\n\njetcache.[local|remote].${area}.limit\n100\n仅local类型的缓存需要指定，缓存实例最大元素数\n\n\njetcache.[local|remote].${area}.expireAfterWriteInMillis\n无穷大\n默认过期时间，毫秒单位\n\n\njetcache.local.${area}.expireAfterAccessInMillis\n0\n仅local类型的缓存有效，毫秒单位，最大不活动间隔\n\n\n​\t\t以上方案仅支持手工控制缓存，但是springcache方案中的方法缓存特别好用，给一个方法添加一个注解，方法就会自动使用缓存。jetcache也提供了对应的功能，即方法缓存。\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之jetcache本地缓存方案","url":"/2022/06/23/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8Bjetcache%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88/","content":"​\t\t远程方案中，配置中使用remote表示远程，换成local就是本地，只不过类型不一样而已。\n步骤①：导入springboot整合jetcache对应的坐标starter\n&lt;dependency&gt;    &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt;    &lt;artifactId&gt;jetcache-starter-redis&lt;/artifactId&gt;    &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;\n\n步骤②：本地缓存基本配置\njetcache:  local:    default:      type: linkedhashmap      keyConvertor: fastjson\n\n​\t\t为了加速数据获取时key的匹配速度，jetcache要求指定key的类型转换器。简单说就是，如果你给了一个Object作为key的话，我先用key的类型转换器给转换成字符串，然后再保存。等到获取数据时，仍然是先使用给定的Object转换成字符串，然后根据字符串匹配。由于jetcache是阿里的技术，这里推荐key的类型转换器使用阿里的fastjson。\n步骤③：启用缓存\n@SpringBootApplication//jetcache启用缓存的主开关@EnableCreateCacheAnnotationpublic class Springboot20JetCacheApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Springboot20JetCacheApplication.class, args);    &#125;&#125;\n\n步骤④：创建缓存对象Cache时，标注当前使用本地缓存\n@Servicepublic class SMSCodeServiceImpl implements SMSCodeService &#123;    @CreateCache(name=&quot;jetCache_&quot;,expire = 1000,timeUnit = TimeUnit.SECONDS,cacheType = CacheType.LOCAL)    private Cache&lt;String ,String&gt; jetCache;    public String sendCodeToSMS(String tele) &#123;        String code = codeUtils.generator(tele);        jetCache.put(tele,code);        return code;    &#125;    public boolean checkCode(SMSCode smsCode) &#123;        String code = jetCache.get(smsCode.getTele());        return smsCode.getCode().equals(code);    &#125;&#125;\n\n​\t\tcacheType控制当前缓存使用本地缓存还是远程缓存，配置cacheType&#x3D;CacheType.LOCAL即使用本地缓存。\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之jetcache远程缓存方案","url":"/2022/06/23/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8Bjetcache%E8%BF%9C%E7%A8%8B%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88/","content":"​\t目前我们使用的缓存都是要么A要么B，能不能AB一起用呢？springboot针对缓存的整合仅仅停留在用缓存上面，如果缓存自身不支持同时支持AB一起用，springboot也没办法，所以要想解决AB缓存一起用的问题，就必须找一款缓存能够支持AB两种缓存一起用，有这种缓存吗？还真有，阿里出品，jetcache。\n​\tjetcache严格意义上来说，并不是一个缓存解决方案，只能说他算是一个缓存框架，然后把别的缓存放到jetcache中管理，这样就可以支持AB缓存一起用了。并且jetcache参考了springboot整合缓存的思想，整体技术使用方式和springboot的缓存解决方案思想非常类似。\n​\t\t做之前要先明确一下，jetcache并不是随便拿两个缓存都能拼到一起去的。目前jetcache支持的缓存方案本地缓存支持两种，远程缓存支持两种，分别如下：\n\n本地缓存（Local）\nLinkedHashMap\nCaffeine\n\n\n远程缓存（Remote）\nRedis\nTair\n\n\n\n步骤①：导入springboot整合jetcache对应的坐标starter，当前坐标默认使用的远程方案是redis\n&lt;dependency&gt;    &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt;    &lt;artifactId&gt;jetcache-starter-redis&lt;/artifactId&gt;    &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;\n\n步骤②：远程方案基本配置\njetcache:  remote:    default:      type: redis      host: localhost      port: 6379      poolConfig:        maxTotal: 50\n\n​\t\t其中poolConfig是必配项，否则会报错\n步骤③：启用缓存，在引导类上方标注注解@EnableCreateCacheAnnotation配置springboot程序中可以使用注解的形式创建缓存\n@SpringBootApplication//jetcache启用缓存的主开关@EnableCreateCacheAnnotationpublic class Springboot20JetCacheApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Springboot20JetCacheApplication.class, args);    &#125;&#125;\n\n步骤④：创建缓存对象Cache，并使用注解@CreateCache标记当前缓存的信息，然后使用Cache对象的API操作缓存，put写缓存，get读缓存。\n@Servicepublic class SMSCodeServiceImpl implements SMSCodeService &#123;    @Autowired    private CodeUtils codeUtils;        @CreateCache(name=&quot;jetCache_&quot;,expire = 10,timeUnit = TimeUnit.SECONDS)    private Cache&lt;String ,String&gt; jetCache;    public String sendCodeToSMS(String tele) &#123;        String code = codeUtils.generator(tele);        jetCache.put(tele,code);        return code;    &#125;    public boolean checkCode(SMSCode smsCode) &#123;        String code = jetCache.get(smsCode.getTele());        return smsCode.getCode().equals(code);    &#125;&#125;\n\n​\t\t通过上述jetcache使用远程方案连接redis可以看出，jetcache操作缓存时的接口操作更符合开发者习惯，使用缓存就先获取缓存对象Cache，放数据进去就是put，取数据出来就是get，更加简单易懂。并且jetcache操作缓存时，可以为某个缓存对象设置过期时间，将同类型的数据放入缓存中，方便有效周期的管理。\n​\t\t上述方案中使用的是配置中定义的default缓存，其实这个default是个名字，可以随便写，也可以随便加。例如再添加一种缓存解决方案，参照如下配置进行：\njetcache:  remote:    default:      type: redis      host: localhost      port: 6379      poolConfig:        maxTotal: 50    sms:      type: redis      host: localhost      port: 6379      poolConfig:        maxTotal: 50\n\n​\t\t如果想使用名称是sms的缓存，需要再创建缓存时指定参数area，声明使用对应缓存即可\n@Servicepublic class SMSCodeServiceImpl implements SMSCodeService &#123;    @Autowired    private CodeUtils codeUtils;        @CreateCache(area=&quot;sms&quot;,name=&quot;jetCache_&quot;,expire = 10,timeUnit = TimeUnit.SECONDS)    private Cache&lt;String ,String&gt; jetCache;    public String sendCodeToSMS(String tele) &#123;        String code = codeUtils.generator(tele);        jetCache.put(tele,code);        return code;    &#125;    public boolean checkCode(SMSCode smsCode) &#123;        String code = jetCache.get(smsCode.getTele());        return smsCode.getCode().equals(code);    &#125;&#125;\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之发送多组件邮件（附件、复杂正文）","url":"/2022/06/23/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E5%8F%91%E9%80%81%E5%A4%9A%E7%BB%84%E4%BB%B6%E9%82%AE%E4%BB%B6%EF%BC%88%E9%99%84%E4%BB%B6%E3%80%81%E5%A4%8D%E6%9D%82%E6%AD%A3%E6%96%87%EF%BC%89/","content":"​\t\t发送简单邮件仅需要提供对应的4个基本信息就可以了，如果想发送复杂的邮件，需要更换邮件对象。使用MimeMessage可以发送特殊的邮件。\n发送网页正文邮件@Servicepublic class SendMailServiceImpl2 implements SendMailService &#123;    @Autowired    private JavaMailSender javaMailSender;    //发送人    private String from = &quot;test@qq.com&quot;;    //接收人    private String to = &quot;test@126.com&quot;;    //标题    private String subject = &quot;测试邮件&quot;;    //正文    private String context = &quot;&lt;img src=&#x27;ABC.JPG&#x27;/&gt;&lt;a href=&#x27;https://www.itcast.cn&#x27;&gt;点开有惊喜&lt;/a&gt;&quot;;    public void sendMail() &#123;        try &#123;            MimeMessage message = javaMailSender.createMimeMessage();            MimeMessageHelper helper = new MimeMessageHelper(message);            helper.setFrom(to+&quot;(小甜甜)&quot;);            helper.setTo(from);            helper.setSubject(subject);            helper.setText(context,true);\t\t//此处设置正文支持html解析            javaMailSender.send(message);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n发送带有附件的邮件@Servicepublic class SendMailServiceImpl2 implements SendMailService &#123;    @Autowired    private JavaMailSender javaMailSender;    //发送人    private String from = &quot;test@qq.com&quot;;    //接收人    private String to = &quot;test@126.com&quot;;    //标题    private String subject = &quot;测试邮件&quot;;    //正文    private String context = &quot;测试邮件正文&quot;;    public void sendMail() &#123;        try &#123;            MimeMessage message = javaMailSender.createMimeMessage();            MimeMessageHelper helper = new MimeMessageHelper(message,true);\t\t//此处设置支持附件            helper.setFrom(to+&quot;(小甜甜)&quot;);            helper.setTo(from);            helper.setSubject(subject);            helper.setText(context);            //添加附件            File f1 = new File(&quot;springboot_23_mail-0.0.1-SNAPSHOT.jar&quot;);            File f2 = new File(&quot;resources\\\\logo.png&quot;);            helper.addAttachment(f1.getName(),f1);            helper.addAttachment(&quot;最靠谱的培训结构.png&quot;,f2);            javaMailSender.send(message);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n总结\nspringboot整合javamail其实就是简化了发送邮件的客户端对象JavaMailSender的初始化过程，通过配置的形式加载信息简化开发过程\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之发送简单邮件","url":"/2022/06/23/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E5%8F%91%E9%80%81%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6/","content":"\nSMTP（Simple Mail Transfer Protocol）：简单邮件传输协议，用于发送电子邮件的传输协议\nPOP3（Post Office Protocol - Version 3）：用于接收电子邮件的标准协议\nIMAP（Internet Mail Access Protocol）：互联网消息协议，是POP3的替代协议\n\n​\t\t简单说就是SMPT是发邮件的标准，POP3是收邮件的标准，IMAP是对POP3的升级。我们制作程序中操作邮件，通常是发邮件，所以SMTP是使用的重点，收邮件大部分都是通过邮件客户端完成，所以开发收邮件的代码极少。除非你要读取邮件内容，然后解析，做邮件功能的统一处理。例如HR的邮箱收到求职者的简历，可以读取后统一处理。但是为什么不制作独立的投递简历的系统呢？所以说，好奇怪的需求，因为要想收邮件就要规范发邮件的人的书写格式，这个未免有点强人所难，并且极易收到外部攻击，你不可能使用白名单来收邮件。如果能使用白名单来收邮件然后解析邮件，还不如开发个系统给白名单中的人专用呢，更安全，总之就是鸡肋了。下面就开始学习springboot如何整合javamail发送邮件。\n发送简单邮件步骤①：导入springboot整合javamail的starter\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;\n\n步骤②：配置邮箱的登录信息\nspring:  mail:    host: smtp.126.com    username: test@126.com    password: test\n\n​\t\tjava程序仅用于发送邮件，邮件的功能还是邮件供应商提供的，所以这里是用别人的邮件服务，要配置对应信息。\n​\t\thost配置的是提供邮件服务的主机协议，当前程序仅用于发送邮件，因此配置的是smtp的协议。\n​\t\tpassword并不是邮箱账号的登录密码，是邮件供应商提供的一个加密后的密码，也是为了保障系统安全性。不然外部人员通过地址访问下载了配置文件，直接获取到了邮件密码就会有极大的安全隐患。有关该密码的获取每个邮件供应商提供的方式都不一样，此处略过。可以到邮件供应商的设置页面找POP3或IMAP这些关键词找到对应的获取位置。下例仅供参考：\n\n步骤③：使用JavaMailSender接口发送邮件\n@Servicepublic class SendMailServiceImpl implements SendMailService &#123;    @Autowired    private JavaMailSender javaMailSender;    //发送人    private String from = &quot;test@qq.com&quot;;    //接收人    private String to = &quot;test@126.com&quot;;    //标题    private String subject = &quot;测试邮件&quot;;    //正文    private String context = &quot;测试邮件正文内容&quot;;    @Override    public void sendMail() &#123;        SimpleMailMessage message = new SimpleMailMessage();        message.setFrom(from+&quot;(小甜甜)&quot;);        message.setTo(to);        message.setSubject(subject);        message.setText(context);        javaMailSender.send(message);    &#125;&#125;\n\n​\t\t将发送邮件的必要信息（发件人、收件人、标题、正文）封装到SimpleMailMessage对象中，可以根据规则设置发送人昵称等。\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之整合ActiveMQ","url":"/2022/06/24/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88ActiveMQ/","content":"​\t\tActiveMQ是MQ产品中的元老级产品，早期标准MQ产品之一，在AMQP协议没有出现之前，占据了消息中间件市场的绝大部分份额，后期因为AMQP系列产品的出现，迅速走弱，目前仅在一些线上运行的产品中出现，新产品开发较少采用。\n安装​\t\twindows版安装包下载地址：https://activemq.apache.org/components/classic/download&#x2F;\n​\t\t下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件\n\n启动服务器\nactivemq.bat\n\n​\t\t运行bin目录下的win32或win64目录下的activemq.bat命令即可，根据自己的操作系统选择即可，默认对外服务端口61616。\n访问web管理服务\n​\t\tActiveMQ启动后会启动一个Web控制台服务，可以通过该服务管理ActiveMQ。\nhttp://127.0.0.1:8161/\n\n​\t\tweb管理服务默认端口8161，访问后可以打开ActiveMQ的管理界面，如下：\n\n​\t\t首先输入访问用户名和密码，初始化用户名和密码相同，均为：admin，成功登录后进入管理后台界面，如下：\n\n​\t\t看到上述界面视为启动ActiveMQ服务成功。\n启动失败\n​\t\t在ActiveMQ启动时要占用多个端口，以下为正常启动信息：\nwrapper  | --&gt; Wrapper Started as Consolewrapper  | Launching a JVM...jvm 1    | Wrapper (Version 3.2.3) http://wrapper.tanukisoftware.orgjvm 1    |   Copyright 1999-2006 Tanuki Software, Inc.  All Rights Reserved.jvm 1    |jvm 1    | Java Runtime: Oracle Corporation 1.8.0_172 D:\\soft\\jdk1.8.0_172\\jrejvm 1    |   Heap sizes: current=249344k  free=235037k  max=932352kjvm 1    |     JVM args: -Dactivemq.home=../.. -Dactivemq.base=../.. -Djavax.net.ssl.keyStorePassword=password -Djavax.net.ssl.trustStorePassword=password -Djavax.net.ssl.keyStore=../../conf/broker.ks -Djavax.net.ssl.trustStore=../../conf/broker.ts -Dcom.sun.management.jmxremote -Dorg.apache.activemq.UseDedicatedTaskRunner=true -Djava.util.logging.config.file=logging.properties -Dactivemq.conf=../../conf -Dactivemq.data=../../data -Djava.security.auth.login.config=../../conf/login.config -Xmx1024m -Djava.library.path=../../bin/win64 -Dwrapper.key=7ySrCD75XhLCpLjd -Dwrapper.port=32000 -Dwrapper.jvm.port.min=31000 -Dwrapper.jvm.port.max=31999 -Dwrapper.pid=9364 -Dwrapper.version=3.2.3 -Dwrapper.native_library=wrapper -Dwrapper.cpu.timeout=10 -Dwrapper.jvmid=1jvm 1    | Extensions classpath:jvm 1    |   [..\\..\\lib,..\\..\\lib\\camel,..\\..\\lib\\optional,..\\..\\lib\\web,..\\..\\lib\\extra]jvm 1    | ACTIVEMQ_HOME: ..\\..jvm 1    | ACTIVEMQ_BASE: ..\\..jvm 1    | ACTIVEMQ_CONF: ..\\..\\confjvm 1    | ACTIVEMQ_DATA: ..\\..\\datajvm 1    | Loading message broker from: xbean:activemq.xmljvm 1    |  INFO | Refreshing org.apache.activemq.xbean.XBeanBrokerFactory$1@5f3ebfe0: startup date [Mon Feb 28 16:07:48 CST 2022]; root of context hierarchyjvm 1    |  INFO | Using Persistence Adapter: KahaDBPersistenceAdapter[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\kahadb]jvm 1    |  INFO | KahaDB is version 7jvm 1    |  INFO | PListStore:[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\localhost\\tmp_storage] startedjvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10434-1646035669595-0:1) is startingjvm 1    |  INFO | Listening for connections at: tcp://CZBK-20210302VL:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector openwire startedjvm 1    |  INFO | Listening for connections at: amqp://CZBK-20210302VL:5672?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector amqp startedjvm 1    |  INFO | Listening for connections at: stomp://CZBK-20210302VL:61613?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector stomp startedjvm 1    |  INFO | Listening for connections at: mqtt://CZBK-20210302VL:1883?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector mqtt startedjvm 1    |  INFO | Starting Jetty serverjvm 1    |  INFO | Creating Jetty connectorjvm 1    |  WARN | ServletContext@o.e.j.s.ServletContextHandler@7350746f&#123;/,null,STARTING&#125; has uncovered http methods for path: /jvm 1    |  INFO | Listening for connections at ws://CZBK-20210302VL:61614?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector ws startedjvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10434-1646035669595-0:1) startedjvm 1    |  INFO | For help or more information please see: http://activemq.apache.orgjvm 1    |  WARN | Store limit is 102400 mb (current store usage is 0 mb). The data directory: D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\kahadb only has 68936 mb of usable space. - resetting to maximum available disk space: 68936 mbjvm 1    |  INFO | ActiveMQ WebConsole available at http://127.0.0.1:8161/jvm 1    |  INFO | ActiveMQ Jolokia REST API available at http://127.0.0.1:8161/api/jolokia/\n\n​\t\t其中占用的端口有：61616、5672、61613、1883、61614，如果启动失败，请先管理对应端口即可。以下就是某个端口占用的报错信息，可以从抛出异常的位置看出，启动5672端口时端口被占用，显示java.net.BindException: Address already in use: JVM_Bind。Windows系统中终止端口运行的操作参看【命令行启动常见问题及解决方案】\nwrapper  | --&gt; Wrapper Started as Consolewrapper  | Launching a JVM...jvm 1    | Wrapper (Version 3.2.3) http://wrapper.tanukisoftware.orgjvm 1    |   Copyright 1999-2006 Tanuki Software, Inc.  All Rights Reserved.jvm 1    |jvm 1    | Java Runtime: Oracle Corporation 1.8.0_172 D:\\soft\\jdk1.8.0_172\\jrejvm 1    |   Heap sizes: current=249344k  free=235038k  max=932352kjvm 1    |     JVM args: -Dactivemq.home=../.. -Dactivemq.base=../.. -Djavax.net.ssl.keyStorePassword=password -Djavax.net.ssl.trustStorePassword=password -Djavax.net.ssl.keyStore=../../conf/broker.ks -Djavax.net.ssl.trustStore=../../conf/broker.ts -Dcom.sun.management.jmxremote -Dorg.apache.activemq.UseDedicatedTaskRunner=true -Djava.util.logging.config.file=logging.properties -Dactivemq.conf=../../conf -Dactivemq.data=../../data -Djava.security.auth.login.config=../../conf/login.config -Xmx1024m -Djava.library.path=../../bin/win64 -Dwrapper.key=QPJoy9ZoXeWmmwTS -Dwrapper.port=32000 -Dwrapper.jvm.port.min=31000 -Dwrapper.jvm.port.max=31999 -Dwrapper.pid=14836 -Dwrapper.version=3.2.3 -Dwrapper.native_library=wrapper -Dwrapper.cpu.timeout=10 -Dwrapper.jvmid=1jvm 1    | Extensions classpath:jvm 1    |   [..\\..\\lib,..\\..\\lib\\camel,..\\..\\lib\\optional,..\\..\\lib\\web,..\\..\\lib\\extra]jvm 1    | ACTIVEMQ_HOME: ..\\..jvm 1    | ACTIVEMQ_BASE: ..\\..jvm 1    | ACTIVEMQ_CONF: ..\\..\\confjvm 1    | ACTIVEMQ_DATA: ..\\..\\datajvm 1    | Loading message broker from: xbean:activemq.xmljvm 1    |  INFO | Refreshing org.apache.activemq.xbean.XBeanBrokerFactory$1@2c9392f5: startup date [Mon Feb 28 16:06:16 CST 2022]; root of context hierarchyjvm 1    |  INFO | Using Persistence Adapter: KahaDBPersistenceAdapter[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\kahadb]jvm 1    |  INFO | KahaDB is version 7jvm 1    |  INFO | PListStore:[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\localhost\\tmp_storage] startedjvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is startingjvm 1    |  INFO | Listening for connections at: tcp://CZBK-20210302VL:61616?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector openwire startedjvm 1    | ERROR | Failed to start Apache ActiveMQ (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1)jvm 1    | java.io.IOException: Transport Connector could not be registered in JMX: java.io.IOException: Failed to bind to server socket: amqp://0.0.0.0:5672?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600 due to: java.net.BindException: Address already in use: JVM_Bindjvm 1    |      at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:28)jvm 1    |      at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:2288)jvm 1    |      at org.apache.activemq.broker.BrokerService.startTransportConnector(BrokerService.java:2769)jvm 1    |      at org.apache.activemq.broker.BrokerService.startAllConnectors(BrokerService.java:2665)jvm 1    |      at org.apache.activemq.broker.BrokerService.doStartBroker(BrokerService.java:780)jvm 1    |      at org.apache.activemq.broker.BrokerService.startBroker(BrokerService.java:742)jvm 1    |      at org.apache.activemq.broker.BrokerService.start(BrokerService.java:645)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet(XBeanBrokerService.java:73)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1748)jvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1685)jvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1615)jvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)jvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:481)jvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:312)jvm 1    |      at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)jvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:308)jvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)jvm 1    |      at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:756)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:64)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:52)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.&lt;init&gt;(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)jvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)jvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)jvm 1    |      at java.lang.Thread.run(Thread.java:748)jvm 1    | Caused by: java.io.IOException: Failed to bind to server socket: amqp://0.0.0.0:5672?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600 due to: java.net.BindException: Address already in use: JVM_Bindjvm 1    |      at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:34)jvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:146)jvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportFactory.doBind(TcpTransportFactory.java:62)jvm 1    |      at org.apache.activemq.transport.TransportFactorySupport.bind(TransportFactorySupport.java:40)jvm 1    |      at org.apache.activemq.broker.TransportConnector.createTransportServer(TransportConnector.java:335)jvm 1    |      at org.apache.activemq.broker.TransportConnector.getServer(TransportConnector.java:145)jvm 1    |      at org.apache.activemq.broker.TransportConnector.asManagedConnector(TransportConnector.java:110)jvm 1    |      at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:2283)jvm 1    |      ... 46 morejvm 1    | Caused by: java.net.BindException: Address already in use: JVM_Bindjvm 1    |      at java.net.DualStackPlainSocketImpl.bind0(Native Method)jvm 1    |      at java.net.DualStackPlainSocketImpl.socketBind(DualStackPlainSocketImpl.java:106)jvm 1    |      at java.net.AbstractPlainSocketImpl.bind(AbstractPlainSocketImpl.java:387)jvm 1    |      at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:190)jvm 1    |      at java.net.ServerSocket.bind(ServerSocket.java:375)jvm 1    |      at java.net.ServerSocket.&lt;init&gt;(ServerSocket.java:237)jvm 1    |      at javax.net.DefaultServerSocketFactory.createServerSocket(ServerSocketFactory.java:231)jvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:143)jvm 1    |      ... 52 morejvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is shutting downjvm 1    |  INFO | socketQueue interrupted - stoppingjvm 1    |  INFO | Connector openwire stoppedjvm 1    |  INFO | Could not accept connection during shutdown  : null (null)jvm 1    |  INFO | Connector amqp stoppedjvm 1    |  INFO | Connector stomp stoppedjvm 1    |  INFO | Connector mqtt stoppedjvm 1    |  INFO | Connector ws stoppedjvm 1    |  INFO | PListStore:[D:\\soft\\activemq\\bin\\win64\\..\\..\\data\\localhost\\tmp_storage] stoppedjvm 1    |  INFO | Stopping async queue tasksjvm 1    |  INFO | Stopping async topic tasksjvm 1    |  INFO | Stopped KahaDBjvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) uptime 0.426 secondsjvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is shutdownjvm 1    |  INFO | Closing org.apache.activemq.xbean.XBeanBrokerFactory$1@2c9392f5: startup date [Mon Feb 28 16:06:16 CST 2022]; root of context hierarchyjvm 1    |  WARN | Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;org.apache.activemq.xbean.XBeanBrokerService#0&#x27; defined in class path resource [activemq.xml]: Invocation of init method failed; nested exception is java.io.IOException: Transport Connector could not be registered in JMX: java.io.IOException: Failed to bind to server socket: amqp://0.0.0.0:5672?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600 due to: java.net.BindException: Address already in use: JVM_Bindjvm 1    | ERROR: java.lang.RuntimeException: Failed to execute start task. Reason: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call &#x27;refresh&#x27; before accessing beans via the ApplicationContextjvm 1    | java.lang.RuntimeException: Failed to execute start task. Reason: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call &#x27;refresh&#x27; before accessing beans via the ApplicationContextjvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:91)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)jvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)jvm 1    |      at java.lang.Thread.run(Thread.java:748)jvm 1    | Caused by: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call &#x27;refresh&#x27; before accessing beans via the ApplicationContextjvm 1    |      at org.springframework.context.support.AbstractRefreshableApplicationContext.getBeanFactory(AbstractRefreshableApplicationContext.java:164)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1034)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:555)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:64)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:52)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.&lt;init&gt;(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)jvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)jvm 1    |      ... 16 morejvm 1    | ERROR: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call &#x27;refresh&#x27; before accessing beans via the ApplicationContextjvm 1    | java.lang.IllegalStateException: BeanFactory not initialized or already closed - call &#x27;refresh&#x27; before accessing beans via the ApplicationContextjvm 1    |      at org.springframework.context.support.AbstractRefreshableApplicationContext.getBeanFactory(AbstractRefreshableApplicationContext.java:164)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1034)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:555)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:64)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.&lt;init&gt;(ResourceXmlApplicationContext.java:52)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.&lt;init&gt;(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)jvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)jvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)jvm 1    |      at java.lang.Thread.run(Thread.java:748)wrapper  | &lt;-- Wrapper Stopped请按任意键继续. . .\n\n整合​\t\t做了这么多springboot整合第三方技术，已经摸到门路了，加坐标，做配置，调接口，直接开工\n步骤①：导入springboot整合ActiveMQ的starter\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt;\n\n步骤②：配置ActiveMQ的服务器地址\nspring:  activemq:    broker-url: tcp://localhost:61616\n\n步骤③：使用JmsMessagingTemplate操作ActiveMQ\n@Servicepublic class MessageServiceActivemqImpl implements MessageService &#123;    @Autowired    private JmsMessagingTemplate messagingTemplate;    @Override    public void sendMessage(String id) &#123;        System.out.println(&quot;待发送短信的订单已纳入处理队列，id：&quot;+id);        messagingTemplate.convertAndSend(&quot;order.queue.id&quot;,id);    &#125;    @Override    public String doMessage() &#123;        String id = messagingTemplate.receiveAndConvert(&quot;order.queue.id&quot;,String.class);        System.out.println(&quot;已完成短信发送业务，id：&quot;+id);        return id;    &#125;&#125;\n\n​\t\t发送消息需要先将消息的类型转换成字符串，然后再发送，所以是convertAndSend，定义消息发送的位置，和具体的消息内容，此处使用id作为消息内容。\n​\t\t接收消息需要先将消息接收到，然后再转换成指定的数据类型，所以是receiveAndConvert，接收消息除了提供读取的位置，还要给出转换后的数据的具体类型。\n步骤④：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n@Componentpublic class MessageListener &#123;    @JmsListener(destination = &quot;order.queue.id&quot;)    @SendTo(&quot;order.other.queue.id&quot;)    public String receive(String id)&#123;        System.out.println(&quot;已完成短信发送业务，id：&quot;+id);        return &quot;new:&quot;+id;    &#125;&#125;\n\n​\t\t使用注解@JmsListener定义当前方法监听ActiveMQ中指定名称的消息队列。\n​\t\t如果当前消息队列处理完还需要继续向下传递当前消息到另一个队列中使用注解@SendTo即可，这样即可构造连续执行的顺序消息队列。\n步骤⑤：切换消息模型由点对点模型到发布订阅模型，修改jms配置即可\nspring:  activemq:    broker-url: tcp://localhost:61616  jms:    pub-sub-domain: true\n\n​\t\tpub-sub-domain默认值为false，即点对点模型，修改为true后就是发布订阅模型。\n总结\nspringboot整合ActiveMQ提供了JmsMessagingTemplate对象作为客户端操作消息队列\n操作ActiveMQ需要配置ActiveMQ服务器地址，默认端口61616\n企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@JmsListener\n配置jms的pub-sub-domain属性可以在点对点模型和发布订阅模型间切换消息模型\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之整合Kafka","url":"/2022/06/24/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88Kafka/","content":"安装​\t\twindows版安装包下载地址：https:&#x2F;&#x2F;kafka.apache.org&#x2F;downloads\n​\t\t下载完毕后得到tgz压缩文件，使用解压缩软件解压缩即可使用，解压后得到如下文件\n\n​\t\t建议使用windows版2.8.1版本。\n启动服务器\n​\t\tkafka服务器的功能相当于RocketMQ中的broker，kafka运行还需要一个类似于命名服务器的服务。在kafka安装目录中自带一个类似于命名服务器的工具，叫做zookeeper，它的作用是注册中心。\nzookeeper-server-start.bat ..\\..\\config\\zookeeper.properties\t\t# 启动zookeeperkafka-server-start.bat ..\\..\\config\\server.properties\t\t\t\t# 启动kafka\n\n​\t\t运行bin目录下的windows目录下的zookeeper-server-start命令即可启动注册中心，默认对外服务端口2181。\n​\t\t运行bin目录下的windows目录下的kafka-server-start命令即可启动kafka服务器，默认对外服务端口9092。\n创建主题​\t\t和之前操作其他MQ产品相似，kakfa也是基于主题操作，操作之前需要先初始化topic。\n# 创建topickafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic fang# 查询topickafka-topics.bat --zookeeper 127.0.0.1:2181 --list\t\t\t\t\t# 删除topickafka-topics.bat --delete --zookeeper localhost:2181 --topic fang\n\n测试服务器启动状态测试服务器启动状态\n​\t\tKafka提供有一套测试服务器功能的测试程序，运行bin目录下的windows目录下的命令即可使用。\nkafka-console-producer.bat --broker-list localhost:9092 --topic fang\t\t\t\t\t\t\t# 测试生产消息kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic fang --from-beginning\t# 测试消息消费\n\n整合步骤①：导入springboot整合Kafka的starter，此坐标由springboot维护版本\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;\n\n步骤②：配置Kafka的服务器地址\nspring:  kafka:    bootstrap-servers: localhost:9092    consumer:      group-id: order\n\n​\t\t设置默认的生产者消费者所属组id。\n步骤③：使用KafkaTemplate操作Kafka\n@Servicepublic class MessageServiceKafkaImpl implements MessageService &#123;    @Autowired    private KafkaTemplate&lt;String,String&gt; kafkaTemplate;    @Override    public void sendMessage(String id) &#123;        System.out.println(&quot;待发送短信的订单已纳入处理队列（kafka），id：&quot;+id);        kafkaTemplate.send(&quot;fang&quot;,id);    &#125;&#125;\n\n​\t\t使用send方法发送消息，需要传入topic名称。\n步骤④**：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n@Componentpublic class MessageListener &#123;    @KafkaListener(topics = &quot;fang&quot;)    public void onMessage(ConsumerRecord&lt;String,String&gt; record)&#123;        System.out.println(&quot;已完成短信发送业务(kafka)，id：&quot;+record.value());    &#125;&#125;\n\n​\t\t使用注解@KafkaListener定义当前方法监听Kafka中指定topic的消息，接收到的消息封装在对象ConsumerRecord中，获取数据从ConsumerRecord对象中获取即可。\n总结\nspringboot整合Kafka使用KafkaTemplate对象作为客户端操作消息队列\n\n操作Kafka需要配置Kafka服务器地址，默认端口9092\n\n企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@KafkaListener。接收消息保存在形参ConsumerRecord对象中\n\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之整合Memcached缓存","url":"/2022/06/23/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88Memcached%E7%BC%93%E5%AD%98/","content":"​\t\t按照之前的套路，其实变更缓存并不繁琐，但是springboot并没有支持使用memcached作为其缓存解决方案，也就是说在type属性中没有memcached的配置选项，这里就需要更变一下处理方式了。在整合之前先安装memcached。\n安装​\t\twindows版安装包下载地址：https://www.runoob.com/memcached/window-install-memcached.html\n​\t\t下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件\n\n​\t\t可执行文件只有一个memcached.exe，使用该文件可以将memcached作为系统服务启动，执行此文件时会出现报错信息，如下：\n\n​\t\t此处出现问题的原因是注册系统服务时需要使用管理员权限，当前账号权限不足导致安装服务失败，切换管理员账号权限启动命令行\n​\t\t然后再次执行安装服务的命令即可，如下：\nmemcached.exe -d install\n\n​\t\t服务安装完毕后可以使用命令启动和停止服务，如下：\nmemcached.exe -d start\t\t# 启动服务memcached.exe -d stop\t\t# 停止服务\n\n​\t\t也可以在任务管理器中进行服务状态的切换\n\n整合Memcached​\t\t由于memcached未被springboot收录为缓存解决方案，因此使用memcached需要通过手工硬编码的方式来使用，于是前面的套路都不适用了，需要自己写了。\n​\t\tmemcached目前提供有三种客户端技术，分别是Memcached Client for Java、SpyMemcached和Xmemcached，其中性能指标各方面最好的客户端是Xmemcached，本次整合就使用这个作为客户端实现技术了。下面开始使用Xmemcached\n步骤①：导入xmemcached的坐标\n&lt;dependency&gt;    &lt;groupId&gt;com.googlecode.xmemcached&lt;/groupId&gt;    &lt;artifactId&gt;xmemcached&lt;/artifactId&gt;    &lt;version&gt;2.4.7&lt;/version&gt;&lt;/dependency&gt;\n\n步骤②：配置memcached，制作memcached的配置类\n@Configurationpublic class XMemcachedConfig &#123;    @Bean    public MemcachedClient getMemcachedClient() throws IOException &#123;        MemcachedClientBuilder memcachedClientBuilder = new XMemcachedClientBuilder(&quot;localhost:11211&quot;);        MemcachedClient memcachedClient = memcachedClientBuilder.build();        return memcachedClient;    &#125;&#125;\n\n​\t\tmemcached默认对外服务端口11211。\n步骤③：使用xmemcached客户端操作缓存，注入MemcachedClient对象\n@Servicepublic class SMSCodeServiceImpl implements SMSCodeService &#123;    @Autowired    private CodeUtils codeUtils;    @Autowired    private MemcachedClient memcachedClient;    public String sendCodeToSMS(String tele) &#123;        String code = codeUtils.generator(tele);        try &#123;            memcachedClient.set(tele,10,code);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return code;    &#125;    public boolean checkCode(SMSCode smsCode) &#123;        String code = null;        try &#123;            code = memcachedClient.get(smsCode.getTele()).toString();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return smsCode.getCode().equals(code);    &#125;&#125;\n\n​\t\t设置值到缓存中使用set操作，取值使用get操作，其实更符合我们开发者的习惯。\n​\t\t上述代码中对于服务器的配置使用硬编码写死到了代码中，将此数据提取出来，做成独立的配置属性。\n定义配置属性\n定义配置类，加载必要的配置属性，读取配置文件中memcached节点信息\n\n@Component@ConfigurationProperties(prefix = &quot;memcached&quot;)@Datapublic class XMemcachedProperties &#123;    private String servers;    private int poolSize;    private long opTimeout;&#125;\n\n\n定义memcached节点信息\n\nmemcached:  servers: localhost:11211  poolSize: 10  opTimeout: 3000\n\n\n在memcached配置类中加载信息\n\n@Configurationpublic class XMemcachedConfig &#123;    @Autowired    private XMemcachedProperties props;    @Bean    public MemcachedClient getMemcachedClient() throws IOException &#123;        MemcachedClientBuilder memcachedClientBuilder = new XMemcachedClientBuilder(props.getServers());        memcachedClientBuilder.setConnectionPoolSize(props.getPoolSize());        memcachedClientBuilder.setOpTimeout(props.getOpTimeout());        MemcachedClient memcachedClient = memcachedClientBuilder.build();        return memcachedClient;    &#125;&#125;\n\n总结\nmemcached安装后需要启动对应服务才可以对外提供缓存功能，安装memcached服务需要基于windows系统管理员权限\n由于springboot没有提供对memcached的缓存整合方案，需要采用手工编码的形式创建xmemcached客户端操作缓存\n导入xmemcached坐标后，创建memcached配置类，注册MemcachedClient对应的bean，用于操作缓存\n初始化MemcachedClient对象所需要使用的属性可以通过自定义配置属性类的形式加载\n\n思考​\t\t到这里已经完成了三种缓存的整合，其中redis和mongodb需要安装独立的服务器，连接时需要输入对应的服务器地址，这种是远程缓存，Ehcache是一个典型的内存级缓存，因为它什么也不用安装，启动后导入jar包就有缓存功能了。这个时候就要问了，能不能这两种缓存一起用呢？\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之整合RabbitMQ","url":"/2022/06/24/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88RabbitMQ/","content":"​\t\tRabbitMQ是MQ产品中的目前较为流行的产品之一，它遵从AMQP协议。RabbitMQ的底层实现语言使用的是Erlang，所以安装RabbitMQ需要先安装Erlang。\nErlang安装​\t\twindows版安装包下载地址：https:&#x2F;&#x2F;www.erlang.org/downloads\n​\t\t下载完毕后得到exe安装文件，一键傻瓜式安装，安装完毕需要重启，需要重启，需要重启。\n​\t\t安装的过程中可能会出现依赖Windows组件的提示，根据提示下载安装即可，都是自动执行的，如下：\n\n​\t\tErlang安装后需要配置环境变量，否则RabbitMQ将无法找到安装的Erlang。需要配置项如下，作用等同JDK配置环境变量的作用。\n\nERLANG_HOME（安装后的那个目录）\nPATH（安装后的那个目录的bin）\n\n安装​\t\twindows版安装包下载地址：https:&#x2F;&#x2F;rabbitmq.com&#x2F;install-windows.html\n​\t\t下载完毕后得到exe安装文件，一键傻瓜式安装，安装完毕后会得到如下文件\n\n启动服务器rabbitmq-service.bat start\t\t# 启动服务rabbitmq-service.bat stop\t\t# 停止服务rabbitmqctl status\t\t\t\t# 查看服务状态\n\n​\t\t运行sbin目录下的rabbitmq-service.bat命令即可，start参数表示启动，stop参数表示退出，默认对外服务端口5672。\n​\t\t注意：启动rabbitmq的过程实际上是开启rabbitmq对应的系统服务，需要管理员权限方可执行。\n​\t\t说明：有没有感觉5672的服务端口很熟悉？activemq与rabbitmq有一个端口冲突问题，学习阶段无论操作哪一个？请确保另一个处于关闭状态。\n​\t\t说明：不喜欢命令行的小伙伴可以使用任务管理器中的服务页，找到RabbitMQ服务，使用鼠标右键菜单控制服务的启停。\n\n访问web管理服务​\t\tRabbitMQ也提供有web控制台服务，但是此功能是一个插件，需要先启用才可以使用。\nrabbitmq-plugins.bat list\t\t\t\t\t\t\t# 查看当前所有插件的运行状态rabbitmq-plugins.bat enable rabbitmq_management\t\t# 启动rabbitmq_management插件\n\n​\t\t启动插件后可以在插件运行状态中查看是否运行，运行后通过浏览器即可打开服务后台管理界面\nhttp://localhost:15672\n\n​\t\tweb管理服务默认端口15672，访问后可以打开RabbitMQ的管理界面，如下：\n\n​\t\t首先输入访问用户名和密码，初始化用户名和密码相同，均为：guest，成功登录后进入管理后台界面，如下：\n\n整合(direct模型)​\t\tRabbitMQ满足AMQP协议，因此不同的消息模型对应的制作不同，先使用最简单的direct模型开发。\n步骤①：导入springboot整合amqp的starter，amqp协议默认实现为rabbitmq方案\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;\n\n步骤②：配置RabbitMQ的服务器地址\nspring:  rabbitmq:    host: localhost    port: 5672\n\n步骤③：初始化直连模式系统设置\n​\t\t由于RabbitMQ不同模型要使用不同的交换机，因此需要先初始化RabbitMQ相关的对象，例如队列，交换机等\n@Configurationpublic class RabbitConfigDirect &#123;    @Bean    public Queue directQueue()&#123;        return new Queue(&quot;direct_queue&quot;);    &#125;    @Bean    public Queue directQueue2()&#123;        return new Queue(&quot;direct_queue2&quot;);    &#125;    @Bean    public DirectExchange directExchange()&#123;        return new DirectExchange(&quot;directExchange&quot;);    &#125;    @Bean    public Binding bindingDirect()&#123;        return BindingBuilder.bind(directQueue()).to(directExchange()).with(&quot;direct&quot;);    &#125;    @Bean    public Binding bindingDirect2()&#123;        return BindingBuilder.bind(directQueue2()).to(directExchange()).with(&quot;direct2&quot;);    &#125;&#125;\n\n​\t\t队列Queue与直连交换机DirectExchange创建后，还需要绑定他们之间的关系Binding，这样就可以通过交换机操作对应队列。\n步骤④：使用AmqpTemplate操作RabbitMQ\n@Servicepublic class MessageServiceRabbitmqDirectImpl implements MessageService &#123;    @Autowired    private AmqpTemplate amqpTemplate;    @Override    public void sendMessage(String id) &#123;        System.out.println(&quot;待发送短信的订单已纳入处理队列（rabbitmq direct），id：&quot;+id);        amqpTemplate.convertAndSend(&quot;directExchange&quot;,&quot;direct&quot;,id);    &#125;&#125;\n\n​\t\tamqp协议中的操作API接口名称看上去和jms规范的操作API接口很相似，但是传递参数差异很大。\n步骤⑤：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n@Componentpublic class MessageListener &#123;    @RabbitListener(queues = &quot;direct_queue&quot;)    public void receive(String id)&#123;        System.out.println(&quot;已完成短信发送业务(rabbitmq direct)，id：&quot;+id);    &#125;&#125;\n\n​\t\t使用注解@RabbitListener定义当前方法监听RabbitMQ中指定名称的消息队列。\n整合(topic模型)步骤①：同上\n步骤②：同上\n步骤③：初始化主题模式系统设置\n@Configurationpublic class RabbitConfigTopic &#123;    @Bean    public Queue topicQueue()&#123;        return new Queue(&quot;topic_queue&quot;);    &#125;    @Bean    public Queue topicQueue2()&#123;        return new Queue(&quot;topic_queue2&quot;);    &#125;    @Bean    public TopicExchange topicExchange()&#123;        return new TopicExchange(&quot;topicExchange&quot;);    &#125;    @Bean    public Binding bindingTopic()&#123;        return BindingBuilder.bind(topicQueue()).to(topicExchange()).with(&quot;topic.*.id&quot;);    &#125;    @Bean    public Binding bindingTopic2()&#123;        return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(&quot;topic.orders.*&quot;);    &#125;&#125;\n\n​\t\t主题模式支持routingKey匹配模式，*表示匹配一个单词，#表示匹配任意内容，这样就可以通过主题交换机将消息分发到不同的队列中，详细内容请参看RabbitMQ系列课程。\t\n\n\n\n匹配键\ntopic.*.*\ntopic.#\n\n\n\ntopic.order.id\ntrue\ntrue\n\n\norder.topic.id\nfalse\nfalse\n\n\ntopic.sm.order.id\nfalse\ntrue\n\n\ntopic.sm.id\nfalse\ntrue\n\n\ntopic.id.order\ntrue\ntrue\n\n\ntopic.id\nfalse\ntrue\n\n\ntopic.order\nfalse\ntrue\n\n\n步骤④：使用AmqpTemplate操作RabbitMQ\n@Servicepublic class MessageServiceRabbitmqTopicImpl implements MessageService &#123;    @Autowired    private AmqpTemplate amqpTemplate;    @Override    public void sendMessage(String id) &#123;        System.out.println(&quot;待发送短信的订单已纳入处理队列（rabbitmq topic），id：&quot;+id);        amqpTemplate.convertAndSend(&quot;topicExchange&quot;,&quot;topic.orders.id&quot;,id);    &#125;&#125;\n\n​\t\t发送消息后，根据当前提供的routingKey与绑定交换机时设定的routingKey进行匹配，规则匹配成功消息才会进入到对应的队列中。\n步骤⑤：使用消息监听器在服务器启动后，监听指定队列\n@Componentpublic class MessageListener &#123;    @RabbitListener(queues = &quot;topic_queue&quot;)    public void receive(String id)&#123;        System.out.println(&quot;已完成短信发送业务(rabbitmq topic 1)，id：&quot;+id);    &#125;    @RabbitListener(queues = &quot;topic_queue2&quot;)    public void receive2(String id)&#123;        System.out.println(&quot;已完成短信发送业务(rabbitmq topic 22222222)，id：&quot;+id);    &#125;&#125;\n\n​\t\t使用注解@RabbitListener定义当前方法监听RabbitMQ中指定名称的消息队列。\n总结\nspringboot整合RabbitMQ提供了AmqpTemplate对象作为客户端操作消息队列\n操作ActiveMQ需要配置ActiveMQ服务器地址，默认端口5672\n企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@RabbitListener\nRabbitMQ有5种消息模型，使用的队列相同，但是交换机不同。交换机不同，对应的消息进入的策略也不同\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之整合Redis缓存","url":"/2022/06/23/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88Redis%E7%BC%93%E5%AD%98/","content":"​\t\t上节使用Ehcache替换了springboot内置的缓存技术，其实springboot支持的缓存技术还很多，下面使用redis技术作为缓存解决方案来实现手机验证码案例。\n​\t\t比对使用Ehcache的过程，加坐标，改缓存实现类型为ehcache，做Ehcache的配置。如果还成redis做缓存呢？一模一样，加坐标，改缓存实现类型为redis，做redis的配置。差别之处只有一点，redis的配置可以在yml文件中直接进行配置，无需制作独立的配置文件。\n步骤①：导入redis的坐标\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n步骤②：配置缓存技术实现使用redis\nspring:  redis:    host: localhost    port: 6379  cache:    type: redis\n\n​\t\t如果需要对redis作为缓存进行配置，注意不是对原始的redis进行配置，而是配置redis作为缓存使用相关的配置，隶属于spring.cache.redis节点下，注意不要写错位置了。\nspring:  redis:    host: localhost    port: 6379  cache:    type: redis    redis:      use-key-prefix: false      key-prefix: sms_      cache-null-values: false      time-to-live: 10s\n\n总结\n\nspringboot使用redis作为缓存实现需要导入redis的坐标\n修改设置，配置缓存供应商为redis，并提供对应的缓存配置\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之整合RocketMQ","url":"/2022/06/24/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88RocketMQ/","content":"​\t\tRocketMQ由阿里研发，后捐赠给apache基金会，目前是apache基金会顶级项目之一，也是目前市面上的MQ产品中较为流行的产品之一，它遵从AMQP协议。\n安装​\t\twindows版安装包下载地址：https://rocketmq.apache.org&#x2F;\n​\t\t下载完毕后得到zip压缩文件，解压缩即可使用，解压后得到如下文件\n\n​\t\tRocketMQ安装后需要配置环境变量，具体如下：\n\nROCKETMQ_HOME\nPATH\nNAMESRV_ADDR （建议）： 127.0.0.1:9876\n\n​\t\t关于NAMESRV_ADDR对于初学者来说建议配置此项，也可以通过命令设置对应值，操作略显繁琐，建议配置。系统学习RocketMQ知识后即可灵活控制该项。\nRocketMQ工作模式\n​\t\t在RocketMQ中，处理业务的服务器称为broker，生产者与消费者不是直接与broker联系的，而是通过命名服务器进行通信。broker启动后会通知命名服务器自己已经上线，这样命名服务器中就保存有所有的broker信息。当生产者与消费者需要连接broker时，通过命名服务器找到对应的处理业务的broker，因此命名服务器在整套结构中起到一个信息中心的作用。并且broker启动前必须保障命名服务器先启动。\n\n启动服务器\nmqnamesrv\t\t# 启动命名服务器mqbroker\t\t# 启动broker\n\n​\t\t运行bin目录下的mqnamesrv命令即可启动命名服务器，默认对外服务端口9876。\n​\t\t运行bin目录下的mqbroker命令即可启动broker服务器，如果环境变量中没有设置NAMESRV_ADDR则需要在运行mqbroker指令前通过set指令设置NAMESRV_ADDR的值，并且每次开启均需要设置此项。\n测试服务器启动状态\n​\t\tRocketMQ提供有一套测试服务器功能的测试程序，运行bin目录下的tools命令即可使用。\ntools org.apache.rocketmq.example.quickstart.Producer\t\t# 生产消息tools org.apache.rocketmq.example.quickstart.Consumer\t\t# 消费消息\n\n整合（异步消息）步骤①：导入springboot整合RocketMQ的starter，此坐标不由springboot维护版本\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;\n\n步骤②：配置RocketMQ的服务器地址\nrocketmq:  name-server: localhost:9876  producer:    group: group_rocketmq\n\n​\t\t设置默认的生产者消费者所属组group。\n步骤③：使用RocketMQTemplate操作RocketMQ\n@Servicepublic class MessageServiceRocketmqImpl implements MessageService &#123;    @Autowired    private RocketMQTemplate rocketMQTemplate;    @Override    public void sendMessage(String id) &#123;        System.out.println(&quot;待发送短信的订单已纳入处理队列（rocketmq），id：&quot;+id);        SendCallback callback = new SendCallback() &#123;            @Override            public void onSuccess(SendResult sendResult) &#123;                System.out.println(&quot;消息发送成功&quot;);            &#125;            @Override            public void onException(Throwable e) &#123;                System.out.println(&quot;消息发送失败！！！！！&quot;);            &#125;        &#125;;        rocketMQTemplate.asyncSend(&quot;order_id&quot;,id,callback);    &#125;&#125;\n\n​\t\t使用asyncSend方法发送异步消息。\n步骤④：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息\n@Component@RocketMQMessageListener(topic = &quot;order_id&quot;,consumerGroup = &quot;group_rocketmq&quot;)public class MessageListener implements RocketMQListener&lt;String&gt; &#123;    @Override    public void onMessage(String id) &#123;        System.out.println(&quot;已完成短信发送业务(rocketmq)，id：&quot;+id);    &#125;&#125;\n\n​\t\tRocketMQ的监听器必须按照标准格式开发，实现RocketMQListener接口，泛型为消息类型。\n​\t\t使用注解@RocketMQMessageListener定义当前类监听RabbitMQ中指定组、指定名称的消息队列。\n总结\nspringboot整合RocketMQ使用RocketMQTemplate对象作为客户端操作消息队列\n操作RocketMQ需要配置RocketMQ服务器地址，默认端口9876\n企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@RocketMQMessageListener\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之整合j2cache缓存","url":"/2022/06/23/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88j2cache%E7%BC%93%E5%AD%98/","content":"​\t\tjetcache可以在限定范围内构建多级缓存，但是灵活性不足，不能随意搭配缓存，本节介绍一种可以随意搭配缓存解决方案的缓存整合框架，j2cache。下面就来讲解如何使用这种缓存框架，以Ehcache与redis整合为例：\n步骤①：导入j2cache、redis、ehcache坐标\n&lt;dependency&gt;    &lt;groupId&gt;net.oschina.j2cache&lt;/groupId&gt;    &lt;artifactId&gt;j2cache-core&lt;/artifactId&gt;    &lt;version&gt;2.8.4-release&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;net.oschina.j2cache&lt;/groupId&gt;    &lt;artifactId&gt;j2cache-spring-boot2-starter&lt;/artifactId&gt;    &lt;version&gt;2.8.0-release&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;&lt;/dependency&gt;\n\n​\t\tj2cache的starter中默认包含了redis坐标，官方推荐使用redis作为二级缓存，因此此处无需导入redis坐标\n步骤②：配置一级与二级缓存，并配置一二级缓存间数据传递方式，配置书写在名称为j2cache.properties的文件中。如果使用ehcache还需要单独添加ehcache的配置文件\n# 1级缓存j2cache.L1.provider_class = ehcacheehcache.configXml = ehcache.xml# 2级缓存j2cache.L2.provider_class = net.oschina.j2cache.cache.support.redis.SpringRedisProviderj2cache.L2.config_section = redisredis.hosts = localhost:6379# 1级缓存中的数据如何到达二级缓存j2cache.broadcast = net.oschina.j2cache.cache.support.redis.SpringRedisPubSubPolicy\n\n​\t\t此处配置不能乱配置，需要参照官方给出的配置说明进行。例如1级供应商选择ehcache，供应商名称仅仅是一个ehcache，但是2级供应商选择redis时要写专用的Spring整合Redis的供应商类名SpringRedisProvider，而且这个名称并不是所有的redis包中能提供的，也不是spring包中提供的。因此配置j2cache必须参照官方文档配置，而且还要去找专用的整合包，导入对应坐标才可以使用。\n​\t\t一级与二级缓存最重要的一个配置就是两者之间的数据沟通方式，此类配置也不是随意配置的，并且不同的缓存解决方案提供的数据沟通方式差异化很大，需要查询官方文档进行设置。\n步骤③：使用缓存\n@Servicepublic class SMSCodeServiceImpl implements SMSCodeService &#123;    @Autowired    private CodeUtils codeUtils;    @Autowired    private CacheChannel cacheChannel;    public String sendCodeToSMS(String tele) &#123;        String code = codeUtils.generator(tele);        cacheChannel.set(&quot;sms&quot;,tele,code);        return code;    &#125;    public boolean checkCode(SMSCode smsCode) &#123;        String code = cacheChannel.get(&quot;sms&quot;,smsCode.getTele()).asString();        return smsCode.getCode().equals(code);    &#125;&#125;\n\n​\t\tj2cache的使用和jetcache比较类似，但是无需开启使用的开关，直接定义缓存对象即可使用，缓存对象名CacheChannel。\n​\t\tj2cache的使用不复杂，配置是j2cache的核心，毕竟是一个整合型的缓存框架。缓存相关的配置过多，可以查阅j2cache-core核心包中的j2cache.properties文件中的说明。如下：\n#J2Cache configuration########################################## Cache Broadcast Method# values:# jgroups -&gt; use jgroups&#x27;s multicast# redis -&gt; use redis publish/subscribe mechanism (using jedis)# lettuce -&gt; use redis publish/subscribe mechanism (using lettuce, Recommend)# rabbitmq -&gt; use RabbitMQ publisher/consumer mechanism# rocketmq -&gt; use RocketMQ publisher/consumer mechanism# none -&gt; don&#x27;t notify the other nodes in cluster# xx.xxxx.xxxx.Xxxxx your own cache broadcast policy classname that implement net.oschina.j2cache.cluster.ClusterPolicy#########################################j2cache.broadcast = redis# jgroups propertiesjgroups.channel.name = j2cachejgroups.configXml = /network.xml# RabbitMQ propertiesrabbitmq.exchange = j2cacherabbitmq.host = localhostrabbitmq.port = 5672rabbitmq.username = guestrabbitmq.password = guest# RocketMQ propertiesrocketmq.name = j2cacherocketmq.topic = j2cache# use ; to split multi hostsrocketmq.hosts = 127.0.0.1:9876########################################## Level 1&amp;2 provider# values:# none -&gt; disable this level cache# ehcache -&gt; use ehcache2 as level 1 cache# ehcache3 -&gt; use ehcache3 as level 1 cache# caffeine -&gt; use caffeine as level 1 cache(only in memory)# redis -&gt; use redis as level 2 cache (using jedis)# lettuce -&gt; use redis as level 2 cache (using lettuce)# readonly-redis -&gt; use redis as level 2 cache ,but never write data to it. if use this provider, you must uncomment `j2cache.L2.config_section` to make the redis configurations available.# memcached -&gt; use memcached as level 2 cache (xmemcached),# [classname] -&gt; use custom provider#########################################j2cache.L1.provider_class = caffeinej2cache.L2.provider_class = redis# When L2 provider isn&#x27;t `redis`, using `L2.config_section = redis` to read redis configurations# j2cache.L2.config_section = redis# Enable/Disable ttl in redis cache data (if disabled, the object in redis will never expire, default:true)# NOTICE: redis hash mode (redis.storage = hash) do not support this feature)j2cache.sync_ttl_to_redis = true# Whether to cache null objects by default (default false)j2cache.default_cache_null_object = true########################################## Cache Serialization Provider# values:# fst -&gt; using fast-serialization (recommend)# kryo -&gt; using kryo serialization# json -&gt; using fst&#x27;s json serialization (testing)# fastjson -&gt; using fastjson serialization (embed non-static class not support)# java -&gt; java standard# fse -&gt; using fse serialization# [classname implements Serializer]#########################################j2cache.serialization = json#json.map.person = net.oschina.j2cache.demo.Person########################################## Ehcache configuration########################################## ehcache.configXml = /ehcache.xml# ehcache3.configXml = /ehcache3.xml# ehcache3.defaultHeapSize = 1000########################################## Caffeine configuration# caffeine.region.[name] = size, xxxx[s|m|h|d]##########################################caffeine.properties = /caffeine.properties########################################## Redis connection configuration################################################################################### Redis Cluster Mode## single -&gt; single redis server# sentinel -&gt; master-slaves servers# cluster -&gt; cluster servers (数据库配置无效，使用 database = 0）# sharded -&gt; sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）##########################################redis.mode = single#redis storage mode (generic|hash)redis.storage = generic## redis pub/sub channel nameredis.channel = j2cache## redis pub/sub server (using redis.hosts when empty)redis.channel.host =#cluster name just for shardedredis.cluster_name = j2cache## redis cache namespace optional, default[empty]redis.namespace =## redis command scan parameter count, default[1000]#redis.scanCount = 1000## connection# Separate multiple redis nodes with commas, such as 192.168.0.10:6379,192.168.0.11:6379,192.168.0.12:6379redis.hosts = 127.0.0.1:6379redis.timeout = 2000redis.password =redis.database = 0redis.ssl = false## redis pool propertiesredis.maxTotal = 100redis.maxIdle = 10redis.maxWaitMillis = 5000redis.minEvictableIdleTimeMillis = 60000redis.minIdle = 1redis.numTestsPerEvictionRun = 10redis.lifo = falseredis.softMinEvictableIdleTimeMillis = 10redis.testOnBorrow = trueredis.testOnReturn = falseredis.testWhileIdle = trueredis.timeBetweenEvictionRunsMillis = 300000redis.blockWhenExhausted = falseredis.jmxEnabled = false########################################## Lettuce scheme## redis -&gt; single redis server# rediss -&gt; single redis server with ssl# redis-sentinel -&gt; redis sentinel# redis-cluster -&gt; cluster servers#################################################################################### Lettuce Mode## single -&gt; single redis server# sentinel -&gt; master-slaves servers# cluster -&gt; cluster servers (数据库配置无效，使用 database = 0）# sharded -&gt; sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）############################################ redis command scan parameter count, default[1000]#lettuce.scanCount = 1000lettuce.mode = singlelettuce.namespace =lettuce.storage = hashlettuce.channel = j2cachelettuce.scheme = redislettuce.hosts = 127.0.0.1:6379lettuce.password =lettuce.database = 0lettuce.sentinelMasterId =lettuce.maxTotal = 100lettuce.maxIdle = 10lettuce.minIdle = 10# timeout in millisecondslettuce.timeout = 10000# redis cluster topology refresh interval in millisecondslettuce.clusterTopologyRefresh = 3000########################################## memcached server configurations# refer to https://gitee.com/mirrors/XMemcached#########################################memcached.servers = 127.0.0.1:11211memcached.username =memcached.password =memcached.connectionPoolSize = 10memcached.connectTimeout = 1000memcached.failureMode = falsememcached.healSessionInterval = 1000memcached.maxQueuedNoReplyOperations = 100memcached.opTimeout = 100memcached.sanitizeKeys = false\n\n总结\nj2cache是一个缓存框架，自身不具有缓存功能，它提供多种缓存整合在一起使用的方案\nj2cache需要通过复杂的配置设置各级缓存，以及缓存之间数据交换的方式\nj2cache操作接口通过CacheChannel实现\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之整合quartz","url":"/2022/06/23/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88quartz/","content":"定时任务是企业级开发中必不可少的组成部分，诸如长周期业务数据的计算，例如年度报表，诸如系统脏数据的处理，再比如系统性能监控报告，还有抢购类活动的商品上架，这些都离不开定时任务。\n​\t\tQuartz技术是一个比较成熟的定时任务框架，怎么说呢？有点繁琐，用过的都知道，配置略微复杂。springboot对其进行整合后，简化了一系列的配置，将很多配置采用默认设置，这样开发阶段就简化了很多。再学习springboot整合Quartz前先普及几个Quartz的概念。\n\n工作（Job）：用于定义具体执行的工作\n工作明细（JobDetail）：用于描述定时工作相关的信息\n触发器（Trigger）：描述了工作明细与调度器的对应关系\n调度器（Scheduler）：用于描述触发工作的执行规则，通常使用cron表达式定义规则\n\n​\t\t简单说就是你定时干什么事情，这就是工作，工作不可能就是一个简单的方法，还要设置一些明细信息。工作啥时候执行，设置一个调度器，可以简单理解成设置一个工作执行的时间。工作和调度都是独立定义的，它们两个怎么配合到一起呢？用触发器。完了，就这么多。下面开始springboot整合Quartz。\n步骤①：导入springboot整合Quartz的starter\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;&lt;/dependency&gt;\n\n步骤②：定义任务Bean，按照Quartz的开发规范制作，继承QuartzJobBean\npublic class MyQuartz extends QuartzJobBean &#123;    @Override    protected void executeInternal(JobExecutionContext context) throws JobExecutionException &#123;        System.out.println(&quot;quartz task run...&quot;);    &#125;&#125;\n\n步骤③：创建Quartz配置类，定义工作明细（JobDetail）与触发器的（Trigger）bean\n@Configurationpublic class QuartzConfig &#123;    @Bean    public JobDetail printJobDetail()&#123;        //绑定具体的工作        return JobBuilder.newJob(MyQuartz.class).storeDurably().build();    &#125;    @Bean    public Trigger printJobTrigger()&#123;        ScheduleBuilder schedBuilder = CronScheduleBuilder.cronSchedule(&quot;0/5 * * * * ?&quot;);        //绑定对应的工作明细        return TriggerBuilder.newTrigger().forJob(printJobDetail()).withSchedule(schedBuilder).build();    &#125;&#125;\n\n​\t\t工作明细中要设置对应的具体工作，使用newJob()操作传入对应的工作任务类型即可。\n​\t\t触发器需要绑定任务，使用forJob()操作传入绑定的工作明细对象。此处可以为工作明细设置名称然后使用名称绑定，也可以直接调用对应方法绑定。触发器中最核心的规则是执行时间，此处使用调度器定义执行时间，执行时间描述方式使用的是cron表达式。有关cron表达式的规则，各位小伙伴可以去参看相关课程学习，略微复杂，而且格式不能乱设置，不是写个格式就能用的，写不好就会出现冲突问题。\n总结\n\nspringboot整合Quartz就是将Quartz对应的核心对象交给spring容器管理，包含两个对象，JobDetail和Trigger对象\nJobDetail对象描述的是工作的执行信息，需要绑定一个QuartzJobBean类型的对象\nTrigger对象定义了一个触发器，需要为其指定绑定的JobDetail是哪个，同时要设置执行周期调度器\n\n思考\n​\t\t上面的操作看上去不多，但是Quartz将其中的对象划分粒度过细，导致开发的时候有点繁琐，spring针对上述规则进行了简化，开发了自己的任务管理组件——Task\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之整合task","url":"/2022/06/23/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88task/","content":"​\t\tspring根据定时任务的特征，将定时任务的开发简化到了极致。怎么说呢？要做定时任务总要告诉容器有这功能吧，然后定时执行什么任务直接告诉对应的bean什么时间执行就行了，就这么简单，一起来看怎么做\n步骤①：开启定时任务功能，在引导类上开启定时任务功能的开关，使用注解@EnableScheduling\n@SpringBootApplication//开启定时任务功能@EnableSchedulingpublic class Springboot22TaskApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Springboot22TaskApplication.class, args);    &#125;&#125;\n\n步骤②：定义Bean，在对应要定时执行的操作上方，使用注解@Scheduled定义执行的时间，执行时间的描述方式还是cron表达式\n@Componentpublic class MyBean &#123;    @Scheduled(cron = &quot;0/1 * * * * ?&quot;)    public void print()&#123;        System.out.println(Thread.currentThread().getName()+&quot; :spring task run...&quot;);    &#125;&#125;\n\n​\t\t完事，这就完成了定时任务的配置。总体感觉其实什么东西都没少，只不过没有将所有的信息都抽取成bean，而是直接使用注解绑定定时执行任务的事情而已。\n​\t\t如何想对定时任务进行相关配置，可以通过配置文件进行\nspring:  task:   \tscheduling:      pool:       \tsize: 1\t\t\t\t\t\t\t# 任务调度线程池大小 默认 1      thread-name-prefix: ssm_      \t# 调度线程名称前缀 默认 scheduling-              shutdown:          await-termination: false\t\t# 线程池关闭时等待所有任务完成          await-termination-period: 10s\t# 调度线程关闭前最大等待时间，确保最后一定关闭\n\n总结\n\nspring task需要使用注解@EnableScheduling开启定时任务功能\n\n为定时执行的的任务设置执行周期，描述方式cron表达式\n\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之消息简介","url":"/2022/06/24/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%B6%88%E6%81%AF%E7%AE%80%E4%BB%8B/","content":"消息的概念​\t\t从广义角度来说，消息其实就是信息，但是和信息又有所不同。信息通常被定义为一组数据，而消息除了具有数据的特征之外，还有消息的来源与接收的概念。通常发送消息的一方称为消息的生产者，接收消息的一方称为消息的消费者。这样比较后，发现其实消息和信息差别还是很大的。\n​\t\t为什么要设置生产者和消费者呢？这就是要说到消息的意义了。信息通常就是一组数据，但是消息由于有了生产者和消费者，就出现了消息中所包含的信息可以被二次解读，生产者发送消息，可以理解为生产者发送了一个信息，也可以理解为生产者发送了一个命令；消费者接收消息，可以理解为消费者得到了一个信息，也可以理解为消费者得到了一个命令。对比一下我们会发现信息是一个基本数据，而命令则可以关联下一个行为动作，这样就可以理解为基于接收的消息相当于得到了一个行为动作，使用这些行为动作就可以组织成一个业务逻辑，进行进一步的操作。总的来说，消息其实也是一组信息，只是为其赋予了全新的含义，因为有了消息的流动，并且是有方向性的流动，带来了基于流动的行为产生的全新解读。开发者就可以基于消息的这种特殊解，将其换成代码中的指令。\n​\t\t对于消息的理解，初学者总认为消息内部的数据非常复杂，这是一个误区。比如我发送了一个消息，要求接受者翻译发送过去的内容。初学者会认为消息中会包含被翻译的文字，已经本次操作要执行翻译操作而不是打印操作。其实这种现象有点过度解读了，发送的消息中仅仅包含被翻译的文字，但是可以通过控制不同的人接收此消息来确认要做的事情。例如发送被翻译的文字仅到A程序，而A程序只能进行翻译操作，这样就可以发送简单的信息完成复杂的业务了，是通过接收消息的主体不同，进而执行不同的操作，而不会在消息内部定义数据的操作行为，当然如果开发者希望消息中包含操作种类信息也是可以的，只是提出消息的内容可以更简单，更单一。\n​\t\t对于消息的生产者与消费者的工作模式，还可以将消息划分成两种模式，同步消费与异步消息。\n​\t\t所谓同步消息就是生产者发送完消息，等待消费者处理，消费者处理完将结果告知生产者，然后生产者继续向下执行业务。这种模式过于卡生产者的业务执行连续性，在现在的企业级开发中，上述这种业务场景通常不会采用消息的形式进行处理。\n​\t\t所谓异步消息就是生产者发送完消息，无需等待消费者处理完毕，生产者继续向下执行其他动作。比如生产者发送了一个日志信息给日志系统，发送过去以后生产者就向下做其他事情了，无需关注日志系统的执行结果。日志系统根据接收到的日志信息继续进行业务执行，是单纯的记录日志，还是记录日志并报警，这些和生产者无关，这样生产者的业务执行效率就会大幅度提升。并且可以通过添加多个消费者来处理同一个生产者发送的消息来提高系统的高并发性，改善系统工作效率，提高用户体验。一旦某一个消费者由于各种问题宕机了，也不会对业务产生影响，提高了系统的高可用性。\nJava处理消息的标准规范​\t\t目前企业级开发中广泛使用的消息处理技术共三大类，具体如下：\n\nJMS\nAMQP\nMQTT\n\n​\t\t为什么是三大类，而不是三个技术呢？因为这些都是规范，就想JDBC技术，是个规范，开发针对规范开发，运行还要靠实现类，例如MySQL提供了JDBC的实现，最终运行靠的还是实现。并且这三类规范都是针对异步消息进行处理的，也符合消息的设计本质，处理异步的业务。对以上三种消息规范做一下普及\nJMS​\t\tJMS（Java Message Service）,这是一个规范，作用等同于JDBC规范，提供了与消息服务相关的API接口。\nJMS消息模型\n​\t\tJMS规范中规范了消息有两种模型。分别是点对点模型和发布订阅模型。\n​\t\t点对点模型：peer-2-peer，生产者会将消息发送到一个保存消息的容器中，通常使用队列模型，使用队列保存消息。一个队列的消息只能被一个消费者消费，或未被及时消费导致超时。这种模型下，生产者和消费者是一对一绑定的。\n​\t\t发布订阅模型：publish-subscribe，生产者将消息发送到一个保存消息的容器中，也是使用队列模型来保存。但是消息可以被多个消费者消费，生产者和消费者完全独立，相互不需要感知对方的存在。\n​\t\t以上这种分类是从消息的生产和消费过程来进行区分，针对消息所包含的信息不同，还可以进行不同类别的划分。\nJMS消息种类\n​\t\t根据消息中包含的数据种类划分，可以将消息划分成6种消息。\n\nTextMessage\nMapMessage\nBytesMessage\nStreamMessage\nObjectMessage\nMessage （只有消息头和属性）\n\n​\t\tJMS主张不同种类的消息，消费方式不同，可以根据使用需要选择不同种类的消息。但是这一点也成为其诟病之处，后面再说。整体上来说，JMS就是典型的保守派，什么都按照J2EE的规范来，做一套规范，定义若干个标准，每个标准下又提供一大批API。目前对JMS规范实现的消息中间件技术还是挺多的，毕竟是皇家御用，肯定有人舔，例如ActiveMQ、Redis、HornetMQ。但是也有一些不太规范的实现，参考JMS的标准设计，但是又不完全满足其规范，例如：RabbitMQ、RocketMQ。\nAMQP​\t\tJMS的问世为消息中间件提供了很强大的规范性支撑，但是使用的过程中就开始被人诟病，比如JMS设置的极其复杂的多种类消息处理机制。本来分门别类处理挺好的，为什么会被诟病呢？原因就在于JMS的设计是J2EE规范，站在Java开发的角度思考问题。但是现实往往是复杂度很高的。比如我有一个.NET开发的系统A，有一个Java开发的系统B，现在要从A系统给B系统发业务消息，结果两边数据格式不统一，没法操作。JMS不是可以统一数据格式吗？提供了6种数据种类，总有一款适合你啊。NO，一个都不能用。因为A系统的底层语言不是Java语言开发的，根本不支持那些对象。这就意味着如果想使用现有的业务系统A继续开发已经不可能了，必须推翻重新做使用Java语言开发的A系统。\n​\t\t这时候有人就提出说，你搞那么复杂，整那么多种类干什么？找一种大家都支持的消息数据类型不就解决这个跨平台的问题了吗？大家一想，对啊，于是AMQP孕育而生。\n​\t\t单从上面的说明中其实可以明确感知到，AMQP的出现解决的是消息传递时使用的消息种类的问题，化繁为简，但是其并没有完全推翻JMS的操作API，所以说AMQP仅仅是一种协议，规范了数据传输的格式而已。\n​\t\tAMQP（advanced message queuing protocol）：一种协议（高级消息队列协议，也是消息代理规范），规范了网络交换的数据格式，兼容JMS操作。优点\n​\t\t具有跨平台性，服务器供应商，生产者，消费者可以使用不同的语言来实现\nJMS消息种类\n​\t\tAMQP消息种类：byte[]\n​\t\tAMQP在JMS的消息模型基础上又进行了进一步的扩展，除了点对点和发布订阅的模型，开发了几种全新的消息模型，适应各种各样的消息发送。\nAMQP消息模型\n\ndirect exchange\nfanout exchange\ntopic exchange\nheaders exchange\nsystem exchange\n\n​\t\t目前实现了AMQP协议的消息中间件技术也很多，而且都是较为流行的技术，例如：RabbitMQ、StormMQ、RocketMQ\nMQTT​\t\tMQTT（Message Queueing Telemetry Transport）消息队列遥测传输，专为小设备设计，是物联网（IOT）生态系统中主要成分之一。由于与JavaEE企业级开发没有交集，此处不作过多的说明。\n​\t\t除了上述3种J2EE企业级应用中广泛使用的三种异步消息传递技术，还有一种技术也不能忽略，Kafka。\nKafKa​\t\tKafka，一种高吞吐量的分布式发布订阅消息系统，提供实时消息功能。Kafka技术并不是作为消息中间件为主要功能的产品，但是其拥有发布订阅的工作模式，也可以充当消息中间件来使用，而且目前企业级开发中其身影也不少见。\n​\t\t本节内容讲围绕着上述内容中的几种实现方案讲解springboot整合各种各样的消息中间件。由于各种消息中间件必须先安装再使用，下面的内容采用Windows系统安装，降低各位学习者的学习难度，基本套路和之前学习NoSQL解决方案一样，先安装再整合。\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之监控原理","url":"/2022/06/25/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E7%9B%91%E6%8E%A7%E5%8E%9F%E7%90%86/","content":"​\t\t通过查阅监控中的映射指标，可以看到当前系统中可以运行的所有请求路径，其中大部分路径以&#x2F;actuator开头\n\n​\t\t首先这些请求路径不是开发者自己编写的，其次这个路径代表什么含义呢？既然这个路径可以访问，就可以通过浏览器发送该请求看看究竟可以得到什么信息。\n\n​\t\t通过发送请求，可以得到一组json信息，如下\n&#123;    &quot;_links&quot;: &#123;        &quot;self&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator&quot;,            &quot;templated&quot;: false        &#125;,        &quot;beans&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/beans&quot;,            &quot;templated&quot;: false        &#125;,        &quot;caches-cache&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/caches/&#123;cache&#125;&quot;,            &quot;templated&quot;: true        &#125;,        &quot;caches&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/caches&quot;,            &quot;templated&quot;: false        &#125;,        &quot;health&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/health&quot;,            &quot;templated&quot;: false        &#125;,        &quot;health-path&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/health/&#123;*path&#125;&quot;,            &quot;templated&quot;: true        &#125;,        &quot;info&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/info&quot;,            &quot;templated&quot;: false        &#125;,        &quot;conditions&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/conditions&quot;,            &quot;templated&quot;: false        &#125;,        &quot;shutdown&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/shutdown&quot;,            &quot;templated&quot;: false        &#125;,        &quot;configprops&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/configprops&quot;,            &quot;templated&quot;: false        &#125;,        &quot;configprops-prefix&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/configprops/&#123;prefix&#125;&quot;,            &quot;templated&quot;: true        &#125;,        &quot;env&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/env&quot;,            &quot;templated&quot;: false        &#125;,        &quot;env-toMatch&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/env/&#123;toMatch&#125;&quot;,            &quot;templated&quot;: true        &#125;,        &quot;loggers&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/loggers&quot;,            &quot;templated&quot;: false        &#125;,        &quot;loggers-name&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/loggers/&#123;name&#125;&quot;,            &quot;templated&quot;: true        &#125;,        &quot;heapdump&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/heapdump&quot;,            &quot;templated&quot;: false        &#125;,        &quot;threaddump&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/threaddump&quot;,            &quot;templated&quot;: false        &#125;,        &quot;metrics-requiredMetricName&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/metrics/&#123;requiredMetricName&#125;&quot;,            &quot;templated&quot;: true        &#125;,        &quot;metrics&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/metrics&quot;,            &quot;templated&quot;: false        &#125;,        &quot;scheduledtasks&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/scheduledtasks&quot;,            &quot;templated&quot;: false        &#125;,        &quot;mappings&quot;: &#123;            &quot;href&quot;: &quot;http://localhost:81/actuator/mappings&quot;,            &quot;templated&quot;: false        &#125;    &#125;&#125;\n\n​\t\t其中每一组数据都有一个请求路径，而在这里请求路径中有之前看到过的health，发送此请求又得到了一组信息\n&#123;    &quot;status&quot;: &quot;UP&quot;,    &quot;components&quot;: &#123;        &quot;diskSpace&quot;: &#123;            &quot;status&quot;: &quot;UP&quot;,            &quot;details&quot;: &#123;                &quot;total&quot;: 297042808832,                &quot;free&quot;: 72284409856,                &quot;threshold&quot;: 10485760,                &quot;exists&quot;: true            &#125;        &#125;,        &quot;ping&quot;: &#123;            &quot;status&quot;: &quot;UP&quot;        &#125;    &#125;&#125;\n\n​\t\t当前信息与监控面板中的数据存在着对应关系\n\n​\t\t原来监控中显示的信息实际上是通过发送请求后得到json数据，然后展示出来。按照上述操作，可以发送更多的以&#x2F;actuator开头的链接地址，获取更多的数据，这些数据汇总到一起组成了监控平台显示的所有数据。\n​\t\t到这里我们得到了一个核心信息，监控平台中显示的信息实际上是通过对被监控的应用发送请求得到的。那这些请求谁开发的呢？打开被监控应用的pom文件，其中导入了springboot admin的对应的client，在这个资源中导入了一个名称叫做actuator的包。被监控的应用之所以可以对外提供上述请求路径，就是因为添加了这个包。\n\n​\t\t这个actuator是什么呢？这就是监控的端点。\n​\t\tActuator，可以称为端点，描述了一组监控信息，SpringBootAdmin提供了多个内置端点，通过访问端点就可以获取对应的监控信息，也可以根据需要自定义端点信息。通过发送请求路劲**&#x2F;actuator可以访问应用所有端点信息，如果端点中还有明细信息可以发送请求&#x2F;actuator&#x2F;端点名称**来获取详细信息。以下列出了所有端点信息说明：\n\n\n\nID\n描述\n默认启用\n\n\n\nauditevents\n暴露当前应用程序的审计事件信息。\n是\n\n\nbeans\n显示应用程序中所有 Spring bean 的完整列表。\n是\n\n\ncaches\n暴露可用的缓存。\n是\n\n\nconditions\n显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。\n是\n\n\nconfigprops\n显示所有 @ConfigurationProperties 的校对清单。\n是\n\n\nenv\n暴露 Spring ConfigurableEnvironment 中的属性。\n是\n\n\nflyway\n显示已应用的 Flyway 数据库迁移。\n是\n\n\nhealth\n显示应用程序健康信息\n是\n\n\nhttptrace\n显示 HTTP 追踪信息（默认情况下，最后 100 个  HTTP 请求&#x2F;响应交换）。\n是\n\n\ninfo\n显示应用程序信息。\n是\n\n\nintegrationgraph\n显示 Spring Integration 图。\n是\n\n\nloggers\n显示和修改应用程序中日志记录器的配置。\n是\n\n\nliquibase\n显示已应用的 Liquibase 数据库迁移。\n是\n\n\nmetrics\n显示当前应用程序的指标度量信息。\n是\n\n\nmappings\n显示所有 @RequestMapping 路径的整理清单。\n是\n\n\nscheduledtasks\n显示应用程序中的调度任务。\n是\n\n\nsessions\n允许从 Spring Session 支持的会话存储中检索和删除用户会话。当使用 Spring Session 的响应式 Web 应用程序支持时不可用。\n是\n\n\nshutdown\n正常关闭应用程序。\n否\n\n\nthreaddump\n执行线程 dump。\n是\n\n\nheapdump\n返回一个 hprof 堆 dump 文件。\n是\n\n\njolokia\n通过 HTTP 暴露 JMX bean（当  Jolokia 在 classpath 上时，不适用于 WebFlux）。\n是\n\n\nlogfile\n返回日志文件的内容（如果已设置 logging.file 或 logging.path 属性）。支持使用 HTTP Range 头来检索部分日志文件的内容。\n是\n\n\nprometheus\n以可以由 Prometheus 服务器抓取的格式暴露指标。\n是\n\n\n​\t\t上述端点每一项代表被监控的指标，如果对外开放则监控平台可以查询到对应的端点信息，如果未开放则无法查询对应的端点信息。通过配置可以设置端点是否对外开放功能。使用enable属性控制端点是否对外开放。其中health端点为默认端点，不能关闭。\nmanagement:  endpoint:    health:\t\t\t\t\t\t# 端点名称      show-details: always    info:\t\t\t\t\t\t# 端点名称      enabled: true\t\t\t\t# 是否开放\n\n​\t\t为了方便开发者快速配置端点，springboot admin设置了13个较为常用的端点作为默认开放的端点，如果需要控制默认开放的端点的开放状态，可以通过配置设置，如下：\nmanagement:  endpoints:    enabled-by-default: true\t# 是否开启默认端点，默认值true\n\n​\t\t上述端点开启后，就可以通过端点对应的路径查看对应的信息了。但是此时还不能通过HTTP请求查询此信息，还需要开启通过HTTP请求查询的端点名称，使用“*”可以简化配置成开放所有端点的WEB端HTTP请求权限。\nmanagement:  endpoints:    web:      exposure:        include: &quot;*&quot;\n\n​\t\t整体上来说，对于端点的配置有两组信息，一组是endpoints开头的，对所有端点进行配置，一组是endpoint开头的，对具体端点进行配置。\nmanagement:  endpoint:\t\t# 具体端点的配置    health:      show-details: always    info:      enabled: true  endpoints:\t# 全部端点的配置    web:      exposure:        include: &quot;*&quot;    enabled-by-default: true\n\n总结\n被监控客户端通过添加actuator的坐标可以对外提供被访问的端点功能\n\n端点功能的开放与关闭可以通过配置进行控制\n\nweb端默认无法获取所有端点信息，通过配置开放端点功能\n\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之监控的意义","url":"/2022/06/25/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E7%9B%91%E6%8E%A7%E7%9A%84%E6%84%8F%E4%B9%89/","content":"​\t\t在说监控之前，需要回顾一下软件业的发展史。最早的软件完成一些非常简单的功能，代码不多，错误也少。随着软件功能的逐步完善，软件的功能变得越来越复杂，功能不能得到有效的保障，这个阶段出现了针对软件功能的检测，也就是软件测试。伴随着计算机操作系统的逐步升级，软件的运行状态也变得开始让人捉摸不透，出现了不稳定的状况。伴随着计算机网络的发展，程序也从单机状态切换成基于计算机网络的程序，应用于网络的程序开始出现，由于网络的不稳定性，程序的运行状态让使用者更加堪忧。互联网的出现彻底打破了软件的思维模式，随之而来的互联网软件就更加凸显出应对各种各样复杂的网络情况之下的弱小。计算机软件的运行状况已经成为了软件运行的一个大话题，针对软件的运行状况就出现了全新的思维，建立起了初代的软件运行状态监控。\n​\t\t什么是监控？就是通过软件的方式展示另一个软件的运行情况，运行的情况则通过各种各样的指标数据反馈给监控人员。例如网络是否顺畅、服务器是否在运行、程序的功能是否能够整百分百运行成功，内存是否够用，等等等等。\n​\t\t本章要讲解的监控就是对软件的运行情况进行监督，但是springboot程序与非springboot程序的差异还是很大的，为了方便监控软件的开发，springboot提供了一套功能接口，为开发者加速开发过程。\n\n​\t\t对于现代的互联网程序来说，规模越来越大，功能越来越复杂，还要追求更好的客户体验，因此要监控的信息量也就比较大了。由于现在的互联网程序大部分都是基于微服务的程序，一个程序的运行需要若干个服务来保障，因此第一个要监控的指标就是服务是否正常运行，也就是监控服务状态是否处理宕机状态。一旦发现某个服务宕机了，必须马上给出对应的解决方案，避免整体应用功能受影响。其次，由于互联网程序服务的客户量是巨大的，当客户的请求在短时间内集中达到服务器后，就会出现各种程序运行指标的波动。比如内存占用严重，请求无法及时响应处理等，这就是第二个要监控的重要指标，监控服务运行指标。虽然软件是对外提供用户的访问需求，完成对应功能的，但是后台的运行是否平稳，是否出现了不影响客户使用的功能隐患，这些也是要密切监控的，此时就需要在不停机的情况下，监控系统运行情况，日志是一个不错的手段。如果在众多日志中找到开发者或运维人员所关注的日志信息，简单快速有效的过滤出要看的日志也是监控系统需要考虑的问题，这就是第三个要监控的指标，监控程序运行日志。虽然我们期望程序一直平稳运行，但是由于突发情况的出现，例如服务器被攻击、服务器内存溢出等情况造成了服务器宕机，此时当前服务不能满足使用需要，就要将其重启甚至关闭，如果快速控制服务器的启停也是程序运行过程中不可回避的问题，这就是第四个监控项，管理服务状态。以上这些仅仅是从大的方面来思考监控这个问题，还有很多的细节点，例如上线了一个新功能，定时提醒用户续费，这种功能不是上线后马上就运行的，但是当前功能是否真的启动，如果快速的查询到这个功能已经开启，这也是监控中要解决的问题，等等。看来监控真的是一项非常重要的工作。\n​\t\t通过上述描述，可以看出监控很重要。那具体的监控要如何开展呢？还要从实际的程序运行角度出发。比如现在有3个服务支撑着一个程序的运行，每个服务都有自己的运行状态。\n\n​\t\t此时被监控的信息就要在三个不同的程序中去查询并展示，但是三个服务是服务于一个程序的运行的，如果不能合并到一个平台上展示，监控工作量巨大，而且信息对称性差，要不停的在三个监控端查看数据。如果将业务放大成30个，300个，3000个呢？看来必须有一个单独的平台，将多个被监控的服务对应的监控指标信息汇总在一起，这样更利于监控工作的开展。\n\n​\t\t新的程序专门用来监控，新的问题就出现了，是被监控程序主动上报信息还是监控程序主动获取信息？如果监控程序不能主动获取信息，这就意味着监控程序有可能看到的是很久之前被监控程序上报的信息，万一被监控程序宕机了，监控程序就无法区分究竟是好久没法信息了，还是已经下线了。所以监控程序必须具有主动发起请求获取被监控服务信息的能力。\n\n​\t\t如果监控程序要监控服务时，主动获取对方的信息。那监控程序如何知道哪些程序被自己监控呢？不可能在监控程序中设置我监控谁，这样互联网上的所有程序岂不是都可以被监控到，这样的话信息安全将无法得到保障。合理的做法只能是在被监控程序启动时上报监控程序，告诉监控程序你可以监控我了。看来需要在被监控程序端做主动上报的操作，这就要求被监控程序中配置对应的监控程序是谁。\n\n​\t\t被监控程序可以提供各种各样的指标数据给监控程序看，但是每一个指标都代表着公司的机密信息，并不是所有的指标都可以给任何人看的，乃至运维人员，所以对被监控指标的是否开放出来给监控系统看，也需要做详细的设定。\n​\t\t以上描述的整个过程就是一个监控系统的基本流程。\n总结\n监控是一个非常重要的工作，是保障程序正常运行的基础手段\n监控的过程通过一个监控程序进行，它汇总所有被监控的程序的信息集中统一展示\n被监控程序需要主动上报自己被监控，同时要设置哪些指标被监控\n\n思考​\t\t下面就要开始做监控了，新的问题就来了，监控程序怎么做呢？难道要自己写吗？肯定是不现实的，如何进行监控？\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之自定义监控指标","url":"/2022/06/25/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87/","content":"​\t\t端点描述了被监控的信息，除了系统默认的指标，还可以自行添加显示的指标，下面就通过3种不同的端点的指标自定义方式来学习端点信息的二次开发。\nINFO端点​\t\tinfo端点描述了当前应用的基本信息，可以通过两种形式快速配置info端点的信息\n\n配置形式\n在yml文件中通过设置info节点的信息就可以快速配置端点信息\n\n\ninfo:  appName: @project.artifactId@  version: @project.version@  author: fang\n\n  配置完毕后，对应信息显示在监控平台上\n​\t\t也可以通过请求端点信息路径获取对应json信息\nhttp://localhost:81/actuator/info\n\n\n编程形式\n通过配置的形式只能添加固定的数据，如果需要动态数据还可以通过配置bean的方式为info端点添加信息，此信息与配置信息共存\n\n\n@Componentpublic class InfoConfig implements InfoContributor &#123;    @Override    public void contribute(Info.Builder builder) &#123;        builder.withDetail(&quot;runTime&quot;,System.currentTimeMillis());\t\t//添加单个信息        Map infoMap = new HashMap();\t\t        infoMap.put(&quot;buildTime&quot;,&quot;2006&quot;);        builder.withDetails(infoMap);\t\t\t\t\t\t\t\t\t//添加一组信息    &#125;&#125;\n\nHealth端点​\t\thealth端点描述当前应用的运行健康指标，即应用的运行是否成功。通过编程的形式可以扩展指标信息。\n@Componentpublic class HealthConfig extends AbstractHealthIndicator &#123;    @Override    protected void doHealthCheck(Health.Builder builder) throws Exception &#123;        boolean condition = true;        if(condition) &#123;            builder.status(Status.UP);\t\t\t\t\t//设置运行状态为启动状态            builder.withDetail(&quot;runTime&quot;, System.currentTimeMillis());            Map infoMap = new HashMap();            infoMap.put(&quot;buildTime&quot;, &quot;2006&quot;);            builder.withDetails(infoMap);        &#125;else&#123;            builder.status(Status.OUT_OF_SERVICE);\t\t//设置运行状态为不在服务状态            builder.withDetail(&quot;上线了吗？&quot;,&quot;你做梦&quot;);        &#125;    &#125;&#125;\n\n​\t\t当任意一个组件状态不为UP时，整体应用对外服务状态为非UP状态。\nMetrics端点​\t\tmetrics端点描述了性能指标，除了系统自带的监控性能指标，还可以自定义性能指标。\n@Servicepublic class BookServiceImpl extends ServiceImpl&lt;BookDao, Book&gt; implements IBookService &#123;    @Autowired    private BookDao bookDao;    private Counter counter;    public BookServiceImpl(MeterRegistry meterRegistry)&#123;        counter = meterRegistry.counter(&quot;用户付费操作次数：&quot;);    &#125;    @Override    public boolean delete(Integer id) &#123;        //每次执行删除业务等同于执行了付费业务        counter.increment();        return bookDao.deleteById(id) &gt; 0;    &#125;&#125;\n\n​\t\t在性能指标中就出现了自定义的性能指标监控项\n\n自定义端点​\t\t可以根据业务需要自定义端点，方便业务监控\n@Component@Endpoint(id=&quot;pay&quot;,enableByDefault = true)public class PayEndpoint &#123;    @ReadOperation    public Object getPay()&#123;        Map payMap = new HashMap();        payMap.put(&quot;level 1&quot;,&quot;300&quot;);        payMap.put(&quot;level 2&quot;,&quot;291&quot;);        payMap.put(&quot;level 3&quot;,&quot;666&quot;);        return payMap;    &#125;&#125;\n\n​\t\t由于此端点数据spirng boot admin无法预知该如何展示，所以通过界面无法看到此数据，通过HTTP请求路径可以获取到当前端点的信息，但是需要先开启当前端点对外功能，或者设置当前端点为默认开发的端点。\n\n总结\n端点的指标可以自定义，但是每种不同的指标根据其功能不同，自定义方式不同\ninfo端点通过配置和编程的方式都可以添加端点指标\nhealth端点通过编程的方式添加端点指标，需要注意要为对应指标添加启动状态的逻辑设定\nmetrics指标通过在业务中添加监控操作设置指标\n可以自定义端点添加更多的指标\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之购物订单发送手机短信案例","url":"/2022/06/24/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E8%B4%AD%E7%89%A9%E8%AE%A2%E5%8D%95%E5%8F%91%E9%80%81%E6%89%8B%E6%9C%BA%E7%9F%AD%E4%BF%A1%E6%A1%88%E4%BE%8B/","content":"​\t\t为了便于下面演示各种各样的消息中间件技术，我们创建一个购物过程生成订单时为用户发送短信的案例环境，模拟使用消息中间件实现发送手机短信的过程。\n​\t\t手机验证码案例需求如下：\n\n执行下单业务时（模拟此过程），调用消息服务，将要发送短信的订单id传递给消息中间件\n\n消息处理服务接收到要发送的订单id后输出订单id（模拟发短信）\n由于不涉及数据读写，仅开发业务层与表现层，其中短信处理的业务代码独立开发，代码如下：\n\n\n订单业务\n​\t\t业务层接口\npublic interface OrderService &#123;    void order(String id);&#125;\n\n​\t\t模拟传入订单id，执行下订单业务，参数为虚拟设定，实际应为订单对应的实体类\n​\t\t业务层实现\n@Servicepublic class OrderServiceImpl implements OrderService &#123;    @Autowired    private MessageService messageService;        @Override    public void order(String id) &#123;        //一系列操作，包含各种服务调用，处理各种业务        System.out.println(&quot;订单处理开始&quot;);        //短信消息处理        messageService.sendMessage(id);        System.out.println(&quot;订单处理结束&quot;);        System.out.println();    &#125;&#125;\n\n​\t\t业务层转调短信处理的服务MessageService\n​\t\t表现层服务\n@RestController@RequestMapping(&quot;/orders&quot;)public class OrderController &#123;    @Autowired    private OrderService orderService;    @PostMapping(&quot;&#123;id&#125;&quot;)    public void order(@PathVariable String id)&#123;        orderService.order(id);    &#125;&#125;\n\n​\t\t表现层对外开发接口，传入订单id即可（模拟）\n短信处理业务\n​\t\t业务层接口\npublic interface MessageService &#123;    void sendMessage(String id);    String doMessage();&#125;\n\n​\t\t短信处理业务层接口提供两个操作，发送要处理的订单id到消息中间件，另一个操作目前暂且设计成处理消息，实际消息的处理过程不应该是手动执行，应该是自动执行，到具体实现时再进行设计\n​\t\t业务层实现\n@Servicepublic class MessageServiceImpl implements MessageService &#123;    private ArrayList&lt;String&gt; msgList = new ArrayList&lt;String&gt;();    @Override    public void sendMessage(String id) &#123;        System.out.println(&quot;待发送短信的订单已纳入处理队列，id：&quot;+id);        msgList.add(id);    &#125;    @Override    public String doMessage() &#123;        String id = msgList.remove(0);        System.out.println(&quot;已完成短信发送业务，id：&quot;+id);        return id;    &#125;&#125;\n\n​\t\t短信处理业务层实现中使用集合先模拟消息队列，观察效果\n​\t\t表现层服务\n@RestController@RequestMapping(&quot;/msgs&quot;)public class MessageController &#123;    @Autowired    private MessageService messageService;    @GetMapping    public String doMessage()&#123;        String id = messageService.doMessage();        return id;    &#125;&#125;\n\n​\t\t短信处理表现层接口暂且开发出一个处理消息的入口，但是此业务是对应业务层中设计的模拟接口，实际业务不需要设计此接口。\n","tags":["SpringBoot"]},{"title":"SpringCloud之Eureka服务注册中心","url":"/2022/07/03/SpringCloud%E4%B9%8BEureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/","content":"1、什么是EurekaNetflix 在设计Eureka 时，遵循的就是CAP原则\nCAP原则又称CAP定理，指的是在一个分布式系统中一致性（Consistency）可用性（Availability）分区容错性（Partition tolerance）CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。\n\nEureka是Netflix的一个子模块，也是核心模块之一。Eureka是一个基于REST的服务，用于定位服务， 以实现云端中间层服务发现和故障转移，服务注册与发现对于微服务来说是非常重要的，有了服务发现 与注册，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类 似于Dubbo的注册中心，比如Zookeeper；\n2、原理理解\nEureka基本的架构\nSpringcloud 封装了Netflix公司开发的Eureka模块来实现服务注册与发现 (对比Zookeeper).\nEureka采用了C-S的架构设计，EurekaServer作为服务注册功能的服务器，他是服务注册中心.\n而系统中的其他微服务，使用Eureka的客户端连接到EurekaServer并维持心跳连接。这样系统的维护人员就可以通过EurekaServer来监控系统中各个微服务是否正常运行，Springcloud 的一些其他模块 (比如Zuul) 就可以通过EurekaServer来发现系统中的其他微服务，并执行相关的逻辑.\n\n\n\n\n\n和Dubbo架构对比.\n\n\n\nEureka 包含两个组件：Eureka Server 和 Eureka Client.\n\nEureka Server 提供服务注册，各个节点启动后，回在EurekaServer中进行注册，这样Eureka Server中的服务注册表中将会储存所有课用服务节点的信息，服务节点的信息可以在界面中直观的看到.\n\nEureka Client 是一个Java客户端，用于简化EurekaServer的交互，客户端同时也具备一个内置的，使用轮询负载算法的负载均衡器。在应用启动后，将会向EurekaServer发送心跳 (默认周期为30秒) 。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除掉 (默认周期为90s).\n\n三大角色\n\nEureka Server：提供服务的注册与发现\nService Provider：服务生产方，将自身服务注册到Eureka中，从而使服务消费方能狗找到\nService Consumer：服务消费方，从Eureka中获取注册服务列表，从而找到消费服务\n\n\n\n3、服务构建1.eureka-server\nspringcloud-eureka-7001 模块建立\npom.xml 配置\n\n&lt;!--导包~--&gt;&lt;dependencies&gt;    &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt;    &lt;!--导入Eureka Server依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;        &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--热部署工具--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\napplication.yml\n\nserver:  port: 7001# Eureka配置eureka:  instance:    # Eureka服务端的实例名字    hostname: 127.0.0.1  client:    # 表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要)    register-with-eureka: false    # fetch-registry是false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务    fetch-registry: false    # Eureka监控页面~    service-url:      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123; server.port&#125;/eureka/      # 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个defaultZone地址\n\n\n主启动类\n\n@SpringBootApplication// @EnableEurekaServer 服务端的启动类，可以接受别人注册进来~@EnableEurekaServerpublic class EurekaServer_7001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaServer_7001.class,args);    &#125;&#125;\n\n\n启动成功后访问 http://localhost:7001/ 得到以下页面\n\n\n\nSystem Status：系统信息\nDS Replicas：服务器副本 \nInstances currently registered with Eureka：已注册的微服务列表 \nGeneral Info：一般信息 \nInstance Info：实例信息\n\n2.eureka-client调整之前创建的springlouc-provider-dept-8001\n\n导入Eureka依赖\n\n&lt;!--Eureka依赖--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n2.yaml 中配置 eureka 的支持\n# Eureka配置：配置服务注册中心地址eureka:  client:    service-url:      defaultZone: http://localhost:7001/eureka/\n\n3.为主启动类添加@EnableEurekaClient注解\n@SpringBootApplication// @EnableEurekaClient 开启Eureka客户端注解，在服务启动后自动向注册中心注册服务@EnableEurekaClientpublic class DeptProvider_8001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DeptProvider_8001.class,args);    &#125;&#125;\n\n截止目前：服务端也有了，客户端也有了，启动7001，再启动8001，测试访问\n\n4、actuator与注册微服务信息完善1.主机名称：服务名称修改\n在8001的yaml中修改一下配置\n# Eureka配置：配置服务注册中心地址eureka:  client:    service-url:      defaultZone: http://localhost:7001/eureka/  instance:    instance-id: springcloud-provider-dept-8001 #修改Eureka上的默认描述信息\n\n重启后刷新：\n\n2.访问信息有IP信息提示\nyaml中在增加一个配置\n# Eureka配置：配置服务注册中心地址eureka:  client:    service-url:      defaultZone: http://localhost:7001/eureka/  instance:    instance-id: springcloud-provider-dept-8001 #修改Eureka上的默认描述信息    prefer-ip-address: true # true访问路径可以显示IP地址\n\n3.info内容构建现在点击info，出现ERROR页面\n\n修改8001的pom文件，新增依赖！\n&lt;!--actuator完善监控信息--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\napplication.yml中添加配置\n# info配置info:# 项目的名称app.name: fang-springcloud# 公司的名称company.name: 天津理工大学\n\n重启项目测试：7001、8001,点击进入就可以看到对应的json串\n5、Eureka的自我保护机制之前出现的这些红色情况，没出现的，修改一个服务名，故意制造错误！\n\nEureKa自我保护机制：好死不如赖活着一句话总结就是：某时刻某一个微服务不可用，eureka不会立即清理，依旧会对该微服务的信息进行保存！\n\n默认情况下，当eureka server在一定时间内没有收到实例的心跳，便会把该实例从注册表中删除（默认是90秒），但是，如果短时间内丢失大量的实例心跳，便会触发eureka server的自我保护机制，比如在开发测试时，需要频繁地重启微服务实例，但是我们很少会把eureka server一起重启（因为在开发过程中不会修改eureka注册中心），当一分钟内收到的心跳数大量减少时，会触发该保护机制。可以在eureka管理界面看到Renews threshold和Renews(last min)，当后者（最后一分钟收到的心跳数）小于前者（心跳阈值）的时候，触发保护机制，会出现红色的警告：EMERGENCY!EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&#39;RE NOT.RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEGING EXPIRED JUST TO BE SAFE.从警告中可以看到，eureka认为虽然收不到实例的心跳，但它认为实例还是健康的，eureka会保护这些实例，不会把它们从注册表中删掉。\n该保护机制的目的是避免网络连接故障，在发生网络故障时，微服务和注册中心之间无法正常通信，但服务本身是健康的，不应该注销该服务，如果eureka因网络故障而把微服务误删了，那即使网络恢复了，该微服务也不会重新注册到eureka server了，因为只有在微服务启动的时候才会发起注册请求，后面只会发送心跳和服务列表请求，这样的话，该实例虽然是运行着，但永远不会被其它服务所感知。所以，eureka server在短时间内丢失过多的客户端心跳时，会进入自我保护模式，该模式下，eureka会保护注册表中的信息，不在注销任何微服务，当网络故障恢复后，eureka会自动退出保护模式。自我保护模式可以让集群更加健壮。\n但是我们在开发测试阶段，需要频繁地重启发布，如果触发了保护机制，则旧的服务实例没有被删除，这时请求有可能跑到旧的实例中，而该实例已经关闭了，这就导致请求错误，影响开发测试。所以，在开发测试阶段，我们可以把自我保护模式关闭，只需在eureka server配置文件中加上如下配置即可：eureka.server.enable-self-preservation=false【不推荐关闭自我保护机制】\n\n6、8001服务发现 Discovery对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息。【对外暴露服务】 \n修改springcloud-provider-dept-8001工程中的DeptController，新增方法\n/** * DiscoveryClient 可以用来获取一些配置的信息，得到具体的微服务！ */@Autowiredprivate DiscoveryClient client;/** * 获取一些注册进来的微服务的信息~， * * @return */@GetMapping(&quot;/dept/discovery&quot;)public Object discovery() &#123;    // 获取微服务列表的清单    List&lt;String&gt; services = client.getServices();    System.out.println(&quot;discovery=&gt;services:&quot; + services);    // 得到一个具体的微服务信息,通过具体的微服务id，applicaioinName；    List&lt;ServiceInstance&gt; instances = client.getInstances(&quot;SPRINGCLOUD-PROVIDER-DEPT&quot;);    for (ServiceInstance instance : instances) &#123;        System.out.println(                instance.getHost() + &quot;\\t&quot; + // 主机名称                        instance.getPort() + &quot;\\t&quot; + // 端口号                        instance.getUri() + &quot;\\t&quot; + // uri                        instance.getServiceId() // 服务id        );    &#125;    return this.client;&#125;\n\n主启动类中加入@EnableDiscoveryClient 注解\n@SpringBootApplication// @EnableEurekaClient 开启Eureka客户端注解，在服务启动后自动向注册中心注册服务@EnableEurekaClient// @EnableEurekaClient 开启服务发现客户端的注解，可以用来获取一些配置的信息，得到具体的微服务@EnableDiscoveryClientpublic class DeptProvider_8001 &#123;    ...&#125;\n\n启动Eureka服务，启动8001提供者 \n访问测试 http://localhost:8001/dept/discovery \n后台输出：\n\n7、consumer访问服务springcloud-consumer-dept-80 \n修改DeptConsumerController增加一个方法\n@GetMapping(&quot;/consumer/dept/discovery&quot;)public Object discovery()&#123;\treturn restTemplate.getForObject(REST_URL_PREFIX+&quot;/dept/discovery&quot;,Object.class);&#125;\n\n启动 80 项目进行测试！\n\n8、Eureka：集群环境配置\n1.初始化新建springcloud-eureka-7002、springcloud-eureka-7003 模块\n1.为pom.xml添加依赖 (与springcloud-eureka-7001相同)\n&lt;!--导包~--&gt;&lt;dependencies&gt;    &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt;    &lt;!--导入Eureka Server依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;        &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--热部署工具--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n2.application.yml配置(与springcloud-eureka-7001相同)\nserver:  port: 7003# Eureka配置eureka:  instance:    hostname: localhost # Eureka服务端的实例名字  client:    register-with-eureka: false # 表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要)    fetch-registry: false # fetch-registry如果为false,则表示自己为注册中心    service-url: # 监控页面~      # 重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/      defaultZone: http://$&#123;    eureka.instance.hostname&#125;:$&#123;    server.port&#125;/eureka/\n\n3.主启动类(与springcloud-eureka-7001相同)\n@SpringBootApplication// @EnableEurekaServer 服务端的启动类，可以接受别人注册进来~public class EurekaServer_7003 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaServer_7003.class,args);    &#125;&#125;\n\n2.集群成员相互关联配置一些自定义本机名字，找到本机hosts文件并打开\n\n在hosts文件最后加上，要访问的本机名称，默认是localhost\n\n修改application.yml的配置，如图为springcloud-eureka-7001配置，springcloud-eureka-7002&#x2F;springcloud-eureka-7003同样分别修改为其对应的名称即可\n\n在集群中使springcloud-eureka-7001关联springcloud-eureka-7002、springcloud-eureka-7003\n完整的springcloud-eureka-7001下的application.yml如下\nserver:  port: 7001#Eureka配置eureka:  instance:    hostname: eureka7001.com #Eureka服务端的实例名字  client:    register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要)    fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心    service-url: #监控页面~      #重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/      # 单机： defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/      # 集群（关联）：7001关联7002、7003      defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/\n\n同时在集群中使springcloud-eureka-7002关联springcloud-eureka-7001、springcloud-eureka-7003\n完整的springcloud-eureka-7002下的application.yml如下\nserver:  port: 7002#Eureka配置eureka:  instance:    hostname: eureka7002.com #Eureka服务端的实例名字  client:    register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要)    fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心    service-url: #监控页面~      #重写Eureka的默认端口以及访问路径 ---&gt;http://localhost:7001/eureka/      # 单机： defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/      # 集群（关联）：7002关联7001、7003      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7003.com:7003/eureka/\n\nspringcloud-eureka-7003配置方式同理可得.\n通过springcloud-provider-dept-8001下的yml配置文件，修改Eureka配置：配置服务注册中心地址\n# Eureka配置：配置服务注册中心地址eureka:  client:    service-url:      # 注册中心地址7001-7003      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/  instance:    instance-id: springcloud-provider-dept-8001 #修改Eureka上的默认描述信息\n\n这样模拟集群就搭建号了，就可以把一个项目挂载到三个服务器上了\n\n9、对比Zookeeper1. 回顾CAP原则RDBMS (MySQL\\Oracle\\sqlServer) &#x3D;&#x3D;&#x3D;&gt; ACID\nNoSQL (Redis\\MongoDB) &#x3D;&#x3D;&#x3D;&gt; CAP\n2. ACID是什么？\nA (Atomicity) 原子性\nC (Consistency) 一致性\nI (Isolation) 隔离性\nD (Durability) 持久性\n\n3. CAP是什么?\nC (Consistency) 强一致性\nA (Availability) 可用性\nP (Partition tolerance) 分区容错性\n\nCAP的三进二：CA、AP、CP\n4. CAP理论的核心\n一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求\n根据CAP原理，将NoSQL数据库分成了满足CA原则，满足CP原则和满足AP原则三大类\nCA：单点集群，满足一致性，可用性的系统，通常可扩展性较差\nCP：满足一致性，分区容错的系统，通常性能不是特别高\nAP：满足可用性，分区容错的系统，通常可能对一致性要求低一些\n\n\n\n5. 作为分布式服务注册中心，Eureka比Zookeeper好在哪里？著名的CAP理论指出，一个分布式系统不可能同时满足C (一致性) 、A (可用性) 、P (容错性)，由于分区容错性P再分布式系统中是必须要保证的，因此我们只能再A和C之间进行权衡。\n\nZookeeper 保证的是 CP —&gt; 满足一致性，分区容错的系统，通常性能不是特别高\nEureka 保证的是 AP —&gt; 满足可用性，分区容错的系统，通常可能对一致性要求低一些\n\nZookeeper保证的是CP\n当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接收服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30-120s，且选举期间整个zookeeper集群是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因为网络问题使得zookeeper集群失去master节点是较大概率发生的事件，虽然服务最终能够恢复，但是，漫长的选举时间导致注册长期不可用，是不可容忍的。\nEureka保证的是AP\nEureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时，如果发现连接失败，则会自动切换至其他节点，只要有一台Eureka还在，就能保住注册服务的可用性，只不过查到的信息可能不是最新的，除此之外，Eureka还有之中自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：\n\nEureka不在从注册列表中移除因为长时间没收到心跳而应该过期的服务\nEureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上 (即保证当前节点依然可用)\n当网络稳定时，当前实例新的注册信息会被同步到其他节点中\n\n因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪\n","tags":["SpringCloud"]},{"title":"SpringCloud之Feign：负载均衡(基于服务端)","url":"/2022/07/05/SpringCloud%E4%B9%8BFeign%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF/","content":"1、简介Feign是声明式Web Service客户端，它让微服务之间的调用变得更简单，类似controller调用service。SpringCloud集成了Ribbon和Eureka，可以使用Feigin提供负载均衡的http客户端\n只需要创建一个接口，然后添加注解即可~\nFeign，主要是社区版，大家都习惯面向接口编程。这个是很多开发人员的规范。调用微服务访问两种方法\n\n微服务名字 【ribbon】\n接口和注解 【feign】\n\nFeign能干什么？\n\nFeign旨在使编写Java Http客户端变得更容易\n前面在使用Ribbon + RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一个客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步的封装，由他来帮助我们定义和实现依赖服务接口的定义，在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它 (类似以前Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解)，即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon 时，自动封装服务调用客户端的开发量。\n\nFeign默认集成了Ribbon\n\n利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并且通过轮询实现了客户端的负载均衡，而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。\n\n2、Feign使用步骤1、参考springcloud-consumer-dept-ribbon-80 \n2、新建springcloud-consumer-dept-feign-80 \n\n修改主启动类名称 \n将springcloud-consumer-dept-80的内容都拷贝到 feign项目中 \n删除myrule文件夹\n修改主启动类的名称为 DeptConsumerFeign80\n\n3、springcloud-consumer-dept-feign-80修改pom.xml ， 添加对Feign的支持。\n&lt;!--Feign的依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n4、修改springcloud-api工程 \n\npom.xml添加feign的支持 \n新建一个Service包\n\n&lt;!--Feign的依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n\n编写接口 DeptClientService，并增加新的注解@FeignClient。\n\n// @FeignClient:微服务客户端注解,value:指定微服务的名字,这样就可以使Feign客户端直接找到对应的微服务@FeignClient(value = “SPRINGCLOUD-PROVIDER-DEPT”)public interface DeptClientService &#123;    @GetMapping(&quot;/dept/get/&#123;id&#125;&quot;)    public Dept queryById(@PathVariable(&quot;id&quot;) Long id);    @GetMapping(&quot;/dept/list&quot;)    public Dept queryAll();    @GetMapping(&quot;/dept/add&quot;)    public Dept addDept(Dept dept);&#125;\n\n5、springcloud-consumer-dept-feign-80工程修改Controller，添加上一步新建的DeptClientService\n@RestControllerpublic class DeptConsumerController &#123;    @Autowired    private DeptClientService deptClientService;    /**     * 消费方添加部门信息     * @param dept     * @return     */    @RequestMapping(&quot;/consumer/dept/add&quot;)    public boolean add(Dept dept) &#123;        return deptClientService.addDept(dept);    &#125;    /**     * 消费方根据id查询部门信息     * @param id     * @return     */    @RequestMapping(&quot;/consumer/dept/get/&#123;id&#125;&quot;)    public Dept get(@PathVariable(&quot;id&quot;) Long id) &#123;       return deptClientService.queryById(id);    &#125;    /**     * 消费方查询部门信息列表     * @return     */    @RequestMapping(&quot;/consumer/dept/list&quot;)    public List&lt;Dept&gt; list() &#123;        return deptClientService.queryAll();    &#125;&#125;\n\n6、microservicecloud-consumer-dept-feign工程修改主启动类，开启Feign使用！\n@SpringBootApplication@EnableEurekaClient// feign客户端注解,并指定要扫描的包以及配置接口DeptClientService@EnableFeignClients(basePackages = &#123; &quot;com.fang.springcloud&quot;&#125;)// 切记不要加这个注解，不然会出现404访问不到//@ComponentScan(&quot;com.fang.springcloud&quot;)public class FeignDeptConsumer_80 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(FeignDeptConsumer_80.class, args);    &#125;&#125;\n\n3、小结\nFeign通过接口的方法调用Rest服务 ( 之前是Ribbon+RestTemplate ) \n该请求发送给Eureka服务器 （http://MICROSERVICECLOUD-PROVIDER-DEPT/dept/list） \n通过Feign直接找到服务接口，由于在进行服务调用的时候融合了Ribbon技术，所以也支持负载均衡作 用！ \nfeign其实不是做负载均衡的,负载均衡是ribbon的功能,feign只是集成了ribbon而已,但是负载均衡的功能还是feign内置的ribbon再做,而不是feign。 feign的作用的替代RestTemplate,性能比较低，但是可以使代码可读性很强。\n\n","tags":["SpringCloud"]},{"title":"SpringCloud之Hystrix断路器","url":"/2022/07/05/SpringCloud%E4%B9%8BHystrix%E6%96%AD%E8%B7%AF%E5%99%A8/","content":"1、概述1、分布式系统面临的问题 \n复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免的失败！\n\n2、 服务雪崩\n多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的“扇出”，如果扇出的链路上某个微服务的调用响应时间过长，或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。\n\n对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几十秒内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障，这些都表示需要对故障和延迟进行隔离和管理，以达到单个依赖关系的失败而不影响整个应用程序或系统运行。\n我们需要，弃车保帅！\n3、什么是Hystrix？\nHystrix是一个应用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等，Hystrix 能够保证在一个依赖出问题的情况下，不会导致整个体系服务失败，避免级联故障，以提高分布式系统的弹性。\n“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控 (类似熔断保险丝) ，向调用方返回一个服务预期的，可处理的备选响应 (FallBack) ，而不是长时间的等待或者抛出调用方法无法处理的异常，这样就可以保证了服务调用方的线程不会被长时间，不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。\n\n3、Hystrix能干嘛？\n\n服务降级\n服务熔断\n服务限流\n接近实时的监控\n…\n\n当一切正常时，请求流可以如下所示：\n\n当许多后端系统中有一个潜在阻塞服务时，它可以阻止整个用户请求：\n\n随着大容量通信量的增加，单个后端依赖项的潜在性会导致所有服务器上的所有资源在几秒钟内饱和。\n应用程序中通过网络或客户端库可能导致网络请求的每个点都是潜在故障的来源。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，从而备份队列、线程和其他系统资源，从而导致更多跨系统的级联故障。\n\n当使用Hystrix包装每个基础依赖项时，上面的图表中所示的体系结构会发生类似于以下关系图的变化。每个依赖项是相互隔离的，限制在延迟发生时它可以填充的资源中，并包含在回退逻辑中，该逻辑决定在依赖项中发生任何类型的故障时要做出什么样的响应：\n\n官网资料：https://github.com/Netflix/Hystrix/wiki\n2、 服务熔断1、什么是服务熔断?\n当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阀值缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是：@HystrixCommand。\n服务熔断解决如下问题：\n\n当所依赖的对象不稳定时，能够起到快速失败的目的；\n快速失败后，能够根据一定的算法动态试探所依赖对象是否恢复。\n\n2、入门案例\n新建springcloud-provider-dept-hystrix-8001模块并拷贝springcloud-provider-dept–8001内的pom.xml、resource和Java代码进行初始化并调整。\n1.导入hystrix依赖\n&lt;!--导入Hystrix依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n2.调整yml配置文件\nserver:  port: 8001# mybatis配置mybatis:  # springcloud-api 模块下的pojo包  type-aliases-package: com.haust.springcloud.pojo  # 本模块下的mybatis-config.xml核心配置文件类路径  config-location: classpath:mybatis/mybatis-config.xml  # 本模块下的mapper配置文件类路径  mapper-locations: classpath:mybatis/mapper/*.xml# spring配置spring:  application:    #项目名    name: springcloud-provider-dept  datasource:    # 德鲁伊数据源    type: com.alibaba.druid.pool.DruidDataSource    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://localhost:3306/db01?useUnicode=true&amp;characterEncoding=utf-8    username: root    password: root# Eureka配置：配置服务注册中心地址eureka:  client:    service-url:      # 注册中心地址7001-7003      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/  instance:    instance-id: springcloud-provider-dept-hystrix-8001 #就是改这    prefer-ip-address: true #改为true后默认显示的是ip地址而不再是localhost#info配置info:  app.name: haust-springcloud #项目的名称  company.name: com.haust #公司的名称\n\n3.修改DeptController\n@RestControllerpublic class DeptController &#123;    @Autowired    private DeptService deptService;    /**     * 根据id查询部门信息     * 如果根据id查询出现异常,则走hystrixGet这段备选代码     * @param id     * @return     */    @HystrixCommand(fallbackMethod = &quot;hystrixGet&quot;)    @RequestMapping(&quot;/dept/get/&#123;id&#125;&quot;)//根据id查询    public Dept get(@PathVariable(&quot;id&quot;) Long id)&#123;        Dept dept = deptService.queryById(id);        if (dept==null)&#123;            throw new RuntimeException(&quot;这个id=&gt;&quot;+id+&quot;,不存在该用户，或信息无法找到~&quot;);        &#125;        return dept;    &#125;    /**     * 根据id查询备选方案(熔断)     * @param id     * @return     */    public Dept hystrixGet(@PathVariable(&quot;id&quot;) Long id)&#123;        return new Dept().setDeptno(id)                .setDname(&quot;这个id=&gt;&quot;+id+&quot;,没有对应的信息,null---@Hystrix~&quot;)                .setDb_source(&quot;在MySQL中没有这个数据库&quot;);    &#125;&#125;\n\n4.为主启动类添加对熔断的支持注解@EnableCircuitBreaker\n@SpringBootApplication@EnableEurekaClient // EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务@EnableDiscoveryClient // 服务发现~@EnableCircuitBreaker // 添加对熔断的支持注解public class HystrixDeptProvider_8001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(HystrixDeptProvider_8001.class,args);    &#125;&#125;\n\n5.测试 \n\n启动Eureka集群\n启动主启动类 HystrixDeptProvider_8001\n访问 http://localhost/consumer/dept/get/111\n\n\n\n而不适用熔断的springcloud-provider-dept–8001模块访问相同地址会出现下面状况:\n\n\n\n因此，为了避免因某个微服务后台出现异常或错误而导致整个应用或网页报错，使用熔断是必要的\n\n3、服务降级1、什么是服务降级?\n服务降级是指 当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理，或换种简单的方式处理，从而释放服务器资源以保证核心业务正常运作或高效运作。说白了，就是尽可能的把系统资源让给优先级高的服务。\n资源有限，而请求是无限的。如果在并发高峰期，不做服务降级处理，一方面肯定会影响整体服务的性能，严重的话可能会导致宕机某些重要的服务不可用。所以，一般在高峰期，为了保证核心功能服务的可用性，都要对某些服务降级处理。比如当双11活动时，把交易无关的服务统统降级，如查看蚂蚁深林，查看历史订单等等。\n服务降级主要用于什么场景呢？当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，可以将一些 不重要 或 不紧急 的服务或任务进行服务的 延迟使用 或 暂停使用。\n降级的方式可以根据业务来，可以延迟服务，比如延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行 ；或者在粒度范围内关闭服务，比如关闭相关文章的推荐。\n总结：整体资源快不够了，忍痛将某些服务先关掉，待渡过难关，再开启回来。\n\n由上图可得，当某一时间内服务A的访问量暴增，而B和C的访问量较少，为了缓解A服务的压力，这时候需要B和C暂时关闭一些服务功能，去承担A的部分服务，从而为A分担压力，叫做服务降级。\n2、服务降级需要考虑的问题\n\n那些服务是核心服务，哪些服务是非核心服务\n那些服务可以支持降级，那些服务不能支持降级，降级策略是什么\n除服务降级之外是否存在更复杂的业务放通场景，策略是什么？\n\n3、自动降级分类\n1）超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况\n2）失败次数降级：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况\n3）故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）\n4）限流降级：秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。\n4、入门案例\n1.在springcloud-api模块下的service包中新建降级配置类DeptClientServiceFallBackFactory.java\n@Componentpublic class DeptClientServiceFallBackFactory implements FallbackFactory &#123;    @Override    public DeptClientService create(Throwable cause) &#123;        return new DeptClientService() &#123;            @Override            public Dept queryById(Long id) &#123;                return new Dept()                        .setDeptno(id)                        .setDname(&quot;id=&gt;&quot; + id + &quot;没有对应的信息，客户端提供了降级的信息，这个服务现在已经被关闭&quot;)                        .setDb_source(&quot;没有数据~&quot;);            &#125;            @Override            public List&lt;Dept&gt; queryAll() &#123;                return null;            &#125;            @Override            public Boolean addDept(Dept dept) &#123;                return false;            &#125;        &#125;;    &#125;&#125;\n\n2.在DeptClientService中指定降级配置类DeptClientServiceFallBackFactory\n@Component //注册到spring容器中//@FeignClient:微服务客户端注解,value:指定微服务的名字,这样就可以使Feign客户端直接找到对应的微服务@FeignClient(value = &quot;SPRINGCLOUD-PROVIDER-DEPT&quot;,fallbackFactory = DeptClientServiceFallBackFactory.class)//fallbackFactory指定降级配置类public interface DeptClientService &#123;    @GetMapping(&quot;/dept/get/&#123;id&#125;&quot;)    public Dept queryById(@PathVariable(&quot;id&quot;) Long id);    @GetMapping(&quot;/dept/list&quot;)    public List&lt;Dept&gt; queryAll();    @GetMapping(&quot;/dept/add&quot;)    public Boolean addDept(Dept dept);&#125;\n\n3.在springcloud-consumer-dept-feign模块中开启降级：\nserver:  port: 80# Eureka配置eureka:  client:    register-with-eureka: false # 不向 Eureka注册自己    service-url: # 从三个注册中心中随机取一个去访问      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/# 开启降级feign.hystrixfeign:  hystrix:    enabled: true\n\n4.测试 \n\n启动eureka集群 \n启动 springcloud-provider-dept-hystrix-8001 \n启动 springcloud-consumer-dept-feign-80 \n正常访问测试 http://localhost/consumer/dept/get/1 \n故意关闭微服务启动 springcloud-provider-dept-hystrix-8001 \n客户端自己调用提示 http://localhost/consumer/dept/get/1\n\n\n\n此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时 也会获得提示信息而不会挂起耗死服务器。\n\n4、服务熔断和降级的区别\n服务熔断—&gt;服务端：某个服务超时或异常，引起熔断~，类似于保险丝(自我熔断)\n服务降级—&gt;客户端：从整体网站请求负载考虑，当某个服务熔断或者关闭之后，服务将不再被调用，此时在客户端，我们可以准备一个 FallBackFactory ，返回一个默认的值(缺省值)。会导致整体的服务下降，但是好歹能用，比直接挂掉强。\n触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）\n实现方式不太一样，服务降级具有代码侵入性(由控制器完成&#x2F;或自动降级)，熔断一般称为自我熔断。\n\n熔断，降级，限流：\n限流：限制并发的请求访问量，超过阈值则拒绝；\n降级：服务分优先级，牺牲非核心服务（不可用），保证核心服务稳定；从整体负荷考虑；\n熔断：依赖的下游服务故障触发熔断，避免引发本系统崩溃；系统自动执行和恢复\n5、Dashboard 流监控\n除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控（Hystrix Dashboard），Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求，多少成功，多少失败等等。 \n\nNetflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控，SpringCloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面！\n\n\n\n1、新建springcloud-consumer-hystrix-dashboard模块\n2、添加依赖\n&lt;!--Hystrix依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--dashboard依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--Ribbon--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--Eureka--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--实体类+web--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.haust&lt;/groupId&gt;    &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--热部署--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;\n\n3、主启动类\n@SpringBootApplication// 开启Dashboard@EnableHystrixDashboardpublic class DeptConsumerDashboard_9001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DeptConsumerDashboard_9001.class,args);    &#125;&#125;\n\n4、给springcloud-provider-dept-hystrix-8001模块下的主启动类添加如下代码,添加监控\n@SpringBootApplication@EnableEurekaClient //EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务public class DeptProvider_8001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DeptProvider_8001.class,args);    &#125;    //增加一个 Servlet    @Bean    public ServletRegistrationBean hystrixMetricsStreamServlet()&#123;        ServletRegistrationBean registrationBean = new ServletRegistrationBean(new HystrixMetricsStreamServlet());        //访问该页面就是监控页面        registrationBean.addUrlMappings(&quot;/actuator/hystrix.stream&quot;);        return registrationBean;    &#125;&#125;\n\n5、所有的Provider微服务提供类(8001&#x2F;8002&#x2F;8003) 都需要监控依赖配置\n&lt;!--actuator监控信息完善--&gt;&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n6、访问：http://localhost:9001/hystrix\n\n7、监控测试\n\n多次刷新 http://localhost:8001/dept/get/1\n多次刷新 http://localhost:8001/dept/get/1\n添加监控地址\nDelay : 该参数用来控制服务器上轮询监控信息的延迟时间，默认为2000毫秒，可以通过配置 该属性来降低客户端的网络和CPU消耗 \nTitle ： 该参数对应了头部标题HystrixStream之后的内容，默认会使用具体监控实例URL，可 以通过配置该信息来展示更合适的标题。\n\n\n\n\n\n监控结果\n\n\n\n如何看\n七色\n\n\n\n\n\n一圈 \n实心圆：共有两种含义，他通过颜色的变化代表了实例的健康程度 \n它的健康程度从绿色&lt;黄色&lt;橙色&lt;红色 递减 \n该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大，该实心圆就越大，所以通过该实心圆的展示，就可以在大量的实例中快速发现故障实例和高压力实例\n\n\n\n\n\n一线 \n曲线：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的上升和下降趋势！\n\n\n\n\n\n整图说明\n\n\n","tags":["SpringCloud"]},{"title":"SpringCloud之Rest微服务构建","url":"/2022/07/03/SpringCloud%E4%B9%8BRest%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%84%E5%BB%BA/","content":"1、 介绍\n我们会使用一个Dept部门模块做一个微服务通用案例Consumer消费者(Client)通过REST调用Provider提供者(Server)提供的服务。\n回顾Spring，SpringMVC，Mybatis等以往学习的知识。\nMaven的分包分模块架构复习。\n\n一个简单的Maven模块结构是这样的：-- app-parent: 一个父项目(app-parent)聚合了很多子项目(app-util\\app-dao\\app-web...)  |-- pom.xml  |  |-- app-core  ||---- pom.xml  |  |-- app-web  ||---- pom.xml  ......\n\n一个父工程带着多个Moudule子模块\nMicroServiceCloud父工程(Project)下初次带着3个子模块(Module)\n\nspringcloud-api 【封装的整体entity &#x2F; 接口 &#x2F; 公共配置等】 \nspringcloud-provider-dept-8001【服务提供者】 \nspringcloud-consumer-dept-80【服务消费者】\n\n2、 创建父工程\n新建父工程项目springcloud，切记Packageing是pom模式\n主要是定义POM文件，将后续各个子模块公用的jar包等统一提取出来，类似一个抽象父类\n\npom.xml如下：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.fang&lt;/groupId&gt;    &lt;artifactId&gt;springcloud&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;!--打包方式  pom--&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;properties&gt;        &lt;junit.version&gt;4.12&lt;/junit.version&gt;        &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;        &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt;    &lt;/properties&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;                &lt;version&gt;0.2.0.RELEASE&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!--springCloud的依赖--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;Greenwich.SR1&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!--SpringBoot--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;                &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!--数据库--&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                &lt;version&gt;5.1.47&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;                &lt;artifactId&gt;druid&lt;/artifactId&gt;                &lt;version&gt;1.1.10&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--SpringBoot 启动器--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;1.3.2&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--日志测试~--&gt;            &lt;dependency&gt;                &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;                &lt;artifactId&gt;logback-core&lt;/artifactId&gt;                &lt;version&gt;1.2.3&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;junit&lt;/groupId&gt;                &lt;artifactId&gt;junit&lt;/artifactId&gt;                &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;log4j&lt;/groupId&gt;                &lt;artifactId&gt;log4j&lt;/artifactId&gt;                &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                &lt;artifactId&gt;lombok&lt;/artifactId&gt;                &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;&lt;/project&gt;\n\n3、创建api公共模块新建springcloud-api模块\n\n可以观察发现，在父工程中多了一个Modules\n\n编写springcloud-api 的 pom.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt;        &lt;groupId&gt;com.fang&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;!--当前Module的名字--&gt;    &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt;    &lt;!--当前Module需要到的jar包，按自己需求添加，如果父项目已经包含了，可以不用写版本号--&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\n创建部门数据库脚本，数据库名：springcloud01\nCREATE TABLE dept(        deptno BIGINT NOT NULL PRIMARY KEY AUTO_INCREMENT,        dname VARCHAR(60),        db_source VARCHAR(60));INSERT INTO dept(dname,db_source) VALUES(&#x27;开发部&#x27;,DATABASE());INSERT INTO dept(dname,db_source) VALUES(&#x27;人事部&#x27;,DATABASE());INSERT INTO dept(dname,db_source) VALUES(&#x27;财务部&#x27;,DATABASE());INSERT INTO dept(dname,db_source) VALUES(&#x27;市场部&#x27;,DATABASE());INSERT INTO dept(dname,db_source) VALUES(&#x27;运维部&#x27;,DATABASE());SELECT * FROM dept;\n\n编写实体类，注意：实体类都序列化！\npackage com.fang.springcloud.pojo;import lombok.Data;import lombok.NoArgsConstructor;import lombok.experimental.Accessors;import java.io.Serializable;@NoArgsConstructor@Data@Accessors(chain = true) //链式写法public class Dept implements Serializable &#123; //Dept(实体类) orm mysql-&gt;Dept(表) 类表关系映射    private Long deptno; //主键    private String dname; //部门名称    //来自哪个数据库，因为微服务架构可以一个服务对应一个数据库，同一个信息被存到多个不同的数据库    private String db_source;    public Dept(String dname) &#123;        this.dname = dname;    &#125;    /*    链式写法：    Dept dept = new Dept()    dept.setDeptno(11L).setDname(&quot;school&quot;).setDb_source(&quot;DB01&quot;);    **/&#125;\n\n3、创建provider模块新建springcloud-provider-dept-8001模块 \n编辑pom.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt;        &lt;groupId&gt;com.fang&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;springcloud-provider-dept-8001&lt;/artifactId&gt;    &lt;dependencies&gt;        &lt;!--引入自定义的模块，我们就可以使用这个模块中的类了--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fang&lt;/groupId&gt;            &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-core&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-test&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- spring-boot-devtools --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\n编辑 application.yml\nserver:  port: 8001#mybatis的配置mybatis:  config-location: classpath:mybatis/mybatis-config.xml  type-aliases-package: com.fang.springcloud.pojo  mapper-locations:    - classpath:mybatis/mapper/**/*.xml#spring的相关配置spring:  application:    name: springcloud-provider-dept  datasource:    type: com.alibaba.druid.pool.DruidDataSource # 数据源    driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动    url: jdbc:mysql://localhost:3306/springcloud01 #数据库名称    username: root    password: 123456    dbcp2:      min-idle: 5 #数据库连接池的最小维持连接数      initial-size: 5 #初始化连接数      max-total: 5 #最大连接数      max-wait-millis: 200 #等待连接获取的最大超时时间\n\n根据配置新建mybatis-config.xml文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;!--开启二级缓存--&gt;        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;    &lt;/settings&gt;&lt;/configuration&gt;\n\n编写部门的dao接口\nimport com.fang.springcloud.pojo.Dept;import org.apache.ibatis.annotations.Mapper;import java.util.List;@Mapperpublic interface DeptDao &#123;    public boolean addDept(Dept dept); //添加一个部门    public Dept queryById(Long id); //根据id查询部门    public List&lt;Dept&gt; queryAll(); //查询所有部门&#125;\n\n接口对应的Mapper.xml文件 mybatis\\mapper\\DeptMapper.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.fang.springcloud.dao.DeptDao&quot;&gt;    &lt;insert id=&quot;addDept&quot; parameterType=&quot;Dept&quot;&gt;        insert into dept (dname,db_source) values (#&#123;dname&#125;,DATABASE());    &lt;/insert&gt;    &lt;select id=&quot;queryById&quot; resultType=&quot;Dept&quot; parameterType=&quot;Long&quot;&gt;        select deptno,dname,db_source from dept where deptno = #&#123;deptno&#125;;    &lt;/select&gt;    &lt;select id=&quot;queryAll&quot; resultType=&quot;Dept&quot;&gt;        select deptno,dname,db_source from dept;    &lt;/select&gt;&lt;/mapper&gt;\n\n创建Service服务层接口\npackage com.fang.springcloud.service;import com.fang.springcloud.pojo.Dept;import java.util.List;public interface DeptService &#123;    public boolean addDept(Dept dept); //添加一个部门    public Dept queryById(Long id); //根据id查询部门    public List&lt;Dept&gt; queryAll(); //查询所有部门&#125;\n\nServiceImpl实现类\npackage com.fang.springcloud.service.impl;import com.fang.springcloud.dao.DeptDao;import com.fang.springcloud.pojo.Dept;import com.fang.springcloud.service.DeptService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class DeptServiceImpl implements DeptService &#123;    //自动注入    @Autowired    private DeptDao deptDao;    @Override    public boolean addDept(Dept dept) &#123;        return deptDao.addDept(dept);    &#125;    @Override    public Dept queryById(Long id) &#123;        return deptDao.queryById(id);    &#125;    @Override    public List&lt;Dept&gt; queryAll() &#123;        return deptDao.queryAll();    &#125;&#125;\n\nDeptController提供REST服务\npackage com.fang.springcloud.controller;import com.fang.springcloud.pojo.Dept;import com.fang.springcloud.service.DeptService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;@RestController@RequestMapping(&quot;/dept&quot;)public class DeptController &#123;    @Autowired    private DeptService service;    // @RequestBody// 如果参数是放在请求体中，传入后台的话，那么后台要用@RequestBody才能接收到    @PostMapping(&quot;/add&quot;)    public boolean addDept(@RequestBody Dept dept) &#123;        return service.addDept(dept);    &#125;    @GetMapping(&quot;/get/&#123;id&#125;&quot;)    public Dept get(@PathVariable(&quot;id&quot;) Long id) &#123;        return service.queryById(id);    &#125;    @GetMapping(&quot;/list&quot;)    public List&lt;Dept&gt; queryAll() &#123;        return service.queryAll();    &#125;&#125;\n\n编写DeptProvider的主启动类\npackage com.fang.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class DeptProvider8001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DeptProvider8001.class,args);    &#125;&#125;\n\n4、创建consumer模块新建springcloud-consumer-dept-80模块 \n编辑pom.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt;        &lt;groupId&gt;com.fang&lt;/groupId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;springcloud-consumer-dept-80&lt;/artifactId&gt;    &lt;description&gt;部门微服务消费者&lt;/description&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fang&lt;/groupId&gt;            &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--热部署--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project\n\napplication.yml 配置文件\nserver:  port: 80\n\n新建一个ConfigBean包注入 RestTemplate！\npackage com.fang.springcloud.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;@Configurationpublic class ConfigBean &#123;    //@Configuration -- spring  applicationContext.xml    //配置负载均衡实现RestTemplate    // IRule    // RoundRobinRule 轮询    // RandomRule 随机    // AvailabilityFilteringRule ： 会先过滤掉，跳闸，访问故障的服务~，对剩下的进行轮询~    // RetryRule ： 会先按照轮询获取服务~，如果服务获取失败，则会在指定的时间内进行，重试    @Bean    public RestTemplate getRestTemplate()&#123;        return new RestTemplate();    &#125;&#125;\n\n创建Controller包，编写DeptConsumerController类\npackage com.fang.springcloud.controller;import com.fang.springcloud.pojo.Dept;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import java.util.List;@RestControllerpublic class DeptConsumerController &#123;    /**     * 理解：消费者，不应该有service层~     * RestTemplate .... 供我们直接调用就可以了！ 注册到Spring中     * (地址：url, 实体：Map ,Class&lt;T&gt; responseType)     * 提供多种便捷访问远程http服务的方法，简单的Restful服务模板~     */    @Autowired    private RestTemplate restTemplate;    /**     * 服务提供方地址前缀     * &lt;p&gt;     * Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问     */    private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;;    /**     * 消费方添加部门信息     * @param dept     * @return     */    @RequestMapping(&quot;/consumer/dept/add&quot;)    public boolean add(Dept dept) &#123;        // postForObject(服务提供方地址(接口),参数实体,返回类型.class)        return restTemplate.postForObject(REST_URL_PREFIX + &quot;/dept/add&quot;, dept, Boolean.class);    &#125;    /**     * 消费方根据id查询部门信息     * @param id     * @return     */    @RequestMapping(&quot;/consumer/dept/get/&#123;id&#125;&quot;)    public Dept get(@PathVariable(&quot;id&quot;) Long id) &#123;        // getForObject(服务提供方地址(接口),返回类型.class)        return restTemplate.getForObject(REST_URL_PREFIX + &quot;/dept/get/&quot; + id, Dept.class);    &#125;    /**     * 消费方查询部门信息列表     * @return     */    @RequestMapping(&quot;/consumer/dept/list&quot;)    public List&lt;Dept&gt; list() &#123;        return restTemplate.getForObject(REST_URL_PREFIX + &quot;/dept/list&quot;, List.class);    &#125;&#125;\n\n主启动类\npackage com.fang.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class DeptConsumer80 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DeptConsumer80.class,args);    &#125;&#125;\n","tags":["SpringCloud"]},{"title":"SpringCloud之Ribbon：负载均衡(基于客户端)","url":"/2022/07/04/SpringCloud%E4%B9%8BRibbon%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-%E5%9F%BA%E4%BA%8E%E5%AE%A2%E6%88%B7%E7%AB%AF/","content":"1、负载均衡以及Ribbon\nRibbon是什么？\n\n\nSpring Cloud Ribbon 是基于Netflix Ribbon 实现的一套客户端负载均衡的工具。\n简单的说，Ribbon 是 Netflix 发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将 Netflix 的中间层服务连接在一起。Ribbon 的客户端组件提供一系列完整的配置项，如：连接超时、重试等。简单的说，就是在配置文件中列出 LoadBalancer (简称LB：负载均衡) 后面所有的及其，Ribbon 会自动的帮助你基于某种规则 (如简单轮询，随机连接等等) 去连接这些机器。我们也容易使用 Ribbon 实现自定义的负载均衡算法！\n\n\nRibbon能干嘛？\n\n\nLB，即负载均衡 (LoadBalancer) ，在微服务或分布式集群中经常用的一种应用。\n\n负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高用)。\n\n常见的负载均衡软件有 Nginx、Lvs 等等。\n\nDubbo、SpringCloud 中均给我们提供了负载均衡，SpringCloud 的负载均衡算法可以自定义。\n\n负载均衡简单分类：\n\n集中式LB\n即在服务的提供方和消费方之间使用独立的LB设施，如**Nginx(反向代理服务器)**，由该设施负责把访问请求通过某种策略转发至服务的提供方！\n\n\n进程式 LB\n将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个合适的服务器。\nRibbon 就属于进程式LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址！\n\n\n\nRibbon的github地址 ： https://github.com/NetFlix/ribbon\n\n\n\n2、Ribbon配置初步1.向pom.xml中添加Ribbon和Eureka依赖\n&lt;!--Ribbon--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--Eureka: Ribbon需要从Eureka服务中心获取要拿什么--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n2.在application.yml文件中配置Eureka\n# Eureka配置eureka:  client:    register-with-eureka: false # 不向 Eureka注册自己    service-url: # 从三个注册中心中随机取一个去访问      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/\n\n3.主启动类加上@EnableEurekaClient注解，开启Eureka\n//Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号@SpringBootApplication@EnableEurekaClient //开启Eureka 客户端public class DeptConsumer_80 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DeptConsumer_80.class, args);    &#125;&#125;\n\n4.自定义Spring配置类：ConfigBean.java 配置负载均衡实现RestTemplate\n@Configurationpublic class ConfigBean &#123;    //@Configuration -- spring  applicationContext.xml    @LoadBalanced //配置负载均衡实现RestTemplate    @Bean    public RestTemplate getRestTemplate() &#123;        return new RestTemplate();    &#125;&#125;\n\n5.修改DeptConsumerController客户端访问类，之前的写的地址是写死的，现在需要变化！\n\n//Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问//private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;;private static final String REST_URL_PREFIX = &quot;http://SPRINGCLOUD-PROVIDER-DEPT&quot;;\n\n6.测试 \n\nhttp://localhost/consumer/dept/get/1 \nhttp://localhost/consumer/dept/list\n\n7.小结\nRibbon和Eureka整合后Consumer可以直接调用服务而不用再关心地址和端口号！\n3、使用Ribbon实现负载均衡流程图：\n\nRibbon在工作时分成两步：\n\n先选择EurekaServer，它优先选择在同一个区域内负载均衡较少的Server。\n在根据用户指定的策略，在从server去到的服务注册列表中选择一个地址。 其中Ribbon提供了多种策略，比如轮询（默认），随机和根据响应时间加权重,,,等等\n\n测试： \n1.新建两个服务提供者Moudle：springcloud-provider-dept-8003、springcloud-provider-dept-8002\n2.参照springcloud-provider-dept-8001 依次为另外两个Moudle添加pom.xml依赖 、resourece下的mybatis和application.yml配置，Java代码\n3.启动所有服务测试(根据自身电脑配置决定启动服务的个数)，访问http://eureka7001.com:7002/查看结果\n4.新建8002&#x2F;8003数据库，各自微服务分别连接各自的数据库，复制DB1！ \n\n新建springcloud01 \n新建springcloud02 \n新建springcloud03\n\n5.修改8002&#x2F;8003各自的YML文件 \n\n端口 \n数据库连接 \n实例名也需要修改\n\ninstance:\tinstance-id: springcloud-provider-dept8003\n\n\n对外暴露的统一的服务实例名【三个服务名字必须一致！】\n\napplication:\tname: springcloud-provider-dept\n\n6.启动3个Eureka集群配置区 \n\nhttp://localhost:8001/dept/list \nhttp://localhost:8002/dept/list\nhttp://localhost:8003/dept/list \n启动springcloud-consumer-dept-ribbon-80 \n客户端通过Ribbon完成负载均衡并访问上一步的Dept微服务 http://localhost/consumer/dept/list 多刷新几次注意观察结果！\n\n总结： Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和 Eureka结合只是其中的一个实例。\n4、Ribbon核心组件IRule1.IRule：根据特定算法从服务列表中选取一个要访问的服务！\n\nRoundRobinRule【轮询】 \nRandomRule【随机】 \nAvailabilityFilterRule【会先过滤掉由于多次访问故障而处于断路器跳闸的服务，还有并发的连接 数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问】 \nWeightedResponseTimeRule【根据平均响应时间计算所有服务的权重，响应时间越快服务权重越 大，被选中的概率越高，刚启动时如果统计信息不足，则使用RoundRobinRule策略，等待统计信 息足够，会切换到WeightedResponseTimeRule】 \nRetryRule【先按照RoundRobinRule的策略获取服务，如果获取服务失败，则在指定时间内会进行 重试，获取可用的服务】 \nBestAvailableRule【会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并 发量最小的服务】 \nZoneAvoidanceRule【默认规则，复合判断server所在区域的性能和server的可用性选择服务器】\n\n2.查看分析源码： \n\nIRule \nILoadBalancer \nAbstractLoadBalancer \nAbstractLoadBalancerRule：这个抽象父类十分重要！核心\nRoundRobinRule\n\n分析一下方法：\npublic Server choose(ILoadBalancer lb, Object key) &#123;        if (lb == null) &#123;            log.warn(&quot;no load balancer&quot;);            return null;        &#125;        Server server = null;        int count = 0;        while (server == null &amp;&amp; count++ &lt; 10) &#123;            List&lt;Server&gt; reachableServers = lb.getReachableServers();            List&lt;Server&gt; allServers = lb.getAllServers();            int upCount = reachableServers.size();            int serverCount = allServers.size();            if ((upCount == 0) || (serverCount == 0)) &#123;                log.warn(&quot;No up servers available from load balancer: &quot; + lb);                return null;            &#125;            int nextServerIndex = incrementAndGetModulo(serverCount);    //每一次得到下一个ServerIndex，也就是所谓的轮询            server = allServers.get(nextServerIndex);            if (server == null) &#123;                /* Transient. */                Thread.yield();                continue;            &#125;            if (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;                return (server);            &#125;        // Next.            server = null;        &#125;        if (count &gt;= 10) &#123;            log.warn(&quot;No available alive servers after 10 tries from load            balancer: &quot;            + lb);        &#125;        return server;&#125;\n\n切换为随机策略实现试试，在ConfigBean中添加方法\n@Configurationpublic class ConfigBean &#123;    //@Configuration -- spring  applicationContext.xml    /**     * IRule:     * RoundRobinRule 轮询策略     * RandomRule 随机策略     * AvailabilityFilteringRule ： 会先过滤掉，跳闸，访问故障的服务~，对剩下的进行轮询~     * RetryRule ： 会先按照轮询获取服务~，如果服务获取失败，则会在指定的时间内进行，重试     */    @Bean    public IRule myRule() &#123;        return new RandomRule();//使用随机策略        //return new RoundRobinRule();//使用轮询策略        //return new AvailabilityFilteringRule();//使用轮询策略        //return new RetryRule();//使用轮询策略    &#125;&#125;\n\n重启80服务进行访问测试，查看运行结果！【注意，可能服务长时间不使用会崩】 http://localhost/consumer/dept/list\n5、自定义Ribbon1.主启动类添加@RibbonClient注解\n在启动该微服务的时候就能去加载我们自定义的Ribbon配置类，从而使配置类生效，例如:\n//在微服务启动的时候就能加载自定义的Ribbon类(自定义的规则会覆盖原有默认的规则)@RibbonClient(name = &quot;SPRINGCLOUD-PROVIDER-DEPT&quot;,configuration = MyRule.class)//开启负载均衡,并指定自定义的规则\n\n2.注意配置细节\n官方文档明确给出了警告： 这个自定义配置类不能放在@ComponentScan所扫描的当前包以及子包下，否则我们自定义的这个配置 类就会被所有的Ribbon客户端所共享，也就是说达不到特殊化定制的目的了！\n\n3.步骤 \n\n由于有以上配置细节原因，我们建立一个包 com.fang.myrule\n在这里新建一个自定义规则的Rubbion类\n\n@Configurationpublic class MySelfRule &#123;    @Bean    public IRule myRule()&#123;        return new RandomRule(); //Ribbon默认是轮询，我们自定义为随机算法    &#125;&#125;\n\n\n主启动类开启负载均衡并指定自定义的Rubbion配置类\n\n//Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号@SpringBootApplication@EnableEurekaClient//在微服务启动的时候就能加载自定义的Ribbon类(自定义的规则会覆盖原有默认的规则)@RibbonClient(name = &quot;SPRINGCLOUD-PROVIDER-DEPT&quot;,configuration = MySelfRule.class)//开启负载均衡,并指定自定义的规则public class DeptConsumer_80 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DeptConsumer_80.class, args);    &#125;&#125;\n\n4.自定义规则深度解析\n1、问题：依旧轮询策略，但是加上新需求，每个服务器要求被调用5次，就是以前每一个机器一次，现在每个机器5次； \n2、解析源码：RandomRule.java ， IDEA直接点击进去，复制出来，变成我们自己的类 MyRandomRule \npublic class RandomRule extends AbstractLoadBalancerRule &#123;    /**     * Randomly choose from all living servers     */    @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = &quot;RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE&quot;)        //ILoadBalancer选择的随机算法    public Server choose(ILoadBalancer lb, Object key) &#123;        if (lb == null) &#123;            return null;        &#125;        Server server = null;        while (server == null) &#123;            //查看线程是否中断了            if (Thread.interrupted()) &#123;                return null;            &#125;            //Reachable： 可及；可到达；够得到            List&lt;Server&gt; upList = lb.getReachableServers();//活着的服务            List&lt;Server&gt; allList = lb.getAllServers();//获取所有的服务            int serverCount = allList.size();            if (serverCount == 0) &#123;                /*                 * No servers. End regardless of pass, because subsequent passes                 * only get more restrictive.                 */                return null;            &#125;            int index = chooseRandomInt(serverCount);//生成区间随机数！            server = upList.get(index);//从活着的服务中，随机取出一个            if (server == null) &#123;                /*                 * The only time this should happen is if the server list were                 * somehow trimmed. This is a transient condition. Retry after                 * yielding.                 */                Thread.yield();                continue;            &#125;            if (server.isAlive()) &#123;                return (server);            &#125;            // Shouldn&#x27;t actually happen.. but must be transient or a bug.            server = null;            Thread.yield();        &#125;        return server;    &#125;//随机    protected int chooseRandomInt(int serverCount) &#123;        return ThreadLocalRandom.current().nextInt(serverCount);    &#125;\t@Override\tpublic Server choose(Object key) &#123;\t\treturn choose(getLoadBalancer(), key);\t&#125;&#125;\n\n参考源码修改为我们需求要求的MyRandomRule.java\npublic class MyRandomRule extends AbstractLoadBalancerRule &#123;    /**     * 每个服务访问5次则换下一个服务(总共3个服务)     * &lt;p&gt;     * total=0,默认=0,如果=5,指向下一个服务节点     * index=0,默认=0,如果total=5,index+1     */    private int total = 0;//被调用的次数    private int currentIndex = 0;//当前是谁在提供服务    //@edu.umd.cs.findbugs.annotations.SuppressWarnings(value = &quot;RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE&quot;)    public Server choose(ILoadBalancer lb, Object key) &#123;        if (lb == null) &#123;            return null;        &#125;        Server server = null;        while (server == null) &#123;            if (Thread.interrupted()) &#123;                return null;            &#125;            List&lt;Server&gt; upList = lb.getReachableServers();//获得当前活着的服务            List&lt;Server&gt; allList = lb.getAllServers();//获取所有的服务            int serverCount = allList.size();            if (serverCount == 0) &#123;                /*                 * No servers. End regardless of pass, because subsequent passes                 * only get more restrictive.                 */                return null;            &#125;            //int index = chooseRandomInt(serverCount);//生成区间随机数            //server = upList.get(index);//从或活着的服务中,随机获取一个            //=====================自定义代码=========================            if (total &lt; 5) &#123;                server = upList.get(currentIndex);                total++;            &#125; else &#123;                total = 0;                currentIndex++;                if (currentIndex &gt; upList.size()) &#123;                    currentIndex = 0;                &#125;                server = upList.get(currentIndex);//从活着的服务中,获取指定的服务来进行操作            &#125;            //======================================================            if (server == null) &#123;                /*                 * The only time this should happen is if the server list were                 * somehow trimmed. This is a transient condition. Retry after                 * yielding.                 */                Thread.yield();                continue;            &#125;            if (server.isAlive()) &#123;                return (server);            &#125;            // Shouldn&#x27;t actually happen.. but must be transient or a bug.            server = null;            Thread.yield();        &#125;        return server;    &#125;    protected int chooseRandomInt(int serverCount) &#123;        return ThreadLocalRandom.current().nextInt(serverCount);    &#125;    @Override    public Server choose(Object key) &#123;        return choose(getLoadBalancer(), key);    &#125;    @Override    public void initWithNiwsConfig(IClientConfig clientConfig) &#123;        // TODO Auto-generated method stub    &#125;&#125;\n\n调用，在我们自定义的IRule方法中返回刚才我们写好的随机算法类\n @Configurationpublic class MySelfRule &#123;         @Bean    public IRule myRule()&#123;                 return new RandomRule(); //Ribbon默认是轮询，我们自定义为随机算法        &#125;&#125;\n\n","tags":["SpringCloud"]},{"title":"SpringCloud之Spring Cloud Config 分布式配置","url":"/2022/07/06/SpringCloud%E4%B9%8BSpring-Cloud-Config-%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE/","content":"Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持。使用Config Server，您可以在所有环境中管理应用程序的外部属性。客户端和服务器上的概念映射与Spring Environment和PropertySource抽象相同，因此它们与Spring应用程序非常契合，但可以与任何以任何语言运行的应用程序一起使用。随着应用程序通过从开发人员到测试和生产的部署流程，您可以管理这些环境之间的配置，并确定应用程序具有迁移时需要运行的一切。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。很容易添加替代实现，并使用Spring配置将其插入。\n1、概述1、分布式系统面临的–配置文件问题\n微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要必要的配置信息才能运行，所以一套集中式的，动态的配置管理设施是必不可少的。spring cloud提供了configServer来解决这个问题，我们每一个微服务自己带着一个application.yml，那上百个的配置文件修改起来，令人头疼！\n2、什么是SpringCloud config分布式配置中心？\n\nspring cloud config 为微服务架构中的微服务提供集中化的外部支持，配置服务器为各个不同微服务应用的所有环节提供了一个中心化的外部配置。\nspring cloud config 分为服务端和客户端两部分。\n服务端也称为 分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密，解密信息等访问接口。\n客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理。并且可用通过git客户端工具来方便的管理和访问配置内容。\n3、spring cloud config 分布式配置中心能干嘛？\n\n集中式管理配置文件\n不同环境，不同配置，动态化的配置更新，分环境部署，比如 &#x2F;dev &#x2F;test &#x2F;prod &#x2F;beta &#x2F;release\n运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息\n当配置发生变动时，服务不需要重启，即可感知到配置的变化，并应用新的配置\n将配置信息以REST接口的形式暴露\n\n4、spring cloud config 分布式配置中心与GitHub整合\n由于spring cloud config 默认使用git来存储配置文件 (也有其他方式，比如自持SVN 和本地文件)，但是最推荐的还是git ，而且使用的是 http &#x2F; https 访问的形式。\n2、入门案例\n服务端\n\n1、新建springcloud-config-server-3344模块导入pom.xml依赖\n&lt;dependencies&gt;    &lt;!--web--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--config--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--eureka--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;        &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n2、resource下创建application.yml配置文件，Spring Cloud Config服务器从git存储库（必须提供）为远程客户端提供配置：\nserver:  port: 3344spring:  application:    name: springcloud-config-server  # 连接码云远程仓库  cloud:    config:      server:        git:          # 注意是https的而不是ssh          uri: https://gitee.com/ck/springcloud-config.git             # 通过 config-server可以连接到git，访问其中的资源以及配置~# 不加这个配置会报Cannot execute request on any known server 这个错：连接Eureka服务端地址不对# 或者直接注释掉eureka依赖 这里暂时用不到eurekaeureka:  client:    register-with-eureka: false    fetch-registry: false\n\n3、主启动类\n@EnableConfigServer // 开启spring cloud config server服务@SpringBootApplicationpublic class Config_server_3344 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Config_server_3344.class,args);    &#125;&#125;\n\n4、将本地git仓库springcloud-config文件夹下新建的application.yml提交到码云仓库：\n定位资源的默认策略是克隆一个git仓库（在spring.cloud.config.server.git.uri），并使用它来初始化一个迷你SpringApplication。小应用程序的Environment用于枚举属性源并通过JSON端点发布。\nHTTP服务具有以下格式的资源：\n/&#123;    application&#125;/&#123;    profile&#125;[/&#123;    label&#125;]/&#123;    application&#125;-&#123;    profile&#125;.yml/&#123;    label&#125;/&#123;    application&#125;-&#123;    profile&#125;.yml/&#123;    application&#125;-&#123;    profile&#125;.properties/&#123;    label&#125;/&#123;    application&#125;-&#123;    profile&#125;.properties\n\n其中“应用程序”作为SpringApplication中的spring.config.name注入（即常规的Spring Boot应用程序中通常是“应用程序”），“配置文件”是活动配置文件（或逗号分隔列表的属性），“label”是可选的git标签（默认为“master”）。\n5、测试访问http://localhost:3344/application-dev.yml\n\n\n客户端\n\n1、将本地git仓库springcloud-config文件夹下新建的config-client.yml提交到码云仓库：\n2、新建一个springcloud-config-client-3355模块，并导入依赖\n&lt;!--config--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-start --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;    &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\n\n3、resources下创建application.yml和bootstrap.yml配置文件(bootstrap.yml 是系统级别的配置)\n# 系统级别的配置spring:  cloud:    config:      name: config-client # 需要从git上读取的资源名称，不要后缀      profile: dev      label: master      uri: http://localhost:3344      # 用户级别的配置spring:  application:    name: springcloud-config-client\n\n4、创建controller包下的ConfigClientController.java 用于测试\n@RestControllerpublic class ConfigClientController &#123;    @Value(&quot;$&#123;spring.application.name&#125;&quot;)    private String applicationName; //获取微服务名称    @Value(&quot;$&#123;eureka.client.service-url.defaultZone&#125;&quot;)    private String eurekaServer; //获取Eureka服务    @Value(&quot;$&#123;server.port&#125;&quot;)    private String port; //获取服务端的端口号    @RequestMapping(&quot;/config&quot;)    public String getConfig()&#123;        return &quot;applicationName:&quot;+applicationName +         &quot;eurekaServer:&quot;+eurekaServer +         &quot;port:&quot;+port;    &#125;&#125;\n\n5、主启动类\n@SpringBootApplicationpublic class ConfigClient &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ConfigClient.class,args);    &#125;&#125;\n\n6、测试：\n启动服务端Config_server_3344 再启动客户端ConfigClient\n访问：http://localhost:8201/config/\n\n\n小案例\n\n1、本地新建config-dept.yml和config-eureka.yml并提交到码云仓库\n新建springcloud-config-eureka-7001模块，并将原来的springcloud-eureka-7001模块下的内容拷贝的该模块。\n2、清空该模块的application.yml配置，并新建bootstrap.yml连接远程配置\nspring:  cloud:    config:      name: config-eureka # 仓库中的配置文件名称      label: master      profile: dev      uri: http://localhost:3344\n\n3、在pom.xml中添加spring cloud config依赖\n&lt;!--config--&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-config --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;    &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n4、主启动类\n@SpringBootApplication@EnableEurekaServer //EnableEurekaServer 服务端的启动类，可以接受别人注册进来~public class ConfigEurekaServer_7001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ConfigEurekaServer_7001.class,args);    &#125;&#125;\n\n5、测试\n第一步：启动 Config_Server_3344，并访问 http://localhost:3344/master/config-eureka-dev.yml 测试\n\n第二部：启动ConfigEurekaServer_7001，访问 http://localhost:7001/ 测试\n6、新建springcloud-config-dept-8001模块并拷贝springcloud-provider-dept-8001的内容，同理导入spring cloud config依赖、清空application.yml 、新建bootstrap.yml配置文件并配置\nspring:  cloud:    config:      name: config-dept      label: master      profile: dev      uri: http://localhost:3344\n\n7、主启动类\n@SpringBootApplication@EnableEurekaClient //在服务启动后自动注册到Eureka中！@EnableDiscoveryClient //服务发现~@EnableCircuitBreaker //public class ConfigDeptProvider_8001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ConfigDeptProvider_8001.class,args);    &#125;    //增加一个 Servlet    @Bean    public ServletRegistrationBean hystrixMetricsStreamServlet()&#123;        ServletRegistrationBean registrationBean = new ServletRegistrationBean(new HystrixMetricsStreamServlet());        registrationBean.addUrlMappings(&quot;/actuator/hystrix.stream&quot;);        return registrationBean;    &#125;&#125;\n\n","tags":["SpringCloud"]},{"title":"SpringCloud之SpringCloud入门概述","url":"/2022/07/01/SpringCloud%E4%B9%8BSpringCloud%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/","content":"1、SpringCloud是什么？Spring官网：https://spring.io/\n2、SpringCloud和SpringBoot的关系\nSpringBoot专注于开苏方便的开发单个个体微服务；\nSpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务，整合并管理起来，为各个微服务之间提供：配置管理、服务发现、断路器、路由、为代理、事件总栈、全局锁、决策竞选、分布式会话等等集成服务；\nSpringBoot可以离开SpringCloud独立使用，开发项目，但SpringCloud离不开SpringBoot，属于依赖关系；\nSpringBoot专注于快速、方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架；\n\n3、Dubbo 和 SpringCloud技术选型\n分布式+服务治理Dubbo\n\n​\t\t目前成熟的互联网架构，应用服务化拆分 + 消息中间件\n\nDubbo 和 SpringCloud对比\n\n​\t\t可以看一下社区活跃度：\n​\t\thttps://github.com/dubbo\n​\t\thttps://github.com/spring-cloud\n对比结果：\n\n最大区别：SpringCloud抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式。 严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上 面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契 约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适。\n品牌机与组装机的区别：很明显，Spring Cloud的功能比DUBBO更加强大，涵盖面更广，而且作为Spring的拳头项目，它也能够 与Spring Framework、Spring Boot、Spring Data、Spring Batch等其他Spring项目完美融合，这些对于微服务而言是至关重要的。使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果你是一 名高手，那这些都不是问题；而Spring Cloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性，但是如果要在使用非原装组件外的东西，就需要对其基础有足 够的了解。 \n社区支持与更新力度：最为重要的是，DUBBO停止了5年左右的更新，虽然2017.7重启了。对于技术发展的新需求，需要由开 发者自行拓展升级（比如当当网弄出了DubboX），这对于很多想要采用微服务架构的中小软件组织， 显然是不太合适的，中小公司没有这么强大的技术能力去修改Dubbo源码+周边的一整套解决方案，并 不是每一个公司都有阿里的大牛+真实的线上生产环境测试过。\n解决的问题域不一样：Dubbo的定位是一款RPC框架，Spring Cloud的目标是微服务架构下的一站式解 决方案\n4、Dubbo 和 SpringCloud 对比\nDistributed&#x2F;versioned configuration 分布式&#x2F;版本控制配置\nService registration and discovery 服务注册与发现\nRouting 路由\nService-to-service calls 服务到服务的调用\nLoad balancing 负载均衡配置\nCircuit Breakers 断路器\nDistributed messaging 分布式消息管理\n…\n\n5、SpringCloud下载官网：Spring Cloud\n版本号有点特别：\n\nSpring Cloud是一个由众多独立子项目组成的大型综合项目，每个子项目有不同的发行节奏，都维护着 自己的发布版本号。Spring Cloud通过一个资源清单BOM（Bill of Materials）来管理每个版本的子项目 清单。为避免与子项目的发布号混淆，所以没有采用版本号的方式，而是通过命名的方式。\n自学参考书：\n\nSpringCloud Netflix 中文文档：https://springcloud.cc/spring-cloud-netflix.html\nSpringCloud 中文API文档(官方文档翻译版)：https://springcloud.cc/spring-cloud-dalston.html\nSpringCloud中国社区：http://springcloud.cn/\nSpringCloud中文网：https://springcloud.cc\n\n","tags":["SpringCloud"]},{"title":"SpringCloud之Zull路由网关","url":"/2022/07/06/SpringCloud%E4%B9%8BZull%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3/","content":"1、什么是zuul?Zull包含了对请求的路由(用来跳转的)和过滤两个最主要功能：\n其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础，而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础。Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。\n\n注意：Zuul 服务最终还是会注册进 Eureka\n提供：代理 + 路由 + 过滤 三大功能！\n2、Zuul能干嘛？\n路由\n过滤\n\n官方文档：https://github.com/Netflix/zuul/\n3、路由的基本配置1、新建springcloud-zuul模块，并导入依赖\n&lt;dependencies&gt;    &lt;!--导入zuul依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;        &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Hystrix依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;        &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--dashboard依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboar&lt;/artifactId&gt;        &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Ribbon--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;        &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Eureka--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;        &lt;version&gt;1.4.6.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--实体类+web--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.haust&lt;/groupId&gt;        &lt;artifactId&gt;springcloud-api&lt;/artifactId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--热部署--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n2、application.yml\nserver:  port: 9527spring:  application:    name: springcloud-zuul-gateway #微服务名称# eureka 注册中心配置eureka:  client:    service-url:      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/  instance: #实例的id    instance-id: gateway9527.com    prefer-ip-address: true # 显示ipinfo:  app.name: fang.springcloud # 项目名称  company.name: fang # 公司名称\n\n3、host修改\n路径：C:\\Windows\\System32\\drivers\\etc\\hosts\n127.0.0.1 myzuul.com\n\n4、主启动类\n@SpringBootApplication@EnableZuulProxy // 开启Zuulpublic class ZuulApplication_9527 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ZuulApplication_9527.class,args);    &#125;&#125;\n\n5、启动\n\nEureka集群 \n一个服务提供类：springcloud-provider-dept-8001 \nzuul路由 \n访问 ：http://localhost:7001/\n\n\n6、测试 \n\n不用路由 ：http://localhost:8001/dept/get/2 \n使用路由 ：http://myzuul.com:9527/springcloud-provider-dept/dept/get/2 \n网关 &#x2F; 微服务名字 &#x2F; 具体的服务\n\n\n\n4、路由访问映射规则问题：http://myzuul.com:9527/springcloud-provider-dept/dept/get/2 这样去访问的话，就暴露了我 们真实微服务的名称！这不是我们需要的！怎么处理呢?\n1、修改：springcloud-zuul-gateway-9527 工程 代理名称 yml配置修改，增加Zuul路由映射！\n#Zuul路由映射zuul:\troutes:\t\tmydept.serviceId: springcloud-provider-dept\t\tmydept.path: /mydept/**\n\n\n配置前访问：http://myzuul.com:9527/springcloud-provider-dept/dept/get/2 \n配置后访问：http://myzuul.com:9527/mydept/dept/get/2 \n问题，现在访问原路径依旧可以访问！这不是我们所希望的！\n\n2、原真实服务名忽略\nzuul:\t\t    routes:        mydept.serviceId: springcloud-provider-dept # eureka注册中心的服务提供方路由名称        mydept.path: /mydept/** # 将eureka注册中心的服务提供方路由名称 改为自定义路由名称      # 不能再使用这个路径访问了，*： 忽略,隐藏全部的服务名称~      ignored-services: &quot;springcloud-provider-dept&quot;\n\n3、测试：现在访问http://myzuul.com:9527/springcloud-provider-dept/dept/get/2 就访问不了了 \n4、上面的例子中，我们只写了一个，那要是有多个需要隐藏，怎么办呢?\nzuul:\t    routes:        mydept.serviceId: springcloud-provider-dept # eureka注册中心的服务提供方路由名称        mydept.path: /mydept/** # 将eureka注册中心的服务提供方路由名称 改为自定义路由名称      # 不能再使用这个路径访问了，*： 忽略,隐藏全部的服务名称~      ignored-services: &quot;*&quot;\n\n5、设置统一公共前缀\nzuul:\t    routes:        mydept.serviceId: springcloud-provider-dept # eureka注册中心的服务提供方路由名称        mydept.path: /mydept/** # 将eureka注册中心的服务提供方路由名称 改为自定义路由名称      # 不能再使用这个路径访问了，*： 忽略,隐藏全部的服务名称~      ignored-services: &quot;*&quot;      prefix: /fang\n\n6、访问：http://myzuul.com:9527/fang/mydept/dept/get/2 ，加上统一的前缀！kuang，否则，就访 问不了了！\n","tags":["SpringCloud"]},{"title":"SpringCloud之微服务概述","url":"/2022/07/01/SpringCloud%E4%B9%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%BF%B0/","content":"1、什么是微服务？\n什么是微服务？\n\n微服务(Microservice Architecture) 是近几年流行的一种架构思想，关于它的概念很难一言以蔽之。\n究竟什么是微服务呢？我们在此引用ThoughtWorks 公司的首席科学家 Martin Fowler 于2014年提出的一段话：\n原文：https://martinfowler.com/articles/microservices.html\n汉化：https://www.cnblogs.com/liuning8023/p/4493156.html\n\n就目前而言，对于微服务，业界并没有一个统一的，标准的定义。\n但通常而言，微服务架构是一种架构模式，或者说是一种架构风格，它提倡将单一的应用程序划分成一组小的服务，每个服务运行在其独立的自己的进程内，服务之间互相协调，互相配置，为用户提供最终价值，服务之间采用轻量级的通信机制(HTTP)互相沟通，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应该根据业务上下文，选择合适的语言，工具(Maven)对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。\n\n\n再来从技术维度角度理解下：\n\n\n微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。\n\n2、微服务与微服务架构\n微服务\n\n强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题&#x2F;提供落地对应服务的一个服务应用，狭义的看，可以看作是IDEA中的一个个微服务工程，或者Moudel。IDEA 工具里面使用Maven开发的一个个独立的小Moudel，它具体是使用SpringBoot开发的一个小模块，专业的事情交给专业的模块来做，一个模块就做着一件事情。强调的是一个个的个体，每个个体完成一个具体的任务或者功能。\n\n微服务架构\n\n一种新的架构形式，Martin Fowler 于2014年提出。\n微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制**(如HTTP)互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具(如Maven)**对其进行构建。\n3、微服务优缺点\n优点\n\n\n单一职责原则；\n每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求；\n开发简单，开发效率高，一个服务可能就是专一的只干一件事；\n微服务能够被小团队单独开发，这个团队只需2-5个开发人员组成；\n微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的；\n微服务能使用不同的语言开发；\n易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如jenkins，Hudson，bamboo；\n微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果，无需通过合作才能体现价值；\n微服务允许利用和融合最新技术；\n微服务只是业务逻辑的代码，不会和HTML，CSS，或其他的界面混合;\n每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库；\n\n\n缺点\n\n\n开发人员要处理分布式系统的复杂性；\n多服务运维难度，随着服务的增加，运维的压力也在增大；\n系统部署依赖问题；\n服务间通信成本问题；\n数据一致性问题；\n系统集成测试问题；\n性能和监控问题；\n\n微服务技术栈有那些？\n\n4、 为什么选择SpringCloud作为微服务架构\n选型依据\n\n整体解决方案和框架成熟度\n社区热度\n可维护性\n学习曲线\n\n\n当前各大IT公司用的微服务架构有那些？\n\n阿里：dubbo+HFS\n京东：JFS\n新浪：Motan\n当当网：DubboX\n\n\n各微服务框架对比\n\n\n\n","tags":["SpringCloud"]},{"title":"SpringBoot开发实用篇之整合Swagger","url":"/2022/07/11/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88Swagger/","content":"1、Swagger简介1.前后端分离Vue + SpringBoot\n2.后端时代：前端只用管理静态页面；html ⇒ 后端。模板引擎JSP ⇒ 后端是主力。\n3.前后端分离时代：\n后端：后端控制层，服务层，数据访问层【后端团队】\n前端：前端控制层，视图层【前端团队】\n伪造后端数据，json。已经存在了，不需要后端，前端工程依旧能够跑起来。\n\n\n前后端如何交互？ &#x3D;&#x3D;&#x3D;&gt; API\n前后端相对独立，松耦合；\n前后端甚至可以部署在不同的服务器上；\n\n4.产生一个问题：\n前后端集成联调，前端人员无法和后端人员无法做到，“即时协商，尽早解决”，最终导致问题集中爆发；\n\n5.解决方案：\n首先指定schema[计划的提纲]，实时更新最新API，降低集成的风险；\n早些年：指定word计划文档；\n前后端分离：\n前端测试后端接口：postman\n后端提供接口，需要实时更新最新的消息及改动！\n\n\n\n6.Swagger\n号称世界上最流行的Api框架\nRestFul Api 文档在线自动生成工具 &#x3D;&gt; Api文档与Api定义同步更新\n直接运行，可以在线测试API接口；\n支持多种语言：（Java、Php…）\n\n官网：https://swagger.io/\n在项目中使用swagger需要springfox；\n\nswagger2\nui\n\n2、集成Swagger\n新建一个SpringBoot - web项目\n导入相关依赖\n\n\n&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;\n\n\n编写一个Hello工程\n配置Swagger &#x3D;&#x3D;&gt; Config\n\npackage com.fang.swagger.config;import org.springframework.context.annotation.Configuration;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2   // 开启Swagger2public class SwaggerConfig &#123;    &#125;\n\n\n测试运行 http://localhost:8080/swagger-ui.html\n\n\n3、配置Swagger\nswagger的bean实例Docket；（在上面SwaggerConfig 类中添加）所以通过配置Docket实例来配置Swaggger。\n\n//配置了swagger的Docket 的 bean 实例@Beanpublic Docket docket()&#123;    return new Docket(DocumentationType.SWAGGER_2)&#125;\n\n\n可以通过apiInfo()属性配置文档信息\n\n//配置 swagger 信息 = apiInfo  private ApiInfo apiInfo()&#123;      //作者信息      Contact contact = new Contact(&quot;联系人名字&quot;, &quot;&quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;);      return new ApiInfo(   \t     &quot;Swagger学习&quot;, // 标题      \t &quot;学习演示如何配置Swagger&quot;, // 描述     \t   \t    &quot;v1.0&quot;, // 版本              &quot;http://terms.service.url/组织链接&quot;, // 组织链接               contact, // 联系人信息               &quot;Apach 2.0 许可&quot;, // 许可               &quot;许可链接&quot;, // 许可连接               new ArrayList&lt;&gt;()// 扩展\t      );  &#125;\n\n\nDocket 实例关联上 apiInfo()\n\n//配置了swagger的Docket 的 bean 实例@Beanpublic Docket docket()&#123;    return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());&#125;\n\n4、Swagger配置扫描接口\n构建Docket时通过select()方法配置怎么扫描接口。\n\n//配置了swagger的Docket 的 bean 实例    @Bean    public Docket docket()&#123;        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                // RequestHandlerSelectors, 配置要扫描的包                // basePackage(): 指定要扫描的包                // any(): 扫描全部                // none(): 都不扫描                // withClassAnnotation : 扫描类上的注解, 参数是一个注解的反射对象                // 例如：withClassAnnotation(RestController.class) 只扫描类上有@RestController的生成文档                // withMethodAnnotation: 扫描方法上的注解, 参数是一个注解的反射对象                .apis(RequestHandlerSelectors.basePackage(&quot;com.fang.swagger.controller&quot;))                .build();  //build    &#125;\n\n\n除此之外，我们还可以配置接口扫描过滤：\n\n//配置了swagger的Docket 的 bean 实例    @Bean    public Docket docket()&#123;        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                // RequestHandlerSelectors, 配置要扫描的包                // basePackage(): 指定要扫描的包                // any(): 扫描全部                // none(): 都不扫描                // withClassAnnotation : 扫描类上的注解, 参数是一个注解的反射对象                // 例如：withClassAnnotation(RestController.class) 只扫描类上有@RestController的生成文档                // withMethodAnnotation: 扫描方法上的注解, 参数是一个注解的反射对象                .apis(RequestHandlerSelectors.basePackage(&quot;com.fang.swagger.controller&quot;))                // paths(): 过滤什么路径                .paths(PathSelectors.ant(&quot;/fang/**&quot;))                .build();  //build    &#125;\n\n\n这里的可选值还有\n\nany() // 任何请求都扫描none() // 任何请求都不扫描regex(final String pathRegex) // 通过正则表达式控制ant(final String antPattern) // 通过ant()控制\n\n5、配置开关Swagger\n通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了\n\n//配置了swagger的Docket 的 bean 实例    @Bean    public Docket docket()&#123;        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .enable(false) //配置是否启用Swagger，如果是false，在浏览器将无法访问                .select()                .apis(RequestHandlerSelectors.basePackage(&quot;com.fang.swagger.controller&quot;))                // paths(): 过滤什么路径                .paths(PathSelectors.ant(&quot;/fang/**&quot;))                .build();  //build    &#125;\n\n\n问题：我只希望我的Swagger在生产环境中使用，在发布的时候不使用？解题思路：\n\n判断是不是生产环境 flag &#x3D; false\n\n注入enable(flag)\n\n\n\n\n​\t\t解题步骤：​\t\t1.先在resources目录下创建两个properties文件\n​\t\t2.接下来在application.properties文件中激活环境\nspring.profiles.active=dev\n\n​         3.在application-dev.properties中\nserver.port=8081\n\n​        4.在application-pro.properties中\nserver.port=8082\n\n​         5..接着上面的docket()，在方法中加入形参Environment获取application.properties中的设置的环境\n @Bean public Docket docket(Environment environment)&#123;     // 设置要显示的Swagger环境     Profiles profiles = Profiles.of(&quot;dev&quot;, &quot;test&quot;);     // 通过 environment.acceptsProfiles(profiles) 判断是否处在自己设定的环境当中     boolean flag = environment.acceptsProfiles(profiles);     return new Docket(DocumentationType.SWAGGER_2)             .apiInfo(apiInfo())             //此处判断是生产环境 flag 就是为true 就可以访问Swagger             .enable(flag)                          .select()             .apis(RequestHandlerSelectors.basePackage(&quot;com.kuang.swagger.controller&quot;))//                .paths(PathSelectors.ant(&quot;/kuang/**&quot;))             .build();  //build &#125;\n\n6、配置API分组\n如果没有配置分组，默认是default。通过groupName()方法即可配置分组：\n\n.groupName(&quot;hello&quot;)\n\n配置多个分组，多个Docket实例即可\n@Beanpublic Docket docket1()&#123;    return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;A&quot;);&#125;@Beanpublic Docket docket2()&#123;    return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;B&quot;);&#125;@Beanpublic Docket docket3()&#123;    return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;C&quot;);&#125;\n\nSwagger中就会出现多个分组\n7、实体配置\n新建一个实体类\n\nimport io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;@ApiModel(&quot;用户实体类&quot;)public class User &#123;    @ApiModelProperty(&quot;用户名&quot;)    public String username;    @ApiModelProperty(&quot;密码&quot;)    public String password;&#125;\n\n\n只要这个实体在请求接口的返回值上（即使是泛型），都能映射到实体项中：\n\nimport io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123;    @GetMapping(value = &quot;/hello&quot;)    public String hello()&#123;        return &quot;hello&quot;;    &#125;    // 只要我们的接口中，返回值中存在实体类, 他就会扫描到Swagger中    @PostMapping(value = &quot;/user&quot;)    public User user()&#123;        return new User();    &#125;    @ApiOperation(&quot;hello控制类&quot;)    @GetMapping(value = &quot;/hello2&quot;)    public String hello2(@ApiParam(&quot;用户名&quot;) String username)&#123;        return &quot;hello &quot; + username;    &#125;    @ApiOperation(&quot;Post测试类&quot;)    @GetMapping(value = &quot;/postt&quot;)    public User postt(@ApiParam(&quot;用户名&quot;) User user)&#123;        return user;    &#125;&#125;\n\n注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体 都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。 \n\n@ApiModel为类添加注释 \n@ApiModelProperty为类属性添加注释\n\n8、常用注解Swagger的所有注解定义在io.swagger.annotations包下 \n\n下面列一些经常用到的，未列举出来的可以另行查阅说明：\n\n\n\n我们也可以给请求的接口配置一些注释\n\n@ApiOperation(&quot;接口&quot;)@PostMapping(&quot;/hello&quot;)@ResponseBodypublic String kuang(@ApiParam(&quot;这个名字会被返回&quot;)String username)&#123;return username;&#125;\n\n相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档 (写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架， 可以说基本就不需要人为操作了。\nSwagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出 Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式 环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。\n9、其他皮肤我们可以导入不同的包实现不同的皮肤定义： \n\n默认的 访问 http://localhost:8080/swagger-ui.html\n\n&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;\n\n\nbootstrap-ui 访问 http://localhost:8080/doc.html\n\n&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;    &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;    &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;\t\n\n\nLayui-ui 访问 http://localhost:8080/docs.html\n\n&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.caspar-chen&lt;/groupId&gt;    &lt;artifactId&gt;swagger-ui-layer&lt;/artifactId&gt;    &lt;version&gt;1.1.3&lt;/version&gt;&lt;/dependency&gt;\n\n\nmg-ui 访问 http://localhost:8080/document.html\n\n&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.zyplayer&lt;/groupId&gt;    &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt;    &lt;version&gt;1.0.6&lt;/version&gt;&lt;/dependency&gt;\n\n总结\n我们可以通过Swagger给一些比较比较难理解的属性后接口，增加注释信息\n接口文档实时更新\n可以在线测试\n\n","tags":["SpringBoot"]},{"title":"leetcode之两数之和","url":"/2022/07/07/leetcode%E4%B9%8B%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n示例:\n给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]\n\n方法一：暴力枚举1、思路及算法最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。\n当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。\nimport java.util.Arrays;public class leetcode &#123;        public int[] twoSum(int[] nums, int target) &#123;            int n = nums.length;            for (int i = 0; i &lt; n; ++i) &#123;                for (int j = i + 1; j &lt; n; ++j) &#123;                    if (nums[i] + nums[j] == target) &#123;                        return new int[]&#123;i, j&#125;;                    &#125;                &#125;            &#125;            return new int[0];        &#125;    public static void main(String[] args) &#123;        leetcode lt = new leetcode();        int[] nums =new int[]&#123;2,7,15,17&#125;;        System.out.println(Arrays.toString(lt.twoSum(nums,9)));    &#125;&#125;\n\n2、复杂度分析时间复杂度：O(N^2^)，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。\n时间复杂度：O(1)\n方法二：哈希表1、思路及算法注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。\n使用哈希表，可以将寻找 target - x 的时间复杂度降低到从O(N) 降低到 O(1)。\n这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。\nimport java.util.Arrays;import java.util.HashMap;public class leetcode &#123;        public int[] twoSum(int[] nums, int target) &#123;            HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();            int n = nums.length;            for (int i = 0; i &lt; n; ++i) &#123;                    if (hashMap.containsKey(target-nums[i])) &#123;                        return new int[]&#123;hashMap.get(target-nums[i]), i&#125;;                &#125;                    hashMap.put(nums[i],i);            &#125;            return new int[0];        &#125;    public static void main(String[] args) &#123;        leetcode lt = new leetcode();        int[] nums =new int[]&#123;2,7,15,17&#125;;        System.out.println(Arrays.toString(lt.twoSum(nums,9)));    &#125;&#125;\n\n2、复杂度分析时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。\n空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。\n","tags":["leetcode"]},{"title":"leetcode之两数相加","url":"/2022/07/08/leetcode%E4%B9%8B%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","content":"题目描述给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\nclass Solution &#123;    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;        ListNode root = new ListNode(0);        ListNode cursor = root;        int carry = 0;        while(l1 != null || l2 != null || carry != 0) &#123;            int l1Val = l1 != null ? l1.val : 0;            int l2Val = l2 != null ? l2.val : 0;            int sumVal = l1Val + l2Val + carry;            carry = sumVal / 10;                        ListNode sumNode = new ListNode(sumVal % 10);            cursor.next = sumNode;            cursor = sumNode;                        if(l1 != null) l1 = l1.next;            if(l2 != null) l2 = l2.next;        &#125;                return root.next;    &#125;&#125;\n\n解题思路：\n\n","tags":["leetcode"]},{"title":"Anylogic之基于百度地图实现多车实时运行","url":"/2022/07/19/Anylogic%E4%B9%8B%E5%9F%BA%E4%BA%8E%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BD%A6%E5%AE%9E%E6%97%B6%E8%BF%90%E8%A1%8C/","content":"1、功能分析使用数组进行数据存储，根据数组里面的经纬度来实现多车运行，其中Icon的图标从https://www.iconfinder.com/获得，我们还需要实现跟随小车的标注，并且需要增加两个功能，小车速度的增加和减小。\n2、代码实现\n首先我们进行地图初始化\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;\t&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;\t&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, user-scalable=no&quot; /&gt;\t&lt;style&gt;\t\thtml, body, #allmap &#123;\t\t\theight: 100%;\t\t\twidth: 100%;\t\t&#125;\t\t.input-card .btn&#123;\t\t\tmargin-right: 1.2rem;\t\t\twidth: 9rem;\t\t&#125;\t\t.input-card .btn:last-child&#123;\t\t\tmargin-right: 0;\t\t&#125;\t&lt;/style&gt;\t&lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=GjxdF4HBRYNY0piKp6K7I4U7lOI7Lyor&quot;&gt;&lt;/script&gt;\t&lt;title&gt;单个标注点沿直线的轨迹运动&lt;/title&gt;\t&lt;link rel=&quot;stylesheet&quot; href=&quot;https://a.amap.com/jsapi_demos/static/demo-center/css/demo-center.css&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;div class=&quot;input-card&quot;&gt;\t&lt;h4&gt;速度控制&lt;/h4&gt;\t&lt;div class=&quot;input-item&quot;&gt;\t\t&lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;速度x2&quot; id=&quot;start&quot; onclick=&quot;startAnimation()&quot;/&gt;\t\t&lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;速度÷2&quot; id=&quot;pause&quot; onclick=&quot;pauseAnimation()&quot;/&gt;\t&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;\t// 百度地图API功能\tvar map=new BMap.Map(&quot;allmap&quot;); // 创建map实例\tmap.centerAndZoom(new BMap.Point(116.36239048877775, 39.938322220559), 15);// 初始化地图,设置中心点坐标和地图级别\tmap.enableScrollWheelZoom(true);//鼠标滚轮缩放\tmap.addControl(new BMap.MapTypeControl()); //添加切换地图类型附件\tvar time =500;//定时器的时间\tvar PointArr = [//第一个小车存储的数据\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36239048877775,&quot;lat&quot;:39.938322220559&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36239048877775,&quot;lat&quot;:39.93793496684673&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36239048877775,&quot;lat&quot;:39.93760303333522&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36246235321855,&quot;lat&quot;:39.936883838492925&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36246235321855,&quot;lat&quot;:39.93627528306042&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36246235321855,&quot;lat&quot;:39.93577737001302&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36246235321855,&quot;lat&quot;:39.93527945331416&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36260608210014,&quot;lat&quot;:39.93472620825511&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36260608210014,&quot;lat&quot;:39.933785681309004&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36274981098174,&quot;lat&quot;:39.9334537275117&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36267794654094,&quot;lat&quot;:39.93295579377289&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36267794654094,&quot;lat&quot;:39.932402529780596&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36267794654094,&quot;lat&quot;:39.93184926128044&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36267794654094,&quot;lat&quot;:39.93063205471247&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36274981098174,&quot;lat&quot;:39.92902752181022&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36282167542254,&quot;lat&quot;:39.92841889596463&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36282167542254,&quot;lat&quot;:39.92781026466464&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36289353986334,&quot;lat&quot;:39.92703563512155&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36289353986334,&quot;lat&quot;:39.926260996743295&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36282167542254,&quot;lat&quot;:39.925541681766745&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36289353986334,&quot;lat&quot;:39.92449036155915&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36296540430413,&quot;lat&quot;:39.92410302895963&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36332472650813,&quot;lat&quot;:39.9228303491527&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36382777759371,&quot;lat&quot;:39.9228303491527&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36469015088329,&quot;lat&quot;:39.922775014707135&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36619930414005,&quot;lat&quot;:39.922719680216495&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36655862634404,&quot;lat&quot;:39.92288568355318&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36627116858085,&quot;lat&quot;:39.9242690289156&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36670235522564,&quot;lat&quot;:39.924324362144105&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36742099963362,&quot;lat&quot;:39.924324362144105&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3684989662456,&quot;lat&quot;:39.924324362144105&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.36943320397597,&quot;lat&quot;:39.92437969532753&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.37029557726555,&quot;lat&quot;:39.92437969532753&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.37094235723274,&quot;lat&quot;:39.92437969532753&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.37158913719992,&quot;lat&quot;:39.92449036155915&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3723796460487,&quot;lat&quot;:39.92443502846588&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.37302642601588,&quot;lat&quot;:39.92449036155915&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.37360134154227,&quot;lat&quot;:39.92460102761046&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.37439185039105,&quot;lat&quot;:39.924545694607346&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.37496676591743,&quot;lat&quot;:39.924545694607346&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.37546981700302,&quot;lat&quot;:39.92460102761046&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.37582913920701,&quot;lat&quot;:39.924656360568505&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.37669151249659,&quot;lat&quot;:39.924656360568505&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.37719456358218,&quot;lat&quot;:39.92471169348146&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.37776947910857,&quot;lat&quot;:39.924767026349365&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.37848812351655,&quot;lat&quot;:39.924822359172175&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.37906303904293,&quot;lat&quot;:39.924767026349365&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.37963795456932,&quot;lat&quot;:39.924822359172175&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.38006914121411,&quot;lat&quot;:39.924767026349365&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.38006914121411,&quot;lat&quot;:39.92443502846588&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.38006914121411,&quot;lat&quot;:39.923992362096946&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3801410056549,&quot;lat&quot;:39.92332835713435&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3801410056549,&quot;lat&quot;:39.9229410179086&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3802128700957,&quot;lat&quot;:39.92227700266861&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3802847345365,&quot;lat&quot;:39.92155764550042&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3802847345365,&quot;lat&quot;:39.92089361673764&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3803565989773,&quot;lat&quot;:39.920229581483945&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3803565989773,&quot;lat&quot;:39.91962087679934&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3803565989773,&quot;lat&quot;:39.918956829104815&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3803565989773,&quot;lat&quot;:39.91829277491945&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3804284634181,&quot;lat&quot;:39.91762871424328&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3804284634181,&quot;lat&quot;:39.91696464707632&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3805721922997,&quot;lat&quot;:39.91524911018613&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3805003278589,&quot;lat&quot;:39.914806383957064&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3805003278589,&quot;lat&quot;:39.914363654843264&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3803565989773,&quot;lat&quot;:39.9136442138807&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.38186575223406,&quot;lat&quot;:39.91331216163647&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.38315931216843,&quot;lat&quot;:39.913422845898175&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3844528721028,&quot;lat&quot;:39.913422845898175&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.38553083871477,&quot;lat&quot;:39.91331216163647&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.38739931417552,&quot;lat&quot;:39.913422845898175&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.3885491452283,&quot;lat&quot;:39.913367503789864&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.38977084072187,&quot;lat&quot;:39.91358887195269&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.39092067177464,&quot;lat&quot;:39.91353352997958&#125;,\t\t&#123;&quot;staus&quot;:&quot;404&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.39199863838661,&quot;lat&quot;:39.9136442138807&#125;,\t\t&#123;&quot;staus&quot;:&quot;404&quot;,&quot;id&quot;:&quot;car1&quot;,&quot;lng&quot;:116.39415457161057,&quot;lat&quot;:39.9136442138807&#125;,]\tvar PointArr1 = [//第二个小车存储的数据\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.39997559131523,&quot;lat&quot;:39.92958081330031&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40148474457199,&quot;lat&quot;:39.92974679986831&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40292203338795,&quot;lat&quot;:39.92980212863415&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40443118664471,&quot;lat&quot;:39.92980212863415&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40579661101988,&quot;lat&quot;:39.92980212863415&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40716203539505,&quot;lat&quot;:39.92991278603061&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40852745977021,&quot;lat&quot;:39.92985745735493&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.4088867819742,&quot;lat&quot;:39.92991278603061&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.4090305108558,&quot;lat&quot;:39.929470155362914&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.4091023752966,&quot;lat&quot;:39.928861533484174&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.4091023752966,&quot;lat&quot;:39.92786559500822&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.4092461041782,&quot;lat&quot;:39.92637165990969&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40946169750059,&quot;lat&quot;:39.92388169505393&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40953356194139,&quot;lat&quot;:39.92244300708714&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40938983305979,&quot;lat&quot;:39.92161298093767&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40938983305979,&quot;lat&quot;:39.92039559090589&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40938983305979,&quot;lat&quot;:39.919178179057525&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40960542638219,&quot;lat&quot;:39.91685396858412&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40960542638219,&quot;lat&quot;:39.91574717374566&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40960542638219,&quot;lat&quot;:39.914751042975595&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40974915526378,&quot;lat&quot;:39.91419763068185&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40802440868462,&quot;lat&quot;:39.91414228920457&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40665898430946,&quot;lat&quot;:39.91419763068185&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40594033990148,&quot;lat&quot;:39.91408694768221&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40594033990148,&quot;lat&quot;:39.91309079257217&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40579661101988,&quot;lat&quot;:39.9118179064571&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40608406878307,&quot;lat&quot;:39.91087706226448&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40615593322387,&quot;lat&quot;:39.91010223961911&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40629966210547,&quot;lat&quot;:39.909272062695706&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40608406878307,&quot;lat&quot;:39.90871860577934&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40615593322387,&quot;lat&quot;:39.90766702522079&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40601220434228,&quot;lat&quot;:39.90689216597646&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.4050061021711,&quot;lat&quot;:39.90667077599834&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40320949115115,&quot;lat&quot;:39.90667077599834&#125;,\t\t&#123;&quot;staus&quot;:&quot;200&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.40134101569039,&quot;lat&quot;:39.90661542839114&#125;,\t\t&#123;&quot;staus&quot;:&quot;404&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.39904135358485,&quot;lat&quot;:39.90683681854954&#125;,\t\t&#123;&quot;staus&quot;:&quot;404&quot;,&quot;id&quot;:&quot;car2&quot;,&quot;lng&quot;:116.39746033588729,&quot;lat&quot;:39.90667077599834&#125;]\tvar myIcon=new BMap.Icon(&quot;./car.png&quot;, new BMap.Size(50, 70), &#123;//小车覆盖物\t\toffset: new BMap.Size(20,20),\t\t//相当于CSS精灵\t\timageOffset: new BMap.Size(0, 0)\t\t//图片的偏移量。为了是图片底部中心对准坐标点。\t&#125;);\tvar carMk;//第一个小车\tvar carMk1;//第二个小车\t//小车行驶图标\tvar drivingPoint = myIcon;\t//终点图标\tvar terminalPoint = myIcon;\tvar i = 0;\tvar j = 0;    //下面是控制小车素的的两个按钮函数\tfunction startAnimation () &#123;\t\ttime = time/2;\t&#125;\tfunction pauseAnimation () &#123;\t\ttime = time*2;\t&#125;//动态改变setInterval时间\tvar interval = setInterval(fn, time);\tfunction fn() &#123;\t\tclearInterval(interval);\t\tdrawLine(map,PointArr[i],PointArr[i+1]);//画线调用\t\tdrawLine(map,PointArr1[j],PointArr1[j+1]);//画线调用\t\ti = i + 1;\t\tj = j + 1;\t\tif (time &gt; 0) &#123;\t\t\tinterval = setInterval(fn, time);\t\t&#125;\t&#125;\t// 划线\tfunction drawLine(map,pointArr,pointArrNext) &#123;\t\tif (pointArrNext != undefined) &#123;\t\t\tif (pointArr.id == &quot;car1&quot;) &#123;\t\t\t\tvar polyline = new BMap.Polyline(\t\t\t\t\t[\t\t\t\t\t\tnew BMap.Point(pointArr.lng, pointArr.lat),\t\t\t\t\t\tnew BMap.Point(pointArrNext.lng, pointArrNext.lat)\t\t\t\t\t],\t\t\t\t\t&#123;\t\t\t\t\t\tstrokeColor: &quot;red&quot;,\t\t\t\t\t\tstrokeWeight: 7,\t\t\t\t\t\tstrokeOpacity: 1\t\t\t\t\t&#125;);   //创建折线\t\t\t\tmap.addOverlay(polyline);//将折线添加到地图上\t\t\t\taddMarkerEnd(new BMap.Point(pointArrNext.lng, pointArrNext.lat), pointArrNext.staus, map, pointArrNext, new BMap.Point(pointArr.lng, pointArr.lat), polyline);//添加图标\t\t\t&#125; else if (pointArr.id == &quot;car2&quot;) &#123;\t\t\t\tvar polyline1 = new BMap.Polyline(\t\t\t\t\t[\t\t\t\t\t\tnew BMap.Point(pointArr.lng, pointArr.lat),\t\t\t\t\t\tnew BMap.Point(pointArrNext.lng, pointArrNext.lat)\t\t\t\t\t],\t\t\t\t\t&#123;\t\t\t\t\t\tstrokeColor: &quot;yellow&quot;,\t\t\t\t\t\tstrokeWeight: 7,\t\t\t\t\t\tstrokeOpacity: 1\t\t\t\t\t&#125;);   //创建折线\t\t\t\tmap.addOverlay(polyline1);//将折线添加到地图上\t\t\t\taddMarkerEnd(new BMap.Point(pointArrNext.lng, pointArrNext.lat), pointArrNext.staus, map, pointArrNext, new BMap.Point(pointArr.lng, pointArr.lat), polyline1);//添加图标\t\t\t&#125;\t\t&#125;\t&#125;\tfunction addMarkerEnd(point, name,mapInit,trackUnit,prePoint,p) &#123;\t\tif (trackUnit.id == &quot;car1&quot;) &#123;\t\t\tif (name == &quot;200&quot;) &#123;\t\t\t\tif (carMk) &#123;//先判断第一次进来的时候这个值有没有定义，有的话就清除掉上一次的。然后在进行画图标。第一次进来时候没有定义也就不走这块，直接进行画图标\t\t\t\t\tmapInit.removeOverlay(carMk);\t\t\t\t&#125;\t\t\t\tcarMk = new BMap.Marker(point, &#123;icon: drivingPoint&#125;);  // 创建小车\t\t\t\tgetCarAngle(point, prePoint);// js求解两点之间的角度\t\t\t\tcarMk.setRotation(getCarAngle(point, prePoint) - 90);// 旋转的角度\t\t\t\tvar label = new BMap.Label(trackUnit.id, &#123;offset: new BMap.Size(0, -30)&#125;);\t\t\t\tlabel.setStyle(&#123;\t\t\t\t\tborder: &quot;1px solid rgb(204, 204, 204)&quot;,\t\t\t\t\tcolor: &quot;rgb(0, 0, 0)&quot;,\t\t\t\t\tborderRadius: &quot;10px&quot;,\t\t\t\t\tpadding: &quot;5px&quot;,\t\t\t\t\tbackground: &quot;rgb(255, 255, 255)&quot;,\t\t\t\t&#125;);\t\t\t\tcarMk.setLabel(label);\t\t\t\tmapInit.addOverlay(carMk);\t\t\t&#125; else &#123;\t\t\t\tmapInit.removeOverlay(carMk);\t\t\t\tvar allOverlay = map.getOverlays();\t\t\t\tfor (var i = 0; i &lt; allOverlay.length; i++)&#123;\t\t\t\t\tif(allOverlay[i].toString().indexOf(&quot;Polyline&quot;) &gt; 0)\t\t\t\t\t&#123;//删除折线\t\t\t\t\t\tmap.removeOverlay(allOverlay[i]);\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125; else if (trackUnit.id == &quot;car2&quot;) &#123;\t\t\tif (name == &quot;200&quot;) &#123;\t\t\t\tif (carMk1) &#123;//先判断第一次进来的时候这个值有没有定义，有的话就清除掉上一次的。然后在进行画图标。第一次进来时候没有定义也就不走这块，直接进行画图标\t\t\t\t\tmapInit.removeOverlay(carMk1);\t\t\t\t&#125;\t\t\t\tcarMk1 = new BMap.Marker(point, &#123;icon: terminalPoint&#125;);  // 创建标注\t\t\t\tgetCarAngle(point, prePoint);// js求解两点之间的角度\t\t\t\tcarMk1.setRotation(getCarAngle(point, prePoint) - 90);// 旋转的角度\t\t\t\tvar label = new BMap.Label(trackUnit.id, &#123;offset: new BMap.Size(0, -30)&#125;);//给小车添加标签\t\t\t\tlabel.setStyle(&#123;\t\t\t\t\tborder: &quot;1px solid rgb(204, 204, 204)&quot;,\t\t\t\t\tcolor: &quot;rgb(0, 0, 0)&quot;,\t\t\t\t\tborderRadius: &quot;10px&quot;,\t\t\t\t\tpadding: &quot;5px&quot;,\t\t\t\t\tbackground: &quot;rgb(255, 255, 255)&quot;,\t\t\t\t&#125;);\t\t\t\tcarMk1.setLabel(label);\t\t\t\tmapInit.addOverlay(carMk1);               // 将标注添加到地图中\t\t\t&#125; else &#123;               \t\t\t //移除小车图标\t\t\t\tmapInit.removeOverlay(carMk1);\t\t\t\tvar allOverlay = map.getOverlays();\t\t\t\tfor (var i = 0; i &lt; allOverlay.length; i++)&#123;\t\t\t\t\tif(allOverlay[i].toString().indexOf(&quot;Polyline1&quot;) &gt; 0)\t\t\t\t\t&#123;//删除折线\t\t\t\t\t\tmap.removeOverlay(allOverlay[i]);\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t//获得角度的函数\t\tfunction getCarAngle(n, next) &#123;\t\t\tvar ret\t\t\tvar w1 = n.lat / 180 * Math.PI\t\t\tvar j1 = n.lng / 180 * Math.PI\t\t\tvar w2 = next.lat / 180 * Math.PI\t\t\tvar j2 = next.lng / 180 * Math.PI\t\t\tret = 4 * Math.pow(Math.sin((w1 - w2) / 2), 2) - Math.pow(Math.sin((j1 - j2) / 2) * (Math.cos(w1) - Math.cos(w2)), 2);\t\t\tret = Math.sqrt(ret);\t\t\t// var temp = Math.sin(Math.abs(j1 - j2) / 2) * (Math.cos(w1) + Math.cos(w2));\t\t\tvar temp = Math.sin((j1 - j2) / 2) * (Math.cos(w1) + Math.cos(w2));\t\t\tconsole.log(temp)\t\t\tret = ret / temp;\t\t\tret = Math.atan(ret) / Math.PI * 180;\t\t\tret += 90;\t\t\t// 这里用如此臃肿的if..else是为了判定追踪单个点的具体情况,从而调整ret的值\t\t\tif (j1 - j2 &lt; 0) &#123;\t\t\t\tif (w1 - w2 &lt; 0) &#123;\t\t\t\t\tret;\t\t\t\t&#125; else &#123;\t\t\t\t\tret = -ret + 180;\t\t\t\t&#125;\t\t\t&#125; else &#123;\t\t\t\tif (w1 - w2 &lt; 0) &#123;\t\t\t\t\tret = 180 + ret;\t\t\t\t&#125; else &#123;\t\t\t\t\tret = -ret;\t\t\t\t&#125;\t\t\t&#125;\t\t\treturn ret;\t\t&#125;\t&#125;&lt;/script&gt;\t\n\n","tags":["Anylogic"]},{"title":"ElasticSearch之ElasticSearch实战","url":"/2022/07/26/ElasticSearch%E4%B9%8BElasticSearch%E5%AE%9E%E6%88%98/","content":"1、工程创建（springboot）目录结构\n\n2、基本编码1.导入依赖&lt;properties&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;elasticsearch.version&gt;7.6.1&lt;/elasticsearch.version&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;!-- jsoup解析页面 --&gt;    &lt;!-- 解析网页 爬视频可 研究tiko --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.jsoup&lt;/groupId&gt;        &lt;artifactId&gt;jsoup&lt;/artifactId&gt;        &lt;version&gt;1.10.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- fastjson --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;        &lt;version&gt;1.2.70&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- ElasticSearch --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!-- thymeleaf --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!-- web --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!-- devtools热部署 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;!--  --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;!-- lombok 需要安装插件 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;!-- test --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n2.导入前端素材3.编写 application.preperties配置文件# 更改端口，防止冲突server.port=9999# 关闭thymeleaf缓存spring.thymeleaf.cache=false\n\n4.测试controller和view@Controllerpublic class IndexController &#123;    @GetMapping(&#123;&quot;/&quot;,&quot;index&quot;&#125;)    public String index()&#123;        return &quot;index&quot;;    &#125;&#125;\n\n访问 localhost:9999\n\n\n到这里可以先去编写爬虫，编写之后，回到这里\n\n5.编写Config@Configurationpublic class ElasticSearchConfig &#123;    @Bean    public RestHighLevelClient restHighLevelClient()&#123;        RestHighLevelClient client = new RestHighLevelClient(                RestClient.builder(                        new HttpHost(&quot;127.0.0.1&quot;,9200,&quot;http&quot;)                )        );        return client;    &#125;&#125;\n\n6.编写service\n因为是爬取的数据，那么就不走Dao，以下编写都不会编写接口，开发中必须严格要求编写\n\nContentService\n@Servicepublic class ContentService &#123;    @Autowired    private RestHighLevelClient restHighLevelClient;    // 1、解析数据放入 es 索引中    public Boolean parseContent(String keyword) throws IOException &#123;        // 获取内容        List&lt;Content&gt; contents = HtmlParseUtil.parseJD(keyword);        // 内容放入 es 中        BulkRequest bulkRequest = new BulkRequest();        bulkRequest.timeout(&quot;2m&quot;); // 可更具实际业务是指        for (int i = 0; i &lt; contents.size(); i++) &#123;            bulkRequest.add(                    new IndexRequest(&quot;jd_goods&quot;)                            .id(&quot;&quot;+(i+1))                            .source(JSON.toJSONString(contents.get(i)), XContentType.JSON)            );        &#125;        BulkResponse bulk = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);        restHighLevelClient.close();        return !bulk.hasFailures();    &#125;        // 2、根据keyword分页查询结果    public List&lt;Map&lt;String, Object&gt;&gt; search(String keyword, Integer pageIndex, Integer pageSize) throws IOException &#123;        if (pageIndex &lt; 0)&#123;            pageIndex = 0;        &#125;        SearchRequest jd_goods = new SearchRequest(&quot;jd_goods&quot;);        // 创建搜索源建造者对象        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();        // 条件采用：精确查询 通过keyword查字段name        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(&quot;name&quot;, keyword);        searchSourceBuilder.query(termQueryBuilder);        searchSourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS));// 60s        // 分页        searchSourceBuilder.from(pageIndex);        searchSourceBuilder.size(pageSize);        // 高亮        // ....        // 搜索源放入搜索请求中        jd_goods.source(searchSourceBuilder);        // 执行查询，返回结果        SearchResponse searchResponse = restHighLevelClient.search(jd_goods, RequestOptions.DEFAULT);        restHighLevelClient.close();        // 解析结果        SearchHits hits = searchResponse.getHits();        List&lt;Map&lt;String,Object&gt;&gt; results = new ArrayList&lt;&gt;();        for (SearchHit documentFields : hits.getHits()) &#123;            Map&lt;String, Object&gt; sourceAsMap = documentFields.getSourceAsMap();            results.add(sourceAsMap);        &#125;        // 返回查询的结果        return results;    &#125;&#125;\n\n7.编写controller@Controllerpublic class ContentController &#123;    @Autowired    private ContentService contentService;    @ResponseBody    @GetMapping(&quot;/parse/&#123;keyword&#125;&quot;)    public Boolean parse(@PathVariable(&quot;keyword&quot;) String keyword) throws IOException &#123;        return contentService.parseContent(keyword);    &#125;    @ResponseBody    @GetMapping(&quot;/search/&#123;keyword&#125;/&#123;pageIndex&#125;/&#123;pageSize&#125;&quot;)    public List&lt;Map&lt;String, Object&gt;&gt; parse(@PathVariable(&quot;keyword&quot;) String keyword,                                           @PathVariable(&quot;pageIndex&quot;) Integer pageIndex,                                           @PathVariable(&quot;pageSize&quot;) Integer pageSize) throws IOException &#123;        return contentService.search(keyword,pageIndex,pageSize);    &#125;&#125;\n\n8.测试结果8.1解析数据放入 es 索引中\n\n8.2根据keyword分页查询结果3、爬虫（jsoup）\n数据获取：数据库、消息队列、爬虫、…\n\n1.搜索京东搜索页面，并分析页面http://search.jd.com/search?keyword=java\n\n1.1页面如下\n1.2审查页面元素页面列表id：J_goodsList\n\n目标元素：img、price、name\n\n2.爬取数据（获取请求返回的页面信息，筛选出可用的）2.1创建HtmlParseUtil，并简单编写public class HtmlParseUtil &#123;    public static void main(String[] args) throws IOException &#123;        /// 使用前需要联网        // 请求url        String url = &quot;http://search.jd.com/search?keyword=java&quot;;        // 1.解析网页(jsoup 解析返回的对象是浏览器Document对象)        Document document = Jsoup.parse(new URL(url), 30000);        // 使用document可以使用在js对document的所有操作        // 2.获取元素（通过id）        Element j_goodsList = document.getElementById(&quot;J_goodsList&quot;);        // 3.获取J_goodsList ul 每一个 li        Elements lis = j_goodsList.getElementsByTag(&quot;li&quot;);        // 4.获取li下的 img、price、name        for (Element li : lis) &#123;            String img = li.getElementsByTag(&quot;img&quot;).eq(0).attr(&quot;src&quot;);// 获取li下 第一张图片            String name = li.getElementsByClass(&quot;p-name&quot;).eq(0).text();            String price = li.getElementsByClass(&quot;p-price&quot;).eq(0).text();            System.out.println(&quot;=======================&quot;);            System.out.println(&quot;img : &quot; + img);            System.out.println(&quot;name : &quot; + name);            System.out.println(&quot;price : &quot; + price);        &#125;    &#125;&#125;\n\n运行结果\n\n原因是啥？\n\n一般图片特别多的网站，所有的图片都是通过延迟加载的\n\n// 打印标签内容Elements lis = j_goodsList.getElementsByTag(&quot;li&quot;);System.out.println(lis);\n\n打印所有li标签，发现img标签中并没有属性src的设置，只是data-lazy-ing设置图片加载的地址\n\n2.2创建HtmlParseUtil、改写\n更改图片获取属性为 data-lazy-img\n\n与实体类结合，实体类如下\n\n\n@Data@AllArgsConstructor@NoArgsConstructorpublic class Content implements Serializable &#123;    private static final long serialVersionUID = -8049497962627482693L;    private String name;    private String img;    private String price;&#125;\n\n\n封装为方法\n\npublic class HtmlParseUtil &#123;    public static void main(String[] args) throws IOException &#123;        System.out.println(parseJD(&quot;java&quot;));    &#125;    public static List&lt;Content&gt; parseJD(String keyword) throws IOException &#123;        /// 使用前需要联网        // 请求url        String url = &quot;http://search.jd.com/search?keyword=&quot; + keyword;        // 1.解析网页(jsoup 解析返回的对象是浏览器Document对象)        Document document = Jsoup.parse(new URL(url), 30000);        // 使用document可以使用在js对document的所有操作        // 2.获取元素（通过id）        Element j_goodsList = document.getElementById(&quot;J_goodsList&quot;);        // 3.获取J_goodsList ul 每一个 li        Elements lis = j_goodsList.getElementsByTag(&quot;li&quot;);//        System.out.println(lis);        // 4.获取li下的 img、price、name        // list存储所有li下的内容        List&lt;Content&gt; contents = new ArrayList&lt;Content&gt;();        for (Element li : lis) &#123;            // 由于网站图片使用懒加载，将src属性替换为data-lazy-img            String img = li.getElementsByTag(&quot;img&quot;).eq(0).attr(&quot;data-lazy-img&quot;);// 获取li下 第一张图片            String name = li.getElementsByClass(&quot;p-name&quot;).eq(0).text();            String price = li.getElementsByClass(&quot;p-price&quot;).eq(0).text();            // 封装为对象            Content content = new Content(name,img,price);            // 添加到list中            contents.add(content);        &#125;//        System.out.println(contents);        // 5.返回 list        return contents;    &#125;&#125;\n\n结果展示\n\n4、搜索高亮\n在3、的基础上添加内容\n\n4.1ContentService// 3、 在2的基础上进行高亮查询public List&lt;Map&lt;String, Object&gt;&gt; highlightSearch(String keyword, Integer pageIndex, Integer pageSize) throws IOException &#123;    SearchRequest searchRequest = new SearchRequest(&quot;jd_goods&quot;);    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();    // 精确查询，添加查询条件    TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(&quot;name&quot;, keyword);    searchSourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS));    searchSourceBuilder.query(termQueryBuilder);    // 分页    searchSourceBuilder.from(pageIndex);    searchSourceBuilder.size(pageSize);    // 高亮 =========    HighlightBuilder highlightBuilder = new HighlightBuilder();    highlightBuilder.field(&quot;name&quot;);    highlightBuilder.preTags(&quot;&lt;span style=&#x27;color:red&#x27;&gt;&quot;);    highlightBuilder.postTags(&quot;&lt;/span&gt;&quot;);    searchSourceBuilder.highlighter(highlightBuilder);    // 执行查询    searchRequest.source(searchSourceBuilder);    SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);    // 解析结果 ==========    SearchHits hits = searchResponse.getHits();    List&lt;Map&lt;String, Object&gt;&gt; results = new ArrayList&lt;&gt;();    for (SearchHit documentFields : hits.getHits()) &#123;        // 使用新的字段值（高亮），覆盖旧的字段值        Map&lt;String, Object&gt; sourceAsMap = documentFields.getSourceAsMap();        // 高亮字段        Map&lt;String, HighlightField&gt; highlightFields = documentFields.getHighlightFields();        HighlightField name = highlightFields.get(&quot;name&quot;);        // 替换        if (name != null)&#123;            Text[] fragments = name.fragments();            StringBuilder new_name = new StringBuilder();            for (Text text : fragments) &#123;                new_name.append(text);            &#125;            sourceAsMap.put(&quot;name&quot;,new_name.toString());        &#125;        results.add(sourceAsMap);    &#125;    return results;&#125;\n\n4.2ContentController@ResponseBody@GetMapping(&quot;/h_search/&#123;keyword&#125;/&#123;pageIndex&#125;/&#123;pageSize&#125;&quot;)public List&lt;Map&lt;String, Object&gt;&gt; highlightParse(@PathVariable(&quot;keyword&quot;) String keyword,                                       @PathVariable(&quot;pageIndex&quot;) Integer pageIndex,                                       @PathVariable(&quot;pageSize&quot;) Integer pageSize) throws IOException &#123;    return contentService.highlightSearch(keyword,pageIndex,pageSize);&#125;\n\n4.3结果展示\n5、前后端分离（简单使用Vue）\n删除Controller 方法上的 @ResponseBody注解\n\n\n5.1下载并引入Vue.min.js和axios.js\n如果安装了nodejs，可以按如下步骤，没有可以到后面素材处下载\n\nnpm install vuenpm install axios\n\n\n\n\n5.2修改静态页面5.2.1引入js&lt;script th:src=&quot;@&#123;/js/vue.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script th:src=&quot;@&#123;/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt;\n\n5.2.2修改后的index.html&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;/&gt;    &lt;title&gt;狂神说Java-ES仿京东实战&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/style.css&#125;&quot;/&gt;    &lt;script th:src=&quot;@&#123;/js/jquery.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body class=&quot;pg&quot;&gt;&lt;div class=&quot;page&quot;&gt;    &lt;div id=&quot;app&quot; class=&quot; mallist tmall- page-not-market &quot;&gt;        &lt;!-- 头部搜索 --&gt;        &lt;div id=&quot;header&quot; class=&quot; header-list-app&quot;&gt;            &lt;div class=&quot;headerLayout&quot;&gt;                &lt;div class=&quot;headerCon &quot;&gt;                    &lt;!-- Logo--&gt;                    &lt;h1 id=&quot;mallLogo&quot;&gt;                        &lt;img th:src=&quot;@&#123;/images/jdlogo.png&#125;&quot; alt=&quot;&quot;&gt;                    &lt;/h1&gt;                    &lt;div class=&quot;header-extra&quot;&gt;                        &lt;!--搜索--&gt;                        &lt;div id=&quot;mallSearch&quot; class=&quot;mall-search&quot;&gt;                            &lt;form name=&quot;searchTop&quot; class=&quot;mallSearch-form clearfix&quot;&gt;                                &lt;fieldset&gt;                                    &lt;legend&gt;天猫搜索&lt;/legend&gt;                                    &lt;div class=&quot;mallSearch-input clearfix&quot;&gt;                                        &lt;div class=&quot;s-combobox&quot; id=&quot;s-combobox-685&quot;&gt;                                            &lt;div class=&quot;s-combobox-input-wrap&quot;&gt;                                                &lt;input v-model=&quot;keyword&quot;  type=&quot;text&quot; autocomplete=&quot;off&quot; id=&quot;mq&quot;                                                       class=&quot;s-combobox-input&quot;  aria-haspopup=&quot;true&quot;&gt;                                            &lt;/div&gt;                                        &lt;/div&gt;                                        &lt;button type=&quot;submit&quot; @click.prevent=&quot;searchKey&quot; id=&quot;searchbtn&quot;&gt;搜索&lt;/button&gt;                                    &lt;/div&gt;                                &lt;/fieldset&gt;                            &lt;/form&gt;                            &lt;ul class=&quot;relKeyTop&quot;&gt;                                &lt;li&gt;&lt;a&gt;狂神说Java&lt;/a&gt;&lt;/li&gt;                                &lt;li&gt;&lt;a&gt;狂神说前端&lt;/a&gt;&lt;/li&gt;                                &lt;li&gt;&lt;a&gt;狂神说Linux&lt;/a&gt;&lt;/li&gt;                                &lt;li&gt;&lt;a&gt;狂神说大数据&lt;/a&gt;&lt;/li&gt;                                &lt;li&gt;&lt;a&gt;狂神聊理财&lt;/a&gt;&lt;/li&gt;                            &lt;/ul&gt;                        &lt;/div&gt;                    &lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;!-- 商品详情页面 --&gt;        &lt;div id=&quot;content&quot;&gt;            &lt;div class=&quot;main&quot;&gt;                &lt;!-- 品牌分类 --&gt;                &lt;form class=&quot;navAttrsForm&quot;&gt;                    &lt;div class=&quot;attrs j_NavAttrs&quot; style=&quot;display:block&quot;&gt;                        &lt;div class=&quot;brandAttr j_nav_brand&quot;&gt;                            &lt;div class=&quot;j_Brand attr&quot;&gt;                                &lt;div class=&quot;attrKey&quot;&gt;                                    品牌                                &lt;/div&gt;                                &lt;div class=&quot;attrValues&quot;&gt;                                    &lt;ul class=&quot;av-collapse row-2&quot;&gt;                                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt; 狂神说 &lt;/a&gt;&lt;/li&gt;                                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt; Java &lt;/a&gt;&lt;/li&gt;                                    &lt;/ul&gt;                                &lt;/div&gt;                            &lt;/div&gt;                        &lt;/div&gt;                    &lt;/div&gt;                &lt;/form&gt;                &lt;!-- 排序规则 --&gt;                &lt;div class=&quot;filter clearfix&quot;&gt;                    &lt;a class=&quot;fSort fSort-cur&quot;&gt;综合&lt;i class=&quot;f-ico-arrow-d&quot;&gt;&lt;/i&gt;&lt;/a&gt;                    &lt;a class=&quot;fSort&quot;&gt;人气&lt;i class=&quot;f-ico-arrow-d&quot;&gt;&lt;/i&gt;&lt;/a&gt;                    &lt;a class=&quot;fSort&quot;&gt;新品&lt;i class=&quot;f-ico-arrow-d&quot;&gt;&lt;/i&gt;&lt;/a&gt;                    &lt;a class=&quot;fSort&quot;&gt;销量&lt;i class=&quot;f-ico-arrow-d&quot;&gt;&lt;/i&gt;&lt;/a&gt;                    &lt;a class=&quot;fSort&quot;&gt;价格&lt;i class=&quot;f-ico-triangle-mt&quot;&gt;&lt;/i&gt;&lt;i class=&quot;f-ico-triangle-mb&quot;&gt;&lt;/i&gt;&lt;/a&gt;                &lt;/div&gt;                &lt;!-- 商品详情 --&gt;                &lt;div class=&quot;view grid-nosku&quot; &gt;                    &lt;div class=&quot;product&quot; v-for=&quot;result in results&quot;&gt;                        &lt;div class=&quot;product-iWrap&quot;&gt;                            &lt;!--商品封面--&gt;                            &lt;div class=&quot;productImg-wrap&quot;&gt;                                &lt;a class=&quot;productImg&quot;&gt;                                    &lt;img :src=&quot;result.img&quot;&gt;                                &lt;/a&gt;                            &lt;/div&gt;                            &lt;!--价格--&gt;                            &lt;p class=&quot;productPrice&quot;&gt;                                &lt;em v-text=&quot;result.price&quot;&gt;&lt;/em&gt;                            &lt;/p&gt;                            &lt;!--标题--&gt;                            &lt;p class=&quot;productTitle&quot;&gt;                                &lt;a v-html=&quot;result.name&quot;&gt;&lt;/a&gt;                            &lt;/p&gt;                            &lt;!-- 店铺名 --&gt;                            &lt;div class=&quot;productShop&quot;&gt;                                &lt;span&gt;店铺： 狂神说Java &lt;/span&gt;                            &lt;/div&gt;                            &lt;!-- 成交信息 --&gt;                            &lt;p class=&quot;productStatus&quot;&gt;                                &lt;span&gt;月成交&lt;em&gt;999笔&lt;/em&gt;&lt;/span&gt;                                &lt;span&gt;评价 &lt;a&gt;3&lt;/a&gt;&lt;/span&gt;                            &lt;/p&gt;                        &lt;/div&gt;                    &lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script th:src=&quot;@&#123;/js/vue.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script th:src=&quot;@&#123;/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;script&gt;    new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            &quot;keyword&quot;: &#x27;&#x27;, // 搜索的关键字            &quot;results&quot;:[] // 后端返回的结果        &#125;,        methods:&#123;            searchKey()&#123;                var keyword = this.keyword;                console.log(keyword);                axios.get(&#x27;h_search/&#x27;+keyword+&#x27;/0/20&#x27;).then(response=&gt;&#123;                    console.log(response.data);                    this.results=response.data;                &#125;)            &#125;        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n5.2.3测试\n6、安装包及前端素材链接: https://pan.baidu.com/s/14CIHvUmXsK_8KHRrXkH1iA 提取码: 2n99 复制这段内容后打开百度网盘手机App，操作更方便哦\n使用term（精确查询）时，三个问题，问题如下：\n\n字段值必须是一个词（索引中存在的词），才能匹配\n\n问题：中文字符串，term查询时无法查询到数据（比如，“编程”两字在文档中存在，但是搜索不到）\n\n原因：索引为配置中文分词器（默认使用standard，即所有中文字符串都会被切分为单个中文汉字作为单词），所以没有超过1个汉字的词，也就无法匹配，进而查不到数据\n\n解决：创建索引时配置中文分词器，如\nPUT example&#123;  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;name&quot;:&#123;        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;ik_max_word&quot;  // ik分词器      &#125;    &#125;  &#125;&#125;\n\n\n查询的英文字符只能是小写，大写都无效\n\n查询时英文单词必须是完整的\n\n\n7、官方文档\n低版本中文文档\nhttps://www.elastic.co/guide/cn/elasticsearch/guide/current/foreword_id.html\n\n最新版本的官方文档\nhttps://www.elastic.co/guide/en/elasticsearch/reference/7.x/index.html\n\nJava操作Es的客户端文档\nhttps://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html\n\nKibana数据可视化界面使用官方文档\nhttps://www.elastic.co/guide/en/kibana/current/index.html\n\n\n8、参考文章学习资料以官网文档为主\n\nElasticSearch知识体系详解\nhttps://www.pdai.tech/md/db/nosql-es/elasticsearch.html(opens new window)\n\nSpringBoot 检索篇 - 整合 Elasticsearch7.6.2\nhttps://blog.csdn.net/weixin_41105242/article/details/107711634\nhttps://www.kuangstudy.com/bbs/1354069127022583809#header39\n\n\n","tags":["ElasticSearch"]},{"title":"ElasticSearch之ElasticSearch概述","url":"/2022/07/26/ElasticSearch%E4%B9%8BElasticSearch%E6%A6%82%E8%BF%B0/","content":"Elaticsearch，简称为es，es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据;本身扩展性很好，可以扩展到上百台服务器，处理PB级别(大数据时代）的数据。es也使用java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。\n据国际权威的数据库产品评测机构DB Engines的统计，在2016年1月，ElasticSearch已超过Solr等，成为排名第一的搜索引擎类应用。\n1、历史多年前，一个叫做Shay Banon的刚结婚不久的失业开发者，由于妻子要去伦敦学习厨师，他便跟着也去了。在他找工作的过程中，为了给妻子构建一个食谱的搜索引擎，他开始构建一个早期版本的Lucene。\n直接基于Lucene工作会比较困难，所以Shay开始抽象Lucene代码以便lava程序员可以在应用中添加搜索功能。他发布了他的第一个开源项目，叫做“Compass”。\n后来Shay找到一份工作，这份工作处在高性能和内存数据网格的分布式环境中，因此高性能的、实时的、分布式的搜索引擎也是理所当然需要的。然后他决定重写Compass库使其成为一个独立的服务叫做Elasticsearch。\n第一个公开版本出现在2010年2月，在那之后Elasticsearch已经成为Github上最受欢迎的项目之一，代码贡献者超过300人。一家主营Elasticsearch的公司就此成立，他们一边提供商业支持一边开发新功能，不过Elasticsearch将永远开源且对所有人可用。\nShay的妻子依旧等待着她的食谱搜索…..\n谁在使用：\n1、维基百科,类似百度百科，全文检索,高亮,搜索推荐&#x2F;22、The Guardian (国外新闻网站) ,类似搜狐新闻,用户行为日志(点击,浏览,收藏,评论) +社交网络数据(对某某新闻的相关看法) ,数据分析,给到每篇新闻文章的作者,让他知道他的文章的公众反馈(好,坏,热门，垃圾,鄙视，崇拜)3、Stack Overflow (国外的程序异常讨论论坛) , IT问题,程序的报错,提交上去,有人会跟你讨论和回答,全文检索,搜索相关问题和答案,程序报错了,就会将报错信息粘贴到里面去,搜索有没有对应的答案4、GitHub (开源代码管理),搜索 上千亿行代码5、电商网站,检索商品6、日志数据分析, logstash采集日志, ES进行复杂的数据分析, ELK技术, elasticsearch+logstash+kibana7、商品价格监控网站,用户设定某商品的价格阈值,当低于该阈值的时候,发送通知消息给用户,比如说订阅牙膏的监控,如果高露洁牙膏的家庭套装低于50块钱,就通知我,我就去买8、BI系统,商业智能, Business Intelligence。比如说有个大型商场集团，BI ,分析一下某某区域最近3年的用户消费 金额的趋势以及用户群体的组成构成,产出相关的数张报表, **区,最近3年,每年消费金额呈现100%的增长,而且用户群体85%是高级白领，开-个新商场。ES执行数据分析和挖掘, Kibana进行数据可视化9、国内:站内搜索(电商,招聘,门户,等等),IT系统搜索(OA,CRM,ERP,等等),数据分析(ES热门的一一个使用场景)\n2、ES和Solr1.ElasticSearch简介\nElasticsearch是一个实时分布式搜索和分析引擎。 它让你以前所未有的速度处理大数据成为可能。\n它用于全文搜索、结构化搜索、分析以及将这三者混合使用:\n维基百科使用Elasticsearch提供全文搜索并高亮关键字,以及输入实时搜索(search-asyou-type)和搜索纠错(did-you-mean)等搜索建议功能。\n英国卫报使用Elasticsearch结合用户日志和社交网络数据提供给他们的编辑以实时的反馈,以便及时了解公众对新发表的文章的回应。\nStackOverflow结合全文搜索与地理位置查询,以及more-like-this功能来找到相关的问题和答案。\nGithub使用Elasticsearch检索1300亿行的代码。\n但是Elasticsearch不仅用于大型企业，它还让像DataDog以及Klout这样的创业公司将最初的想法变成可扩展的解决方案。\nElasticsearch可以在你的笔记本上运行,也可以在数以百计的服务器上处理PB级别的数据。\nElasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域, Lucene可被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。\n但是, Lucene只是一个库。 想要使用它,你必须使用Java来作为开发语言并将其直接集成到你的应用中,更糟糕的是, Lucene非常复杂,你需要深入了解检索的相关知识来理解它是如何工作的。\n\n\nElasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能,但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性,从而让全文搜索变得简单。\n\n2.Solr简介\nSolr是Apache下的一个顶级开源项目,采用Java开发,它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言,同时实现了可配置、可扩展，并对索引、搜索性能进行了优化\nSolr可以独立运行,运行在letty. Tomcat等这些Selrvlet容器中 , Solr 索引的实现方法很简单,用POST方法向Solr服务器发送一个描述Field及其内容的XML文档, Solr根据xml文档添加、删除、更新索引。Solr 搜索只需要发送HTTP GET请求,然后对Solr返回xml、json等格式的查询结果进行解析,组织页面布局。\nSolr不提供构建UI的功能, Solr提供了一个管理界面,通过管理界面可以查询Solr的配置和运行情况。\nSolr是基于lucene开发企业级搜索服务器,实际上就是封装了lucene.\nSolr是一个独立的企业级搜索应用服务器,它对外提供类似于Web-service的API接口。用户可以通过http请求,向搜索引擎服务器提交-定格式的文件,生成索引;也可以通过提出查找请求,并得到返回结果。\n\n3.ElasticSearch与Solr比较当单纯的对已有数据进行搜索时，Solr更快\n\n\n当实时建立索引时，Solr会产生io阻塞，查询性能较差，ElasticSearch具有明显的优势\n\n\n随着数据量的增加，Solr的搜索效率会变得更低，而ElasticSearch却没有明显的变化\n\n\n转变我们的搜索基础设施后从Solr ElasticSearch，我们看见一个即时~ 50x提高搜索性能！\n\n\n4.ElasticSearch vs Solr 总结\nes基本是&#x3D;&#x3D;开箱即用&#x3D;&#x3D;(解压就可以用了!),非常简单.solr安装略微复杂一丢丢!\nSolr利用Zookeeper进行分布式管理,而&#x3D;&#x3D;Elasticsearch自身带有分布式协调管理功能&#x3D;&#x3D;.\nsolr支持更多格式的数据,比如JSON,XML,CSV, 而elasticsearch仅仅支持json文件格式\nSolr官网提供的功能很多,而elasticsearch本身更注重核心功能,高级功能多有第三方插件提供,例如图形化界面需要kibana友好质层支撑\nSolr查询块,但更新索引时慢(即插入删除慢),用于电商等查询多的应用;\nES建立索引块(即查询慢),即&#x3D;&#x3D;实时性查询快&#x3D;&#x3D;,用于facebook新浪等搜索.\nSolr是传统搜索应用的有力解决方案,但Elasticsearch更适用于新兴的实时搜索应用.\n\n\nSolr比较成熟,有一个更大,更成熟的用户,开发好贡献者社区,而Elasticsearch相对开发维护者较少,更新太快,&#x3D;&#x3D;学习使用成本较高&#x3D;&#x3D;.\n\n","tags":["ElasticSearch"]},{"title":"ElasticSearch之Elasticsearch安装","url":"/2022/07/26/ElasticSearch%E4%B9%8BElasticsearch%E5%AE%89%E8%A3%85/","content":"JDK8，最低要求\n\n使用Java开发，必须保证ElasticSearch的版本与Java的核心jar包版本对应！（Java环境保证没错）\n1、Windows下安装ElasticSearch1.安装下载地址：https://www.elastic.co/cn/downloads/\n历史版本下载：https://www.elastic.co/cn/downloads/past-releases/\n解压即可（尽量将ElasticSearch相关工具放在统一目录下）\n2.熟悉目录\nbin 启动文件目录config 配置文件目录    1og4j2 日志配置文件    jvm.options java 虚拟机相关的配置(默认启动占1g内存，内容不够需要自己调整)    elasticsearch.ym1 elasticsearch 的配置文件! 默认9200端口!跨域!1ib     相关jar包modules 功能模块目录plugins 插件目录    ik分词器\n\n3.启动\n一定要检查自己的java环境是否配置好\n\n\n\n\n2、安装可视化界面elasticsearch-head\n\n使用前提：需要安装nodejs\n1.下载地址https://github.com/mobz/elasticsearch-head\n2.安装解压即可（尽量将ElasticSearch相关工具放在统一目录下）\n3.启动cd elasticsearch-head# 安装依赖npm install# 启动npm run start# 访问http://localhost:9100/\n\n4.安装依赖\n5.运行\n6.访问\n存在跨域问题（只有当两个页面同源，才能交互）\n同源（端口，主机，协议三者都相同）\nhttps://blog.csdn.net/qq_38128179/article/details/84956552\n\n\n开启跨域（在elasticsearch解压目录config下elasticsearch.yml中添加）\n# 开启跨域http.cors.enabled: true# 所有人访问http.cors.allow-origin: &quot;*&quot;\n\n\n重启elasticsearch\n\n再次连接\n\n如何理解上图：\n\n如果你是初学者\n索引 可以看做 “数据库”\n类型 可以看做 “表”\n文档 可以看做 “库中的数据（表中的行）”\n\n\n这个head，我们只是把它当做可视化数据展示工具，之后所有的查询都在kibana中进行\n因为不支持json格式化，不方便\n\n\n\n3、安装kibanaKibana是一个针对ElasticSearch的开源分析及可视化平台,用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana ,可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解。它操作简单,基于浏览器的用户界面可以快速创建仪表板( dashboard )实时显示Elasticsearch查询动态。设置Kibana非常简单。无需编码或者额外的基础架构,几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。\n1.下载地址:\n下载的版本需要与ElasticSearch版本对应\n\nhttps://www.elastic.co/cn/downloads/\n历史版本下载：https://www.elastic.co/cn/downloads/past-releases/\n2.安装解压即可（尽量将ElasticSearch相关工具放在统一目录下）\n\n3.启动\n\n4.访问localhost:5601\n\n\n5.开发工具（Postman、curl、head、谷歌浏览器插件）\n\n可以使用 Kibana进行测试\n\n\n\n如果说，你在英文方面不太擅长，kibana是支持汉化的\n\n6.kibana汉化编辑器打开kibana解压目录/config/kibana.yml，添加\ni18n.locale: &quot;zh-CN&quot;\n\n\n重启kibana\n\n汉化成功\n\n7.了解ELK\nELK是\nElasticsearch、Logstash、 Kibana三大开源框架首字母大写简称\n。市面上也被成为Elastic Stack。\n\n其中Elasticsearch是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架。\n像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架，可见Elasticsearch提供的搜索能力确实强大,市面上很多时候我们简称Elasticsearch为es。\n\n\nLogstash是ELK的中央数据流引擎,用于从不同目标(文件&#x2F;数据存储&#x2F;MQ )收集的不同格式数据,经过过滤后支持输出到不同目的地(文件&#x2F;MQ&#x2F;redis&#x2F;elasticsearch&#x2F;kafka等)。\nKibana可以将elasticsearch的数据通过友好的页面展示出来 ,提供实时分析的功能。\n\n\n市面上很多开发只要提到ELK能够一致说出它是一个日志分析架构技术栈总称 ,但实际上ELK不仅仅适用于日志分析,它还可以支持其它任何数据分析和收集的场景,日志分析和收集只是更具有代表性。并非唯一性。\n\n\n收集清洗数据(Logstash) ==&gt; 搜索、存储(ElasticSearch) ==&gt; 展示(Kibana)\n\n\n"},{"title":"ElasticSearch之Elasticsearch核心概念","url":"/2022/07/26/ElasticSearch%E4%B9%8BElasticsearch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","content":"1、概述1、索引（ElasticSearch）\n\n包多个分片\n\n2、字段类型（映射）\n\n字段类型映射（字段是整型，还是字符型…）\n\n3、文档\n4、分片（Lucene索引，倒排索引）\n\nElasticSearch是面向文档，关系行数据库和ElasticSearch客观对比！一切都是JSON！\n\n\n\n\nRelational DB\nElasticSearch\n\n\n\n数据库（database）\n索引（indices）\n\n\n表（tables）\ntypes &lt;慢慢会被弃用!&gt;\n\n\n行（rows）\ndocuments\n\n\n字段（columns）\nfields\n\n\nelasticsearch（集群）中可以包含多个索引（数据库） ,每个索引中可以包含多个类型（表） ,每个类型下又包含多个文档（行） ,每个文档中又包含多个字段（列）。\n2、物理设计elasticsearch在后台把每个索引划分成多个分片，每分分片可以在集群中的不同服务器间迁移\n一个人就是一个集群! ，即启动的ElasticSearch服务，默认就是一个集群，且默认集群名为elasticsearch\n\n3、逻辑设计一个索引类型中，包含多个文档，比如说文档1，文档2。当我们索引一篇文档时，可以通过这样的顺序找到它：索引 &#x3D;&gt; 类型 &#x3D;&gt; 文档ID ，通过这个组合我们就能索引到某个具体的文档。 注意：ID不必是整数，实际上它是个字符串。\n\n文档（”行“）\n之前说elasticsearch是面向文档的，那么就意味着索引和搜索数据的最小单位是文档，elasticsearch中，文档有几个重要属性:\n\n自我包含，一篇文档同时包含字段和对应的值，也就是同时包含key:value !\n可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的! {就是一个json对象 ! fastjson进行自动转换 !}\n灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在elasticsearch中，对于字段是非常灵活的，有时候,我们可以忽略该字段，或者动态的添加一个新的字段。\n\n尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符串也可以是整形。因为elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在elasticsearch中，类型有时候也称为映射类型。\n\n类型（“表”）\n类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。类型中对于字段的定义称为映射，比如name映射为字符串类型。我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么elasticsearch是怎么做的呢?\n\nelasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch就开始猜，如果这个值是18，那么elasticsearch会认为它是整形。但是elasticsearch也可能猜不对，所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用，别整什么幺蛾子。\n\n\n索引（“库”）\n索引是映射类型的容器， elasticsearch中的索引是一个非常大的文档集合。 索引存储了映射类型的字段和其他设置。然后它们被存储到了各个分片上了。我们来研究下分片是如何工作的。\n物理设计：节点和分片 如何工作\n创建新索引\n\n一个集群至少有一个节点，而一个节点就是一个elasricsearch进程，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个5个分片(primary shard ,又称主分片)构成的，每一个主分片会有一个副本(replica shard，又称复制分片)\n\n上图是一个有3个节点的集群，可以看到主分片和对应的复制分片都不会在同一个节点内，这样有利于某个节点挂掉了，数据也不至于失。实际上，一个分片是一个Lucene索引（一个ElasticSearch索引包含多个Lucene索引） ，一个包含倒排索引的文件目录，倒排索引的结构使得elasticsearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。不过，等等，倒排索引是什么鬼?\n\n倒排索引（Lucene索引底层）\n\n\n简单说就是 按（文章关键字，对应的文档&lt;0个或多个&gt;）形式建立索引，根据关键字就可直接查询对应的文档（含关键字的），无需查询每一个文档，如下图\n\n\nelasticsearch使用的是一种称为倒排索引的结构，采用Lucene倒排索作为底层。这种结构适用于快速的 全文搜索， 一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。 例 如，现在有两个文档， 每个文档包含如下内容：\nStudy every day, good good up to forever # 文档1包含的内容To forever, study every day, good good up # 文档2包含的内容\n\n为了创建倒排索引,我们首先要将每个文档拆分成独立的词(或称为词条或者tokens),然后创建一个包含所有不重复的词条的排序列表,然后列出每个词条出现在哪个文档:\n\n两个文档都匹配,但是第一个文档比第二个匹配程度更高.如果没有别的条件,现在,这两个包含关键字的文档都将返回.\n","tags":["ElasticSearch"]},{"title":"ElasticSearch之IK分词器(elasticsearch插件)","url":"/2022/07/26/ElasticSearch%E4%B9%8BIK%E5%88%86%E8%AF%8D%E5%99%A8-elasticsearch%E6%8F%92%E4%BB%B6/","content":"\nIK分词器：中文分词器\n\n分词：即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一一个匹配操作，默认的中文分词是将每个字看成一个词（不使用用IK分词器的情况下），比如“我爱狂神”会被分为”我”，”爱”，”狂”，”神” ，这显然是不符合要求的，所以我们需要安装中文分词器ik来解决这个问题。\nIK提供了两个分词算法: ik_smart和ik_max_word ,其中ik_smart为最少切分, ik_max_word为最细粒度划分!\n1、下载\n版本要与ElasticSearch版本对应\n\n下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases\n2、安装\nik文件夹是自己创建的\n\n解压即可（但是我们需要解压到ElasticSearch的plugins目录ik文件夹下）\n\n3、重启ElasticSearch\n加载了IK分词器\n\n\n4、使用 ElasticSearch安装补录/bin/elasticsearch-plugin 可以查看插件E:\\ElasticSearch\\elasticsearch-7.6.1\\bin&gt;elasticsearch-plugin list\n\n\n5、使用kibana测试ik_smart：最少切分\n\nik_max_word：最细粒度划分（穷尽词库的可能）\n\n\n从上面看，感觉分词都比较正常，但是大多数，分词都满足不了我们的想法，如下例\n\n\n\n那么，我们需要手动将该词添加到分词器的词典当中\n\n6、添加自定义的词添加到扩展字典中elasticsearch目录/plugins/ik/config/IKAnalyzer.cfg.xml\n\n\n打开 IKAnalyzer.cfg.xml 文件，扩展字典\n\n创建字典文件，添加字典内容\n\n重启ElasticSearch，再次使用kibana测试\n\n","tags":["ElasticSearch"]},{"title":"ElasticSearch之Rest风格说明","url":"/2022/07/26/ElasticSearch%E4%B9%8BRest%E9%A3%8E%E6%A0%BC%E8%AF%B4%E6%98%8E/","content":"一种软件架构风格,而不是标准,只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。\n1、基本Rest命令说明：\n\n\nmethod\nurl地址\n描述\n\n\n\nPUT（创建,修改）\nlocalhost:9200&#x2F;索引名称&#x2F;类型名称&#x2F;文档id\n创建文档（指定文档id）\n\n\nPOST（创建）\nlocalhost:9200&#x2F;索引名称&#x2F;类型名称\n创建文档（随机文档id）\n\n\nPOST（修改）\nlocalhost:9200&#x2F;索引名称&#x2F;类型名称&#x2F;文档id&#x2F;_update\n修改文档\n\n\nDELETE（删除）\nlocalhost:9200&#x2F;索引名称&#x2F;类型名称&#x2F;文档id\n删除文档\n\n\nGET（查询）\nlocalhost:9200&#x2F;索引名称&#x2F;类型名称&#x2F;文档id\n查询文档通过文档ID\n\n\nPOST（查询）\nlocalhost:9200&#x2F;索引名称&#x2F;类型名称&#x2F;文档id&#x2F;_search\n查询所有数据\n\n\n2、测试1.创建一个索引，添加PUT /test1/type1/1&#123;  &quot;name&quot; : &quot;流柚&quot;,  &quot;age&quot; : 18&#125;\n\n\n\n2.字段数据类型\n字符串类型\n\ntext、\nkeyword\n\ntext：支持分词，全文检索,支持模糊、精确查询,不支持聚合,排序操作;text类型的最大支持的字符长度无限制,适合大字段存储；\nkeyword：不进行分词，直接索引、支持模糊、支持精确匹配，支持聚合、排序操作。keyword类型的最大支持的长度为——32766个UTF-8类型的字符,可以通过设置ignore_above指定自持字符长度，超过给定长度后的数据将不被索引，无法通过term精确匹配检索返回结果。\n\n\n\n\n数值型\n\nlong、Integer、short、byte、double、float、half float、scaled float\n\n\n日期类型\n\ndate\n\n\nte布尔类型\n\nboolean\n\n\n二进制类型\n\nbinary\n\n\n等等…\n\n\n3.指定字段的类型（使用PUT）\n类似于建库（建立索引和字段对应类型），也可看做规则的建立\n\nPUT /test2&#123;  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;name&quot;: &#123;        &quot;type&quot;: &quot;text&quot;      &#125;,      &quot;age&quot;:&#123;        &quot;type&quot;: &quot;long&quot;      &#125;,      &quot;birthday&quot;:&#123;        &quot;type&quot;: &quot;date&quot;      &#125;    &#125;  &#125;&#125;\n\n\n4.获取3建立的规则GET test2\n\n\n5.获取默认信息\n_doc 默认类型（default type），type 在未来的版本中会逐渐弃用，因此产生一个默认类型进行代替\n\nPUT /test3/_doc/1&#123;  &quot;name&quot;: &quot;流柚&quot;,  &quot;age&quot;: 18,  &quot;birth&quot;: &quot;1999-10-10&quot;&#125;GET test3\n\n\n\n如果自己的文档字段没有被指定，那么ElasticSearch就会给我们默认配置字段类型\n\n扩展：通过get _cat/ 可以获取ElasticSearch的当前的很多信息！\nGET _cat/indicesGET _cat/aliasesGET _cat/allocationGET _cat/countGET _cat/fielddataGET _cat/healthGET _cat/indicesGET _cat/masterGET _cat/nodeattrsGET _cat/nodesGET _cat/pending_tasksGET _cat/pluginsGET _cat/recoveryGET _cat/repositoriesGET _cat/segmentsGET _cat/shardsGET _cat/snapshotsGET _cat/tasksGET _cat/templatesGET _cat/thread_pool\n\n6.修改\n两种方案\n\n①旧的（使用put覆盖原来的值）\n\n版本+1（_version）\n但是如果漏掉某个字段没有写，那么更新是没有写的字段 ，会消失\n\nPUT /test3/_doc/1&#123;  &quot;name&quot; : &quot;流柚是我的大哥&quot;,  &quot;age&quot; : 18,  &quot;birth&quot; : &quot;1999-10-10&quot;&#125;GET /test3/_doc/1// 修改会有字段丢失PUT /test3/_doc/1&#123;  &quot;name&quot; : &quot;流柚&quot;&#125;GET /test3/_doc/1\n\n\n\n②新的（使用post的update）\n\nversion不会改变\n需要注意doc\n不会丢失字段\n\nPOST /test3/_doc/1/_update&#123;  &quot;doc&quot;:&#123;    &quot;name&quot; : &quot;post修改，version不会加一&quot;,    &quot;age&quot; : 2  &#125;&#125;GET /test3/_doc/1\n\n\n7.删除GET /test1DELETE /test1\n\n\n\n8.查询（简单条件）GET /test3/_doc/_search?q=name:流柚\n\n\n9.复杂查询\ntest3索引中的内容\n\n\n①查询匹配\nmatch：匹配（会使用分词器解析（先分析文档，然后进行查询））\n_source：过滤字段\nsort：排序\nform、size 分页\n\n// 查询匹配GET /blog/user/_search&#123;  &quot;query&quot;:&#123;    &quot;match&quot;:&#123;      &quot;name&quot;:&quot;流&quot;    &#125;  &#125;  ,  &quot;_source&quot;: [&quot;name&quot;,&quot;desc&quot;]  ,  &quot;sort&quot;: [    &#123;      &quot;age&quot;: &#123;        &quot;order&quot;: &quot;asc&quot;      &#125;    &#125;  ]  ,  &quot;from&quot;: 0  ,  &quot;size&quot;: 1&#125;\n\n\n②多条件查询（bool）\nmust 相当于 and\nshould 相当于 or\nmust_not 相当于 not (... and ...)\nfilter 过滤\n\n/// bool 多条件查询//// must &lt;==&gt; and//// should &lt;==&gt; or//// must_not &lt;==&gt; not (... and ...)//// filter数据过滤//// boost//// minimum_should_matchGET /blog/user/_search&#123;  &quot;query&quot;:&#123;    &quot;bool&quot;: &#123;      &quot;must&quot;: [        &#123;          &quot;match&quot;:&#123;            &quot;age&quot;:3          &#125;        &#125;,        &#123;          &quot;match&quot;: &#123;            &quot;name&quot;: &quot;流&quot;          &#125;        &#125;      ],      &quot;filter&quot;: &#123;        &quot;range&quot;: &#123;          &quot;age&quot;: &#123;            &quot;gte&quot;: 1,            &quot;lte&quot;: 3          &#125;        &#125;      &#125;    &#125;  &#125;&#125;\n\n\n③匹配数组\n貌似不能与其它字段一起使用\n可以多关键字查（空格隔开）— 匹配字段也是符合的\nmatch 会使用分词器解析（先分析文档，然后进行查询）\n搜词\n\n// 匹配数组 貌似不能与其它字段一起使用// 可以多关键字查（空格隔开）// match 会使用分词器解析（先分析文档，然后进行查询）GET /blog/user/_search&#123;  &quot;query&quot;:&#123;    &quot;match&quot;:&#123;      &quot;desc&quot;:&quot;年龄 牛 大&quot;    &#125;  &#125;&#125;\n\n\n④精确查询\nterm 直接通过 倒排索引 指定词条查询\n适合查询 number、date、keyword ，不适合text\n\n// 精确查询（必须全部都有，而且不可分，即按一个完整的词查询）// term 直接通过 倒排索引 指定的词条 进行精确查找的GET /blog/user/_search&#123;  &quot;query&quot;:&#123;    &quot;term&quot;:&#123;      &quot;desc&quot;:&quot;年 &quot;    &#125;  &#125;&#125;\n\n\n⑤text和keyword\ntext：\n支持分词，全文检索、支持模糊、精确查询,不支持聚合,排序操作;\ntext类型的最大支持的字符长度无限制,适合大字段存储；\n\n\nkeyword：\n不进行分词，直接索引、支持模糊、支持精确匹配，支持聚合、排序操作。\nkeyword类型的最大支持的长度为——32766个UTF-8类型的字符,可以通过设置ignore_above指定自持字符长度，超过给定长度后的数据将不被索引，无法通过term精确匹配检索返回结果。\n\n\n\n// 测试keyword和text是否支持分词// 设置索引类型PUT /test&#123;  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;text&quot;:&#123;        &quot;type&quot;:&quot;text&quot;      &#125;,      &quot;keyword&quot;:&#123;        &quot;type&quot;:&quot;keyword&quot;      &#125;    &#125;  &#125;&#125;// 设置字段数据PUT /test/_doc/1&#123;  &quot;text&quot;:&quot;测试keyword和text是否支持分词&quot;,  &quot;keyword&quot;:&quot;测试keyword和text是否支持分词&quot;&#125;// text 支持分词// keyword 不支持分词GET /test/_doc/_search&#123;  &quot;query&quot;:&#123;   &quot;match&quot;:&#123;      &quot;text&quot;:&quot;测试&quot;   &#125;  &#125;&#125;// 查的到GET /test/_doc/_search&#123;  &quot;query&quot;:&#123;   &quot;match&quot;:&#123;      &quot;keyword&quot;:&quot;测试&quot;   &#125;  &#125;&#125;// 查不到，必须是 &quot;测试keyword和text是否支持分词&quot; 才能查到GET _analyze&#123;  &quot;analyzer&quot;: &quot;keyword&quot;,  &quot;text&quot;: [&quot;测试liu&quot;]&#125;// 不会分词，即 测试liuGET _analyze&#123;  &quot;analyzer&quot;: &quot;standard&quot;,  &quot;text&quot;: [&quot;测试liu&quot;]&#125;// 分为 测 试 liuGET _analyze&#123;  &quot;analyzer&quot;:&quot;ik_max_word&quot;,  &quot;text&quot;: [&quot;测试liu&quot;]&#125;// 分为 测试 liu\n\n⑥高亮查询/// 高亮查询GET blog/user/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;name&quot;:&quot;流&quot;    &#125;  &#125;  ,  &quot;highlight&quot;: &#123;    &quot;fields&quot;: &#123;      &quot;name&quot;: &#123;&#125;    &#125;  &#125;&#125;// 自定义前缀和后缀GET blog/user/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;name&quot;:&quot;流&quot;    &#125;  &#125;  ,  &quot;highlight&quot;: &#123;    &quot;pre_tags&quot;: &quot;&lt;p class=&#x27;key&#x27; style=&#x27;color:red&#x27;&gt;&quot;,    &quot;post_tags&quot;: &quot;&lt;/p&gt;&quot;,     &quot;fields&quot;: &#123;      &quot;name&quot;: &#123;&#125;    &#125;  &#125;&#125;\n\n\n","tags":["ElasticSearch"]},{"title":"ElasticSearch之SpringBoot整合","url":"/2022/07/26/ElasticSearch%E4%B9%8BSpringBoot%E6%95%B4%E5%90%88/","content":"1、创建工程目录结构\n\n2、导入依赖\n注意依赖版本和安装的版本一致\n\n&lt;properties&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;!-- 统一版本 --&gt;    &lt;elasticsearch.version&gt;7.6.1&lt;/elasticsearch.version&gt;&lt;/properties&gt;\n\n导入elasticsearch\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;\n\n提前导入fastjson、lombok\n&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.70&lt;/version&gt;&lt;/dependency&gt;&lt;!-- lombok需要安装插件 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\n\n3、创建并编写配置类@Configurationpublic class ElasticSearchConfig &#123;    // 注册 rest高级客户端     @Bean    public RestHighLevelClient restHighLevelClient()&#123;        RestHighLevelClient client = new RestHighLevelClient(                RestClient.builder(                        new HttpHost(&quot;127.0.0.1&quot;,9200,&quot;http&quot;)                )        );        return client;    &#125;&#125;\n\n4、创建并编写实体类@Data@NoArgsConstructor@AllArgsConstructorpublic class User implements Serializable &#123;    private static final long serialVersionUID = -3843548915035470817L;    private String name;    private Integer age;&#125;\n\n5、测试\n所有测试均在 SpringbootElasticsearchApplicationTests中编写\n\n1.注入 RestHighLevelClient@Autowiredpublic RestHighLevelClient restHighLevelClient;\n\n2.索引的操作2.1索引的创建// 测试索引的创建， Request PUT liuyou_index@Testpublic void testCreateIndex() throws IOException &#123;    CreateIndexRequest request = new CreateIndexRequest(&quot;liuyou_index&quot;);    CreateIndexResponse response = restHighLevelClient.indices().create(request, RequestOptions.DEFAULT);    System.out.println(response.isAcknowledged());// 查看是否创建成功    System.out.println(response);// 查看返回对象    restHighLevelClient.close();&#125;\n\n2.2索引的获取，并判断其是否存在// 测试获取索引，并判断其是否存在@Testpublic void testIndexIsExists() throws IOException &#123;    GetIndexRequest request = new GetIndexRequest(&quot;index&quot;);    boolean exists = restHighLevelClient.indices().exists(request, RequestOptions.DEFAULT);    System.out.println(exists);// 索引是否存在    restHighLevelClient.close();&#125;\n\n2.3索引的删除// 测试索引删除@Testpublic void testDeleteIndex() throws IOException &#123;    DeleteIndexRequest request = new DeleteIndexRequest(&quot;liuyou_index&quot;);    AcknowledgedResponse response = restHighLevelClient.indices().delete(request, RequestOptions.DEFAULT);    System.out.println(response.isAcknowledged());// 是否删除成功    restHighLevelClient.close();&#125;\n\n3.文档的操作3.1文档的添加// 测试添加文档(先创建一个User实体类，添加fastjson依赖)@Testpublic void testAddDocument() throws IOException &#123;    // 创建一个User对象    User liuyou = new User(&quot;liuyou&quot;, 18);    // 创建请求    IndexRequest request = new IndexRequest(&quot;liuyou_index&quot;);    // 制定规则 PUT /liuyou_index/_doc/1    request.id(&quot;1&quot;);// 设置文档ID    request.timeout(TimeValue.timeValueMillis(1000));// request.timeout(&quot;1s&quot;)    // 将我们的数据放入请求中    request.source(JSON.toJSONString(liuyou), XContentType.JSON);    // 客户端发送请求，获取响应的结果    IndexResponse response = restHighLevelClient.index(request, RequestOptions.DEFAULT);    System.out.println(response.status());// 获取建立索引的状态信息 CREATED    System.out.println(response);// 查看返回内容 IndexResponse[index=liuyou_index,type=_doc,id=1,version=1,result=created,seqNo=0,primaryTerm=1,shards=&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;]&#125;\n\n3.2文档信息的获取// 测试获得文档信息@Testpublic void testGetDocument() throws IOException &#123;    GetRequest request = new GetRequest(&quot;liuyou_index&quot;,&quot;1&quot;);    GetResponse response = restHighLevelClient.get(request, RequestOptions.DEFAULT);    System.out.println(response.getSourceAsString());// 打印文档内容    System.out.println(request);// 返回的全部内容和命令是一样的    restHighLevelClient.close();&#125;\n\n3.3文档的获取，并判断其是否存在// 获取文档，判断是否存在 get /liuyou_index/_doc/1@Testpublic void testDocumentIsExists() throws IOException &#123;    GetRequest request = new GetRequest(&quot;liuyou_index&quot;, &quot;1&quot;);    // 不获取返回的 _source的上下文了    request.fetchSourceContext(new FetchSourceContext(false));    request.storedFields(&quot;_none_&quot;);    boolean exists = restHighLevelClient.exists(request, RequestOptions.DEFAULT);    System.out.println(exists);&#125;\n\n3.4文档的更新// 测试更新文档内容@Testpublic void testUpdateDocument() throws IOException &#123;    UpdateRequest request = new UpdateRequest(&quot;liuyou_index&quot;, &quot;1&quot;);    User user = new User(&quot;lmk&quot;,11);    request.doc(JSON.toJSONString(user),XContentType.JSON);    UpdateResponse response = restHighLevelClient.update(request, RequestOptions.DEFAULT);    System.out.println(response.status()); // OK    restHighLevelClient.close();&#125;\n\n3.5文档的删除// 测试删除文档@Testpublic void testDeleteDocument() throws IOException &#123;    DeleteRequest request = new DeleteRequest(&quot;liuyou_index&quot;, &quot;1&quot;);    request.timeout(&quot;1s&quot;);    DeleteResponse response = restHighLevelClient.delete(request, RequestOptions.DEFAULT);    System.out.println(response.status());// OK&#125;\n\n3.6文档的查询// 查询// SearchRequest 搜索请求// SearchSourceBuilder 条件构造// HighlightBuilder 高亮// TermQueryBuilder 精确查询// MatchAllQueryBuilder// xxxQueryBuilder ...@Testpublic void testSearch() throws IOException &#123;    // 1.创建查询请求对象    SearchRequest searchRequest = new SearchRequest();    // 2.构建搜索条件    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();    // (1)查询条件 使用QueryBuilders工具类创建    // 精确查询    TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(&quot;name&quot;, &quot;liuyou&quot;);    //        // 匹配查询    //        MatchAllQueryBuilder matchAllQueryBuilder = QueryBuilders.matchAllQuery();    // (2)其他&lt;可有可无&gt;：（可以参考 SearchSourceBuilder 的字段部分）    // 设置高亮    searchSourceBuilder.highlighter(new HighlightBuilder());    //        // 分页    //        searchSourceBuilder.from();    //        searchSourceBuilder.size();    searchSourceBuilder.timeout(new TimeValue(60, TimeUnit.SECONDS));    // (3)条件投入    searchSourceBuilder.query(termQueryBuilder);    // 3.添加条件到请求    searchRequest.source(searchSourceBuilder);    // 4.客户端查询请求    SearchResponse search = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);    // 5.查看返回结果    SearchHits hits = search.getHits();    System.out.println(JSON.toJSONString(hits));    System.out.println(&quot;=======================&quot;);    for (SearchHit documentFields : hits.getHits()) &#123;        System.out.println(documentFields.getSourceAsMap());    &#125;&#125;\n\n3.7前面的操作都无法批量添加数据// 上面的这些api无法批量增加数据（只会保留最后一个source）@Testpublic void test() throws IOException &#123;    IndexRequest request = new IndexRequest(&quot;bulk&quot;);// 没有id会自动生成一个随机ID    request.source(JSON.toJSONString(new User(&quot;liu&quot;,1)),XContentType.JSON);    request.source(JSON.toJSONString(new User(&quot;min&quot;,2)),XContentType.JSON);    request.source(JSON.toJSONString(new User(&quot;kai&quot;,3)),XContentType.JSON);    IndexResponse index = restHighLevelClient.index(request, RequestOptions.DEFAULT);    System.out.println(index.status());// created&#125;\n\n3.8批量添加数据// 特殊的，真的项目一般会 批量插入数据@Testpublic void testBulk() throws IOException &#123;    BulkRequest bulkRequest = new BulkRequest();    bulkRequest.timeout(&quot;10s&quot;);    ArrayList&lt;User&gt; users = new ArrayList&lt;&gt;();    users.add(new User(&quot;liuyou-1&quot;,1));    users.add(new User(&quot;liuyou-2&quot;,2));    users.add(new User(&quot;liuyou-3&quot;,3));    users.add(new User(&quot;liuyou-4&quot;,4));    users.add(new User(&quot;liuyou-5&quot;,5));    users.add(new User(&quot;liuyou-6&quot;,6));    // 批量请求处理    for (int i = 0; i &lt; users.size(); i++) &#123;        bulkRequest.add(                // 这里是数据信息                new IndexRequest(&quot;bulk&quot;)                        .id(&quot;&quot;+(i + 1)) // 没有设置id 会自定生成一个随机id                        .source(JSON.toJSONString(users.get(i)),XContentType.JSON)        );    &#125;    BulkResponse bulk = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);    System.out.println(bulk.status());// ok&#125;\n","tags":["ElasticSearch"]},{"title":"Java中间件之阿里服务器购买及宝塔部署环境说明","url":"/2022/07/20/Java%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8B%E9%98%BF%E9%87%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%AD%E4%B9%B0%E5%8F%8A%E5%AE%9D%E5%A1%94%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E/","content":"\n为什么程序员都需要一个自己的服务器？\n\n1、作为一个程序员，必须要发布自己的网站和项目2、练习Linux操作3、自己的远程仓库、远程数据库、远程tomcat…搭建在服务器上4、练习，Linux进行任意的环境部署操作\n\n服务器如何购买？\n\n尽量打折的时候买香港服务器可以避免备案，但尽量不要自己挂VPN，会被封\n如果是学生，可以购买学生机，\n学生机地址：https://https://developer.aliyun.com/plan/grow-up\n活动地址https://cn.aliyun.com/minisite/goods?from_alibabacloud=&amp;userCode=0phtycgr\n\n\n买完服务器之后该做什么\n\n服务器就是一个远程Linux1、在阿里云购买的，需要开通安全组设置；端口映射（端口映射都需要在阿里云的面板安装）\n之后的安装访问宝塔需要8888端口是放行的，这里我先放行端口。进入阿里云服务器控制台\n\n\n\n授权对象是可以指定IP开放的，我这里0.0.0.0&#x2F;0是开放所有ip访问。\n2、获取服务器的公网ip地址； 修改实例名称和密码，再使用xshell 远程连接。进入云服务器控制台可以查看到服务器的公网IP地址，可修改实例名称和密码。Xshell连接到远程服务器，连接到服务器之后，我们需要搭建环境！\n\n连接到服务器之后，我们需要搭建环境！\n\n1、傻瓜式（宝塔面板）宝塔面板安装教学：https://www.bt.cn/bbs/thread-19376-1-1.html\nyum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh\n\n\n下载完毕之后，就可以得到一个地址：宝塔的管理面板\n\nurl\nusername\npassword\n\n\n浏览器访问： http://39.99.254.180:8888/3a7a3006\n输入正确的用户和密码进去宝塔面板\n\n一键部署应用\n\n\n\n端口开启(宝塔和阿里服务器都要开放)\n\n\n\n放入网站进行访问\n\n比如tomcat就直接放到webapps目录下特殊的网站：开源项目，就是按照自己的操作来\n\n\n上传文件尽量使用XFTP\n\n\n网站如果访问测试失败，一定是防火墙问题（Linux服务器，阿里云安全组面板）\n\n我们去Linux服务器，阿里云安全组面板！开放端口访问。\n\nwar 可以直接丢到 tomcat 即可使用，\njar 直接用 java -jar 执行即可访问。eg: java -jar school.jar\n\n","tags":["Java中间件"]},{"title":"Java中间件之Git","url":"/2022/07/19/Java%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8BGit/","content":"1、版本控制1.什么是版本控制版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。\n\n实现跨区域多人协同开发\n追踪和记载一个或者多个文件的历史记录\n组织和保护你的源代码和文档\n统计工作量\n并行开发、提高开发效率\n跟踪记录整个软件的开发过程\n减轻开发人员的负担，节省时间，同时降低人为错误\n\n简单说就是用于管理多人协同开发项目的技术。\n没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。\n无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！\n多人开发就必须要使用版本控制！\n2.常见的版本控制工具我们学习的东西，一定是当下最流行的！\n主流的版本控制器有如下这些：\n\nGit\nSVN（Subversion）\nCVS（Concurrent Versions System）\nVSS（Micorosoft Visual SourceSafe）\nTFS（Team Foundation Server）\nVisual Studio Online\n\n版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN\n3.版本控制分类1、本地版本控制\n记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。\n\n2、集中版本控制  SVN\n所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改\n\n所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS\n3、分布式版本控制 \tGit\n每个人都拥有全部的代码！安全隐患！\n所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。\n不会因为服务器损坏或者网络问题，造成不能工作的情况！\n\n4.Git与SVN的主要区别SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。\nGit是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！\nGit是目前世界上最先进的分布式版本控制系统。\n2、聊聊Git的历史同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。\nLinux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。\nLinux社区中存在很多的大佬！破解研究 BitKeeper ！\n到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！\nGit是目前世界上最先进的分布式版本控制系统。\nGit是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！\n3、Git环境配置1.软件下载打开 [git官网] https://git-scm.com/，下载git对应操作系统的版本。\n所有东西下载慢的话就可以去找镜像！\n官网下载太慢，我们可以使用淘宝镜像下载：http://npm.taobao.org/mirrors/git-for-windows/\n\n下载对应的版本即可安装！\n安装：无脑下一步即可！安装完毕就可以使用了！\n2.启动Git安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！\n\nGit Bash：Unix与Linux风格的命令行，使用最多，推荐最多\nGit CMD：Windows风格的命令行\nGit GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令\n3.常用的Linux命令平时一定要多使用这些基础的命令！\n1）、cd : 改变目录。\n2）、cd . . 回退到上一个目录，直接cd进入默认目录\n3）、pwd : 显示当前所在的目录路径。\n4）、ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。\n5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。\n6）、rm:  删除一个文件, rm index.js 就会把index.js文件删除。\n7）、mkdir:  新建一个目录,就是新建一个文件夹。\n8）、rm -r :  删除一个文件夹, rm -r src 删除src目录\nrm -rf / 切勿在Linux中尝试！删除电脑中全部文件！\n\n9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。\n10）、reset 重新初始化终端&#x2F;清屏。\n11）、clear 清屏。\n12）、history 查看命令历史。\n13）、help 帮助。\n14）、exit 退出。\n15）、#表示注释\n4.Git配置所有的配置文件，其实都保存在本地！\n查看配置 git config -l\n\n查看不同级别的配置文件：\n#查看系统configgit config --system --list　　#查看当前用户（global）配置git config --global  --list\n\nGit相关的配置文件：\n1）、Git\\etc\\gitconfig  ：Git 安装目录下的 gitconfig   –system 系统级\n2）、C:\\Users\\1.ssh.gitconfig   只适用于当前登录用户的配置  –global 全局\n5.设置用户名与邮箱（用户标识，必要）当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：\ngit config --global user.name &quot;fang&quot;  #名称git config --global user.email 3028206521@qq.com   #邮箱\n\n只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。\n4、Git基本理论（重要）1.三个区域Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage&#x2F;Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：\n\n\nWorkspace：工作区，就是你平时存放项目代码的地方\nIndex &#x2F; Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息\nRepository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本\nRemote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换\n\n本地的三个区域确切的说应该是git仓库中HEAD指向的版本：\n\n\nDirectory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。\nWorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。\n.git：存放Git管理信息的目录，初始化仓库的时候自动创建。\nIndex&#x2F;Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。\nLocal Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。\nStash：隐藏，是一个工作状态保存栈，用于保存&#x2F;恢复WorkSpace中的临时状态。\n\n2.工作流程git的工作流程一般是这样的：\n１、在工作目录中添加、修改文件；\n２、将需要进行版本管理的文件放入暂存区域；\n３、将暂存区域的文件提交到git仓库。\n因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)\n\n5、Git项目搭建1.创建工作目录与常用指令工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。\n日常使用只要记住下图6个命令：\n\n2.本地仓库搭建创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。\n1、创建全新的仓库，需要用GIT管理的项目的根目录执行：\n# 在当前目录新建一个Git代码库$ git init\n\n2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。\n3.克隆远程仓库1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！\n# 克隆一个项目和它的整个代码历史(版本信息)$ git clone [url]  # https://gitee.com/kuangstudy/openclass.git\n\n6、Git文件操作1.文件的四种状态版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。\n\nUntracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.\nUnmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件\nModified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !\nStaged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified\n\n2.查看文件状态上面说文件有4种状态，通过如下命令可以查看到文件的状态：\n#查看指定文件状态git status [filename]#查看所有文件状态git status# git add .                  添加所有文件到暂存区# git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息\n\n3.忽略文件有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等\n在主目录下建立”.gitignore”文件，此文件有如下规则：\n\n忽略文件中的空行或以井号（#）开始的行将会被忽略。\n可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。\n如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。\n如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。\n如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。\n\n#为注释*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!lib.txt     #但lib.txt除外/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录tempbuild/       #忽略build/目录下的所有文件doc/*.txt    #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt\n\n7、使用码云1.github 是有墙的，比较慢，在国内的话，我们一般使用 gitee ，公司中有时候会搭建自己的gitlab服务器这个其实可以作为大家未来找工作的一个重要信息！\n1、注册登录码云，完善个人信息\n\n2、设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)\n# 进入 C:\\Users\\1\\.ssh 目录# 生成公钥ssh-keygen\n\n\n3、将公钥信息public key 添加到码云账户中即可！\n\n4、使用码云创建一个自己的仓库！\n\n许可证：开源是否可以随意转载，开源但是不能商业使用，不能转载，…  限制！\n8、IDEA中集成Git1、新建项目，绑定git。将我们远程的git文件目录拷贝到项目中即可\n2、修改文件，使用IDEA操作git。\n\n添加到暂存区\ncommit 提交\npush到远程仓库\n\n3、提交测试\n1.说明：GIT分支分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！\n\ngit分支中常用指令：\n# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]\n\n如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！\nmaster主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。\n9、总结Git学习可以从下面进行学习\n\n\nGit大全https://gitee.com/all-about-git\nGit命令学习：https://oschina.gitee.io/learn-git-branching/\n\n","tags":["Java中间件"]},{"title":"Linux入门之三种软件安装方式及服务器基本环境搭建","url":"/2022/07/24/Linux%E5%85%A5%E9%97%A8%E4%B9%8B%E4%B8%89%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"1、jdk安装（rpm安装）1、rpm下载地址http://www.oracle.com/technetwork/java/javase/downloads/index.html\n2、如果有安装openjdk 则卸载\n[root@fang ~]# java -versionjava version &quot;1.8.0_121&quot;Java(TM) SE Runtime Environment (build 1.8.0_121-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)# 检查[root@fang ~]# rpm -qa|grep jdkjdk1.8.0_121-1.8.0_121-fcs.x86_64# 卸载 -e --nodeps 强制删除[root@fang ~]# rpm -e --nodeps jdk1.8.0_121-1.8.0_121-fcs.x86_64[root@fang ~]# java -version-bash: /usr/bin/java: No such file or directory  # OK\n\n3、安装JDK\n# 安装java rpm[root@fang fang]# rpm -ivh jdk-8u221-linux-x64.rpm# 安装完成后配置环境变量 文件：/etc/profileJAVA_HOME=/usr/java/jdk-14.0.1JRE_HOME=$JAVA_HOME/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH# 保存退出# 让新增的环境变量生效！source /etc/profile# 测试 java -version[root@fang java]# java -versionjava version &quot;1.8.0_221&quot;Java(TM) SE Runtime Environment (build 1.8.0_221-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)\n\n\n\n2、Tomcat安装（解压缩安装）1、安装好了Java环境后我们可以测试下Tomcat！准备好Tomcat的安装包！\n2、将文件移动到&#x2F;usr&#x2F;tomcat&#x2F;下，并解压！\n[root@fang fang]# mv apache-tomcat-9.0.22.tar.gz /usr[root@fang fang]# cd /usr[root@fang usr]# lsapache-tomcat-9.0.22.tar.gz[root@fang usr]# tar -zxvf apache-tomcat-9.0.22.tar.gz   # 解压\n\n3、运行Tomcat，进入bin目录，和我们以前在Windows下看的都是一样的\n# 执行：startup.sh --&gt;启动tomcat# 执行：shutdown.sh --&gt;关闭tomcat./startup.sh./shutdown.sh\n\n4、确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的！\n# 查看firewall服务状态systemctl status firewalld# 开启、重启、关闭、firewalld.service服务# 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop# 查看防火墙规则firewall-cmd --list-all    # 查看全部信息firewall-cmd --list-ports  # 只看端口信息# 开启端口开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent重启防火墙：systemctl restart firewalld.service命令含义：--zone #作用域--add-port=80/tcp  #添加端口，格式为：端口/通讯协议--permanent   #永久生效，没有此参数重启后失效\n\n 如果是阿里云 上传完毕的项目直接购买自己的域名,备案解析过去即可! 域名解析后,如果端口是80 - http或者443-https 可以直接访问,如果是9000 8080 ,就需要通过Apcahe或者Nginx做一下反向代理即可（配置文件）\n3、安装Docker（yum安装）\n基于 CentOS 7 安装\n\n\n官网安装参考手册：https://docs.docker.com/install/linux/docker-ce/centos/\n\n确定你是CentOS7及以上版本\n[root@192 Desktop]# cat /etc/redhat-releaseCentOS Linux release 7.2.1511 (Core)\n\nyum安装gcc相关（需要确保 虚拟机可以上外网 ）\nyum -y install gccyum -y install gcc-c++\n\n卸载旧版本\nyum -y remove docker docker-common docker-selinux docker-engine# 官网版本yum remove docker \\          docker-client \\          docker-client-latest \\          docker-common \\          docker-latest \\          docker-latest-logrotate \\          docker-logrotate \\          docker-engine\n\n安装需要的软件包\nyum install -y yum-utils device-mapper-persistent-data lvm2\n\n设置stable镜像仓库\n# 错误yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo## 报错[Errno 14] curl#35 - TCP connection reset by peer[Errno 12] curl#35 - Timeout# 正确推荐使用国内的yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n更新yum软件包索引\nyum makecache fast\n\n安装Docker CE\nyum -y install docker-ce docker-ce-cli containerd.io\n\n启动docker\nsystemctl start docker\n\n测试\ndocker versiondocker run hello-worlddocker images\n\n","tags":["Linux"]},{"title":"Linux入门之常用的基本命令（必掌握）","url":"/2022/07/24/Linux%E5%85%A5%E9%97%A8%E4%B9%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%88%E5%BF%85%E6%8E%8C%E6%8F%A1%EF%BC%89/","content":"1、目录管理\n绝对路径和相对路径\n\n我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 &#x2F;。\n其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。\n绝对路径：\n路径的写法，由根目录 &#x2F; 写起，例如：&#x2F;usr&#x2F;share&#x2F;doc 这个目录。\n相对路径：\n路径的写法，不是由 &#x2F; 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成：cd ..&#x2F;man 这就是相对路径的写法啦！\n\n处理目录的常用命令\n\n接下来我们就来看几个常见的处理目录的命令吧：\n\nls: 列出目录\ncd：切换目录\npwd：显示目前的目录\nmkdir：创建一个新的目录\nrmdir：删除一个空的目录\ncp: 复制文件或目录\nrm: 移除文件或目录\nmv: 移动文件与目录，或修改文件与目录的名称\n\n你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。\n\nls （列出目录）\n\n在Linux系统当中， ls 命令可能是最常被运行的。\n语法：\n[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称\n\n选项与参数：\n\n-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)\n-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)\n\n将目录下的所有文件列出来(含属性与隐藏档)\n[root@www ~]# ls -al ~\n\n\n\ncd （切换目录）\n\ncd是Change Directory的缩写，这是用来变换工作目录的命令。\n语法：\ncd [相对路径或绝对路径]\n\n测试：\n# 切换到用户目录下[root@fang /]# cd home  # 使用 mkdir 命令创建 fang 目录[root@fang home]# mkdir fang# 进入 fang 目录[root@fang home]# cd fang# 回到上一级[root@fang fang]# cd ..# 回到根目录[root@fang fang]# cd /# 表示回到自己的家目录，亦即是 /root 这个目录[root@fang fang]# cd ~\n\n\npwd ( 显示目前所在的目录 )\n\npwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。\n[root@fang fang]#pwd [-P]\n\n选项与参数：**-P** ：显示出确实的路径，而非使用连接(link) 路径。\n测试：\n# 单纯显示出目前的工作目录[root@fang ~]# pwd/root# 如果是链接，要显示真实地址，可以使用 -P参数[root@fang /]# cd bin[root@fang bin]# pwd -P/usr/bin\n\n\nmkdir （创建新目录）\n\n如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。\nmkdir [-mp] 目录名称\n\n选项与参数：\n\n-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～\n-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！\n\n测试：\n# 进入我们用户目录下[root@fang /]# cd /home# 创建一个 test 文件夹[root@fang home]# mkdir test# 创建多层级目录[root@fang home]# mkdir test1/test2/test3/test4mkdir: cannot create directory ‘test1/test2/test3/test4’:No such file or directory  # &lt;== 没办法直接创建此目录啊！# 加了这个 -p 的选项，可以自行帮你创建多层目录！[root@fang home]# mkdir -p test1/test2/test3/test4# 创建权限为 rwx--x--x 的目录。[root@fang home]# mkdir -m 711 test2[root@fang home]# ls -ldrwxr-xr-x 2 root root  4096 Mar 12 21:55 testdrwxr-xr-x 3 root root  4096 Mar 12 21:56 test1drwx--x--x 2 root root  4096 Mar 12 21:58 test2\n\n\nrmdir ( 删除空的目录 )\n\n语法：\nrmdir [-p] 目录名称\n\n选项与参数：**-p ：**连同上一级『空的』目录也一起删除\n测试：\n# 看看有多少目录存在？[root@fang home]# ls -ldrwxr-xr-x 2 root root  4096 Mar 12 21:55 testdrwxr-xr-x 3 root root  4096 Mar 12 21:56 test1drwx--x--x 2 root root  4096 Mar 12 21:58 test2# 可直接删除掉，没问题[root@fang home]# rmdir test# 因为尚有内容，所以无法删除！[root@fang home]# rmdir test1rmdir: failed to remove ‘test1’: Directory not empty# 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。[root@fang home]# rmdir -p test1/test2/test3/test4\n\n注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录，后面我们会将！\n\ncp ( 复制文件或目录 )\n\n语法：\n[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory\n\n选项与参数：\n\n-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)\n-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；\n-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；\n-r：递归持续复制，用於目录的复制行为；(常用)\n-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；\n-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)\n-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身。\n-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；\n-u：若 destination 比 source 旧才升级 destination ！\n\n测试：\n# 找一个有文件的目录，我这里找到 root目录[root@fang home]# cd /root[root@fang ~]# lsinstall.sh[root@fang ~]# cd /home# 复制 root目录下的install.sh 到 home目录下[root@fang home]# cp /root/install.sh /home[root@fang home]# lsinstall.sh# 再次复制，加上-i参数，增加覆盖询问？[root@fang home]# cp -i /root/install.sh /homecp: overwrite ‘/home/install.sh’? y # n不覆盖，y为覆盖\n\n\nrm ( 移除文件或目录 )\n\n语法：\nrm [-fir] 文件或目录\n\n选项与参数：\n\n-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；\n-i ：互动模式，在删除前会询问使用者是否动作\n-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！\n\n测试：\n# 将刚刚在 cp 的实例中创建的 install.sh删除掉！[root@fang home]# rm -i install.shrm: remove regular file ‘install.sh’? y# 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！# 尽量不要在服务器上使用 rm -rf /\n\n\nmv  ( 移动文件与目录，或修改名称 )\n\n语法：\n[root@www ~]# mv [-fiu] source destination[root@www ~]# mv [options] source1 source2 source3 .... directory\n\n选项与参数：\n\n-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；\n-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！\n-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)\n\n测试：\n# 复制一个文件到当前目录[root@fang home]# cp /root/install.sh /home# 创建一个文件夹 test[root@fang home]# mkdir test# 将复制过来的文件移动到我们创建的目录，并查看[root@fang home]# mv install.sh test[root@fang home]# lstest[root@fang home]# cd test[root@fang test]# lsinstall.sh# 将文件夹重命名，然后再次查看！[root@fang test]# cd ..[root@fang home]# mv test mvtest[root@fang home]# lsmvtest\n\n2、基本属性\n看懂文件属性\n\nLinux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。\n在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如：\n\n实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。\n在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：\n\n当为[ d ]则是目录\n当为[ - ]则是文件；\n若是[ l ]则表示为链接文档 ( link file )；\n若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；\n若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。\n\n接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。\n其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。\n要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。\n每个文件的属性由左边第一部分的10个字符来确定（如下图）：\n\n从左至右用0-9这些数字来表示。\n第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。\n其中：\n第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；\n第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；\n第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。\n对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。\n同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。\n文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。\n因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。\n在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。\n\n修改文件属性\n\n1、chgrp：更改文件属组\nchgrp [-R] 属组名 文件名\n\n-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。\n2、chown：更改文件属主，也可以同时更改文件属组\nchown [–R] 属主名 文件名chown [-R] 属主名：属组名 文件名\n\n3、chmod：更改文件9个属性\nchmod [-R] xyz 文件或目录\n\nLinux文件属性有两种设置方法，一种是数字，一种是符号。\nLinux文件的基本权限就有九个，分别是owner&#x2F;group&#x2F;others三种身份各有自己的read&#x2F;write&#x2F;execute权限。\n先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：\nr:4     w:2         x:1\n\n每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：\n\nowner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7\ngroup &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7\nothers&#x3D; — &#x3D; 0+0+0 &#x3D; 0\n\nchmod 770 filename\n\n3、文件内容查看\n概述\n\nLinux系统中使用以下命令来查看文件的内容：\n\ncat 由第一行开始显示文件内容\ntac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！\nnl  显示的时候，顺道输出行号！\nmore 一页一页的显示文件内容\nless 与 more 类似，但是比 more 更好的是，他可以往前翻页！\nhead 只看头几行\ntail 只看尾巴几行\n\n你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。\n\ncat 由第一行开始显示文件内容\n\n语法：\ncat [-AbEnTv]\n\n选项与参数：\n\n-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；\n-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！\n-E ：将结尾的断行字节 $ 显示出来；\n-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；\n-T ：将 [tab] 按键以 ^I 显示出来；\n-v ：列出一些看不出来的特殊字符\n\n测试：\n# 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/[root@fang ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0BOOTPROTO=dhcpONBOOT=yes\n\n\ntac\n\ntac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：\n[root@fang ~]# tac /etc/sysconfig/network-scripts/ifcfg-eth0ONBOOT=yesBOOTPROTO=dhcpDEVICE=eth0\n\n\n\n\nnl  显示行号\n\n语法：\nnl [-bnw] 文件\n\n选项与参数：\n\n-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；\n-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；\n-w ：行号栏位的占用的位数。\n\n测试：\n[root@fang ~]# nl /etc/sysconfig/network-scripts/ifcfg-eth01DEVICE=eth02BOOTPROTO=dhcp3ONBOOT=yes\n\n\n\n\nmore  一页一页翻动\n\n在 more 这个程序的运行过程中，你有几个按键可以按的：\n\n空白键 (space)：代表向下翻一页；\nEnter   ：代表向下翻『一行』；\n&#x2F;字串   ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；\n:f    ：立刻显示出档名以及目前显示的行数；\nq    ：代表立刻离开 more ，不再显示该文件内容。\nb 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。\n\n[root@fang etc]# more /etc/csh.login....(中间省略)....--More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令\n\n\n\n\nless  一页一页翻动，以下实例输出&#x2F;etc&#x2F;man.config文件的内容：\n\nless运行时可以输入的命令有：\n\n空白键  ：向下翻动一页；\n[pagedown]：向下翻动一页；\n[pageup] ：向上翻动一页；\n&#x2F;字串  ：向下搜寻『字串』的功能；\n?字串  ：向上搜寻『字串』的功能；\nn   ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！)\nN   ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！)\nq   ：离开 less 这个程序；\n\n[root@fang etc]# more /etc/csh.login....(中间省略)....:   # 这里可以等待你输入命令！\n\n\n\n\nhead  取出文件前面几行\n\n语法：\nhead [-n number] 文件\n\n选项与参数：**-n** 后面接数字，代表显示几行的意思！\n默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：\n[root@fang etc]# head -n 20 /etc/csh.login\n\n\n\n\ntail  取出文件后面几行\n\n语法：\ntail [-n number] 文件\n\n选项与参数：\n\n-n ：后面接数字，代表显示几行的意思\n\n默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样：\n[root@fang etc]# tail -n 20 /etc/csh.login\n\n\n\n\n拓展：Linux 链接概念\n\nLinux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。\n情况下，ln 命令产生硬链接。\n硬连接\n硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。\n硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。\n软连接\n另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。\n测试：\n[root@fang /]# cd /home[root@fang home]# touch f1 # 创建一个测试文件f1[root@fang home]# lsf1[root@fang home]# ln f1 f2     # 创建f1的一个硬连接文件f2[root@fang home]# ln -s f1 f3   # 创建f1的一个符号连接文件f3[root@fang home]# ls -li       # -i参数显示文件的inode节点信息397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f1397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f2397248 lrwxrwxrwx 1 root root     2 Mar 13 00:50 f3 -&gt; f1\n\n从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。\n# echo 字符串输出 &gt;&gt; f1 输出到 f1文件[root@fang home]# echo &quot;I am f1 file&quot; &gt;&gt;f1[root@fang home]# cat f1I am f1 file[root@fang home]# cat f2I am f1 file[root@fang home]# cat f3I am f1 file[root@fang home]# rm -f f1[root@fang home]# cat f2I am f1 file[root@fang home]# cat f3cat: f3: No such file or directory\n\n通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效；\n依此您可以做一些相关的测试，可以得到以下全部结论：\n\n删除符号连接f3,对f1,f2无影响；\n删除硬连接f2，对f1,f3也无影响；\n删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；\n同时删除原文件f1,硬连接f2，整个文件会真正的被删除。\n\n","tags":["Linux"]},{"title":"Linux入门之概述及环境搭建","url":"/2022/07/23/Linux%E5%85%A5%E9%97%A8%E4%B9%8B%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"1、入门概述\n我们为什么要学习Linux\n\nlinux诞生了这么多年，以前还喊着如何能取代windows系统，现在这个口号已经小多了，任何事物发展都有其局限性都有其天花板。就如同在国内再搞一个社交软件取代腾讯一样，想想而已基本不可能，因为用户已经习惯于使用微信交流，不是说技术上实现不了解而是老百姓已经习惯了，想让他们不用，即使他们自己不用亲戚朋友还是要用，没有办法的事情。\n用习惯了windows操作系统，再让大家切换到别的操作系统基本上是不可能的事情，改变一个人已经养成的习惯太难。没有办法深入到普通老百姓的生活中，并不意味着linux就没有用武之地了。在服务器端，在开发领域linux倒是越来越受欢迎，很多程序员都觉得不懂点linux都觉得不好意思，linux在开源社区的地位依然岿然不动。\n尤其是作为一个后端程序员，是必须要掌握Linux的，因为这都成为了你找工作的基础门槛了，所以不得不学习！\n\nLinux 简介\n\nLinux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。\nLinux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。\nLinux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。\n\nLinux 发行版\n\nLinux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。\n\n\nLinux 应用领域\n\n今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。\n目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎。\n\n巴西联邦政府由于支持 Linux 而世界闻名。\n有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。\n印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。\n中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。\n在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。\n葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。\n法国和德国同样开始逐步采用 Linux。\n\n\nLinux vs Windows\n\n\n2、环境搭建Linux 的安装，安装步骤比较繁琐，现在其实云服务器挺普遍的，价格也便宜，如果直接不想搭建，也可以直接买一台学习用用！\n\n安装CentOS（虚拟机安装，耗资源）\n\n1、可以通过镜像进行安装！\n\n这里是阿里云Centos7的镜像http://mirrors.aliyun.com/centos/7/isos/x86_64/\n\n\n\n然后手动安装，按照提示安装即可\n\n\n\n这一步一定注意，检查这里是否有网https://blog.csdn.net/qq_40722827/article/details/103219850\n\n\n\n这里就设置好密码和用户，这里的root密码就是root用户的密码，一定记住了\n\n\n\n然后等待安装完毕进入系统，进行登录root用户注意:密码是不回显的，也就是说你输入它不会有*号，永远是空白\n\n\n\n这里我们没有可视化界面需要安装可视化界面输入以下命令，按下enter键\n\nyum groupinstall &quot;X Window System&quot;\n\n\n检查已安装的软件以及安装后可以安装的软件。 使用以下命令，然后按“Enter”键\n\nyum grouplist\n\n\n安装所需的图形界面软件GNOME（GNOME Desktop），输入以下命令，并按Enter键，\n\n“yum groupinstall &quot;GNOME Desktop”\n\n\n等待程序安装，然后使用以下命令自查一下，installed那一栏有无GNOME\n\nyum grouplist \n\n\n重新启动系统以进入图形界面，如下图所示。重新安装，然后在此界面\n\n\n\n直接安装\n\n\n2、可以使用狂神配好的centos制作好的镜像！\n\n首先解压\n\n\n\n然后使用vm虚拟机去打开\n\n\n\n启动即可\n\n\n\n如果登录root用户，选择Not Listed ，用户名：root；密码：123456.\n\n3、安装 VMware 虚拟机软件，然后打开我们的镜像即可使用！\n\n购买云服务器（推荐）\n\n虚拟机安装后占用空间，也会有些卡顿，我们作为程序员其实可以选择购买一台自己的服务器，这样的话更加接近真实线上工作；\n1、阿里云购买服务器：https://www.aliyun.com/minisite/goods?userCode=0phtycgr\n2、购买完毕后，获取服务器的ip地址，重置服务器密码，就可以远程登录了\n\n获取公网IP地址\n修改登录密码\n\n\n\n查看或者修改端口\n\n\n3、下载 xShell 工具，进行远程连接使用！\n\n新建会话\n\n\n\n登录，用户名是root，密码是你刚刚设置的实例密码\n\n\n\n登录成功，这里以后就是我们的linux操作系统了\n之后可以使用xftp去执行文件传输操作\n\n注意事项：\n如果要打开端口，需要在阿里云的安全组面板中开启对应的出入规则，不然的话会被阿里拦截！\n\n如果前期不好操作，可以推荐安装宝塔面板，傻瓜式管理服务器\n\n安装教程：https://www.bt.cn/bbs/thread-19376-1-1.html\n1、开启对应的端口\n2、一键安装\n3、安装完毕后会得到远程面板的地址，账号，密码，就可以登录了\n4、登录之后就可以可视化的安装环境和部署网站！\n\n关于域名\n\n如果自己的网站想要上线，就一定要购买一个域名然后进行备案；\n备案的话需要一些认证和时间，备完完毕后，就可以解析到自己的网站了，这个时候就可以使用域名来进行服务器的访问！\n3、走近Linux系统\n开机登录\n\n开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。\n开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示的，输完回车即可！\n一般来说，用户的登录方式有三种：\n\n命令行登录\nssh登录\n图形界面登录\n\n最高权限账户为 root，可以操作一切！\n\n关机\n\n在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。\n关机指令为：shutdown ；\nsync # 将数据由内存同步到硬盘中。shutdown # 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：shutdown –h 10 # 这个命令告诉大家，计算机将在10分钟后关机shutdown –h now # 立马关机shutdown –h 20:25 # 系统会在今天20:25关机shutdown –h +10 # 十分钟后关机shutdown –r now # 系统立马重启shutdown –r +10 # 系统十分钟后重启reboot # 就是重启，等同于 shutdown –r nowhalt # 关闭系统，等同于shutdown –h now 和 poweroff\n\n最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。\n\n系统目录结构\n\n登录系统后，在当前命令窗口下输入命令：\nls /\n\n你会看到如下图所示：\n\n树状目录结构：（Linux的一切资源都挂载在这个 &#x2F; 根节点下）\n\n以下是对这些目录的解释：\n\n&#x2F;bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。\n&#x2F;boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。（不要动）\n&#x2F;dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。\n&#x3D;&#x3D;&#x2F;etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。（以后存放配置文件的地方，比如Redis、Tomcat配置等等）&#x3D;&#x3D;\n&#x3D;&#x3D;&#x2F;home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。&#x3D;&#x3D;\n&#x3D;&#x3D;&#x2F;opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。&#x3D;&#x3D;\n&#x2F;lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。（不要动）\n&#x2F;lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。（存放突然关机的文件）\n&#x2F;media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。\n&#x2F;mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。（后面会把一些本地的文件挂载在这个目录下）\n&#x2F;proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。（不用管）\n&#x3D;&#x3D;&#x2F;root：该目录为系统管理员，也称作超级权限者的用户主目录。&#x3D;&#x3D;\n&#x2F;sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。\n&#x2F;srv：该目录存放一些服务启动之后需要提取的数据。\n&#x2F;sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。\n&#x3D;&#x3D;&#x2F;tmp：这个目录是用来存放一些临时文件的。（用完即丢的文件可以放到这个目录下，如安装包等等）&#x3D;&#x3D;\n&#x3D;&#x3D;&#x2F;usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。&#x3D;&#x3D;\n&#x2F;usr&#x2F;bin： 系统用户使用的应用程序。\n&#x2F;usr&#x2F;sbin： 超级用户使用的比较高级的管理程序和系统守护程序。\n&#x2F;usr&#x2F;src： 内核源代码默认的放置目录。\n&#x3D;&#x3D;&#x2F;var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。&#x3D;&#x3D;\n&#x2F;run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。\n&#x2F;www：存放服务器网站相关的资源，环境以及项目等等。\n\n","tags":["Linux"]},{"title":"Linux入门之Vim使用及账号用户管理","url":"/2022/07/24/Linux%E5%85%A5%E9%97%A8%E4%B9%8BVim%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%B4%A6%E5%8F%B7%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/","content":"1、Vim使用\n什么是Vim编辑器\n\nVim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\n简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。\nvim 则可以说是程序开发者的一项很好用的工具。\n所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。\n连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件。\nvim 键盘图：\n\n\n三种使用模式\n\n基本上 vi&#x2F;vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。这三种模式的作用分别是：\n命令模式：\n用户刚刚启动 vi&#x2F;vim，便进入了命令模式。\n此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。\n以下是常用的几个命令：\n\ni 切换到输入模式，以输入字符。\nx 删除当前光标所在处的字符。\n: 切换到底线命令模式，以在最底一行输入命令。\n\n若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。\n命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。\n输入模式：\n在命令模式下按下i就进入了输入模式。\n在输入模式中，可以使用以下按键：\n\n字符按键以及Shift组合，输入字符\nENTER，回车键，换行\nBACK SPACE，退格键，删除光标前一个字符\nDEL，删除键，删除光标后一个字符\n方向键，在文本中移动光标\nHOME&#x2F;END，移动光标到行首&#x2F;行尾\nPage Up&#x2F;Page Down，上&#x2F;下翻页\nInsert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线\nESC，退出输入模式，切换到命令模式\n\n底线命令模式\n在命令模式下按下:（英文冒号）就进入了底线命令模式。\n底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。\n在底线命令模式中，基本的命令有（已经省略了冒号）：\n\nq 退出程序\nw 保存文件\n\n按ESC键可随时退出底线命令模式。\n简单的说，我们可以将这三个模式想成底下的图标来表示：\n\n\n上手体验一下，在home目录下测试\n\n如果你想要使用 vi 来建立一个名为 fang.txt 的文件时，你可以这样做：\n[root@fang home]# vim fang.txt\n\n然后就会进入文件\n按下 i 进入输入模式(也称为编辑模式)，开始编辑文字\n在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！\n在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。\n这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。\n按下 ESC 按钮回到一般模式\n好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 Esc 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！\n在一般模式中按下 :wq 储存后离开 vim！\n\nVim 按键说明\n\n除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。\n第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等\n\n\n\n移动光标的方法\n\n\n\n\nh 或 向左箭头键(←)\n光标向左移动一个字符\n\n\nj 或 向下箭头键(↓)\n光标向下移动一个字符\n\n\nk 或 向上箭头键(↑)\n光标向上移动一个字符\n\n\nl 或 向右箭头键(→)\n光标向右移动一个字符\n\n\n[Ctrl] + [f]\n屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)\n\n\n[Ctrl] + [b]\n屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)\n\n\n[Ctrl] + [d]\n屏幕『向下』移动半页\n\n\n[Ctrl] + [u]\n屏幕『向上』移动半页\n\n\n+\n光标移动到非空格符的下一行\n\n\n-\n光标移动到非空格符的上一行\n\n\nn&lt; space&gt;\n那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。\n\n\n0 或功能键[Home]\n这是数字『 0 』：移动到这一行的最前面字符处 (常用)\n\n\n$ 或功能键[End]\n移动到这一行的最后面字符处(常用)\n\n\nH\n光标移动到这个屏幕的最上方那一行的第一个字符\n\n\nM\n光标移动到这个屏幕的中央那一行的第一个字符\n\n\nL\n光标移动到这个屏幕的最下方那一行的第一个字符\n\n\nG\n移动到这个档案的最后一行(常用)\n\n\nnG\nn 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)\n\n\ngg\n移动到这个档案的第一行，相当于 1G 啊！(常用)\n\n\nn&lt; Enter&gt;\nn 为数字。光标向下移动 n 行(常用)\n\n\n\n\n\n搜索替换\n\n\n\n\n&#x2F;word\n向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！(常用)\n\n\n?word\n向光标之上寻找一个字符串名称为 word 的字符串。\n\n\nn\n这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！\n\n\nN\n这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。\n\n\n\n\n\n删除、复制与粘贴\n\n\n\n\nx, X\n在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)\n\n\nnx\nn 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。\n\n\ndd\n删除游标所在的那一整行(常用)\n\n\nndd\nn 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)\n\n\nd1G\n删除光标所在到第一行的所有数据\n\n\ndG\n删除光标所在到最后一行的所有数据\n\n\nd$\n删除游标所在处，到该行的最后一个字符\n\n\nd0\n那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符\n\n\nyy\n复制游标所在的那一行(常用)\n\n\nnyy\nn 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)\n\n\ny1G\n复制游标所在行到第一行的所有数据\n\n\nyG\n复制游标所在行到最后一行的所有数据\n\n\ny0\n复制光标所在的那个字符到该行行首的所有数据\n\n\ny$\n复制光标所在的那个字符到该行行尾的所有数据\n\n\np, P\np 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用)\n\n\nJ\n将光标所在行与下一行的数据结合成同一行\n\n\nc\n重复删除多个数据，例如向下删除 10 行，[ 10cj ]\n\n\nu\n复原前一个动作。(常用)\n\n\n[Ctrl]+r\n重做上一个动作。(常用)\n\n\n第二部分：一般模式切换到编辑模式的可用的按钮说明\n\n\n\n进入输入或取代的编辑模式\n\n\n\n\ni, I\n进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用)\n\n\na, A\n进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)\n\n\no, O\n进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用)\n\n\nr, R\n进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)\n\n\n[Esc]\n退出编辑模式，回到一般模式中(常用)\n\n\n第三部分：一般模式切换到指令行模式的可用的按钮说明\n\n\n\n指令行的储存、离开等指令\n\n\n\n\n:w\n将编辑的数据写入硬盘档案中(常用)\n\n\n:w!\n若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！\n\n\n:q\n离开 vi (常用)\n\n\n:q!\n若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。\n\n\n注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～\n\n\n\n:wq\n储存后离开，若为 :wq! 则为强制储存后离开 (常用)\n\n\nZZ\n这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！\n\n\n:w [filename]\n将编辑的数据储存成另一个档案（类似另存新档）\n\n\n:r [filename]\n在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面\n\n\n:n1,n2 w [filename]\n将 n1 到 n2 的内容储存成 filename 这个档案。\n\n\n:! command\n暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls &#x2F;home』即可在 vi 当中看 &#x2F;home 底下以 ls 输出的档案信息！\n\n\n:set nu\n显示行号，设定之后，会在每一行的前缀显示该行的行号\n\n\n:set nonu\n与 set nu 相反，为取消行号！\n\n\n2、账号管理\n简介\n\nLinux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。\n用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。\n每个用户账号都拥有一个唯一的用户名和各自的口令。\n用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。\n实现用户账号的管理，要完成的工作主要有如下几个方面：\n\n用户账号的添加、删除与修改。\n用户口令的管理。\n用户组的管理。\n\n\n用户账号的管理\n\n用户账号的管理工作主要涉及到用户账号的添加、修改和删除。\n添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。\n\n添加账号 useradd\n\nuseradd 选项 用户名\n\n参数说明：\n\n选项 :\n\n\n-c comment 指定一段注释性描述。\n-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\n-g 用户组 指定用户所属的用户组。\n-G 用户组，用户组 指定用户所属的附加组。\n-m　使用者目录如不存在则自动建立。\n-s Shell文件 指定用户的登录Shell。\n-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。\n\n\n用户名 :\n\n\n指定新账号的登录名。\n\n\n\n测试：\n# 此命令创建了一个用户fang，其中-m选项用来为登录名fang产生一个主目录 /home/fang[root@fang home]# useradd -m fang\n\n增加用户账号就是在&#x2F;etc&#x2F;passwd文件中为新用户增加一条记录，同时更新其他系统文件如&#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等。\n\n删除帐号\n\n如果一个用户的账号不再使用，可以从系统中删除。\n删除用户账号就是要将&#x2F;etc&#x2F;passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。\n删除一个已有的用户账号使用userdel命令，其格式如下：\nuserdel 选项 用户名\n\n常用的选项是 -r，它的作用是把用户的主目录一起删除。\n[root@fang home]# userdel -r fang\n\n此命令删除用户fang在系统文件中（主要是&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等）的记录，同时删除用户的主目录。\n\nLinux下如何切换用户\n\n1.切换用户的命令为：su username 【username是你的用户名哦】\n2.从普通用户切换到root用户，还可以使用命令：sudo su\n3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令\n4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】\n$表示普通用户\n#表示超级用户，也就是root用户\n\n修改帐号\n\n修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。\n修改已有用户的信息使用usermod命令，其格式如下：\nusermod 选项 用户名\n\n常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。\n例如：\n# usermod -s /bin/ksh -d /home/z –g developer fang\n\n此命令将用户fang的登录Shell修改为ksh，主目录改为&#x2F;home&#x2F;z，用户组改为developer。\n\n用户口令的管理\n\n用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。\n指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。\n命令的格式为：\npasswd 选项 用户名\n\n可使用的选项：\n\n-l 锁定口令，即禁用账号。\n-u 口令解锁。\n-d 使账号无口令。\n-f 强迫用户下次登录时修改口令。\n\n如果默认用户名，则修改当前用户的口令。\n例如，假设当前用户是fang，则下面的命令修改该用户自己的口令：\n$ passwdOld password:******New password:*******Re-enter new password:*******\n\n如果是超级用户，可以用下列形式指定任何用户的口令：\n# passwd fangNew password:*******Re-enter new password:*******\n\n普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。\n为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。\n为用户指定空口令时，执行下列形式的命令：\n# passwd -d fang\n\n此命令将用户 fang的口令删除，这样用户 fang下一次登录时，系统就不再允许该用户登录了。\npasswd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：\n# passwd -l fang\n\n3、用户组管理每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。\n用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对&#x2F;etc&#x2F;group文件的更新。\n\n增加一个新的用户组使用groupadd命令\n\ngroupadd 选项 用户组\n\n可以使用的选项有：\n\n-g GID 指定新用户组的组标识号（GID）。\n-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。\n\n实例1：\n# groupadd group1\n\n此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。\n实例2：\n# groupadd -g 101 group2\n\n此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。\n\n如果要删除一个已有的用户组，使用groupdel命令\n\ngroupdel 用户组\n\n例如：\n# groupdel group1\n\n此命令从系统中删除组group1。\n\n修改用户组的属性使用groupmod命令\n\ngroupmod 选项 用户组\n\n常用的选项有：\n\n-g GID 为用户组指定新的组标识号。\n-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。\n-n新用户组 将用户组的名字改为新名字\n\n# 此命令将组group2的组标识号修改为102。groupmod -g 102 group2# 将组group2的标识号改为10000，组名修改为group3。groupmod –g 10000 -n group3 group2\n\n\n切换组\n\n如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。\n用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：\n$ newgrp root\n\n这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。\n\n&#x2F;etc&#x2F;passwd\n\n完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。\n与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等。\n下面分别介绍这些文件的内容。\n&#x2F;etc&#x2F;passwd文件是用户管理工作涉及的最重要的一个文件。\nLinux系统中的每个用户都在&#x2F;etc&#x2F;passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。\n这个文件对所有用户都是可读的。它的内容类似下面的例子：\n＃ cat /etc/passwdroot:x:0:0:Superuser:/:daemon:x:1:1:System daemons:/etc:bin:x:2:2:Owner of system commands:/bin:sys:x:3:3:Owner of system files:/usr/sys:adm:x:4:4:System accounting:/usr/adm:uucp:x:5:5:UUCP administrator:/usr/lib/uucp:auth:x:7:21:Authentication administrator:/tcb/files/auth:cron:x:9:16:Cron daemon:/usr/spool/cron:listen:x:37:4:Network daemon:/usr/net/nls:lp:x:71:18:Printer administrator:/usr/spool/lp:\n\n从上面的例子我们可以看到，&#x2F;etc&#x2F;passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：\n用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell\n\n1）”用户名”是代表用户账号的字符串。\n通常长度不超过8个字符，并且由大小写字母和&#x2F;或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。\n为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。\n2）“口令”一些系统中，存放着加密后的用户口令字。\n虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于&#x2F;etc&#x2F;passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到&#x2F;etc&#x2F;shadow文件中，而在&#x2F;etc&#x2F;passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。\n3）“用户标识号”是一个整数，系统内部用它来标识用户。\n一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。\n通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。\n4）“组标识号”字段记录的是用户所属的用户组。\n它对应着&#x2F;etc&#x2F;group文件中的一条记录。\n5)“注释性描述”字段记录着用户的一些个人情况。\n例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。\n6)“主目录”，也就是用户的起始工作目录。\n它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。\n7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。\nShell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX&#x2F;TOPS-20 type C Shell), bash(Bourne Again Shell)等。\n系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为&#x2F;bin&#x2F;sh。\n用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。\n利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。\n8)系统中有一类用户称为伪用户（pseudo users）。\n这些用户在&#x2F;etc&#x2F;passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。\n常见的伪用户如下所示：\n伪 用 户 含 义bin 拥有可执行的用户命令文件sys 拥有系统文件adm 拥有帐户文件uucp UUCP使用lp lp或lpd子系统使用nobody NFS使用\n\n\n&#x2F;etc&#x2F;shadow\n\n1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。\n由于&#x2F;etc&#x2F;passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是&#x2F;etc&#x2F;shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。\n2、&#x2F;etc&#x2F;shadow中的记录行与&#x2F;etc&#x2F;passwd中的一一对应，它由pwconv命令根据&#x2F;etc&#x2F;passwd中的数据自动产生\n它的文件格式与&#x2F;etc&#x2F;passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：\n登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志\n\n\n“登录名”是与&#x2F;etc&#x2F;passwd文件中的登录名相一致的用户账号\n“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { .&#x2F;0-9A-Za-z }中的字符，则对应的用户不能登录。\n“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。\n“最小时间间隔”指的是两次修改口令之间所需的最小天数。\n“最大时间间隔”指的是口令保持有效的最大天数。\n“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。\n“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。\n“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。\n\n\n&#x2F;etc&#x2F;group\n\n用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。\n将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。\n每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。\n当一个用户同时是多个组中的成员时，在&#x2F;etc&#x2F;passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。\n用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。\n用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。此文件的格式也类似于&#x2F;etc&#x2F;passwd文件，由冒号(:)隔开若干个字段，这些字段有：\n组名:口令:组标识号:组内用户列表\n\n\n“组名”是用户组的名称，由字母或数字构成。与&#x2F;etc&#x2F;passwd中的登录名一样，组名不应重复。\n“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。\n“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。\n“组内用户列表”是属于这个组的所有用户的列表&#x2F;b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。\n\n4、磁盘管理\n概述\n\nLinux磁盘管理好坏直接关系到整个系统的性能问题。\nLinux磁盘管理常用命令为 df、du。\n\ndf ：列出文件系统的整体磁盘使用量\ndu：检查磁盘空间使用量\n\n\ndf\n\ndf命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。\n语法：\ndf [-ahikHTm] [目录或文件名]\n\n选项与参数：\n\n-a ：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统；\n-k ：以 KBytes 的容量显示各文件系统；\n-m ：以 MBytes 的容量显示各文件系统；\n-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；\n-H ：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式；\n-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；\n-i ：不用硬盘容量，而以 inode 的数量来显示\n\n测试：\n# 将系统内所有的文件系统列出来！# 在 Linux 底下如果 df 没有加任何选项# 那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！[root@fang /]# dfFilesystem     1K-blocks   Used Available Use% Mounted ondevtmpfs          889100       0    889100   0% /devtmpfs             899460     704    898756   1% /dev/shmtmpfs             899460     496    898964   1% /runtmpfs             899460       0    899460   0% /sys/fs/cgroup/dev/vda1       41152812 6586736  32662368  17% /tmpfs             179896       0    179896   0% /run/user/0# 将容量结果以易读的容量格式显示出来[root@fang /]# df -hFilesystem     Size Used Avail Use% Mounted ondevtmpfs       869M     0 869M   0% /devtmpfs           879M 708K 878M   1% /dev/shmtmpfs           879M 496K 878M   1% /runtmpfs           879M     0 879M   0% /sys/fs/cgroup/dev/vda1       40G  6.3G   32G  17% /tmpfs           176M     0 176M   0% /run/user/0# 将系统内的所有特殊文件格式及名称都列出来[root@fang /]# df -aTFilesystem     Type       1K-blocks   Used Available Use% Mounted onsysfs         sysfs               0       0         0    - /sysproc           proc                0       0         0    - /procdevtmpfs       devtmpfs       889100       0    889100   0% /devsecurityfs     securityfs          0       0         0    - /sys/kernel/securitytmpfs         tmpfs          899460     708    898752   1% /dev/shmdevpts         devpts              0       0         0    - /dev/ptstmpfs         tmpfs          899460     496    898964   1% /runtmpfs         tmpfs          899460       0    899460   0% /sys/fs/cgroupcgroup         cgroup              0       0         0    - /sys/fs/cgroup/systemdpstore         pstore              0       0         0    - /sys/fs/pstorecgroup         cgroup              0       0         0    - /sys/fs/cgroup/freezercgroup         cgroup              0       0         0    - /sys/fs/cgroup/cpusetcgroup         cgroup              0       0         0    - /sys/fs/cgroup/hugetlbcgroup         cgroup              0       0         0    - /sys/fs/cgroup/blkiocgroup         cgroup              0       0         0    - /sys/fs/cgroup/net_cls,net_priocgroup         cgroup              0       0         0    - /sys/fs/cgroup/memorycgroup         cgroup              0       0         0    - /sys/fs/cgroup/pidscgroup         cgroup              0       0         0    - /sys/fs/cgroup/cpu,cpuacctcgroup         cgroup              0       0         0    - /sys/fs/cgroup/devicescgroup         cgroup              0       0         0    - /sys/fs/cgroup/perf_eventconfigfs       configfs            0       0         0    - /sys/kernel/config/dev/vda1     ext4         41152812 6586748  32662356  17% /systemd-1      -                   -       -         -    - /proc/sys/fs/binfmt_miscmqueue         mqueue              0       0         0    - /dev/mqueuedebugfs       debugfs             0       0         0    - /sys/kernel/debughugetlbfs     hugetlbfs           0       0         0    - /dev/hugepagestmpfs         tmpfs          179896       0    179896   0% /run/user/0binfmt_misc   binfmt_misc         0       0         0    - /proc/sys/fs/binfmt_misc# 将 /etc 底下的可用的磁盘容量以易读的容量格式显示[root@fang /]# df -h /etcFilesystem     Size Used Avail Use% Mounted on/dev/vda1       40G  6.3G   32G  17% /\n\n\ndu\n\nLinux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。\n语法：\ndu [-ahskm] 文件或目录名称\n\n选项与参数：\n\n-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。\n-h ：以人们较易读的容量格式 (G&#x2F;M) 显示；\n-s ：列出总量而已，而不列出每个各别的目录占用容量；\n-S ：不包括子目录下的总计，与 -s 有点差别。\n-k ：以 KBytes 列出容量显示；\n-m ：以 MBytes 列出容量显示；\n\n测试：\n# 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:# 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。[root@fang home]# du16./redis8./www/.oracle_jre_usage  # 包括隐藏文件的目录24./www48.                        # 这个目录(.)所占用的总量# 将文件的容量也列出来[root@fang home]# du -a4./redis/.bash_profile4./redis/.bash_logout    ....中间省略....4./kuangstudy.txt # 有文件的列表了48.# 检查根目录底下每个目录所占用的容量[root@fang home]# du -sm /*0/bin146/boot.....中间省略....0/proc.....中间省略....1/tmp3026/usr  # 系统初期最大就是他了啦！513/var2666/www\n\n通配符 * 来代表每个目录。\n与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。\n\n磁盘挂载与卸除\n\n根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载”\nLinux 的磁盘挂载使用mount命令，卸载使用umount命令。\n磁盘挂载语法：\nmount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点\n\n测试：\n# 将 /dev/hdc6 挂载到 /mnt/hdc6 上面！[root@www ~]# mkdir /mnt/hdc6[root@www ~]# mount /dev/hdc6 /mnt/hdc6[root@www ~]# dfFilesystem           1K-blocks     Used Available Use% Mounted on/dev/hdc6              1976312     42072   1833836   3% /mnt/hdc6\n\n磁盘卸载命令 umount 语法：\numount [-fn] 装置文件名或挂载点\n\n选项与参数：\n\n-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；\n-n ：不升级 &#x2F;etc&#x2F;mtab 情况下卸除。\n\n卸载&#x2F;dev&#x2F;hdc6\n[root@www ~]# umount /dev/hdc6\n\n5、进程管理\n简介\n\n1、在LINUX中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号。 \n2、每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。 \n3、 每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。 \n4、一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。\n\nps指令\n\n使用ps指令即可查看当前系统中正在执行的进程的各种进程信息 \n基本语法 \nps –选项 \n选项说明： \n\n-a：显示当前终端的所有进程信息 \n-u：以用户的形式显示进程信息 \n-x：显示后台进程运行的参数\n\nps -aux|grep xxx ，查看某个服务的进程 如，ps -aux|grep mysql\n\n说明： \n1、grep 命令用于查找文件里符合条件的字符串。 \n2、命令格式：命令A|命令B，即命令A的正确输出作为命令B的操作对象\n使用 ps -ef可查看父进程 \nps -ef是以全格式显示当前所有的进程\n-e 显示所有进程。-f 全格式。 \n\nUID：用户ID \nPID：进程ID\n\n\n终止进程kill或killall\n\nkill指令就像是Windows系统中的任务管理-&gt;结束任务一样 \n基本语法： \n\nkill [选项] 进程号（功能描述：通过进程号杀死进程） \nkillall 进程名称 （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负 载过大而变得很慢 时很有用） \n常用选项： -9 :表示强迫进程立即停止\n\nkill -9 PID\n\n\n查看进程树pstree\n\n基本语法： \npstree [选项] ,可以更加直观的来看进程信息 \n常用选项： \n\n-p :显示进程的PID \n-u :显示进程的所属用户\n\n\n","tags":["Linux"]},{"title":"SpringBoot开发实用篇之整合Dubbo和Zookeeper","url":"/2022/07/17/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88Dubbo%E5%92%8CZookeeper/","content":"1、什么是分布式系统？在《分布式系统原理与范型》一书中有如下定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”；\n分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。\n分布式系统（distributed system）是建立在网络之上的软件系统。\n首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。\n1.Dubbo文档随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不紊的演进。\n在Dubbo的官网文档有这样一张图\n\n2.单一应用架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。\n\n适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。\n缺点：\n1、性能扩展比较难\n2、协同开发问题\n3、不利于升级维护\n3.垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。\n\n通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。\n缺点：公用模块无法重复利用，开发性的浪费\n4.分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。\n\n5.流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键。\n\n2、什么是RPCRPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。\n也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数&#x2F;方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数；\n推荐阅读文章：https://www.jianshu.com/p/2accc2840a1b\nRPC基本原理\n\n步骤解析：\n\nRPC两个核心模块：通讯，序列化。\n3、测试环境搭建1.DubboApache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。\ndubbo官网 http://dubbo.apache.org/zh-cn/index.html\n1.了解Dubbo的特性\n2.查看官方文档\ndubbo基本概念\n\n服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。\n服务消费者（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者\n监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心\n调用关系说明\nl 服务容器负责启动，加载，运行服务提供者。\nl 服务提供者在启动时，向注册中心注册自己提供的服务。\nl 服务消费者在启动时，向注册中心订阅自己所需的服务。\nl 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\nl 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\nl 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n2.Dubbo环境搭建点进dubbo官方文档，推荐我们使用Zookeeper 注册中心\n什么是zookeeper呢？可以查看官方文档\n3.Window下安装zookeeper1、下载zookeeper ：地址， 我们下载3.4.14 ， 最新版！解压zookeeper\n2、运行&#x2F;bin&#x2F;zkServer.cmd: 初次运行会报错，没有zoo.cfg配置文件；\n可能遇到问题：闪退 !\n解决方案：编辑zkServer.cmd文件末尾添加pause 。这样运行出错就不会退出，会提示错误信息，方便找到原因。\n\n3、修改zoo.cfg配置文件\n将conf文件夹下面的zoo_sample.cfg复制一份改名为zoo.cfg即可。\n注意几个重要位置：\ndataDir&#x3D;.&#x2F;  临时数据存储的目录（可写相对路径）\nclientPort&#x3D;2181  zookeeper的端口号\n修改完成后再次启动zookeeper\n4、使用zkCli.cmd测试\nls &#x2F;：列出zookeeper根下保存的所有节点\n[zk: 127.0.0.1:2181(CONNECTED) 4] ls /[zookeeper]\n\ncreate –e &#x2F;fang123：创建一个fang节点，值为123\nget &#x2F;fang：获取&#x2F;fang节点的值\n4.window下安装dubbo-admindubbo本身并不是一个服务软件。它其实就是一个jar包，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。\n但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。\n我们这里来安装一下：\n1、下载dubbo-admin\n地址 ：https://github.com/apache/dubbo-admin/tree/master\n2、解压进入目录\n修改 dubbo-admin\\src\\main\\resources \\application.properties 指定zookeeper地址\nserver.port=7001spring.velocity.cache=falsespring.velocity.charset=UTF-8spring.velocity.layout-url=/templates/default.vmspring.messages.fallback-to-system-locale=falsespring.messages.basename=i18n/messagespring.root.password=rootspring.guest.password=guestdubbo.registry.address=zookeeper://127.0.0.1:2181\n\n3、在项目目录下打包dubbo-admin\nmvn clean package -Dmaven.test.skip=true\n\n第一次打包的过程有点慢，需要耐心等待！直到成功！\n4、执行 dubbo-admin\\target 下的dubbo-admin-0.0.1-SNAPSHOT.jar\njava -jar dubbo-admin-0.0.1-SNAPSHOT.jar\n\n【注意：zookeeper的服务一定要打开！】\n执行完毕，我们去访问一下 http://localhost:7001/ ， 这时候我们需要输入登录账户和密码，我们都是默认的root-root；\n登录成功后，查看界面\n\n4、SpringBoot + Dubbo + zookeeper1.框架搭建1. 启动zookeeper ！\n2. IDEA创建一个空项目；\n3.创建一个模块，实现服务提供者：provider-server ， 选择web依赖即可\n4.项目创建完毕，我们写一个服务，比如卖票的服务；\n编写接口\npackage com.fang.provider.service;public interface TicketService &#123;   public String getTicket();&#125;\n\n编写实现类\npackage com.fang.provider.service;public class TicketServiceImpl implements TicketService &#123;   @Override   public String getTicket() &#123;       return &quot;《java》&quot;;  &#125;&#125;\n\n5.创建一个模块，实现服务消费者：consumer-server ， 选择web依赖即可\n6.项目创建完毕，我们写一个服务，比如用户的服务；\n编写service\npackage com.fang.consumer.service;public class UserService &#123;   //我们需要去拿去注册中心的服务&#125;\n\n需求：现在我们的用户想使用买票的服务，这要怎么弄呢 ？\n2.服务提供者1、将服务提供者注册到注册中心，我们需要整合Dubbo和zookeeper，所以需要导包\n我们从dubbo官网进入github，看下方的帮助文档，找到dubbo-springboot，找到依赖包\n&lt;!-- Dubbo Spring Boot Starter --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;   &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;    \n\nzookeeper的包我们去maven仓库下载，zkclient；\n&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;&lt;dependency&gt;   &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;   &lt;artifactId&gt;zkclient&lt;/artifactId&gt;   &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt;\n\n【新版的坑】zookeeper及其依赖包，解决日志冲突，还需要剔除日志依赖；\n&lt;!-- 引入zookeeper --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;   &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;   &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;   &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;   &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;   &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;   &lt;version&gt;3.4.14&lt;/version&gt;   &lt;!--排除这个slf4j-log4j12--&gt;   &lt;exclusions&gt;       &lt;exclusion&gt;           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;           &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;       &lt;/exclusion&gt;   &lt;/exclusions&gt;&lt;/dependency&gt;\n\n2、在springboot配置文件中配置dubbo相关属性！\n#当前应用名字dubbo.application.name=provider-server#注册中心地址dubbo.registry.address=zookeeper://127.0.0.1:2181#扫描指定包下服务dubbo.scan.base-packages=com.fang.provider.service\n\n3、在service的实现类中配置服务注解，发布服务！注意导包问题\nimport org.apache.dubbo.config.annotation.Service;import org.springframework.stereotype.Component;@Service //将服务发布出去@Component //放在容器中public class TicketServiceImpl implements TicketService &#123;   @Override   public String getTicket() &#123;       return &quot;《狂神说Java》&quot;;  &#125;&#125;\n\n逻辑理解 ：应用启动起来，dubbo就会扫描指定的包下带有@component注解的服务，将它发布在指定的注册中心中！\n3.服务消费者1、导入依赖，和之前的依赖一样；\n&lt;!--dubbo--&gt;&lt;!-- Dubbo Spring Boot Starter --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;   &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--zookeeper--&gt;&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;&lt;dependency&gt;   &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;   &lt;artifactId&gt;zkclient&lt;/artifactId&gt;   &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 引入zookeeper --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;   &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;   &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;   &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;   &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;   &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;   &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;   &lt;version&gt;3.4.14&lt;/version&gt;   &lt;!--排除这个slf4j-log4j12--&gt;   &lt;exclusions&gt;       &lt;exclusion&gt;           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;           &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;       &lt;/exclusion&gt;   &lt;/exclusions&gt;&lt;/dependency&gt;\n\n2、配置参数\n#当前应用名字dubbo.application.name=consumer-server#注册中心地址dubbo.registry.address=zookeeper://127.0.0.1:2181\n\n3. 本来正常步骤是需要将服务提供者的接口打包，然后用pom文件导入，我们这里使用简单的方式，直接将服务的接口拿过来，路径必须保证正确，即和服务提供者相同；\n4. 完善消费者的服务类\npackage com.fang.consumer.service;import com.fang.provider.service.TicketService;import org.apache.dubbo.config.annotation.Reference;import org.springframework.stereotype.Service;@Service //注入到容器中public class UserService &#123;   @Reference //远程引用指定的服务，他会按照全类名进行匹配，看谁给注册中心注册了这个全类名   TicketService ticketService;   public void bugTicket()&#123;       String ticket = ticketService.getTicket();       System.out.println(&quot;在注册中心买到&quot;+ticket);  &#125;&#125;\n\n5. 测试类编写；\n@RunWith(SpringRunner.class)@SpringBootTestpublic class ConsumerServerApplicationTests &#123;   @Autowired   UserService userService;   @Test   public void contextLoads() &#123;       userService.bugTicket();  &#125;&#125;\n\n4.启动测试1. 开启zookeeper\n2. 打开dubbo-admin实现监控【可以不用做】\n3. 开启服务者\n4. 消费者消费测试，结果，监控中心：\n\n","tags":["SpringBoot"]},{"title":"SpringBoot开发实用篇之集成SpringSecurity","url":"/2022/07/13/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E9%9B%86%E6%88%90SpringSecurity/","content":"1、简介在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。\n市面上存在比较有名的：Shiro，Spring Security ！\n这里需要阐述一下的是，每一个框架的出现都是为了解决某一问题而产生了，那么Spring Security框架的出现是为了解决什么问题呢？\n首先我们看下它的官网介绍：Spring Security\nSpring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.\nSpring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements\nSpring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。\nSpring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求\n从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。\n怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。\nSpring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。\n对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。\n2、实战测试1、新建一个初始的springboot项目web模块，thymeleaf模块\n2、导入静态资源\nwelcome.html|views|level1        1.html        2.html        3.html|level2        1.html        2.html        3.html|level3        1.html        2.html        3.htmlLogin.html\n\n3、controller跳转！\npackage com.kuang.controller; import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping; @Controllerpublic class RouterController &#123;     @RequestMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;)    public String index()&#123;        return &quot;index&quot;;    &#125;     @RequestMapping(&quot;/toLogin&quot;)    public String toLogin()&#123;        return &quot;views/login&quot;;    &#125;     @RequestMapping(&quot;/level1/&#123;id&#125;&quot;)    public String level1(@PathVariable(&quot;id&quot;) int id)&#123;        return &quot;views/level1/&quot;+id;    &#125;     @RequestMapping(&quot;/level2/&#123;id&#125;&quot;)    public String level2(@PathVariable(&quot;id&quot;) int id)&#123;        return &quot;views/level2/&quot;+id;    &#125;     @RequestMapping(&quot;/level3/&#123;id&#125;&quot;)    public String level3(@PathVariable(&quot;id&quot;) int id)&#123;        return &quot;views/level3/&quot;+id;    &#125; &#125;\n\n4、测试实验环境是否OK！\n3、认识SpringSecuritySpring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！\n记住几个类：\n\nWebSecurityConfigurerAdapter：自定义Security策略\nAuthenticationManagerBuilder：自定义认证策略\n@EnableWebSecurity：开启WebSecurity模式\n\nSpring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。\n“认证”（Authentication）\n身份验证是关于验证您的凭据，如用户名&#x2F;用户ID和密码，以验证您的身份。\n身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。\n“授权” （Authorization）\n授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。\n这个概念是通用的，而不是只在Spring Security 中存在。\n认证和授权目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能\n1、引入 Spring Security 模块\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2、编写 Spring Security 配置类\n参考官网：https://spring.io/projects/spring-security\n查看我们自己项目中的版本，找到对应的帮助文档：\nhttps://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5  #servlet-applications 8.16.4\n\n3、编写基础配置类\npackage com.kuang.config; import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; @EnableWebSecurity // 开启WebSecurity模式public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;     @Override    protected void configure(HttpSecurity http) throws Exception &#123;            &#125;&#125;\n\n4、定制请求的授权规则\n@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;    // 定制请求的授权规则    // 首页所有人可以访问    http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()    .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)    .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)    .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);&#125;\n\n5、测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！\n6、在configure()方法中加入以下配置，开启自动配置的登录功能！\n// 开启自动配置的登录功能// /login 请求来到登录页// /login?error 重定向到这里表示登录失败http.formLogin();\n\n7、测试一下：发现，没有权限的时候，会跳转到登录的页面！\n\n8、查看刚才登录页的注释信息；\n我们可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法\n//定义认证规则@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        //在内存中定义，也可以在jdbc中去拿....    auth.inMemoryAuthentication()            .withUser(&quot;kuangshen&quot;).password(&quot;123456&quot;).roles(&quot;vip2&quot;,&quot;vip3&quot;)            .and()            .withUser(&quot;root&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)            .and()            .withUser(&quot;guest&quot;).password(&quot;123456&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;);&#125;\n\n9、测试，我们可以使用这些账号登录进行测试！发现会报错！\nThere is no PasswordEncoder mapped for the id “null”\n\n10、原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码\n//定义认证规则@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;    //在内存中定义，也可以在jdbc中去拿....    //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。    //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密    //spring security 官方推荐的是使用bcrypt加密方式。        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())            .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)            .and()            .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)            .and()            .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);&#125;\n\n11、测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定\n权限控制和注销1、开启自动配置的注销的功能\n//定制请求的授权规则@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;    //....    //开启自动配置的注销的功能       // /logout 注销请求    http.logout();&#125;\n\n2、我们在前端，增加一个注销的按钮，index.html 导航栏中\n&lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;    &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销&lt;/a&gt;\n\n3、我们可以去测试一下，登录成功后点击注销，发现注销完毕会跳转到登录页面！\n4、但是，我们想让他注销成功后，依旧可以跳转到首页，该怎么处理呢？\n// .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页http.logout().logoutSuccessUrl(&quot;/&quot;);\n\n5、测试，注销完毕后，发现跳转到首页OK\n6、我们现在又来一个需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！这个就是真实的网站情况了！该如何做呢？\n我们需要结合thymeleaf中的一些功能\nsec：authorize&#x3D;”isAuthenticated()”:是否认证登录！来显示不同的页面\nMaven依赖：\n&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;    &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;    &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n7、修改我们的 前端页面\n\n导入命名空间\n\nxmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;\n\n\n修改导航栏，增加认证判断\n\n&lt;!--登录注销--&gt;&lt;div class=&quot;right menu&quot;&gt;    &lt;!--如果未登录--&gt;    &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt;        &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/login&#125;&quot;&gt;            &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录        &lt;/a&gt;    &lt;/div&gt;    &lt;!--如果已登录--&gt;    &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;        &lt;a class=&quot;item&quot;&gt;            &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt;            用户名：&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;            角色：&lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt;        &lt;/a&gt;    &lt;/div&gt;    &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;        &lt;a class=&quot;item&quot; th:href=&quot;@&#123;/logout&#125;&quot;&gt;            &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销        &lt;/a&gt;    &lt;/div&gt;&lt;/div&gt;\n\n8、重启测试，我们可以登录试试看，登录成功后确实，显示了我们想要的页面；\n9、如果注销404了，就是因为它默认防止csrf跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加\nhttp.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求http.logout().logoutSuccessUrl(&quot;/&quot;);\n\n10、我们继续将下面的角色功能块认证完成！\n&lt;!-- sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot; --&gt;&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip1&#x27;)&quot;&gt;    &lt;div class=&quot;ui raised segment&quot;&gt;        &lt;div class=&quot;ui&quot;&gt;            &lt;div class=&quot;content&quot;&gt;                &lt;h5 class=&quot;content&quot;&gt;Level 1&lt;/h5&gt;                &lt;hr&gt;                &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-1&lt;/a&gt;&lt;/div&gt;                &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-2&lt;/a&gt;&lt;/div&gt;                &lt;div&gt;&lt;a th:href=&quot;@&#123;/level1/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-3&lt;/a&gt;&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip2&#x27;)&quot;&gt;    &lt;div class=&quot;ui raised segment&quot;&gt;        &lt;div class=&quot;ui&quot;&gt;            &lt;div class=&quot;content&quot;&gt;                &lt;h5 class=&quot;content&quot;&gt;Level 2&lt;/h5&gt;                &lt;hr&gt;                &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-1&lt;/a&gt;&lt;/div&gt;                &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-2&lt;/a&gt;&lt;/div&gt;                &lt;div&gt;&lt;a th:href=&quot;@&#123;/level2/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-3&lt;/a&gt;&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole(&#x27;vip3&#x27;)&quot;&gt;    &lt;div class=&quot;ui raised segment&quot;&gt;        &lt;div class=&quot;ui&quot;&gt;            &lt;div class=&quot;content&quot;&gt;                &lt;h5 class=&quot;content&quot;&gt;Level 3&lt;/h5&gt;                &lt;hr&gt;                &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/1&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-1&lt;/a&gt;&lt;/div&gt;                &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/2&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-2&lt;/a&gt;&lt;/div&gt;                &lt;div&gt;&lt;a th:href=&quot;@&#123;/level3/3&#125;&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-3&lt;/a&gt;&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;\n\n11、测试一下！\n12、权限控制和注销搞定！\n4、记住我现在的情况，我们只要登录之后，关闭浏览器，再登录，就会让我们重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现呢？很简单\n1、开启记住我功能\n//定制请求的授权规则@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;    //。。。。。。。。。。。    //记住我    http.rememberMe();&#125;\n\n2、我们再次启动项目测试一下，发现登录页多了一个记住我功能，我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！\n思考：如何实现的呢？其实非常简单\n我们可以查看浏览器的cookie\n3、我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie\n4、结论：登录成功后，将cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie，具体的原理我们在JavaWeb阶段都讲过了，这里就不在多说了！\n5、定制登录页现在这个登录页面都是spring security 默认的，怎么样可以使用我们自己写的Login界面呢？\n1、在刚才的登录页配置后面指定 loginpage\nhttp.formLogin().loginPage(&quot;/toLogin&quot;);\n\n2、然后前端也需要指向我们自己定义的 login请求\n&lt;a class=&quot;item&quot; th:href=&quot;@&#123;/toLogin&#125;&quot;&gt;    &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录&lt;/a&gt;\n\n3、我们登录，需要将这些信息发送到哪里，我们也需要配置，login.html 配置提交请求及方式，方式必须为post:\n在 loginPage()源码中的注释上有写明：\n\n&lt;form th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt;    &lt;div class=&quot;field&quot;&gt;        &lt;label&gt;Username&lt;/label&gt;        &lt;div class=&quot;ui left icon input&quot;&gt;            &lt;input type=&quot;text&quot; placeholder=&quot;Username&quot; name=&quot;username&quot;&gt;            &lt;i class=&quot;user icon&quot;&gt;&lt;/i&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;field&quot;&gt;        &lt;label&gt;Password&lt;/label&gt;        &lt;div class=&quot;ui left icon input&quot;&gt;            &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;            &lt;i class=&quot;lock icon&quot;&gt;&lt;/i&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;input type=&quot;submit&quot; class=&quot;ui blue submit button&quot;/&gt;&lt;/form&gt;\n\n4、这个请求提交上来，我们还需要验证处理，怎么做呢？我们可以查看formLogin()方法的源码！我们配置接收登录的用户名和密码的参数！\nhttp.formLogin()    .usernameParameter(&quot;username&quot;)    .passwordParameter(&quot;password&quot;)    .loginPage(&quot;/toLogin&quot;)    .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求\n\n5、在登录页增加记住我的多选框\n&lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt; 记住我\n\n6、后端验证处理！\n//定制记住我的参数！http.rememberMe().rememberMeParameter(&quot;remember&quot;);\n\n7、测试，OK\n6、完整配置代码package com.kuang.config; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; @EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;     //定制请求的授权规则    @Override    protected void configure(HttpSecurity http) throws Exception &#123;         http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()        .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)        .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)        .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);          //开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！            // /login 请求来到登录页            // /login?error 重定向到这里表示登录失败        http.formLogin()            .usernameParameter(&quot;username&quot;)            .passwordParameter(&quot;password&quot;)            .loginPage(&quot;/toLogin&quot;)            .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求         //开启自动配置的注销的功能            // /logout 注销请求            // .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页         http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求        http.logout().logoutSuccessUrl(&quot;/&quot;);         //记住我        http.rememberMe().rememberMeParameter(&quot;remember&quot;);    &#125;     //定义认证规则    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        //在内存中定义，也可以在jdbc中去拿....        //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。        //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密        //spring security 官方推荐的是使用bcrypt加密方式。         auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())                .withUser(&quot;kuangshen&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)                .and()                .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)                .and()                .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;);    &#125;&#125;\n\n","tags":["SpringBoot"]},{"title":"leetcode之无重复字符的最长子串","url":"/2022/07/12/leetcode%E4%B9%8B%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","content":"1、问题描述\n2、思路以这个字符串为例：abcabcbb，当i等于3时，也就是指向了第二个a, 此时我就需要查之前有没有出现过a, 如果出现了是在哪一个位置出现的。然后通过last[index] 查到等于1, 也就是说，如果start 依然等于0的话，那么当前窗口就有两个a了，也就是字符串重复了，所以我们需要移动当前窗口的start指针，移动到什么地方呢？移动到什么地方，窗口内就没有重复元素了呢？ 对了，就是a上一次出现的位置的下一个位置，就是1 + 1 &#x3D; 2。当start &#x3D;&#x3D; 2, 当前窗口就没有了重复元素，那么以当前字符为结尾的最长无重复子串就是bca,然后再和之前的res取最大值。然后i指向后面的位置，按照同样思路计算。\n3、代码class Solution &#123;    public int lengthOfLongestSubstring(String s) &#123;        // 记录字符上一次出现的位置        int[] last = new int[128];        for(int i = 0; i &lt; 128; i++) &#123;            last[i] = -1;        &#125;        int n = s.length();        int res = 0;        int start = 0; // 窗口开始位置        for(int i = 0; i &lt; n; i++) &#123;            int index = s.charAt(i);            start = Math.max(start, last[index] + 1);            res   = Math.max(res, i - start + 1);            last[index] = i;        &#125;        return res;    &#125;&#125;\n\n","tags":["leetcode"]},{"title":"SpringBoot开发实用篇之集成Shiro","url":"/2022/07/15/SpringBoot%E5%BC%80%E5%8F%91%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E9%9B%86%E6%88%90Shiro/","content":"1、Shiro简介1. 什么是Shiro？\nApache Shiro是一个强大且易用的Java安全框架\n可以完成身份验证、授权、密码和会话管理\nShiro可以完成，认证，授权，加密，会话管理，Web集成，缓存等。\nShiro 不仅可以用在 JavaSE 环境中，也可以用在 JavaEE 环境中\n\n官网： http://shiro.apache.org/\n2. 有哪些功能？\nAuthentication：身份认证&#x2F;登录，验证用户是不是拥有相应的身份；\nAuthorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；\nSession Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；\nCryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；\nWeb Support：Web支持，可以非常容易的集成到Web环境；\nCaching：缓存，比如用户登录后，其用户信息、拥有的角色&#x2F;权限不必每次去查，这样可以提高效率；\nConcurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；\nTesting：提供测试支持；\nRun As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；\nRemember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。\n3.Shiro架构（外部）\n应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject；其每个API的含义：\nSubject：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者；\nSecurityManager：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器；\nRealm：域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色&#x2F;权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。\n也就是说对于我们而言，最简单的一个Shiro应用：\n\n应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager；\n我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。\n\n从以上也可以看出，Shiro不提供维护用户&#x2F;权限，而是通过Realm让开发人员自己注入\n4.Shiro架构（内部）\nSubject：主体，可以看到主体可以是任何可以与应用交互的“用户”；\nSecurityManager：相当于SpringMVC中的DispatcherServlet或者Struts2中的FilterDispatcher；是Shiro的心脏；所有具体的交互都通过SecurityManager进行控制；它管理着所有Subject、且负责进行认证和授权、及会话、缓存的管理。\nAuthenticator：认证器，负责主体认证的，这是一个扩展点，如果用户觉得Shiro默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；\nAuthrizer：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；\nRealm：可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro不知道你的用户&#x2F;权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm；\nSessionManager：如果写过Servlet就应该知道Session的概念，Session呢需要有人去管理它的生命周期，这个组件就是SessionManager；而Shiro并不仅仅可以用在Web环境，也可以用在如普通的JavaSE环境、EJB等环境；所有呢，Shiro就抽象了一个自己的Session来管理主体与应用之间交互的数据；这样的话，比如我们在Web环境用，刚开始是一台Web服务器；接着又上了台EJB服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到Memcached服务器）；\nSessionDAO：DAO大家都用过，数据访问对象，用于会话的CRUD，比如我们想把Session保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把Session放到Memcached中，可以实现自己的Memcached SessionDAO；另外SessionDAO中可以使用Cache进行缓存，以提高性能；\nCacheManager：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能\nCryptography：密码模块，Shiro提高了一些常见的加密组件用于如密码加密&#x2F;解密的\n5. 认证流程\n用户 提交 身份信息、凭证信息 封装成 令牌 交由 安全管理器 认证\n2、快速入门1. 拷贝案例\n按照官网提示找到 快速入门案例\n\nGitHub地址：shiro&#x2F;samples&#x2F;quickstart&#x2F;\n从GitHub 的文件中可以看出这个快速入门案例是一个 Maven 项目\n\n新建一个 Maven 工程，删除其 src 目录，将其作为父工程\n\n在父工程中新建一个 Maven 模块\n\n复制快速入门案例 POM.xml 文件中的依赖 （版本号自选）\n\n\n&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;            &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;            &lt;version&gt;1.4.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- configure logging --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;            &lt;version&gt;1.7.29&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;version&gt;1.7.29&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\n\n\n把快速入门案例中的 resource 下的log4j2.xml 复制下来\n\n&lt;Configuration name=&quot;ConfigTest&quot; status=&quot;ERROR&quot; monitorInterval=&quot;5&quot;&gt;      &lt;Appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;Logger name=&quot;org.springframework&quot; level=&quot;warn&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;        &lt;/Logger&gt;        &lt;Logger name=&quot;org.apache&quot; level=&quot;warn&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;        &lt;/Logger&gt;        &lt;Logger name=&quot;net.sf.ehcache&quot; level=&quot;warn&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;        &lt;/Logger&gt;        &lt;Logger name=&quot;org.apache.shiro.util.ThreadContext&quot; level=&quot;warn&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;        &lt;/Logger&gt;        &lt;Root level=&quot;info&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\n\n\n复制一下 shiro.ini 文件\n\n# -----------------------------------------------------------------------------# Users and their assigned roles## Each line conforms to the format defined in the# org.apache.shiro.realm.text.TextConfigurationRealm#setUserDefinitions JavaDoc# -----------------------------------------------------------------------------[users]# user &#x27;root&#x27; with password &#x27;secret&#x27; and the &#x27;admin&#x27; roleroot = secret, admin# user &#x27;guest&#x27; with the password &#x27;guest&#x27; and the &#x27;guest&#x27; roleguest = guest, guest# user &#x27;presidentskroob&#x27; with password &#x27;12345&#x27; (&quot;That&#x27;s the same combination on# my luggage!!!&quot; ;)), and role &#x27;president&#x27;presidentskroob = 12345, president# user &#x27;darkhelmet&#x27; with password &#x27;ludicrousspeed&#x27; and roles &#x27;darklord&#x27; and &#x27;schwartz&#x27;darkhelmet = ludicrousspeed, darklord, schwartz# user &#x27;lonestarr&#x27; with password &#x27;vespa&#x27; and roles &#x27;goodguy&#x27; and &#x27;schwartz&#x27;lonestarr = vespa, goodguy, schwartz# -----------------------------------------------------------------------------# Roles with assigned permissions# # Each line conforms to the format defined in the# org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc# -----------------------------------------------------------------------------[roles]# &#x27;admin&#x27; role has all permissions, indicated by the wildcard &#x27;*&#x27;admin = *# The &#x27;schwartz&#x27; role can do anything (*) with any lightsaber:schwartz = lightsaber:*# The &#x27;goodguy&#x27; role is allowed to &#x27;drive&#x27; (action) the winnebago (type) with# license plate &#x27;eagle5&#x27; (instance specific id)goodguy = winnebago:drive:eagle5\n\n\n复制一下 Quickstart.java 文件,如果有导包的错误，把那两个错误的包删掉，就会自动导对的包了，快速入门案例中用的方法过时了\n\nimport org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.*;import org.apache.shiro.ini.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.session.Session;import org.apache.shiro.subject.Subject;import org.apache.shiro.lang.util.Factory;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * Simple Quickstart application showing how to use Shiro&#x27;s API. * * @since 0.9 RC2 */public class Quickstart &#123;    private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class);    public static void main(String[] args) &#123;        // The easiest way to create a Shiro SecurityManager with configured        // realms, users, roles and permissions is to use the simple INI config.        // We&#x27;ll do that by using a factory that can ingest a .ini file and        // return a SecurityManager instance:        // Use the shiro.ini file at the root of the classpath        // (file: and url: prefixes load from files and urls respectively):        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);        SecurityManager securityManager = factory.getInstance();        // for this simple example quickstart, make the SecurityManager        // accessible as a JVM singleton.  Most applications wouldn&#x27;t do this        // and instead rely on their container configuration or web.xml for        // webapps.  That is outside the scope of this simple quickstart, so        // we&#x27;ll just do the bare minimum so you can continue to get a feel        // for things.        SecurityUtils.setSecurityManager(securityManager);        // Now that a simple Shiro environment is set up, let&#x27;s see what you can do:        // get the currently executing user:        Subject currentUser = SecurityUtils.getSubject();        // Do some stuff with a Session (no need for a web or EJB container!!!)        Session session = currentUser.getSession();        session.setAttribute(&quot;someKey&quot;, &quot;aValue&quot;);        String value = (String) session.getAttribute(&quot;someKey&quot;);        if (value.equals(&quot;aValue&quot;)) &#123;            log.info(&quot;Retrieved the correct value! [&quot; + value + &quot;]&quot;);        &#125;        // let&#x27;s login the current user so we can check against roles and permissions:        if (!currentUser.isAuthenticated()) &#123;            UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);            token.setRememberMe(true);            try &#123;                currentUser.login(token);            &#125; catch (UnknownAccountException uae) &#123;                log.info(&quot;There is no user with username of &quot; + token.getPrincipal());            &#125; catch (IncorrectCredentialsException ice) &#123;                log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;);            &#125; catch (LockedAccountException lae) &#123;                log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked.  &quot; +                        &quot;Please contact your administrator to unlock it.&quot;);            &#125;            // ... catch more exceptions here (maybe custom ones specific to your application?            catch (AuthenticationException ae) &#123;                //unexpected condition?  error?            &#125;        &#125;        //say who they are:        //print their identifying principal (in this case, a username):        log.info(&quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot;);        //test a role:        if (currentUser.hasRole(&quot;schwartz&quot;)) &#123;            log.info(&quot;May the Schwartz be with you!&quot;);        &#125; else &#123;            log.info(&quot;Hello, mere mortal.&quot;);        &#125;        //test a typed permission (not instance-level)        if (currentUser.isPermitted(&quot;lightsaber:wield&quot;)) &#123;            log.info(&quot;You may use a lightsaber ring.  Use it wisely.&quot;);        &#125; else &#123;            log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;);        &#125;        //a (very powerful) Instance Level permission:        if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) &#123;            log.info(&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate (id) &#x27;eagle5&#x27;.  &quot; +                    &quot;Here are the keys - have fun!&quot;);        &#125; else &#123;            log.info(&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;);        &#125;        //all done - log out!        currentUser.logout();        System.exit(0);    &#125;&#125;\n\n\n测试运行一下\n报错，则导入一下 commons-logging 的依赖\n\n&lt;dependency&gt;&lt;groupId&gt;commons-logging&lt;/groupId&gt;&lt;artifactId&gt;commons-logging&lt;/artifactId&gt;&lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;\n\n\n发现，执行完毕什么都没有，可能是maven依赖中的作用域问题，我们需要将scope作用域删掉， 默认是在test，然后重启，那么我们的quickstart就结束了，默认的日志消息！\n\n2. 分析案例\n类的描述\n\n/*** Simple Quickstart application showing how to use Shiro&#x27;s API.* 简单的快速启动应用程序，演示如何使用Shiro的API。*/\n\n\n通过工厂模式创建SecurityManager的实例对象\n\n// The easiest way to create a Shiro SecurityManager with configured        // realms, users, roles and permissions is to use the simple INI config.        // We&#x27;ll do that by using a factory that can ingest a .ini file and        // return a SecurityManager instance:// 使用类路径根目录下的shiro.ini文件        // Use the shiro.ini file at the root of the classpath        // (file: and url: prefixes load from files and urls respectively):        Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);        SecurityManager securityManager = factory.getInstance();        // for this simple example quickstart, make the SecurityManager        // accessible as a JVM singleton.  Most applications wouldn&#x27;t do this        // and instead rely on their container configuration or web.xml for        // webapps.  That is outside the scope of this simple quickstart, so        // we&#x27;ll just do the bare minimum so you can continue to get a feel        // for things.        SecurityUtils.setSecurityManager(securityManager);        // Now that a simple Shiro environment is set up, let&#x27;s see what you can do:\n\n\n通过 SecurityUtils 获取当前执行的用户 Subject\n\n// get the currently executing user: 获取当前正在执行的用户Subject currentUser = SecurityUtils.getSubject();\n\n\nsession的操作\n\n// Do some stuff with a Session (no need for a web or EJB container!!!)        Session session = currentUser.getSession();//获得session        session.setAttribute(&quot;someKey&quot;, &quot;aValue&quot;);//设置Session的值！        String value = (String) session.getAttribute(&quot;someKey&quot;);//从session中获取值        if (value.equals(&quot;aValue&quot;)) &#123;//判断session中是否存在这个值！            log.info(&quot;Retrieved the correct value! [&quot; + value + &quot;]&quot;);        &#125;\n\n\n用户认证功能\n\n// 测试当前的用户是否已经被认证，即是否已经登录！ // let&#x27;s login the current user so we can check against roles and permissions:        if (!currentUser.isAuthenticated()) &#123;// isAuthenticated();是否认证            UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);            token.setRememberMe(true);//记住我功能            try &#123;                currentUser.login(token);//执行登录，可以登录成功的！            &#125; catch (UnknownAccountException uae) &#123;//如果没有指定的用户，则UnknownAccountException异常                log.info(&quot;There is no user with username of &quot; + token.getPrincipal());            &#125; catch (IncorrectCredentialsException ice) &#123;//密码不对的异常！                log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;);            &#125; catch (LockedAccountException lae) &#123;//用户被锁定的异常                log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked.  &quot; +                        &quot;Please contact your administrator to unlock it.&quot;);            &#125;            // ... catch more exceptions here (maybe custom ones specific to your application?            catch (AuthenticationException ae) &#123;&#123; //认证异常，上面的异常都是它的子类                //unexpected condition?  error?            &#125;        &#125;        //say who they are:        //print their identifying principal (in this case, a username):        log.info(&quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot;);\n\n\n角色检查\n\n//test a role://是否存在某一个角色        if (currentUser.hasRole(&quot;schwartz&quot;)) &#123;            log.info(&quot;May the Schwartz be with you!&quot;);        &#125; else &#123;            log.info(&quot;Hello, mere mortal.&quot;);        &#125;\n\n\n权限检查，粗粒度\n\n//测试用户是否具有某一个权限，行为//test a typed permission (not instance-level)        if (currentUser.isPermitted(&quot;lightsaber:wield&quot;)) &#123;            log.info(&quot;You may use a lightsaber ring.  Use it wisely.&quot;);        &#125; else &#123;            log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;);        &#125;\n\n\n权限检查，细粒度\n\n//测试用户是否具有某一个权限，行为，比上面更加的具体！//a (very powerful) Instance Level permission:        if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) &#123;            log.info(&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate (id) &#x27;eagle5&#x27;.  &quot; +                    &quot;Here are the keys - have fun!&quot;);        &#125; else &#123;            log.info(&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;);        &#125;\n\n\n注销操作\n\ncurrentUser.logout();\n\n\n退出系统 System.exit(0);\n\n总览\n\n\n\n3、SpringBoot 集成 Shiro1.准备工作\n搭建一个SpringBoot项目、选中web模块即可！\n导入Maven依赖 thymeleaf\n\n&lt;!--thymeleaf模板--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;    &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;    &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n编写一个页面 index.html templates\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;p th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n编写controller进行访问测试\n\nimport org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class MyController &#123;        @RequestMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;)        public String toIndex(Model model)&#123;                model.addAttribute(&quot;msg&quot;,&quot;hello,Shiro&quot;);                return &quot;index&quot;;        &#125;&#125;\n\n2. 编写配置文件\n导入 SpringBoot 和 Shiro 整合包的依赖\n\n&lt;!--SpringBoot 和 Shiro 整合包--&gt;\t\t&lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-spring-boot-web-starter --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;shiro-spring-boot-web-starter&lt;/artifactId&gt;\t\t\t&lt;version&gt;1.6.0&lt;/version&gt;\t\t&lt;/dependency&gt;\n\n\n下面是编写配置文件Shiro 三大要素\n\nsubject -&gt; ShiroFilterFactoryBean\nsecurityManager -&gt; DefaultWebSecurityManager\nrealm\n\n实际操作中对象创建的顺序 ： realm -&gt; securityManager -&gt;subject\n\n\n\n编写Shiro 配置类 config包\n\nimport org.springframework.context.annotation.Configuration;//声明为配置类@Configurationpublic class ShiroConfig &#123;    //创建 ShiroFilterFactoryBean    //创建 DefaultWebSecurityManager    //创建 realm 对象&#125;\n\n\n我们倒着来，先想办法创建一个 realm 对象\n编写自定义的 realm ，需要继承 AuthorizingRealm\n\nimport org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;//自定义的 Realmpublic class UserRealm extends AuthorizingRealm &#123;    //授权    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;        //打印一个提示        System.out.println(&quot;执行了授权方法&quot;);        return null;    &#125;    //认证    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;        //打印一个提示        System.out.println(&quot;执行了认证方法&quot;);        return null;    &#125;&#125;\n\n\n将这个类注册到我们的Bean中！ ShiroConfig\n\n  @Configurationpublic class ShiroConfig &#123;    //创建 ShiroFilterFactoryBean    //创建 DefaultWebSecurityManager    //创建 realm 对象   //让 spring 托管自定义的 realm 类    @Bean    public UserRealm userRealm()&#123;        return new UserRealm();    &#125;&#125;\n\n\n接下来我们该去创建 DefaultWebSecurityManager 了\n\n//2. securityManager -&gt; DefaultWebSecurityManager    // @Qualifier(&quot;userRealm&quot;) 指定 Bean 的名字为 userRealm    // spring 默认的 BeanName 就是方法名    // name 属性 指定 BeanName    @Bean(name = &quot;SecurityManager&quot;)    public DefaultWebSecurityManager getDefaultWebSecurity(@Qualifier(&quot;userRealm&quot;) UserRealm userRealm)&#123;        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();        //需要关联自定义的 Realm，通过参数把 Realm 对象传递过来        securityManager.setRealm(userRealm);        return securityManager;    &#125;\n\n\n接下来我们该去创建 ShiroFilterFactoryBean 了\n\n//1. subject -&gt; ShiroFilterFactoryBean// @Qualifier(&quot;securityManager&quot;) 指定 Bean 的名字为 securityManager@Bean(name = &quot;shiroFilterFactoryBean&quot;)public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;SecurityManager&quot;) DefaultWebSecurityManager securityManager)&#123;    ShiroFilterFactoryBean subject = new ShiroFilterFactoryBean();    //设置安全管理器    //需要关联 securityManager ，通过参数把 securityManager 对象传递过来    subject.setSecurityManager(securityManager);    return subject;&#125;\n\n3. 搭建简单测试环境\n编写两个页面、在templates目录下新建一个user目录下创建add.html和update.html\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;增加&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;add&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;更新&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;update&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n编写跳转到页面的controller\n\n@RequestMapping(&quot;/user/add&quot;)  public String add()&#123;      return &quot;user/add&quot;;  &#125;  @RequestMapping(&quot;/user/update&quot;)  public String update()&#123;      return &quot;user/update&quot;;  &#125;\n\n\n在index页面上，增加跳转链接\n\n&lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;add&lt;/a&gt; | &lt;ath:href=&quot;@&#123;/user/update&#125;&quot;&gt;update&lt;/a&gt;\n\n\n测试页面跳转是否OK\n\n3. 使用1. 登录拦截\n在上面的 getShiroFilterFactoryBean 方法中加上需要拦截的登录请求\n\n   @Bean(name = &quot;shiroFilterFactoryBean&quot;)    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;SecurityManager&quot;) DefaultWebSecurityManager securityManager)&#123;        ShiroFilterFactoryBean subject = new ShiroFilterFactoryBean();        subject.setSecurityManager(securityManager);//添加 Shiro 的内置过滤器=======================        /*            anon : 无需认证，就可以访问            authc : 必须认证，才能访问            user : 必须拥有 “记住我”功能才能用            perms : 拥有对某个资源的权限才能访问            role : 拥有某个角色权限才能访问         */        Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();        // 设置 /user/addUser 这个请求,只有认证过才能访问//        map.put(&quot;/user/addUser&quot;,&quot;authc&quot;);//        map.put(&quot;/user/deleteUser&quot;,&quot;authc&quot;);        // 设置 /user/ 下面的所有请求,只有认证过才能访问        map.put(&quot;/user/*&quot;,&quot;authc&quot;);        subject.setFilterChainDefinitionMap(map);        //============================================        return subject;    &#125;\n\n\n再起启动测试，访问链接进行测试！拦截OK！但是发现，点击后会跳转到一个Login.jsp页面，这 个不是我们想要的效果，我们需要自己定义一个Login页面！\n\n编写一个自己的Login页面\n\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;shiro登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    &lt;p th:text=&quot;$&#123;msg&#125;&quot; style=&quot;color: #ff0000&quot;&gt;&lt;/p&gt;    &lt;form method=&quot;get&quot; th:action=&quot;@&#123;/login&#125;&quot;&gt;        &lt;p&gt;用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt;        &lt;p&gt;密  码:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;/p&gt;        &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/p&gt;    &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n编写跳转的controller\n\n@RequestMapping(&quot;/toLogin&quot;)public String toLogin()&#123;\treturn &quot;login&quot;;&#125;\n\n\n在shiro中配置一下！ ShiroFilterFactoryBean() 方法下面\n\n//修改到要跳转的login页面；shiroFilterFactoryBean.setLoginUrl(&quot;/toLogin&quot;);\n\n\n\n2. 用户认证\n在 Controller 中写一个登录的控制器\n\n//登录的方法    @RequestMapping(&quot;/login&quot;)    public String login(String username, String password, Model model) &#123;        //获取当前用户        Subject subject = SecurityUtils.getSubject();        //没有认证过        //封装用户的登录数据,获得令牌        UsernamePasswordToken token = new UsernamePasswordToken(username, password);        //登录 及 异常处理        try &#123;            //用户登录            subject.login(token);            return &quot;index&quot;;        &#125; catch (UnknownAccountException uae) &#123;            //如果用户名不存在            System.out.println(&quot;用户名不存在&quot;);            model.addAttribute(&quot;exception&quot;, &quot;用户名不存在&quot;);            return &quot;login&quot;;        &#125; catch (IncorrectCredentialsException ice) &#123;            //如果密码错误            System.out.println(&quot;密码错误&quot;);            model.addAttribute(&quot;exception&quot;, &quot;密码错误&quot;);            return &quot;login&quot;;        &#125;    &#125;\n\n是先执行了 自定义的 UserRealm 中的 AuthenticationInfo 方法，再执行了，登录的相关操作\n下面去自定义的 UserRealm 中的 AuthenticationInfo 方法中去获取用户信息\n\n修改 UserRealm 中的 AuthenticationInfo\n\n@Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;        //打印一个提示        System.out.println(&quot;执行了认证方法&quot;);        // 用户名密码(暂时先自定义一个做测试)        String name = &quot;root&quot;;        String password = &quot;1234&quot;;        //通过参数获取登录的控制器中生成的 令牌        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;        //用户名认证        if (!token.getUsername().equals(name))&#123;            // return null 就表示控制器中抛出的相关异常            return null;        &#125;        //密码认证， Shiro 自己做，为了避免和密码的接触        //最后返回一个 AuthenticationInfo 接口的实现类，这里选择 SimpleAuthenticationInfo        // 三个参数：获取当前用户的认证 ； 密码 ； 认证名        return new SimpleAuthenticationInfo(&quot;&quot;, password, &quot;&quot;);    &#125;\n\n3.整合数据库\n导入Mybatis相关依赖\n\n    &lt;!-- 引入 myBatis，这是 MyBatis官方提供的适配 Spring Boot 的，而不是Spring Boot自己的--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;2.1.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.15&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.1.12&lt;/version&gt;    &lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;    &lt;dependency&gt;        &lt;groupId&gt;log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j&lt;/artifactId&gt;        &lt;version&gt;1.2.17&lt;/version&gt;    &lt;/dependency&gt;\n\n\n编写配置文件-连接配置 application.yml\n\nspring:  datasource:    username: root    password: Root123    #?serverTimezone=UTC解决时区的报错    url: jdbc:mysql://localhost:3306/shiro?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8    driver-class-name: com.mysql.jdbc.Driver    type: com.alibaba.druid.pool.DruidDataSource    #Spring Boot 默认是不注入这些属性值的，需要自己绑定    #druid 数据源专有配置    initialSize: 5    minIdle: 5    maxActive: 20    maxWait: 60000    timeBetweenEvictionRunsMillis: 60000    minEvictableIdleTimeMillis: 300000    validationQuery: SELECT 1 FROM DUAL    testWhileIdle: true    testOnBorrow: false    testOnReturn: false    poolPreparedStatements: true    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority    #则导入 log4j 依赖即可，Maven 地址： https://mvnrepository.com/artifact/log4j/log4j    filters: stat,wall,log4j    maxPoolPreparedStatementPerConnectionSize: 20    useGlobalDataSourceStat: true    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n\n\n编写mybatis的配置 application.properties\n\nmybatis.type-aliases-package=com.fang.pojomybatis.mapper-locations=classpath:mapper/*.xml\n\n\n编写实体类,引入Lombok\n\n&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.16.10&lt;/version&gt;&lt;/dependency&gt;\n\nimport lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123;    private int id;    private String name;    private String pwd;&#125;\n\n\n编写Mapper接口\n\n@Mapper@Repositorypublic interface UserMapper &#123;    public User queryUserByUsername(String username);&#125;\n\n\n编写Mapper配置文件\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.fang.mapper.UserMapper&quot;&gt;    &lt;select id=&quot;queryUserByUsername&quot; parameterType=&quot;String&quot; resultType=&quot;User&quot;&gt;        select * from user where username=#&#123;username&#125;    &lt;/select&gt;&lt;/mapper&gt;\n\n\n编写UserService 层\n\npublic interface UserService &#123;    public User queryUserByUsername(String username);&#125;\n\n@Servicepublic class UserServiceImpl implements UserService &#123;    @Autowired    private UserMapper userMapper;    @Override    public User queryUserByUsername(String username) &#123;        return userMapper.queryUserByUsername(username);    &#125;&#125;\n\n\n改造UserRealm，连接到数据库进行真实的操作！\n\n//自定义Realmpublic class UserRealm extends AuthorizingRealm &#123;    @Autowired    UserService userService;    //执行授权逻辑    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;        System.out.println(&quot;执行了=&gt;授权逻辑PrincipalCollection&quot;);        return null;    &#125;//执行认证逻辑    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;        System.out.println(&quot;执行了=&gt;认证逻辑AuthenticationToken&quot;);        UsernamePasswordToken userToken = (UsernamePasswordToken)token;\t//真实连接数据库\tUser user = userService.queryUserByName(userToken.getUsername());        if (user==null)&#123;        //用户名不存在        return null; //shiro底层就会抛出 UnknownAccountException        &#125;        return new SimpleAuthenticationInfo(&quot;&quot;, user.getPwd(), &quot;&quot;);        &#125;&#125;\n\n4.思考：密码比对原理探究\n这个Shiro，是怎么帮我们实现密码自动比对的呢？ \n我们可以去 realm的父类 AuthorizingRealm 的父类 AuthenticatingRealm 中找一个方法 \n核心： getCredentialsMatcher() 翻译过来：获取证书匹配器 \n我们去看这个接口 CredentialsMatcher 有很多的实现类，MD5盐值加密\n\n我们的密码一般都不能使用明文保存？需要加密处理；思路分析 \n\n如何把一个字符串加密为MD5\n替换当前的Realm 的 CredentialsMatcher 属性，直接使用 Md5CredentialsMatcher 对象， 并设置加密算法\n\n5.用户授权操作使用shiro的过滤器来拦截请求即可！ \n\n在 ShiroFilterFactoryBean 中添加一个过滤器\n\n//授权过滤器filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;); //大家记得注意顺序！\n\n\n我们再次启动测试一下，访问add，未授权错误！\n注意：当我们实现权限拦截后，shiro会自动跳转到未授权的页面，但我们没有这个页面，所有401 了\n配置一个未授权的提示的页面，增加一个controller提示\n\n@RequestMapping(&quot;/noauth&quot;)@ResponseBodypublic String noAuth()&#123;return &quot;未经授权不能访问此页面&quot;;&#125;\n\n\n然后再 shiroFilterFactoryBean 中配置一个未授权的请求页面！\n\nshiroFilterFactoryBean.setUnauthorizedUrl(&quot;/noauth&quot;);\n\n6.Shiro授权\n在UserRealm 中添加授权的逻辑，增加授权的字符串！\n\n//执行授权逻辑@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;    System.out.println(&quot;执行了=&gt;授权逻辑PrincipalCollection&quot;);    //给资源进行授权    SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();    //添加资源的授权字符串    info.addStringPermission(&quot;user:add&quot;);    return info;&#125;\n\n我们再次登录测试，发现登录的用户是可以进行访问add 页面了！授权成功！ 问题，我们现在完全是硬编码，无论是谁登录上来，都可以实现授权通过，但是真实的业务情况应该 是，每个用户拥有自己的一些权限，从而进行操作，所以说，权限，应该在用户的数据库中，正常的情 况下，应该数据库中是由一个权限表的，我们需要联表查询，但是这里为了大家操作理解方便一些，我 们直接在数据库表中增加一个字段来进行操作！\n\n修改实体类，增加一个字段\n\n@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123;    private int id;    private String name;    private String pwd;    private String perms;&#125;\n\n\n我们现在需要再自定义的授权认证中，获取登录的用户，从而实现动态认证授权操作！ \n3.1在用户登录授权的时候，将用户放在 Principal 中，改造下之前的代码\n\n\nreturn new SimpleAuthenticationInfo(user, user.getPwd(), &quot;&quot;);\n\n​\t\t3.2 然后再授权的地方获得这个用户，从而获得它的权限\n//执行授权逻辑@Overrideprotected AuthorizationInfodoGetAuthorizationInfo(PrincipalCollection principals) &#123;   \t System.out.println(&quot;执行了=&gt;授权逻辑PrincipalCollection&quot;);        //给资源进行授权        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();        //添加资源的授权字符串        //info.addStringPermission(&quot;user:add&quot;);        Subject subject = SecurityUtils.getSubject(); //获得当前对象        User currentUser = (User) subject.getPrincipal(); //拿到User对象        info.addStringPermission(currentUser.getPerms()); //设置权限\treturn info;&#125;\n\n7. 退出登录\n在控制器中添加一个退出登录的方法\n\n//退出登录@RequestMapping(&quot;/logout&quot;)public String logout()&#123;    Subject subject = SecurityUtils.getSubject();    subject.logout();    return &quot;login&quot;;&#125;\n\n8.整合Thymeleaf根据权限展示不同的前端页面 \n\n添加Maven的依赖；\n\n&lt;!-- thymeleaf-shiro整合包 --&gt;   &lt;dependency&gt;       &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt;       &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt;       &lt;version&gt;2.0.0&lt;/version&gt;   &lt;/dependency&gt;\n\n\n配置一个shiro的Dialect ，在shiro的配置中增加一个Bean\n\n//配置ShiroDialect：方言，用于 thymeleaf 和 shiro 标签配合使用@Beanpublic ShiroDialect getShiroDialect()&#123;\treturn new ShiroDialect();\t&#125;\n\n\n.修改前端的配置\n\n&lt;div shiro:hasPermission=&quot;user:add&quot;&gt;\t&lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;add&lt;/a&gt;&lt;/div&gt;&lt;div shiro:hasPermission=&quot;user:update&quot;&gt;\t&lt;a th:href=&quot;@&#123;/user/update&#125;&quot;&gt;update&lt;/a&gt;&lt;/div&gt;\n\n\n我们在用户登录后应该把信息放到Session中，我们完善下！在执行认证逻辑时候，加 入session\n\nSubject subject = SecurityUtils.getSubject();subject.getSession().setAttribute(&quot;loginUser&quot;,user);\n\n\n前端从session中获取，然后用来判断是否显示登录\n\n&lt;p th:if=&quot;$&#123;session.loginUser==null&#125;&quot;&gt;\t&lt;a th:href=&quot;@&#123;/toLogin&#125;&quot;&gt;登录&lt;/a&gt;&lt;/p&gt;\n\n4、总体代码1.前端页面 templates目录创建index.html\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;      xmlns:shiro=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;shiro&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;div th:if=&quot;$&#123;session.loginUser==null&#125;&quot;&gt;    &lt;a th:href=&quot;@&#123;/toLogin&#125;&quot;&gt;登录&lt;/a&gt;&lt;/div&gt;&lt;p th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/p&gt;&lt;hr/&gt;&lt;div shiro:hasPermission=&quot;ss:mm&quot;&gt;    &lt;a th:href=&quot;@&#123;/user/add&#125;&quot;&gt;add&lt;/a&gt;&lt;/div&gt;&lt;div shiro:hasPermission=&quot;user:update&quot;&gt;    &lt;a th:href=&quot;@&#123;/user/update&#125;&quot;&gt;update&lt;/a&gt;&lt;/div&gt;&lt;div th:if=&quot;$&#123;session.loginUser&#125;&quot;&gt;    &lt;p&gt;&lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;退出&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n2..连接数据库和认证授权config包下创建ShiroConfig和UserRealm\n@Configurationpublic class ShiroConfig &#123;    //ShiroFilterFactoryBean   第三步    @Bean    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager)&#123;        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();        //设置安全管理器        shiroFilterFactoryBean.setSecurityManager(securityManager);        /*            添加shiro的内置过滤器            anon：无须认证就可以访问            authc：必须认证了才可以访问            perms：拥有对某个资源的权限才能访问            role:拥有某个角色才可以访问         */        Map&lt;String, String&gt; filterMap = new LinkedHashMap();//        filterMap.put(&quot;/user/add&quot;,&quot;authc&quot;);//        filterMap.put(&quot;/user/update&quot;,&quot;authc&quot;);        filterMap.put(&quot;/user/add&quot;,&quot;perms[ss:mm]&quot;);        filterMap.put(&quot;/user/update&quot;,&quot;perms[m:add]&quot;);        filterMap.put(&quot;/user/*&quot;,&quot;authc&quot;);        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap);        //设置跳转到登录页面        shiroFilterFactoryBean.setLoginUrl(&quot;/toLogin&quot;);        //设置到未授权页面        shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/noauth&quot;);        return shiroFilterFactoryBean;    &#125;    //DefaultWebSecurityManager  第二步    @Bean(name = &quot;securityManager&quot;)    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) UserRealm userRealm)&#123;        DefaultWebSecurityManager securityManager=new DefaultWebSecurityManager();        //关联realm        securityManager.setRealm(userRealm);        return securityManager;    &#125;    //创建realm 域对象，需要自定义   第一步    @Bean(name = &quot;userRealm&quot;)    public UserRealm getUserRealm()&#123;        return new UserRealm();    &#125;    //shiro 整合thymeleaf    @Bean    public ShiroDialect getShiroDialect()&#123;        return new ShiroDialect();    &#125;&#125;\n\nfilterMap.put(“&#x2F;user&#x2F;update”,“perms[m:add]”); perms[]括号里是字符串，随便字符串都行,数据库perms字段需要加入与perms[]括号里面相同的字符串\npublic class UserRealm extends AuthorizingRealm &#123;    @Autowired    private UserService userService;    @Override   //授权    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;        System.out.println(&quot;-----授权了-----AuthorizationInfo&quot;);        SimpleAuthorizationInfo info=new SimpleAuthorizationInfo();//        info.addStringPermission(&quot;user:add&quot;);        //从数据库查权限        Subject subject = SecurityUtils.getSubject();        User currentUser = (User) subject.getPrincipal();//其实就是拿认证成功的时候的那个user        info.addStringPermission(currentUser.getPerms());        return info;    &#125;    @Override   //认证    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;        System.out.println(&quot;-----认证了-----AuthenticationInfo&quot;);        UsernamePasswordToken userToken = (UsernamePasswordToken) token;        //用户名，密码去数据库取        User user = userService.queryUserByUsername(userToken.getUsername());        if (user==null)&#123;  //没有这个人            return null;  //其实就是抛出UnknownAccountException异常        &#125;        //之后密码认证，shiro   它自己会做        SimpleAuthenticationInfo info=new SimpleAuthenticationInfo(user,user.getPassword(),&quot;&quot;);        Subject currentSubject = SecurityUtils.getSubject();        Session session = currentSubject.getSession();        session.setAttribute(&quot;loginUser&quot;,user);        return info;    &#125;&#125;\n\n创建数据库表\ncreate table shiro(id int auto_increment primary key ,username varchar(50) not null,password varchar(40) not null,perms varchar(30));\n\n3.目录结构代码1.controller包下创建MyController\n@Controllerpublic class MyController &#123;    @RequestMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;)    public String toIndex(Model model)&#123;        model.addAttribute(&quot;msg&quot;,&quot;hello shiro!!!&quot;);        return &quot;index&quot;;    &#125;      @RequestMapping(&quot;/toLogin&quot;)    public String toLogin()&#123;        return &quot;login&quot;;    &#125;    @RequestMapping(&quot;/login&quot;)    public String login(String username,String password,Model model)&#123;        //获取当前输入的用户        Subject subject = SecurityUtils.getSubject();        //封装用户的数据        UsernamePasswordToken token = new UsernamePasswordToken(username,password);        //登录，没有异常就说明登录成功        try &#123;            subject.login(token);            return &quot;index&quot;;        &#125; catch (UnknownAccountException e) &#123;            model.addAttribute(&quot;msg&quot;,&quot;用户名错误&quot;);            return &quot;login&quot;;        &#125;catch (IncorrectCredentialsException e)&#123;            model.addAttribute(&quot;msg&quot;,&quot;密码错误&quot;);            return &quot;login&quot;;        &#125;    &#125;    //没授权    @RequestMapping(&quot;/noauth&quot;)    @ResponseBody    public String unauthorized()&#123;        return &quot;没经授权无法进入&quot;;    &#125;    //退出    @RequestMapping(&quot;/logout&quot;)    public String logout()&#123;        Subject currentUser = SecurityUtils.getSubject();        currentUser.logout();        System.out.println(&quot;退出了&quot;);        return &quot;login&quot;;    &#125;&#125;\n\n\n\n","tags":["SpringBoot"]},{"title":"leetcode之最长的回文子串","url":"/2022/07/19/leetcode%E4%B9%8B%E6%9C%80%E9%95%BF%E7%9A%84%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","content":"1、问题描述\n2、思路回文的意思是正着念和倒着念一样，如：上海自来水来自海上\n 第一个while从当前字符往右找，如果字符相同则继续往右找，把至少一个连续一样的字符当做中心。 第二个while 就是在不越界的前提下，前后扩展，只要对称位置字符相同则继续往两端找，并把low 和high当做回文的起止索引。最后一步，和已经找到的回文索引比长度，更长则覆盖。到此完成一次for循环，然后继续从下一个字符（可能会跳过若干处理过的字符）继续重复上面的逻辑。直到整个字符数据遍历完毕。\n3、代码class Solution &#123;    public String longestPalindrome(String s) &#123;        if (s == null || s.length() == 0) &#123;            return &quot;&quot;;        &#125;//         保存起始位置，测试了用数组似乎能比全局变量稍快一点        int[] range = new int[2];        char[] str = s.toCharArray();        for (int i = 0; i &lt; s.length(); i++) &#123;//             把回文看成中间的部分全是同一字符，左右部分相对称//             找到下一个与当前字符不同的字符            i = findLongest(str, i, range);        &#125;        return s.substring(range[0], range[1] + 1);    &#125;        public static int findLongest(char[] str, int low, int[] range) &#123;//         查找中间部分        int high = low;        while (high &lt; str.length - 1 &amp;&amp; str[high + 1] == str[low]) &#123;            high++;        &#125;//         定位中间部分的最后一个字符        int ans = high;//         从中间向左右扩散        while (low &gt; 0 &amp;&amp; high &lt; str.length - 1 &amp;&amp; str[low - 1] == str[high + 1]) &#123;            low--;            high++;        &#125;//         记录最大长度        if (high - low &gt; range[1] - range[0]) &#123;            range[0] = low;            range[1] = high;        &#125;        return ans;    &#125;&#125;\n\n","tags":["leetcode"]},{"title":"完整项目之手把手教你如何分析开源项目","url":"/2022/07/12/%E5%AE%8C%E6%95%B4%E9%A1%B9%E7%9B%AE%E4%B9%8B%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/","content":"1.如何分析开源项目\n学习的方式：\n\n\n不知道这个代码怎么来的；\n这个代码跑不起来；\n这个项目对我们有什么帮助，不会模块化分析；\n\n任何一个开源项目，都可以让自己得到提升。\n\n代码自动生成：我们平时会写很多业务代码，用Mybatis Plus去生成的，第三方的工具包去生成。\n开源项目：eladmin\n\n\n\n项目简介\n\n\n一个基于Spring Boot 2.1.0、Spring Boot Jpa、JWT、Spring Security、Redis、Vue的前后端分离的后台管理系统。\n开发文档： https://el-admin.vip\n体验地址： https://el-admin.xin\n账号密码： admin &#x2F; 123456\n\n\n项目源码\n\n\n\n\n\n后端源码\n前端源码\n\n\n\ngithub\neladmin\neladmin-web\n\n\n码云\neladmin\neladmin-web\n\n\n\n观察开源项目\n\n\n后端：\n\n\n\n前端：\n\n\n2.开源项目下载\n\n在码云下载，因为GitHub下载太慢了，下载完毕进行解压。\n后端：https://gitee.com/elunez/eladmin\n前端：https://gitee.com/elunez/eladmin-web\n\n\n解压完不要着急运行，先去观察项目：\n用了哪些技术（Springboot、Vue、Redis、MQ…）\n是否有数据库\n你的环境是否匹配(Maven、(npm、node.js)、redis…)\n\n\n\n\n当需要的环境匹配了，再想办法运行。这里列出项目所需的环境与相关安装教程，方便刚入门的同学：\n\n1、JDK：1.8+ 安装教程：https://www.runoob.com/java/java-environment-setup.html2、Redis 3.0+安装教程：https://www.runoob.com/redis/redis-install.html3、Maven 3.0+安装教程：https://www.runoob.com/maven/maven-setup.html4、MYSQL 5.5.0+安装教程：https://www.runoob.com/mysql/mysql-install.html5、Node v10+ (最好使用 12，高版本可能会有问题)安装教程：https://www.runoob.com/nodejs/nodejs-install-setup.html\n\n\n注意：\n\n前端安装完 node 后，最好设置下淘宝的镜像源，不建议使用 cnpm（可能会出现奇怪的问题）。\n\n\nnpm config set registry https://registry.npm.taobao.org配置后可通过下面方式来验证是否成功npm config get registry在 ~/.npmrc 加入下面内容，可以避免安装 node-sass 失败sass_binary_site=https://npm.taobao.org/mirrors/node-sass/.npmrc 文件位于win：C:\\Users\\[你的账户名称]\\.npmrclinux：直接使用 vi ~/.npmrc\n\n\n\n开发准备\n\n提示：在使用该系统前，还需要做如下准备。\n\n给 idea (opens new window)或者 eclipse (opens new window)安装 lombok 插件，我们用它可以省略get，set 方法，可以使代码更简洁。\n了解MapStruct，项目用到了他映射实体，如果你不熟悉可以查看：熟悉MapStruct(opens new window)\n你需要有 Spring boot 的基础。\n你还需要有 Vue (opens new window)的基础。\n\n注意：因为本项目是前后端分离的，所以需要前后端都启动好，才能进行访问。\n3.如何跑起来\n安装数据库，执行SQL（先创建数据库，编码默认utf8）\n\n\n\n前端跑起来（在文件上全选文件名然后cmd）\n\n# 安装依赖npm install# 启动服务 localhost:8013npm run dev# 构建生产环境npm run build:prod\n\n\n后端项目导入（打开idea——import）\n\n\n\n后端项目结构（一般前后端分离项目，前端依赖于后端）\n\n\n\n\n只要发现Swagger，就需要先进入Swagger-ui页面，因为前后端分离的接口全部都在这里；\n\n\n\n打开Redis\n\n\n\n开发环境重点需要去看端口号：server：port：8000（在总文件application.yml里面）前端也是调这个端口。\n\n\n\n去看Redis的端口号。\n\n\n\n看开发环境dev.yml的JDBC是否有问题。\n\n\n\n启动后端项目：\n\n\n\n进入页面：localhost:8000&#x2F;swagger-ui.html\n\n\n\n前端启动成功！\n用户名和密码：admin&#x2F;123456\n\n\n\n4.前后端分离项目的固定套路\n从前端开始分拆，打开控制台(VS-Code)，点一个接口，分析一波调用关系\n前后端端口调用不一致：前端：8013 后端：8000；研究怎么操作。\n封装了接口请求 ajax(前后端分离) axios(Vue) request(前端封装)\n找到配置（生产配置、开发环境配置）\n\n\n\n\n\n前后端分离项目的重点：找到接口的调用关系。\nSpringboot提供服务、前端调用接口数据、Vue负责渲染页面\n\n\n\n前端项目固定模板：\n\n\n\n每一个接口的后面都在后端有一个一一对应的地址。\n通过抓取前端的请求，找到后端对应的接口。\n\n\n\n在前端文件中，找对应的接口文件：\n\n\n\n在后端文件中，找对应的接口文件：\n\n\n\n怎么去跟后端对接？拿到接口的地址：\n\n\n\n去后端找：\n\n\n\n后端分析套路：Controller ——&gt; Service ——&gt; Dao\n\n\n从前到后知道怎么分析了，但是如何渲染到视图上的呢？\n看前端：搜索一个接口，查看其地址在哪里调用了。\n\n\n\nVue标准套路：\ntemplate：视图层\nscript：js操作，接口的调用\nstyle：页面的样式\n\n\n\n\n\n当我们要学习一个模块，将这个模块独立抽取出来即可，即删除对应的模块，自行修复删除部分。\n例如：学习用户模块，除了了user模块，还需要删除对应的接口文件：\n\n\n\n\n如果你想测试这个接口成不成功，在Swagger UI里测一下，是否可以将它查出来。\n\n\n5.如何找到一个比较好的开源项目\n比较有名的开源项目：\n\n\nlayui\nSemantic UI\nGrabient\nVue Element Admin\n\n\n查找手段：\n\n\n找分类（Java、python）\n看收藏（star），大家都觉得不错的，就是比较好的，有学习的价值\n看具有价值\n根据自身的理解情况：Java、SSM、Springboot…阶段性成果。\n如何学习Java：Java进阶路线七个阶段\n\n后端开发去写前端非常难看，可以使用第三方的：Ant Design Pro 或 Element。\n\n查找步骤：\n\n\n\n\n","tags":["完整项目"]},{"title":"Redis之三种特殊数据类型","url":"/2022/07/31/Redis%E4%B9%8B%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"Geospatial(地理位置)\n使用经纬度定位地理坐标并用一个有序集合zset保存，所以zset命令也可以使用\n\n\n\n\n命令\n描述\n\n\n\ngeoadd key longitud(经度) latitude(纬度) member [..]\n将具体经纬度的坐标存入一个有序集合\n\n\ngeopos key member [member..]\n获取集合中的一个&#x2F;多个成员坐标\n\n\ngeodist key member1 member2 [unit]\n返回两个给定位置之间的距离。默认以米作为单位。\n\n\n&#96;georadius key longitude latitude radius m\nkm\n\n\nGEORADIUSBYMEMBER key member radius...\n功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。\n\n\ngeohash key member1 [member2..]\n返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。\n\n\n1、geoadd\n语法：geoadd key longitude latitude member …\n将给定的空间元素(经度、纬度、名字)添加到指定的键里面。 这些数据会以有序集的形式被储存在键里面，从而使得georadius和georadiusbymember这样的 命令可以在之后通过位置查询取得这些元素。 geoadd命令以标准的x,y格式接受参数，所以用户必须先输入经度，然后再输入纬度。 geoadd能够记录的坐标是有限的：非常接近两极的区域无法被索引。 有效的经度介于-180-180度之间，有效的纬度介于-85.05112878 度至 85.05112878 度之间 当用户尝试输入一个超出范围的经度或者纬度时,geoadd命令将返回一个错误。\n测试：百度搜索经纬度查询，模拟真实数据\n127.0.0.1:6379&gt; geoadd china:city 116.23 40.22 北京(integer) 1127.0.0.1:6379&gt; geoadd china:city 121.48 31.40 上海 113.88 22.55 深圳 120.21 30.20 杭州(integer) 3127.0.0.1:6379&gt; geoadd china:city 106.54 29.40 重庆 108.93 34.23 西安 114.02 30.58 武汉(integer) 3\n\n2、geopos\n语法：geopos key member [member…]\n从key里返回所有给定位置元素的位置（经度和纬度）\n127.0.0.1:6379&gt; geopos china:city 北京1) 1) &quot;116.23000055551528931&quot;2) &quot;40.2200010338739844&quot;127.0.0.1:6379&gt; geopos china:city 上海 重庆1) 1) &quot;121.48000091314315796&quot;2) &quot;31.40000025319353938&quot;2) 1) &quot;106.54000014066696167&quot;2) &quot;29.39999880018641676&quot;127.0.0.1:6379&gt; geopos china:city 新疆1) (nil)\n\n3、geodist\n语法：geodist key member1 member2 [unit]\n返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在，那么命令返回空值\n指定单位的参数unit必须是以下单位的其中一个：\n\nm表示单位为米\nkm表示单位为千米\nmi表示单位为英里\nft表示单位为英尺\n\n如果用户没有显式地指定单位参数，那么geodist默认使用 米 作为单位。\ngeodist命令在计算距离时会假设地球为完美的球形，在极限情况下，这一假设最大会造成0.5%的误差。\n127.0.0.1:6379&gt; geodist china:city 北京 上海&quot;1088785.4302&quot;127.0.0.1:6379&gt; geodist china:city 北京 上海 km&quot;1088.7854&quot;127.0.0.1:6379&gt; geodist china:city 重庆 北京 km&quot;1491.6716&quot;\n\n4、georadius\n语法：\ngeoradius key longitude latitude radius m|km|ft|mi [withcoord][withdist] [withhash][asc|desc][count count]\n\n以给定的经纬度为中心， 找出某一半径内的元素\n重新连接 redis-cli，增加参数 –raw ，可以强制输出中文，不然会乱码\n127.0.0.1:6379&gt; georadius china:city 100 30 1000 km #乱码1) &quot;\\xe9\\x87\\x8d\\xe5\\xba\\x86&quot;2) &quot;\\xe8\\xa5\\xbf\\xe5\\xae\\x89&quot;127.0.0.1:6379&gt; exit[root@localhost bin]#  redis-cli --raw -p 6379# 在 china:city 中寻找坐标 100 30 半径为 1000km 的城市127.0.0.1:6379&gt; georadius china:city 100 30 1000 km重庆西安\n\nwithdist 返回位置名称和中心距离\n127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withdist重庆635.2850西安963.3171\n\nwithcoord 返回位置名称、经纬度\n127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord重庆106.5400001406669616729.39999880018641676西安108.9299985766410827634.23000121926852302\n\nwithdist withcoord 返回位置名称、距离、经纬度，count 限定寻找个数\n127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord withdist count 1重庆635.2850106.5400001406669616729.39999880018641676127.0.0.1:6379&gt; georadius china:city 100 30 1000 km withcoord withdist count 2重庆635.2850106.5400001406669616729.39999880018641676西安963.3171108.9299985766410827634.23000121926852302\n\n5、georadiusbymember\n语法：\ngeoradiusbymember key member radius m|km|ft|mi [withcoord][withdist] [withhash][asc|desc][count count]\n\n找出位于指定范围内的元素，中心点是由给定的位置元素决定\n127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city 北京 1000 km北京西安127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city 上海 400 km杭州上海\n\n6、geohash\n语法：geohash key member [member…]\nRedis使用geohash将二维经纬度转换为一维字符串，字符串越长表示位置更精确，两个字符串越相似表示距离越近。\n127.0.0.1:6379&gt; geohash china:city 北京 重庆wx4sucu47r0wm5z22h53v0127.0.0.1:6379&gt; geohash china:city 北京 上海wx4sucu47r0wtw6sk5n300\n\nzrem\nGEO没有提供删除成员的命令，但是因为GEO的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除。\n127.0.0.1:6379&gt; geoadd china:city 116.23 40.22 beijing1127.0.0.1:6379&gt; zrange china:city 0 -1 # 查看全部的元素重庆西安深圳武汉杭州上海beijing北京127.0.0.1:6379&gt; zrem china:city beijing # 移除元素1127.0.0.1:6379&gt; zrem china:city 北京 # 移除元素1127.0.0.1:6379&gt; zrange china:city 0 -1重庆西安深圳武汉杭州上海\n\n有效经纬度\n\n\n有效的经度从-180度到180度。\n有效的纬度从-85.05112878度到85.05112878度。\n\n\n指定单位的参数 unit 必须是以下单位的其中一个：\n\nm 表示单位为米。\nkm 表示单位为千米。\nmi 表示单位为英里。\nft 表示单位为英尺。\n\n关于GEORADIUS的参数\n\n通过georadius就可以完成 附近的人功能\nwithcoord:带上坐标\nwithdist:带上距离，单位与半径单位相同\nCOUNT n : 只显示前n个(按距离递增排序)\n\n----------------georadius---------------------127.0.0.1:6379&gt; GEORADIUS china:city 120 30 500 km withcoord withdist # 查询经纬度(120,30)坐标500km半径内的成员1) 1) &quot;hangzhou&quot;   2) &quot;29.4151&quot;   3) 1) &quot;120.20000249147415&quot;      2) &quot;30.199999888333501&quot;2) 1) &quot;shanghai&quot;   2) &quot;205.3611&quot;   3) 1) &quot;121.40000134706497&quot;      2) &quot;31.400000253193539&quot;     ------------geohash---------------------------127.0.0.1:6379&gt; geohash china:city yichang shanghai # 获取成员经纬坐标的geohash表示1) &quot;wmrjwbr5250&quot;2) &quot;wtw6ds0y300&quot;\n\nHyperloglog(基数统计)\nRedis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。\n花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。\n因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。\n其底层使用string数据类型\n\n什么是基数？\n\n数据集中不重复的元素的个数。\n\n应用场景：\n网页的访问量（UV）：一个用户多次访问，也只能算作一个人。\n\n传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是计数，Hyperloglog就能帮助我们利用最小的空间完成。\n\n\n\n\n命令\n描述\n\n\n\nPFADD key element1 [elememt2..]\n添加指定元素到 HyperLogLog 中\n\n\nPFCOUNT key [key]\n返回给定 HyperLogLog 的基数估算值。\n\n\nPFMERGE destkey sourcekey [sourcekey..]\n将多个 HyperLogLog 合并为一个 HyperLogLog\n\n\n----------PFADD--PFCOUNT---------------------127.0.0.1:6379&gt; PFADD myelemx a b c d e f g h i j k # 添加元素(integer) 1127.0.0.1:6379&gt; type myelemx # hyperloglog底层使用Stringstring127.0.0.1:6379&gt; PFCOUNT myelemx # 估算myelemx的基数(integer) 11127.0.0.1:6379&gt; PFADD myelemy i j k z m c b v p q s(integer) 1127.0.0.1:6379&gt; PFCOUNT myelemy(integer) 11----------------PFMERGE-----------------------127.0.0.1:6379&gt; PFMERGE myelemz myelemx myelemy # 合并myelemx和myelemy 成为myelemzOK127.0.0.1:6379&gt; PFCOUNT myelemz # 估算基数(integer) 17\n\n如果允许容错，那么一定可以使用Hyperloglog !\n如果不允许容错，就使用set或者自己的数据类型即可 ！\nBitMaps(位图)\n使用位存储，信息状态只有 0 和 1\nBitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。\n\n应用场景\n签到统计、状态统计\n\n\n\n命令\n描述\n\n\n\nsetbit key offset value\n为指定key的offset位设置值\n\n\ngetbit key offset\n获取offset位的值\n\n\nbitcount key [start end]\n统计字符串被设置为1的bit数，也可以指定统计范围按字节\n\n\nbitop operration destkey key[key..]\n对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。\n\n\nBITPOS key bit [start] [end]\n返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位\n\n\n------------setbit--getbit--------------127.0.0.1:6379&gt; setbit sign 0 1 # 设置sign的第0位为 1 (integer) 0127.0.0.1:6379&gt; setbit sign 2 1 # 设置sign的第2位为 1  不设置默认 是0(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0127.0.0.1:6379&gt; setbit sign 5 1(integer) 0127.0.0.1:6379&gt; type signstring127.0.0.1:6379&gt; getbit sign 2 # 获取第2位的数值(integer) 1127.0.0.1:6379&gt; getbit sign 3(integer) 1127.0.0.1:6379&gt; getbit sign 4 # 未设置默认是0(integer) 0-----------bitcount----------------------------127.0.0.1:6379&gt; BITCOUNT sign # 统计sign中为1的位数(integer) 4\n","tags":["Redis"]},{"title":"Redis之Java","url":"/2022/07/31/Redis%E4%B9%8BJava/","content":"JedisJedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件，必须对Jedis熟悉才能 写成漂亮的代码\n测试ping前提打开了redis服务。\n1、新建一个普通的Maven项目\n2、导入redis的依赖！\n&lt;dependencies&gt;    &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;    &lt;dependency&gt;        &lt;groupId&gt;redis.clients&lt;/groupId&gt;        &lt;artifactId&gt;jedis&lt;/artifactId&gt;        &lt;version&gt;3.5.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;        &lt;version&gt;1.2.75&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n3、编写测试代码\npublic class Ping &#123;    public static void main(String[] args) &#123;        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);        //查看服务是否运行        System.out.println(jedis.ping());    &#125;&#125;\n\n常用API基本操作\npublic static void main(String[] args) &#123;    Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);    //验证密码，如果没有设置密码这段代码省略    // jedis.auth(&quot;password&quot;);    jedis.connect(); //连接    jedis.disconnect(); //断开连接    jedis.flushAll(); //清空所有的key&#125;\n\n对key操作的命令\npublic class TestKey &#123;    public static void main(String[] args) &#123;        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);                System.out.println(&quot;清空数据：&quot; + jedis.flushDB());        System.out.println(&quot;判断某个键是否存在：&quot; + jedis.exists(&quot;username&quot;));        System.out.println(&quot;新增&lt;&#x27;username&#x27;,&#x27;zhiyuan&#x27;&gt;的键值对：&quot; + jedis.set(&quot;username&quot;, &quot;zhiyuan&quot;));        System.out.println(&quot;新增&lt;&#x27;password&#x27;,&#x27;password&#x27;&gt;的键值对：&quot; + jedis.set(&quot;password&quot;, &quot;password&quot;));        System.out.print(&quot;系统中所有的键如下：&quot;);        Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;);        System.out.println(keys);        System.out.println(&quot;删除键password:&quot; + jedis.del(&quot;password&quot;));        System.out.println(&quot;判断键password是否存在：&quot; + jedis.exists(&quot;password&quot;));        System.out.println(&quot;查看键username所存储的值的类型：&quot; + jedis.type(&quot;username&quot;));        System.out.println(&quot;随机返回key空间的一个：&quot; + jedis.randomKey());        System.out.println(&quot;重命名key：&quot; + jedis.rename(&quot;username&quot;, &quot;name&quot;));        System.out.println(&quot;取出改后的name：&quot; + jedis.get(&quot;name&quot;));        System.out.println(&quot;按索引查询：&quot; + jedis.select(0));        System.out.println(&quot;删除当前选择数据库中的所有key：&quot; + jedis.flushDB());        System.out.println(&quot;返回当前数据库中key的数目：&quot; + jedis.dbSize());        System.out.println(&quot;删除所有数据库中的所有key：&quot; + jedis.flushAll());    &#125;&#125;\n\n对String操作的命令\npublic class TestString &#123;    public static void main(String[] args) &#123;        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);        jedis.flushDB();        System.out.println(&quot;===========增加数据===========&quot;);        System.out.println(jedis.set(&quot;key1&quot;, &quot;value1&quot;));        System.out.println(jedis.set(&quot;key2&quot;, &quot;value2&quot;));        System.out.println(jedis.set(&quot;key3&quot;, &quot;value3&quot;));        System.out.println(&quot;删除键key2:&quot; + jedis.del(&quot;key2&quot;));        System.out.println(&quot;获取键key2:&quot; + jedis.get(&quot;key2&quot;));        System.out.println(&quot;修改key1:&quot; + jedis.set(&quot;key1&quot;, &quot;value1Changed&quot;));        System.out.println(&quot;获取key1的值：&quot; + jedis.get(&quot;key1&quot;));        System.out.println(&quot;在key3后面加入值：&quot; + jedis.append(&quot;key3&quot;, &quot;End&quot;));        System.out.println(&quot;key3的值：&quot; + jedis.get(&quot;key3&quot;));        System.out.println(&quot;增加多个键值对：&quot; + jedis.mset(&quot;key01&quot;, &quot;value01&quot;, &quot;key02&quot;, &quot;value02&quot;, &quot;key03&quot;, &quot;value03&quot;));        System.out.println(&quot;获取多个键值对：&quot; + jedis.mget(&quot;key01&quot;, &quot;key02&quot;, &quot;key03&quot;));        System.out.println(&quot;获取多个键值对：&quot; + jedis.mget(&quot;key01&quot;, &quot;key02&quot;, &quot;key03&quot;, &quot;key04&quot;));        System.out.println(&quot;删除多个键值对：&quot; + jedis.del(&quot;key01&quot;, &quot;key02&quot;));        System.out.println(&quot;获取多个键值对：&quot; + jedis.mget(&quot;key01&quot;, &quot;key02&quot;, &quot;key03&quot;));        jedis.flushDB();        System.out.println(&quot;===========新增键值对防止覆盖原先值==============&quot;);        System.out.println(jedis.setnx(&quot;key1&quot;, &quot;value1&quot;));        System.out.println(jedis.setnx(&quot;key2&quot;, &quot;value2&quot;));        System.out.println(jedis.setnx(&quot;key2&quot;, &quot;value2-new&quot;));        System.out.println(jedis.get(&quot;key1&quot;));        System.out.println(jedis.get(&quot;key2&quot;));        System.out.println(&quot;===========新增键值对并设置有效时间=============&quot;);        System.out.println(jedis.setex(&quot;key3&quot;, 2, &quot;value3&quot;));        System.out.println(jedis.get(&quot;key3&quot;));        try &#123;            TimeUnit.SECONDS.sleep(3);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(jedis.get(&quot;key3&quot;));        System.out.println(&quot;===========获取原值，更新为新值==========&quot;);        System.out.println(jedis.getSet(&quot;key2&quot;, &quot;key2GetSet&quot;));        System.out.println(jedis.get(&quot;key2&quot;));        System.out.println(&quot;获得key2的值的字串：&quot; + jedis.getrange(&quot;key2&quot;, 2,4));    &#125;&#125;\n\n对List操作命令\npublic class TestList &#123;    public static void main(String[] args) &#123;        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);        jedis.flushDB();        System.out.println(&quot;===========添加一个list===========&quot;);        jedis.lpush(&quot;collections&quot;, &quot;ArrayList&quot;, &quot;Vector&quot;, &quot;Stack&quot;, &quot;HashMap&quot;, &quot;WeakHashMap&quot;, &quot;LinkedHashMap&quot;);        jedis.lpush(&quot;collections&quot;, &quot;HashSet&quot;);        jedis.lpush(&quot;collections&quot;, &quot;TreeSet&quot;);        jedis.lpush(&quot;collections&quot;, &quot;TreeMap&quot;);        System.out.println(&quot;collections的内容：&quot; + jedis.lrange(&quot;collections&quot;, 0, -1));//-1代表倒数第一个元素，-2代表倒数第二个元素,end为-1表示查询全部        System.out.println(&quot;collections区间0-3的元素：&quot; + jedis.lrange(&quot;collections&quot;, 0, 3));        System.out.println(&quot;===============================&quot;);        // 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后add进去的值先被删，类似于出栈        System.out.println(&quot;删除指定元素个数：&quot; + jedis.lrem(&quot;collections&quot;, 2,                &quot;HashMap&quot;));        System.out.println(&quot;collections的内容：&quot; + jedis.lrange(&quot;collections&quot;,                0, -1));        System.out.println(&quot;删除下表0-3区间之外的元素：&quot; + jedis.ltrim(&quot;collections&quot;, 0, 3));        System.out.println(&quot;collections的内容：&quot; + jedis.lrange(&quot;collections&quot;,                0, -1));        System.out.println(&quot;collections列表出栈（左端）：&quot; + jedis.lpop(&quot;collections&quot;));        System.out.println(&quot;collections的内容：&quot; + jedis.lrange(&quot;collections&quot;, 0, -1));        System.out.println(&quot;collections添加元素，从列表右端，与lpush相对应：&quot; + jedis.rpush(&quot;collections&quot;, &quot;EnumMap&quot;));        System.out.println(&quot;collections的内容：&quot; + jedis.lrange(&quot;collections&quot;,                0, -1));        System.out.println(&quot;collections列表出栈（右端）：&quot; + jedis.rpop(&quot;collections&quot;));        System.out.println(&quot;collections的内容：&quot; + jedis.lrange(&quot;collections&quot;,                0, -1));        System.out.println(&quot;修改collections指定下标1的内容：&quot; + jedis.lset(&quot;collections&quot;, 1, &quot;LinkedArrayList&quot;));        System.out.println(&quot;collections的内容：&quot; + jedis.lrange(&quot;collections&quot;,                0, -1));        System.out.println(&quot;===============================&quot;);        System.out.println(&quot;collections的长度：&quot; + jedis.llen(&quot;collections&quot;));        System.out.println(&quot;获取collections下标为2的元素：&quot; + jedis.lindex(&quot;collections&quot;, 2));        System.out.println(&quot;===============================&quot;);        jedis.lpush(&quot;sortedList&quot;, &quot;3&quot;, &quot;6&quot;, &quot;2&quot;, &quot;0&quot;, &quot;7&quot;, &quot;4&quot;);        System.out.println(&quot;sortedList排序前：&quot; + jedis.lrange(&quot;sortedList&quot;, 0,                -1));        System.out.println(jedis.sort(&quot;sortedList&quot;));        System.out.println(&quot;sortedList排序后：&quot; + jedis.lrange(&quot;sortedList&quot;, 0, -1));    &#125;&#125;\n\n对Set的操作命令\npublic class TestSet &#123;    public static void main(String[] args) &#123;        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);        jedis.flushDB();        System.out.println(&quot;============向集合中添加元素（不重复）============&quot;);        System.out.println(jedis.sadd(&quot;eleSet&quot;, &quot;e1&quot;, &quot;e2&quot;, &quot;e4&quot;, &quot;e3&quot;, &quot;e0&quot;, &quot;e8&quot;, &quot;e7&quot;, &quot;e5&quot;));        System.out.println(jedis.sadd(&quot;eleSet&quot;, &quot;e6&quot;));        System.out.println(jedis.sadd(&quot;eleSet&quot;, &quot;e6&quot;));        System.out.println(&quot;eleSet的所有元素为：&quot; + jedis.smembers(&quot;eleSet&quot;));        System.out.println(&quot;删除一个元素e0：&quot; + jedis.srem(&quot;eleSet&quot;, &quot;e0&quot;));        System.out.println(&quot;eleSet的所有元素为：&quot; + jedis.smembers(&quot;eleSet&quot;));        System.out.println(&quot;删除两个元素e7和e6：&quot; + jedis.srem(&quot;eleSet&quot;, &quot;e7&quot;, &quot;e6&quot;));        System.out.println(&quot;eleSet的所有元素为：&quot; + jedis.smembers(&quot;eleSet&quot;));        System.out.println(&quot;随机的移除集合中的一个元素：&quot; + jedis.spop(&quot;eleSet&quot;));        System.out.println(&quot;随机的移除集合中的一个元素：&quot; + jedis.spop(&quot;eleSet&quot;));        System.out.println(&quot;eleSet的所有元素为：&quot; + jedis.smembers(&quot;eleSet&quot;));        System.out.println(&quot;eleSet中包含元素的个数：&quot; + jedis.scard(&quot;eleSet&quot;));        System.out.println(&quot;e3是否在eleSet中：&quot; + jedis.sismember(&quot;eleSet&quot;, &quot;e3&quot;));        System.out.println(&quot;e1是否在eleSet中：&quot; + jedis.sismember(&quot;eleSet&quot;, &quot;e1&quot;));        System.out.println(&quot;e1是否在eleSet中：&quot; + jedis.sismember(&quot;eleSet&quot;, &quot;e5&quot;));        System.out.println(&quot;=================================&quot;);        System.out.println(jedis.sadd(&quot;eleSet1&quot;, &quot;e1&quot;, &quot;e2&quot;, &quot;e4&quot;, &quot;e3&quot;, &quot;e0&quot;, &quot;e8&quot;, &quot;e7&quot;, &quot;e5&quot;));        System.out.println(jedis.sadd(&quot;eleSet2&quot;,&quot;e1&quot;, &quot;e2&quot;, &quot;e4&quot;, &quot;e3&quot;, &quot;e0&quot;, &quot;e8&quot;));        System.out.println(&quot;将eleSet1中删除e1并存入eleSet3中：&quot; + jedis.smove(&quot;eleSet1&quot;, &quot;eleSet3&quot;, &quot;e1&quot;));//移到集合元素        System.out.println(&quot;将eleSet1中删除e2并存入eleSet3中：&quot; + jedis.smove(&quot;eleSet1&quot;, &quot;eleSet3&quot;, &quot;e2&quot;));        System.out.println(&quot;eleSet1中的元素：&quot; + jedis.smembers(&quot;eleSet1&quot;));        System.out.println(&quot;eleSet3中的元素：&quot; + jedis.smembers(&quot;eleSet3&quot;));        System.out.println(&quot;============集合运算=================&quot;);        System.out.println(&quot;eleSet1中的元素：&quot; + jedis.smembers(&quot;eleSet1&quot;));        System.out.println(&quot;eleSet2中的元素：&quot; + jedis.smembers(&quot;eleSet2&quot;));        System.out.println(&quot;eleSet1和eleSet2的交集:&quot; + jedis.sinter(&quot;eleSet1&quot;, &quot;eleSet2&quot;));        System.out.println(&quot;eleSet1和eleSet2的并集:&quot; + jedis.sunion(&quot;eleSet1&quot;, &quot;eleSet2&quot;));        System.out.println(&quot;eleSet1和eleSet2的差集:&quot; + jedis.sdiff(&quot;eleSet1&quot;, &quot;eleSet2&quot;));//eleSet1中有，eleSet2中没有        jedis.sinterstore(&quot;eleSet4&quot;, &quot;eleSet1&quot;, &quot;eleSet2&quot;);//求交集并将交集保存到dstkey的集合        System.out.println(&quot;eleSet4中的元素：&quot; + jedis.smembers(&quot;eleSet4&quot;));    &#125;&#125;\n\n对Hash的操作命令\npublic class TestHash &#123;    public static void main(String[] args) &#123;        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);        jedis.flushDB();        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;key1&quot;, &quot;value1&quot;);        map.put(&quot;key2&quot;, &quot;value2&quot;);        map.put(&quot;key3&quot;, &quot;value3&quot;);        map.put(&quot;key4&quot;, &quot;value4&quot;);        //添加名称为hash（key）的hash元素        jedis.hmset(&quot;hash&quot;, map);        //向名称为hash的hash中添加key为key5，value为value5元素        jedis.hset(&quot;hash&quot;, &quot;key5&quot;, &quot;value5&quot;);        System.out.println(&quot;散列hash的所有键值对为：&quot; + jedis.hgetAll(&quot;hash&quot;));//return Map&lt;String,String&gt;        System.out.println(&quot;散列hash的所有键为：&quot; + jedis.hkeys(&quot;hash&quot;));//returnSet&lt;String&gt;        System.out.println(&quot;散列hash的所有值为：&quot; + jedis.hvals(&quot;hash&quot;));//returnList&lt;String&gt;        System.out.println(&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot; + jedis.hincrBy(&quot;hash&quot;, &quot;key6&quot;, 6));        System.out.println(&quot;散列hash的所有键值对为：&quot; + jedis.hgetAll(&quot;hash&quot;));        System.out.println(&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot; + jedis.hincrBy(&quot;hash&quot;, &quot;key6&quot;, 3));        System.out.println(&quot;散列hash的所有键值对为：&quot; + jedis.hgetAll(&quot;hash&quot;));        System.out.println(&quot;删除一个或者多个键值对：&quot; + jedis.hdel(&quot;hash&quot;, &quot;key2&quot;));        System.out.println(&quot;散列hash的所有键值对为：&quot; + jedis.hgetAll(&quot;hash&quot;));        System.out.println(&quot;散列hash中键值对的个数：&quot; + jedis.hlen(&quot;hash&quot;));        System.out.println(&quot;判断hash中是否存在key2：&quot; + jedis.hexists(&quot;hash&quot;, &quot;key2&quot;));        System.out.println(&quot;判断hash中是否存在key3：&quot; + jedis.hexists(&quot;hash&quot;, &quot;key3&quot;));        System.out.println(&quot;获取hash中的值：&quot; + jedis.hmget(&quot;hash&quot;, &quot;key3&quot;));        System.out.println(&quot;获取hash中的值：&quot; + jedis.hmget(&quot;hash&quot;, &quot;key3&quot;, &quot;key4&quot;));    &#125;&#125;\n\n事务public class TestMulti &#123;    public static void main(String[] args) &#123;        //创建客户端连接服务端，redis服务端需要被开启        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);        jedis.flushDB();        JSONObject jsonObject = new JSONObject();        jsonObject.put(&quot;hello&quot;, &quot;world&quot;);        jsonObject.put(&quot;name&quot;, &quot;java&quot;);        //开启事务        Transaction multi = jedis.multi();        String result = jsonObject.toJSONString();        try &#123;            //向redis存入一条数据            multi.set(&quot;json&quot;, result);            //再存入一条数据            multi.set(&quot;json2&quot;, result);            //这里引发了异常，用0作为被除数            int i = 100 / 0;            //如果没有引发异常，执行进入队列的命令            multi.exec();        &#125; catch (Exception e) &#123;            e.printStackTrace();            //如果出现异常，回滚            multi.discard();        &#125; finally &#123;            System.out.println(jedis.get(&quot;json&quot;));            System.out.println(jedis.get(&quot;json2&quot;));            //最终关闭客户端            jedis.close();        &#125;    &#125;&#125;\n\nSpringBoot整合基础使用概述：\n在SpringBoot中一般使用RedisTemplate提供的方法来操作Redis。那么使用SpringBoot整合Redis需要 那些步骤呢。\n1、 JedisPoolConfig (这个是配置连接池)\n2、 RedisConnectionFactory 这个是配置连接信息，这里的RedisConnectionFactory是一个接口，我们需要使用它的实现类，在SpringD Data Redis方案中提供了以下四种工厂模型：\n\nJredisConnectionFactory\nJedisConnectionFactory\nLettuceConnectionFactory\nSrpConnectionFactory\n\n3、 RedisTemplate 基本操作\n导入依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n说明：在springboot2.x之后，原来使用的jedis被替换成lettuce\nyaml配置\nspring:  redis:    host: 127.0.0.1    port: 6379\n\n测试类中测试\n@Autowiredprivate RedisTemplate&lt;String, String&gt; redisTemplate;@Testvoid contextLoads() &#123;    redisTemplate.opsForValue().set(&quot;myKey&quot;, &quot;myValue&quot;);    System.out.println(redisTemplate.opsForValue().get(&quot;myKey&quot;));&#125;\n\n序列化config创建springboot新项目，安装上面步骤导入依赖\n1、分析 RedisAutoConfiguration 自动配置类\n@Configuration(proxyBeanMethods = false)@ConditionalOnClass(RedisOperations.class)@EnableConfigurationProperties(RedisProperties.class)@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)public class RedisAutoConfiguration &#123;   @Bean   @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)   @ConditionalOnSingleCandidate(RedisConnectionFactory.class)   public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;      RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();      template.setConnectionFactory(redisConnectionFactory);      return template;   &#125;   @Bean   @ConditionalOnMissingBean   @ConditionalOnSingleCandidate(RedisConnectionFactory.class)   public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;      StringRedisTemplate template = new StringRedisTemplate();      template.setConnectionFactory(redisConnectionFactory);      return template;   &#125;&#125;\n\n通过源码可以看出，SpringBoot自动帮我们在容器中生成了一个RedisTemplate和一个StringRedisTemplate。\n但是，这个RedisTemplate的泛型是，写代码不方便，需要写好多类型转换的代码；我们需要一个泛型为形式的RedisTemplate。\n并且，这个RedisTemplate没有设置数据存在Redis时，key及value的序列化方式。\n看到这个@ConditionalOnMissingBean注解后，就知道如果Spring容器中有了RedisTemplate对象了， 这个自动配置的RedisTemplate不会实例化。因此我们可以直接自己写个配置类，配置 RedisTemplate。\n用这个配置我们不可以存储对象，否则会报SerializationException，大家可自己试试\n2、既然自动配置不好用，就重新配置一个RedisTemplate\npackage com.oddfar.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();        template.setConnectionFactory(factory);        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);//        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); //此方法已过期        //新方法        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();        // key采用String的序列化方式        template.setKeySerializer(stringRedisSerializer);        // hash的key也采用String的序列化方式        template.setHashKeySerializer(stringRedisSerializer);        // value序列化方式采用jackson        template.setValueSerializer(jackson2JsonRedisSerializer);        // hash的value序列化方式采用jackson        template.setHashValueSerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        return template;    &#125;&#125;\n\n创建User对象，name和age\n测试存对象\n@SpringBootTestpublic class RedisTest &#123;    @Autowired    private RedisTemplate redisTemplate;    @Test    void test() &#123;        User user = new User(&quot;致远&quot;,3);        redisTemplate.opsForValue().set(&quot;user&quot;,user);        System.out.println(redisTemplate.opsForValue().get(&quot;user&quot;));    &#125;&#125;\n\nredis工具类使用RedisTemplate需要频繁调用.opForxxx然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。\n1、写一个Redis工具类（直接用RedisTemplate操作Redis，需要很多行代码，因此直接封装好一个 RedisUtils，这样写代码更方便点。这个RedisUtils交给Spring容器实例化，使用时直接注解注入。）\npackage com.zxy.demo.redis;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;/** * Redis工具类 * @author ZENG.XIAO.YAN * @date   2018年6月7日 */@Componentpublic final class RedisUtil &#123;\t\t@Autowired\tprivate RedisTemplate&lt;String, Object&gt; redisTemplate;\t// =============================common============================\t/**\t * 指定缓存失效时间\t * @param key 键\t * @param time 时间(秒)\t * @return\t */\tpublic boolean expire(String key, long time) &#123;\t\ttry &#123;\t\t\tif (time &gt; 0) &#123;\t\t\t\tredisTemplate.expire(key, time, TimeUnit.SECONDS);\t\t\t&#125;\t\t\treturn true;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn false;\t\t&#125;\t&#125;\t/**\t * 根据key 获取过期时间\t * @param key 键 不能为null\t * @return 时间(秒) 返回0代表为永久有效\t */\tpublic long getExpire(String key) &#123;\t\treturn redisTemplate.getExpire(key, TimeUnit.SECONDS);\t&#125;\t/**\t * 判断key是否存在\t * @param key 键\t * @return true 存在 false不存在\t */\tpublic boolean hasKey(String key) &#123;\t\ttry &#123;\t\t\treturn redisTemplate.hasKey(key);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn false;\t\t&#125;\t&#125;\t/**\t * 删除缓存\t * @param key 可以传一个值 或多个\t */\t@SuppressWarnings(&quot;unchecked&quot;)\tpublic void del(String... key) &#123;\t\tif (key != null &amp;&amp; key.length &gt; 0) &#123;\t\t\tif (key.length == 1) &#123;\t\t\t\tredisTemplate.delete(key[0]);\t\t\t&#125; else &#123;\t\t\t\tredisTemplate.delete(CollectionUtils.arrayToList(key));\t\t\t&#125;\t\t&#125;\t&#125;\t// ============================String=============================\t/**\t * 普通缓存获取\t * @param key 键\t * @return 值\t */\tpublic Object get(String key) &#123;\t\treturn key == null ? null : redisTemplate.opsForValue().get(key);\t&#125;\t/**\t * 普通缓存放入\t * @param key 键\t * @param value 值\t * @return true成功 false失败\t */\tpublic boolean set(String key, Object value) &#123;\t\ttry &#123;\t\t\tredisTemplate.opsForValue().set(key, value);\t\t\treturn true;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn false;\t\t&#125;\t&#125;\t/**\t * 普通缓存放入并设置时间\t * @param key 键\t * @param value 值\t * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期\t * @return true成功 false 失败\t */\tpublic boolean set(String key, Object value, long time) &#123;\t\ttry &#123;\t\t\tif (time &gt; 0) &#123;\t\t\t\tredisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);\t\t\t&#125; else &#123;\t\t\t\tset(key, value);\t\t\t&#125;\t\t\treturn true;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn false;\t\t&#125;\t&#125;\t/**\t * 递增\t * @param key 键\t * @param delta 要增加几(大于0)\t * @return\t */\tpublic long incr(String key, long delta) &#123;\t\tif (delta &lt; 0) &#123;\t\t\tthrow new RuntimeException(&quot;递增因子必须大于0&quot;);\t\t&#125;\t\treturn redisTemplate.opsForValue().increment(key, delta);\t&#125;\t/**\t * 递减\t * @param key 键\t * @param delta 要减少几(小于0)\t * @return\t */\tpublic long decr(String key, long delta) &#123;\t\tif (delta &lt; 0) &#123;\t\t\tthrow new RuntimeException(&quot;递减因子必须大于0&quot;);\t\t&#125;\t\treturn redisTemplate.opsForValue().increment(key, -delta);\t&#125;\t// ================================Map=================================\t/**\t * HashGet\t * @param key 键 不能为null\t * @param item 项 不能为null\t * @return 值\t */\tpublic Object hget(String key, String item) &#123;\t\treturn redisTemplate.opsForHash().get(key, item);\t&#125;\t/**\t * 获取hashKey对应的所有键值\t * @param key 键\t * @return 对应的多个键值\t */\tpublic Map&lt;Object, Object&gt; hmget(String key) &#123;\t\treturn redisTemplate.opsForHash().entries(key);\t&#125;\t/**\t * HashSet\t * @param key 键\t * @param map 对应多个键值\t * @return true 成功 false 失败\t */\tpublic boolean hmset(String key, Map&lt;String, Object&gt; map) &#123;\t\ttry &#123;\t\t\tredisTemplate.opsForHash().putAll(key, map);\t\t\treturn true;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn false;\t\t&#125;\t&#125;\t/**\t * HashSet 并设置时间\t * @param key 键\t * @param map 对应多个键值\t * @param time 时间(秒)\t * @return true成功 false失败\t */\tpublic boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123;\t\ttry &#123;\t\t\tredisTemplate.opsForHash().putAll(key, map);\t\t\tif (time &gt; 0) &#123;\t\t\t\texpire(key, time);\t\t\t&#125;\t\t\treturn true;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn false;\t\t&#125;\t&#125;\t/**\t * 向一张hash表中放入数据,如果不存在将创建\t * @param key 键\t * @param item 项\t * @param value 值\t * @return true 成功 false失败\t */\tpublic boolean hset(String key, String item, Object value) &#123;\t\ttry &#123;\t\t\tredisTemplate.opsForHash().put(key, item, value);\t\t\treturn true;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn false;\t\t&#125;\t&#125;\t/**\t * 向一张hash表中放入数据,如果不存在将创建\t * @param key 键\t * @param item 项\t * @param value 值\t * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间\t * @return true 成功 false失败\t */\tpublic boolean hset(String key, String item, Object value, long time) &#123;\t\ttry &#123;\t\t\tredisTemplate.opsForHash().put(key, item, value);\t\t\tif (time &gt; 0) &#123;\t\t\t\texpire(key, time);\t\t\t&#125;\t\t\treturn true;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn false;\t\t&#125;\t&#125;\t/**\t * 删除hash表中的值\t * @param key 键 不能为null\t * @param item 项 可以使多个 不能为null\t */\tpublic void hdel(String key, Object... item) &#123;\t\tredisTemplate.opsForHash().delete(key, item);\t&#125;\t/**\t * 判断hash表中是否有该项的值\t * @param key 键 不能为null\t * @param item 项 不能为null\t * @return true 存在 false不存在\t */\tpublic boolean hHasKey(String key, String item) &#123;\t\treturn redisTemplate.opsForHash().hasKey(key, item);\t&#125;\t/**\t * hash递增 如果不存在,就会创建一个 并把新增后的值返回\t * @param key 键\t * @param item 项\t * @param by 要增加几(大于0)\t * @return\t */\tpublic double hincr(String key, String item, double by) &#123;\t\treturn redisTemplate.opsForHash().increment(key, item, by);\t&#125;\t/**\t * hash递减\t * @param key 键\t * @param item 项\t * @param by 要减少记(小于0)\t * @return\t */\tpublic double hdecr(String key, String item, double by) &#123;\t\treturn redisTemplate.opsForHash().increment(key, item, -by);\t&#125;\t// ============================set=============================\t/**\t * 根据key获取Set中的所有值\t * @param key 键\t * @return\t */\tpublic Set&lt;Object&gt; sGet(String key) &#123;\t\ttry &#123;\t\t\treturn redisTemplate.opsForSet().members(key);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn null;\t\t&#125;\t&#125;\t/**\t * 根据value从一个set中查询,是否存在\t * @param key 键\t * @param value 值\t * @return true 存在 false不存在\t */\tpublic boolean sHasKey(String key, Object value) &#123;\t\ttry &#123;\t\t\treturn redisTemplate.opsForSet().isMember(key, value);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn false;\t\t&#125;\t&#125;\t/**\t * 将数据放入set缓存\t * @param key 键\t * @param values 值 可以是多个\t * @return 成功个数\t */\tpublic long sSet(String key, Object... values) &#123;\t\ttry &#123;\t\t\treturn redisTemplate.opsForSet().add(key, values);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn 0;\t\t&#125;\t&#125;\t/**\t * 将set数据放入缓存\t * @param key 键\t * @param time 时间(秒)\t * @param values 值 可以是多个\t * @return 成功个数\t */\tpublic long sSetAndTime(String key, long time, Object... values) &#123;\t\ttry &#123;\t\t\tLong count = redisTemplate.opsForSet().add(key, values);\t\t\tif (time &gt; 0)\t\t\t\texpire(key, time);\t\t\treturn count;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn 0;\t\t&#125;\t&#125;\t/**\t * 获取set缓存的长度\t * @param key 键\t * @return\t */\tpublic long sGetSetSize(String key) &#123;\t\ttry &#123;\t\t\treturn redisTemplate.opsForSet().size(key);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn 0;\t\t&#125;\t&#125;\t/**\t * 移除值为value的\t * @param key 键\t * @param values 值 可以是多个\t * @return 移除的个数\t */\tpublic long setRemove(String key, Object... values) &#123;\t\ttry &#123;\t\t\tLong count = redisTemplate.opsForSet().remove(key, values);\t\t\treturn count;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn 0;\t\t&#125;\t&#125;\t// ===============================list=================================\t/**\t * 获取list缓存的内容\t * @param key 键\t * @param start 开始\t * @param end 结束 0 到 -1代表所有值\t * @return\t */\tpublic List&lt;Object&gt; lGet(String key, long start, long end) &#123;\t\ttry &#123;\t\t\treturn redisTemplate.opsForList().range(key, start, end);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn null;\t\t&#125;\t&#125;\t/**\t * 获取list缓存的长度\t * @param key 键\t * @return\t */\tpublic long lGetListSize(String key) &#123;\t\ttry &#123;\t\t\treturn redisTemplate.opsForList().size(key);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn 0;\t\t&#125;\t&#125;\t/**\t * 通过索引 获取list中的值\t * @param key 键\t * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推\t * @return\t */\tpublic Object lGetIndex(String key, long index) &#123;\t\ttry &#123;\t\t\treturn redisTemplate.opsForList().index(key, index);\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn null;\t\t&#125;\t&#125;\t/**\t * 将list放入缓存\t * @param key 键\t * @param value 值\t * @param time 时间(秒)\t * @return\t */\tpublic boolean lSet(String key, Object value) &#123;\t\ttry &#123;\t\t\tredisTemplate.opsForList().rightPush(key, value);\t\t\treturn true;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn false;\t\t&#125;\t&#125;\t/**\t * 将list放入缓存\t * @param key 键\t * @param value 值\t * @param time 时间(秒)\t * @return\t */\tpublic boolean lSet(String key, Object value, long time) &#123;\t\ttry &#123;\t\t\tredisTemplate.opsForList().rightPush(key, value);\t\t\tif (time &gt; 0)\t\t\t\texpire(key, time);\t\t\treturn true;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn false;\t\t&#125;\t&#125;\t/**\t * 将list放入缓存\t * @param key 键\t * @param value 值\t * @param time 时间(秒)\t * @return\t */\tpublic boolean lSet(String key, List&lt;Object&gt; value) &#123;\t\ttry &#123;\t\t\tredisTemplate.opsForList().rightPushAll(key, value);\t\t\treturn true;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn false;\t\t&#125;\t&#125;\t/**\t * 将list放入缓存\t * \t * @param key 键\t * @param value 值\t * @param time 时间(秒)\t * @return\t */\tpublic boolean lSet(String key, List&lt;Object&gt; value, long time) &#123;\t\ttry &#123;\t\t\tredisTemplate.opsForList().rightPushAll(key, value);\t\t\tif (time &gt; 0)\t\t\t\texpire(key, time);\t\t\treturn true;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn false;\t\t&#125;\t&#125;\t/**\t * 根据索引修改list中的某条数据\t * @param key 键\t * @param index 索引\t * @param value 值\t * @return\t */\tpublic boolean lUpdateIndex(String key, long index, Object value) &#123;\t\ttry &#123;\t\t\tredisTemplate.opsForList().set(key, index, value);\t\t\treturn true;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn false;\t\t&#125;\t&#125;\t/**\t * 移除N个值为value\t * @param key 键\t * @param count 移除多少个\t * @param value 值\t * @return 移除的个数\t */\tpublic long lRemove(String key, long count, Object value) &#123;\t\ttry &#123;\t\t\tLong remove = redisTemplate.opsForList().remove(key, count, value);\t\t\treturn remove;\t\t&#125; catch (Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn 0;\t\t&#125;\t&#125;&#125;\n\nhttps://www.cnblogs.com/zhzhlong/p/11434284.html\nRedis.conf熟悉基本配置\n位置\n\nRedis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf\nconfig get * # 获取全部的配置\n\n\n我们一般情况下，会单独拷贝出来一份进行操作。来保证初始文件的安全。\n正如在 安装redis 中的讲解中拷贝一份\n\n容量单位不区分大小写，G和GB有区别\n\n\n\ninclude 组合多个配置\n\n\n和Spring配置文件类似，可以通过includes包含，redis.conf 可以作为总文件，可以包含其他文件！\n\nNETWORK 网络配置\n\nbind 127.0.0.1 # 绑定的ipprotected-mode yes # 保护模式port 6379 # 默认端口\n\n\nGENERAL 通用\n\ndaemonize yes # 默认情况下，Redis不作为守护进程运行。需要开启的话，改为 yessupervised no # 可通过upstart和systemd管理Redis守护进程loglevel notice # 日志级别。可选项有：\t\t\t\t# debug（记录大量日志信息，适用于开发、测试阶段）\t\t\t\t# verbose（较多日志信息）\t\t\t\t# notice（适量日志信息，使用于生产环境）\t\t\t\t# warning（仅有部分重要、关键信息才会被记录）logfile &quot;&quot; # 日志文件的位置，当指定为空字符串时，为标准输出databases 16 # 设置数据库的数目。默认的数据库是DB 0always-show-logo yes # 是否总是显示logo\n\n\nSNAPSHOPTING 快照，持久化规则\n\n由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中\n持久化方式：\n\nRDB\nAOF\n\n# 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）save 900 1# 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）save 300 10# 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）save 60 10000\n\nRDB文件相关\nstop-writes-on-bgsave-error yes # 持久化出现错误后，是否依然进行继续进行工作rdbcompression yes # 使用压缩rdb文件 yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间rdbchecksum yes # 是否校验rdb文件，更有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗dbfilename dump.rdb # dbfilenamerdb文件名称dir ./ # dir 数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录\n\n\nREPLICATION主从复制\n\n\n后面详细说\n\nSECURITY安全\n\n访问密码的查看，设置和取消\n# 启动redis# 连接客户端# 获得和设置密码config get requirepassconfig set requirepass &quot;123456&quot;#测试ping，发现需要验证127.0.0.1:6379&gt; pingNOAUTH Authentication required.# 验证127.0.0.1:6379&gt; auth 123456OK127.0.0.1:6379&gt; pingPONG\n\n\n客户端连接相关\n\nmaxclients 10000 # 设置能连上redis的最大客户端连接数量maxmemory &lt;bytes&gt; # redis配置的最大内存容量maxmemory-policy noeviction # maxmemory-policy 内存达到上限的处理策略                #volatile-lru：利用LRU算法移除设置过过期时间的key。                #volatile-random：随机移除设置过过期时间的key。                #volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）                #allkeys-lru：利用LRU算法移除任何key。                #allkeys-random：随机移除任何key。                #noeviction：不移除任何key，只是返回一个写错误。\n\nmaxmemory-policy 六种方式\n1、volatile-lru：利用LRU算法移除设置过过期时间的key。\n2、allkeys-lru ： 用lru算法删除lkey\n3、volatile-random：随机删除即将过期key\n4、allkeys-random：随机删除\n5、volatile-ttl ： 删除即将过期的\n6、noeviction ： 不移除任何key，只是返回一个写错误。\nredis 中的默认的过期策略是 volatile-lru 。\n设置方式\nconfig set maxmemory-policy volatile-lru \n\n\nappend only模式\n\n（AOF相关部分）\n\n\nappendfsync everysec # appendfsync aof持久化策略的配置        # no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。        # always表示每次写入都执行fsync，以保证数据同步到磁盘。        # everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。\n","tags":["Redis"]},{"title":"Redis之事务","url":"/2022/07/31/Redis%E4%B9%8B%E4%BA%8B%E5%8A%A1/","content":"Redis的单条命令是保证原子性的，但是redis事务不能保证原子性\n\nRedis事务本质：一组命令的集合。\n—————– 队列 set set set 执行 ——————-\n事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。\n\n一次性\n顺序性\n排他性\n\n\n\nRedis事务没有隔离级别的概念\nRedis单条命令是保证原子性的，但是事务不保证原子性！\n\n\nRedis事务操作过程\n开启事务（multi）\n命令入队\n执行事务（exec）\n\n所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。\n127.0.0.1:6379&gt; multi # 开启事务OK127.0.0.1:6379&gt; set k1 v1 # 命令入队QUEUED127.0.0.1:6379&gt; set k2 v2 # ..QUEUED127.0.0.1:6379&gt; get k1QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; keys *QUEUED127.0.0.1:6379&gt; exec # 事务执行1) OK2) OK3) &quot;v1&quot;4) OK5) 1) &quot;k3&quot;   2) &quot;k2&quot;   3) &quot;k1&quot;\n\n取消事务(discurd)\n127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; DISCARD # 放弃事务OK127.0.0.1:6379&gt; EXEC (error) ERR EXEC without MULTI # 当前未开启事务127.0.0.1:6379&gt; get k1 # 被放弃事务中命令并未执行(nil)\n\n事务错误\n代码语法错误（编译时异常）所有的命令都不执行\n\n127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; error k1 # 这是一条语法错误命令(error) ERR unknown command `error`, with args beginning with: `k1`, # 会报错但是不影响后续命令入队 127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; EXEC(error) EXECABORT Transaction discarded because of previous errors. # 执行报错127.0.0.1:6379&gt; get k1 (nil) # 其他命令并没有被执行\n\n\n代码逻辑错误 (运行时异常) **其他命令可以正常执行 ** &gt;&gt;&gt; 所以不保证事务原子性\n\n127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; INCR k1 # 这条命令逻辑错误（对字符串进行增量）QUEUED127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; exec1) OK2) OK3) (error) ERR value is not an integer or out of range # 运行时报错4) &quot;v2&quot; # 其他命令正常执行# 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。# 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。\n\nWatch监控悲观锁：\n\n很悲观，认为什么时候都会出现问题，无论做什么都会加锁\n\n乐观锁：\n\n很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据\n获取version\n更新的时候比较version\n\n使用watch key监控指定数据，相当于乐观锁加锁。\n\n正常执行\n\n#1、初始化信用卡可用余额和欠额127.0.0.1:6379&gt; set money 100 # 设置余额:100OK127.0.0.1:6379&gt; set use 0 # 支出使用:0OK#2、使用watch检测balance，事务期间balance数据未变动，事务执行成功127.0.0.1:6379&gt; watch money # 监视money (上锁)OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; DECRBY money 20QUEUED127.0.0.1:6379&gt; INCRBY use 20QUEUED127.0.0.1:6379&gt; exec # 监视值没有被中途修改，事务正常执行1) (integer) 802) (integer) 20\n\n\n测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion）\n\n我们启动另外一个客户端模拟插队线程。\n线程1：\n127.0.0.1:6379&gt; watch money # money上锁OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; DECRBY money 20QUEUED127.0.0.1:6379&gt; INCRBY use 20QUEUED127.0.0.1:6379&gt; \t# 此时事务并没有执行\n\n模拟线程插队，线程2：\n127.0.0.1:6379&gt; INCRBY money 500 # 修改了线程一中监视的money(integer) 60012\n\n回到线程1，执行事务：\n127.0.0.1:6379&gt; EXEC # 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败(nil) # 没有结果，说明事务执行失败127.0.0.1:6379&gt; get money # 线程2 修改生效&quot;600&quot;127.0.0.1:6379&gt; get use # 线程1事务执行失败，数值没有被修改&quot;0&quot;\n\n\n解锁获取最新值，然后再加锁进行事务。\nunwatch进行解锁。\n\n注意：每次提交执行exec后都会自动释放锁，不管是否成功，\n","tags":["Redis"]},{"title":"Redis之五大数据类型","url":"/2022/07/31/Redis%E4%B9%8B%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":" Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。\n\nString （字符串类型）\n\n\nString是redis最基本的类型，你可以理解成Memcached一模一样的类型，一个key对应一个value。 \nString类型是二进制安全的，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象。 \nString类型是redis最基本的数据类型，一个redis中字符串value最多可以是512M。\n\n\nHash（哈希，类似 Java里的Map）\n\n\nRedis hash 是一个键值对集合。 \nRedis hash 是一个String类型的field和value的映射表，hash特别适合用于存储对象。 \n类似Java里面的Map\n\n\nList（列表）\n\n\nRedis列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 \n它的底层实际是个链表 !\n\n\nSet（集合）\n\nRedis的Set是String类型的无序集合，它是通过HashTable实现的 !\n\nZset（sorted set：有序集合）\n\n\nRedis zset 和 set 一样，也是String类型元素的集合，且不允许重复的成员。 \n不同的是每个元素都会关联一个double类型的分数。 \nRedis正是通过分数来为集合中的成员进行从小到大的排序，zset的成员是唯一的，但是分数（Score） 却可以重复。\n\nRedis-key\n在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。\n\n下面学习的命令：\n\nexists key：判断键是否存在\ndel key：删除键值对\nmove key db：将键值对移动到指定数据库\nexpire key second：设置键值对的过期时间\ntype key：查看value的数据类型\n\n127.0.0.1:6379&gt; keys * # 查看当前数据库所有key(empty list or set)127.0.0.1:6379&gt; set name fang # set keyOK127.0.0.1:6379&gt; set age 20OK127.0.0.1:6379&gt; keys *1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; move age 1 # 将键值对移动到指定数据库(integer) 1127.0.0.1:6379&gt; EXISTS age # 判断键是否存在(integer) 0 # 不存在127.0.0.1:6379&gt; EXISTS name(integer) 1 # 存在127.0.0.1:6379&gt; SELECT 1OK127.0.0.1:6379[1]&gt; keys *1) &quot;age&quot;127.0.0.1:6379[1]&gt; del age # 删除键值对(integer) 1 # 删除个数127.0.0.1:6379&gt; set age 20OK127.0.0.1:6379&gt; EXPIRE age 15 # 设置键值对的过期时间(integer) 1 # 设置成功 开始计数127.0.0.1:6379&gt; ttl age # 查看key的过期剩余时间(integer) 13127.0.0.1:6379&gt; ttl age(integer) 11127.0.0.1:6379&gt; ttl age(integer) 9127.0.0.1:6379&gt; ttl age(integer) -2 # -2 表示key过期，-1表示key未设置过期时间127.0.0.1:6379&gt; get age # 过期的key 会被自动delete(nil)127.0.0.1:6379&gt; keys *1) &quot;name&quot;127.0.0.1:6379&gt; type name # 查看value的数据类型string\n\n关于TTL命令\nRedis的key，通过TTL命令返回key的过期时间，一般来说有3种：\n\n当前key没有设置过期时间，所以会返回-1.\n当前key有设置过期时间，而且key已经过期，所以会返回-2.\n当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.\n\n关于重命名RENAME和RENAMENX\n\nRENAME key newkey修改 key 的名称\nRENAMENX key newkey仅当 newkey 不存在时，将 key 改名为 newkey 。\n\n更多命令学习：https://www.redis.net.cn/order/\nString(字符串)普通的set、get直接略过。\n\n\n\n命令\n描述\n示例\n\n\n\nAPPEND key value\n向指定的key的value后追加字符串\n127.0.0.1:6379&gt; set msg hello OK 127.0.0.1:6379&gt; append msg “ world” (integer) 11 127.0.0.1:6379&gt; get msg “hello world”\n\n\nDECR/INCR key\n将指定key的value数值进行+1&#x2F;-1(仅对于数字)\n127.0.0.1:6379&gt; set age 20 OK 127.0.0.1:6379&gt; incr age (integer) 21 127.0.0.1:6379&gt; decr age (integer) 20\n\n\nINCRBY/DECRBY key n\n按指定的步长对数值进行加减\n127.0.0.1:6379&gt; INCRBY age 5 (integer) 25 127.0.0.1:6379&gt; DECRBY age 10 (integer) 15\n\n\nINCRBYFLOAT key n\n为数值加上浮点型数值\n127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 “20.2”\n\n\nSTRLEN key\n获取key保存值的字符串长度\n127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; STRLEN msg (integer) 11\n\n\nGETRANGE key start end\n按起止位置获取字符串（闭区间，起止位置都取）\n127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; GETRANGE msg 3 9 “lo worl”\n\n\nSETRANGE key offset value\n用指定的value 替换key中 offset开始的值\n127.0.0.1:6379&gt; SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379&gt; get msg “tehello”\n\n\nGETSET key value\n将给定 key 的值设为 value ，并返回 key 的旧值(old value)。\n127.0.0.1:6379&gt; GETSET msg test “hello world”\n\n\nSETNX key value\n仅当key不存在时进行set\n127.0.0.1:6379&gt; SETNX msg test (integer) 0 127.0.0.1:6379&gt; SETNX name sakura (integer) 1\n\n\nSETEX key seconds value\nset 键值对并设置过期时间\n127.0.0.1:6379&gt; setex name 10 root OK 127.0.0.1:6379&gt; get name (nil)\n\n\nMSET key1 value1 [key2 value2..]\n批量set键值对\n127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 OK\n\n\nMSETNX key1 value1 [key2 value2..]\n批量设置键值对，仅当参数中所有的key都不存在时执行\n127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4 (integer) 0\n\n\nMGET key1 [key2..]\n批量获取多个key保存的值\n127.0.0.1:6379&gt; MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3”\n\n\nPSETEX key milliseconds value\n和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，\n\n\n\ngetset key value\n如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值\n\n\n\n单值多Value\nset、get、del\nexists（是否存在）、append（追加）、strlen（获取长度）\n127.0.0.1:6379&gt; set key1 value1 # 设置值OK127.0.0.1:6379&gt; get key1 # 获得key&quot;value1&quot;127.0.0.1:6379&gt; del key1 # 删除key(integer) 1127.0.0.1:6379&gt; keys * # 查看全部的key(empty list or set)127.0.0.1:6379&gt; exists key1 # 确保 key1 不存在(integer) 0127.0.0.1:6379&gt; append key1 &quot;hello&quot; # 对不存在的 key进行APPEND，等同于SET key1 &quot;hello&quot;(integer) 5 # 字符长度127.0.0.1:6379&gt; APPEND key1 &quot;-2333&quot; # 对已存在的字符串进行 APPEND(integer) 10 # 长度从 5 个字符增加到 10 个字符127.0.0.1:6379&gt; get key1&quot;hello-2333&quot;127.0.0.1:6379&gt; STRLEN key1 # # 获取字符串的长度(integer) 10\n\nincr、decr 一定要是数字才能进行加减，+1 和 -1。\nincrby、decrby 将 key 中储存的数字加上或减去指定的数量。\n127.0.0.1:6379&gt; set views 0 # 设置浏览量为0OK127.0.0.1:6379&gt; incr views # 浏览 + 1(integer) 1127.0.0.1:6379&gt; incr views # 浏览 + 1(integer) 2127.0.0.1:6379&gt; decr views # 浏览 - 1(integer) 1127.0.0.1:6379&gt; incrby views 10 # +10(integer) 11127.0.0.1:6379&gt; decrby views 10 # -10(integer) 1\n\nrange [范围]\ngetrange 获取指定区间范围内的值，类似between…and的关系，从零到负一表示全部\n127.0.0.1:6379&gt; set key2 abcd123456 # 设置key2的值OK127.0.0.1:6379&gt; getrange key2 0 -1 # 获得全部的值&quot;abcd123456&quot;127.0.0.1:6379&gt; getrange key2 0 2 # 截取部分字符串&quot;abc&quot;\n\nsetrange 设置指定区间范围内的值，格式是setrange key值 具体值\n127.0.0.1:6379&gt; get key2&quot;abcd123456&quot;127.0.0.1:6379&gt; SETRANGE key2 1 xx # 替换值(integer) 10127.0.0.1:6379&gt; get key2&quot;axxd123456&quot;\n\nsetex（set with expire）设置过期时间\nsetnx（set if not exist）如何key存在则不覆盖值，还是原来的值（分布式中常用）\n127.0.0.1:6379&gt; setex key3 60 expire # 设置过期时间OK127.0.0.1:6379&gt; ttl key3 # 查看剩余的时间(integer) 55127.0.0.1:6379&gt; setnx mykey &quot;redis&quot; # 如果不存在就设置，成功返回1(integer) 1127.0.0.1:6379&gt; setnx mykey &quot;mongodb&quot; # 如果值存在则不覆盖值，返回0(integer) 0127.0.0.1:6379&gt; get mykey&quot;redis&quot;\n\nmset：同时设置一个或多个 key-value 对。\nmget：返回所有(一个或多个) key 的值。 如果给定的 key 里面，有某个 key 不存在，则此 key 返回特殊值nil\nmsetnx：当所有 key 都成功设置，返回 1 。如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。相当于原子性操作，要么都成功，要么都不成功。\n127.0.0.1:6379&gt; mset k10 v10 k11 v11 k12 v12OK127.0.0.1:6379&gt; keys *1) &quot;k12&quot;2) &quot;k11&quot;3) &quot;k10&quot;127.0.0.1:6379&gt; mget k10 k11 k12 k131) &quot;v10&quot;2) &quot;v11&quot;3) &quot;v12&quot;4) (nil)127.0.0.1:6379&gt; msetnx k10 v10 k15 v15 # 原子性操作！(integer) 0127.0.0.1:6379&gt; get key15(nil)\n\n存储对象：\nset user:1 value（json数据）\n127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2OK127.0.0.1:6379&gt; mget user:1:name user:1:age1) &quot;zhangsan&quot;2) &quot;2&quot;\n\ngetset：先get再set\n127.0.0.1:6379&gt; getset db mongodb # 没有旧值，返回 nil(nil)127.0.0.1:6379&gt; get db&quot;mongodb&quot;127.0.0.1:6379&gt; getset db redis # 返回旧值 mongodb&quot;mongodb&quot;127.0.0.1:6379&gt; get db&quot;redis&quot;\n\nString数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。\n常规计数：微博数，粉丝数等。\nString类似的使用场景：value除了是字符串还可以是数字，用途举例：\n\n计数器\n统计多单位的数量：uid:123666：follow 0\n粉丝数\n对象存储缓存\n\nList(列表)\nRedis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）\n一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。\n\n首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等\n\n正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN\n\n\n\n命令\n描述\n\n\n\nLPUSH/RPUSH key value1[value2..]\n从左边&#x2F;右边向列表中PUSH值(一个或者多个)。\n\n\nLRANGE key start end\n获取list 起止元素&#x3D;&#x3D;（索引从左往右 递增）&#x3D;&#x3D;\n\n\nLPUSHX/RPUSHX key value\n向已存在的列名中push值（一个或者多个）\n\n\n&#96;LINSERT key BEFORE\nAFTER pivot value&#96;\n\n\nLLEN key\n查看列表长度\n\n\nLINDEX key index\n通过索引获取列表元素\n\n\nLSET key index value\n通过索引为元素设值\n\n\nLPOP/RPOP key\n从最左边&#x2F;最右边移除值 并返回\n\n\nRPOPLPUSH source destination\n将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部\n\n\nLTRIM key start end\n通过下标截取指定范围内的列表\n\n\nLREM key count value\nList中是允许value重复的 count &gt; 0：从头部开始搜索 然后删除指定的value 至多删除count个 count &lt; 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。\n\n\nBLPOP/BRPOP key1[key2] timout\n移出并获取列表的第一个&#x2F;最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n\n\nBRPOPLPUSH source destination timeout\n和RPOPLPUSH功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n\n\n---------------------------LPUSH---RPUSH---LRANGE--------------------------------127.0.0.1:6379&gt; LPUSH mylist k1 # LPUSH mylist=&gt;&#123;1&#125;(integer) 1127.0.0.1:6379&gt; LPUSH mylist k2 # LPUSH mylist=&gt;&#123;2,1&#125;(integer) 2127.0.0.1:6379&gt; RPUSH mylist k3 # RPUSH mylist=&gt;&#123;2,1,3&#125;(integer) 3127.0.0.1:6379&gt; get mylist # 普通的get是无法获取list值的(error) WRONGTYPE Operation against a key holding the wrong kind of value127.0.0.1:6379&gt; LRANGE mylist 0 4 # LRANGE 获取起止位置范围内的元素1) &quot;k2&quot;2) &quot;k1&quot;3) &quot;k3&quot;127.0.0.1:6379&gt; LRANGE mylist 0 21) &quot;k2&quot;2) &quot;k1&quot;3) &quot;k3&quot;127.0.0.1:6379&gt; LRANGE mylist 0 11) &quot;k2&quot;2) &quot;k1&quot;127.0.0.1:6379&gt; LRANGE mylist 0 -1 # 获取全部元素1) &quot;k2&quot;2) &quot;k1&quot;3) &quot;k3&quot;---------------------------LPUSHX---RPUSHX-----------------------------------127.0.0.1:6379&gt; LPUSHX list v1 # list不存在 LPUSHX失败(integer) 0127.0.0.1:6379&gt; LPUSHX list v1 v2  (integer) 0127.0.0.1:6379&gt; LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5(integer) 5127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;k5&quot;2) &quot;k4&quot;3) &quot;k2&quot;4) &quot;k1&quot;5) &quot;k3&quot;---------------------------LINSERT--LLEN--LINDEX--LSET----------------------------127.0.0.1:6379&gt; LINSERT mylist after k2 ins_key1 # 在k2元素后 插入ins_key1(integer) 6127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;k5&quot;2) &quot;k4&quot;3) &quot;k2&quot;4) &quot;ins_key1&quot;5) &quot;k1&quot;6) &quot;k3&quot;127.0.0.1:6379&gt; LLEN mylist # 查看mylist的长度(integer) 6127.0.0.1:6379&gt; LINDEX mylist 3 # 获取下标为3的元素&quot;ins_key1&quot;127.0.0.1:6379&gt; LINDEX mylist 0&quot;k5&quot;127.0.0.1:6379&gt; LSET mylist 3 k6 # 将下标3的元素 set值为k6OK127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;k5&quot;2) &quot;k4&quot;3) &quot;k2&quot;4) &quot;k6&quot;5) &quot;k1&quot;6) &quot;k3&quot;---------------------------LPOP--RPOP--------------------------127.0.0.1:6379&gt; LPOP mylist # 左侧(头部)弹出&quot;k5&quot;127.0.0.1:6379&gt; RPOP mylist # 右侧(尾部)弹出&quot;k3&quot;---------------------------RPOPLPUSH--------------------------127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;k4&quot;2) &quot;k2&quot;3) &quot;k6&quot;4) &quot;k1&quot;127.0.0.1:6379&gt; RPOPLPUSH mylist newlist # 将mylist的最后一个值(k1)弹出，加入到newlist的头部&quot;k1&quot;127.0.0.1:6379&gt; LRANGE newlist 0 -11) &quot;k1&quot;127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;k4&quot;2) &quot;k2&quot;3) &quot;k6&quot;---------------------------LTRIM--------------------------127.0.0.1:6379&gt; LTRIM mylist 0 1 # 截取mylist中的 0~1部分OK127.0.0.1:6379&gt; LRANGE mylist 0 -11) &quot;k4&quot;2) &quot;k2&quot;# 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2---------------------------LREM--------------------------127.0.0.1:6379&gt; LREM mylist 3 k2 # 从头部开始搜索 至多删除3个 k2(integer) 3# 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2127.0.0.1:6379&gt; LREM mylist -2 k2 #从尾部开始搜索 至多删除2个 k2(integer) 2# 删除后：mylist: k2,k2,k2,k4,k2,k2---------------------------BLPOP--BRPOP--------------------------mylist: k2,k2,k2,k4,k2,k2newlist: k1127.0.0.1:6379&gt; BLPOP newlist mylist 30 # 从newlist中弹出第一个值，mylist作为候选1) &quot;newlist&quot; # 弹出2) &quot;k1&quot;127.0.0.1:6379&gt; BLPOP newlist mylist 301) &quot;mylist&quot; # 由于newlist空了 从mylist中弹出2) &quot;k2&quot;127.0.0.1:6379&gt; BLPOP newlist 30(30.10s) # 超时了127.0.0.1:6379&gt; BLPOP newlist 30 # 我们连接另一个客户端向newlist中push了test, 阻塞被解决。1) &quot;newlist&quot;2) &quot;test&quot;(12.54s)\n\n\n小结\n\n\nlist实际上是一个链表，before Node after , left, right 都可以插入值\n如果key不存在，则创建新的链表\n如果key存在，新增内容\n如果移除了所有值，空链表，也代表不存在\n在两边插入或者改动值，效率最高！修改中间元素，效率相对较低\n\n应用：\n消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop）\nSet(集合)\nRedis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。\nRedis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。\n集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\n\n\n\n\n命令\n描述\n\n\n\nSADD key member1[member2..]\n向集合中无序增加一个&#x2F;多个成员\n\n\nSCARD key\n获取集合的成员数\n\n\nSMEMBERS key\n返回集合中所有的成员\n\n\nSISMEMBER key member\n查询member元素是否是集合的成员,结果是无序的\n\n\nSRANDMEMBER key [count]\n随机返回集合中count个成员，count缺省值为1\n\n\nSPOP key [count]\n随机移除并返回集合中count个成员，count缺省值为1\n\n\nSMOVE source destination member\n将source集合的成员member移动到destination集合\n\n\nSREM key member1[member2..]\n移除集合中一个&#x2F;多个成员\n\n\nSDIFF key1[key2..]\n返回所有集合的差集 key1- key2 - …\n\n\nSDIFFSTORE destination key1[key2..]\n在SDIFF的基础上，将结果保存到集合中&#x3D;&#x3D;(覆盖)&#x3D;&#x3D;。不能保存到其他类型key噢！\n\n\nSINTER key1 [key2..]\n返回所有集合的交集\n\n\nSINTERSTORE destination key1[key2..]\n在SINTER的基础上，存储结果到集合中。覆盖\n\n\nSUNION key1 [key2..]\n返回所有集合的并集\n\n\nSUNIONSTORE destination key1 [key2..]\n在SUNION的基础上，存储结果到及和张。覆盖\n\n\nSSCAN KEY [MATCH pattern] [COUNT count]\n在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分\n\n\n---------------SADD--SCARD--SMEMBERS--SISMEMBER--------------------127.0.0.1:6379&gt; SADD myset m1 m2 m3 m4 # 向myset中增加成员 m1~m4(integer) 4127.0.0.1:6379&gt; SCARD myset # 获取集合的成员数目(integer) 4127.0.0.1:6379&gt; smembers myset # 获取集合中所有成员1) &quot;m4&quot;2) &quot;m3&quot;3) &quot;m2&quot;4) &quot;m1&quot;127.0.0.1:6379&gt; SISMEMBER myset m5 # 查询m5是否是myset的成员(integer) 0 # 不是，返回0127.0.0.1:6379&gt; SISMEMBER myset m2(integer) 1 # 是，返回1127.0.0.1:6379&gt; SISMEMBER myset m3(integer) 1---------------------SRANDMEMBER--SPOP----------------------------------127.0.0.1:6379&gt; SRANDMEMBER myset 3 # 随机返回3个成员1) &quot;m2&quot;2) &quot;m3&quot;3) &quot;m4&quot;127.0.0.1:6379&gt; SRANDMEMBER myset # 随机返回1个成员&quot;m3&quot;127.0.0.1:6379&gt; SPOP myset 2 # 随机移除并返回2个成员1) &quot;m1&quot;2) &quot;m4&quot;# 将set还原到&#123;m1,m2,m3,m4&#125;---------------------SMOVE--SREM----------------------------------------127.0.0.1:6379&gt; SMOVE myset newset m3 # 将myset中m3成员移动到newset集合(integer) 1127.0.0.1:6379&gt; SMEMBERS myset1) &quot;m4&quot;2) &quot;m2&quot;3) &quot;m1&quot;127.0.0.1:6379&gt; SMEMBERS newset1) &quot;m3&quot;127.0.0.1:6379&gt; SREM newset m3 # 从newset中移除m3元素(integer) 1127.0.0.1:6379&gt; SMEMBERS newset(empty list or set)# 下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算# setx=&gt;&#123;m1,m2,m4,m6&#125;, sety=&gt;&#123;m2,m5,m6&#125;, setz=&gt;&#123;m1,m3,m6&#125;-----------------------------SDIFF------------------------------------127.0.0.1:6379&gt; SDIFF setx sety setz # 等价于setx-sety-setz1) &quot;m4&quot;127.0.0.1:6379&gt; SDIFF setx sety # setx - sety1) &quot;m4&quot;2) &quot;m1&quot;127.0.0.1:6379&gt; SDIFF sety setx # sety - setx1) &quot;m5&quot;-------------------------SINTER---------------------------------------# 共同关注（交集）127.0.0.1:6379&gt; SINTER setx sety setz # 求 setx、sety、setx的交集1) &quot;m6&quot;127.0.0.1:6379&gt; SINTER setx sety # 求setx sety的交集1) &quot;m2&quot;2) &quot;m6&quot;-------------------------SUNION---------------------------------------127.0.0.1:6379&gt; SUNION setx sety setz # setx sety setz的并集1) &quot;m4&quot;2) &quot;m6&quot;3) &quot;m3&quot;4) &quot;m2&quot;5) &quot;m1&quot;6) &quot;m5&quot;127.0.0.1:6379&gt; SUNION setx sety # setx sety 并集1) &quot;m4&quot;2) &quot;m6&quot;3) &quot;m2&quot;4) &quot;m1&quot;5) &quot;m5&quot;\n\n在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。\nHash（哈希）\nRedis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。\nSet就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。\n\n\n\n\n命令\n描述\n\n\n\nHSET key field value\n将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0\n\n\nHMSET key field1 value1 [field2 value2..]\n同时将多个 field-value (域-值)对设置到哈希表 key 中。\n\n\nHSETNX key field value\n只有在字段 field 不存在时，设置哈希表字段的值。\n\n\nHEXISTS key field\n查看哈希表 key 中，指定的字段是否存在。\n\n\nHGET key field value\n获取存储在哈希表中指定字段的值\n\n\nHMGET key field1 [field2..]\n获取所有给定字段的值\n\n\nHGETALL key\n获取在哈希表key 的所有字段和值\n\n\nHKEYS key\n获取哈希表key中所有的字段\n\n\nHLEN key\n获取哈希表中字段的数量\n\n\nHVALS key\n获取哈希表中所有值\n\n\nHDEL key field1 [field2..]\n删除哈希表key中一个&#x2F;多个field字段\n\n\nHINCRBY key field n\n为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段\n\n\nHINCRBYFLOAT key field n\n为哈希表 key 中的指定字段的浮点数值加上增量 n。\n\n\nHSCAN key cursor [MATCH pattern] [COUNT count]\n迭代哈希表中的键值对。\n\n\n------------------------HSET--HMSET--HSETNX----------------127.0.0.1:6379&gt; HSET studentx name sakura # 将studentx哈希表作为一个对象，设置name为sakura(integer) 1127.0.0.1:6379&gt; HSET studentx name gyc # 重复设置field进行覆盖，并返回0(integer) 0127.0.0.1:6379&gt; HSET studentx age 20 # 设置studentx的age为20(integer) 1127.0.0.1:6379&gt; HMSET studentx sex 1 tel 15623667886 # 设置sex为1，tel为15623667886OK127.0.0.1:6379&gt; HSETNX studentx name gyc # HSETNX 设置已存在的field(integer) 0 # 失败127.0.0.1:6379&gt; HSETNX studentx email 12345@qq.com(integer) 1 # 成功----------------------HEXISTS--------------------------------127.0.0.1:6379&gt; HEXISTS studentx name # name字段在studentx中是否存在(integer) 1 # 存在127.0.0.1:6379&gt; HEXISTS studentx addr(integer) 0 # 不存在-------------------HGET--HMGET--HGETALL-----------127.0.0.1:6379&gt; HGET studentx name # 获取studentx中name字段的value&quot;gyc&quot;127.0.0.1:6379&gt; HMGET studentx name age tel # 获取studentx中name、age、tel字段的value1) &quot;gyc&quot;2) &quot;20&quot;3) &quot;15623667886&quot;127.0.0.1:6379&gt; HGETALL studentx # 获取studentx中所有的field及其value 1) &quot;name&quot; 2) &quot;gyc&quot; 3) &quot;age&quot; 4) &quot;20&quot; 5) &quot;sex&quot; 6) &quot;1&quot; 7) &quot;tel&quot; 8) &quot;15623667886&quot; 9) &quot;email&quot;10) &quot;12345@qq.com&quot;--------------------HKEYS--HLEN--HVALS--------------127.0.0.1:6379&gt; HKEYS studentx # 查看studentx中所有的field1) &quot;name&quot;2) &quot;age&quot;3) &quot;sex&quot;4) &quot;tel&quot;5) &quot;email&quot;127.0.0.1:6379&gt; HLEN studentx # 查看studentx中的字段数量(integer) 5127.0.0.1:6379&gt; HVALS studentx # 查看studentx中所有的value1) &quot;gyc&quot;2) &quot;20&quot;3) &quot;1&quot;4) &quot;15623667886&quot;5) &quot;12345@qq.com&quot;-------------------------HDEL--------------------------127.0.0.1:6379&gt; HDEL studentx sex tel # 删除studentx 中的sex、tel字段(integer) 2127.0.0.1:6379&gt; HKEYS studentx1) &quot;name&quot;2) &quot;age&quot;3) &quot;email&quot;-------------HINCRBY--HINCRBYFLOAT------------------------127.0.0.1:6379&gt; HINCRBY studentx age 1 # studentx的age字段数值+1(integer) 21127.0.0.1:6379&gt; HINCRBY studentx name 1 # 非整数字型字段不可用(error) ERR hash value is not an integer127.0.0.1:6379&gt; HINCRBYFLOAT studentx weight 0.6 # weight字段增加0.6&quot;90.8&quot;\n\n Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！Hash更适合于对象的存储，Sring更加适合字符串存储！\nZset（有序集合）\n不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。\nscore相同：按字典顺序排序\n有序集合的成员是唯一的,但分数(score)却可以重复。\n\n\n\n\n命令\n描述\n\n\n\nZADD key score member1 [score2 member2]\n向有序集合添加一个或多个成员，或者更新已存在成员的分数\n\n\nZCARD key\n获取有序集合的成员数\n\n\nZCOUNT key min max\n计算在有序集合中指定区间score的成员数\n\n\nZINCRBY key n member\n有序集合中对指定成员的分数加上增量 n\n\n\nZSCORE key member\n返回有序集中，成员的分数值\n\n\nZRANK key member\n返回有序集合中指定成员的索引\n\n\nZRANGE key start end\n通过索引区间返回有序集合成指定区间内的成员\n\n\nZRANGEBYLEX key min max\n通过字典区间返回有序集合的成员\n\n\nZRANGEBYSCORE key min max\n通过分数返回有序集合指定区间内的成员&#x3D;&#x3D;-inf 和 +inf分别表示最小最大值，只支持开区间()&#x3D;&#x3D;\n\n\nZLEXCOUNT key min max\n在有序集合中计算指定字典区间内成员数量\n\n\nZREM key member1 [member2..]\n移除有序集合中一个&#x2F;多个成员\n\n\nZREMRANGEBYLEX key min max\n移除有序集合中给定的字典区间的所有成员\n\n\nZREMRANGEBYRANK key start stop\n移除有序集合中给定的排名区间的所有成员\n\n\nZREMRANGEBYSCORE key min max\n移除有序集合中给定的分数区间的所有成员\n\n\nZREVRANGE key start end\n返回有序集中指定区间内的成员，通过索引，分数从高到底\n\n\nZREVRANGEBYSCORRE key max min\n返回有序集中指定分数区间内的成员，分数从高到低排序\n\n\nZREVRANGEBYLEX key max min\n返回有序集中指定字典区间内的成员，按字典顺序倒序\n\n\nZREVRANK key member\n返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序\n\n\nZINTERSTORE destination numkeys key1 [key2 ..]\n计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score\n\n\nZUNIONSTORE destination numkeys key1 [key2..]\n计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中\n\n\nZSCAN key cursor [MATCH pattern\\] [COUNT count]\n迭代有序集合中的元素（包括元素成员和元素分值）\n\n\n-------------------ZADD--ZCARD--ZCOUNT--------------127.0.0.1:6379&gt; ZADD myzset 1 m1 2 m2 3 m3 # 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2..(integer) 2127.0.0.1:6379&gt; ZCARD myzset # 获取有序集合的成员数(integer) 2127.0.0.1:6379&gt; ZCOUNT myzset 0 1 # 获取score在 [0,1]区间的成员数量(integer) 1127.0.0.1:6379&gt; ZCOUNT myzset 0 2(integer) 2----------------ZINCRBY--ZSCORE--------------------------127.0.0.1:6379&gt; ZINCRBY myzset 5 m2 # 将成员m2的score +5&quot;7&quot;127.0.0.1:6379&gt; ZSCORE myzset m1 # 获取成员m1的score&quot;1&quot;127.0.0.1:6379&gt; ZSCORE myzset m2&quot;7&quot;--------------ZRANK--ZRANGE-----------------------------------127.0.0.1:6379&gt; ZRANK myzset m1 # 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加(integer) 0127.0.0.1:6379&gt; ZRANK myzset m2(integer) 2127.0.0.1:6379&gt; ZRANGE myzset 0 1 # 获取索引在 0~1的成员1) &quot;m1&quot;2) &quot;m3&quot;127.0.0.1:6379&gt; ZRANGE myzset 0 -1 # 获取全部成员1) &quot;m1&quot;2) &quot;m3&quot;3) &quot;m2&quot;#testset=&gt;&#123;abc,add,amaze,apple,back,java,redis&#125; score均为0------------------ZRANGEBYLEX---------------------------------127.0.0.1:6379&gt; ZRANGEBYLEX testset - + # 返回所有成员1) &quot;abc&quot;2) &quot;add&quot;3) &quot;amaze&quot;4) &quot;apple&quot;5) &quot;back&quot;6) &quot;java&quot;7) &quot;redis&quot;127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 0 3 # 分页 按索引显示查询结果的 0,1,2条记录1) &quot;abc&quot;2) &quot;add&quot;3) &quot;amaze&quot;127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 3 3 # 显示 3,4,5条记录1) &quot;apple&quot;2) &quot;back&quot;3) &quot;java&quot;127.0.0.1:6379&gt; ZRANGEBYLEX testset (- [apple # 显示 (-,apple] 区间内的成员1) &quot;abc&quot;2) &quot;add&quot;3) &quot;amaze&quot;4) &quot;apple&quot;127.0.0.1:6379&gt; ZRANGEBYLEX testset [apple [java # 显示 [apple,java]字典区间的成员1) &quot;apple&quot;2) &quot;back&quot;3) &quot;java&quot;-----------------------ZRANGEBYSCORE---------------------127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 10 # 返回score在 [1,10]之间的的成员1) &quot;m1&quot;2) &quot;m3&quot;3) &quot;m2&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 51) &quot;m1&quot;2) &quot;m3&quot;--------------------ZLEXCOUNT-----------------------------127.0.0.1:6379&gt; ZLEXCOUNT testset - +(integer) 7127.0.0.1:6379&gt; ZLEXCOUNT testset [apple [java(integer) 3------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE--------------------------------127.0.0.1:6379&gt; ZREM testset abc # 移除成员abc(integer) 1127.0.0.1:6379&gt; ZREMRANGEBYLEX testset [apple [java # 移除字典区间[apple,java]中的所有成员(integer) 3127.0.0.1:6379&gt; ZREMRANGEBYRANK testset 0 1 # 移除排名0~1的所有成员(integer) 2127.0.0.1:6379&gt; ZREMRANGEBYSCORE myzset 0 3 # 移除score在 [0,3]的成员(integer) 2# testset=&gt; &#123;abc,add,apple,amaze,back,java,redis&#125; score均为0# myzset=&gt; &#123;(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)&#125;----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX-----------127.0.0.1:6379&gt; ZREVRANGE myzset 0 3 # 按score递减排序，然后按索引，返回结果的 0~31) &quot;m9&quot;2) &quot;m7&quot;3) &quot;m4&quot;4) &quot;m3&quot;127.0.0.1:6379&gt; ZREVRANGE myzset 2 4 # 返回排序结果的 索引的2~41) &quot;m4&quot;2) &quot;m3&quot;3) &quot;m2&quot;127.0.0.1:6379&gt; ZREVRANGEBYSCORE myzset 6 2 # 按score递减顺序 返回集合中分数在[2,6]之间的成员1) &quot;m4&quot;2) &quot;m3&quot;3) &quot;m2&quot;127.0.0.1:6379&gt; ZREVRANGEBYLEX testset [java (add # 按字典倒序 返回集合中(add,java]字典区间的成员1) &quot;java&quot;2) &quot;back&quot;3) &quot;apple&quot;4) &quot;amaze&quot;-------------------------ZREVRANK------------------------------127.0.0.1:6379&gt; ZREVRANK myzset m7 # 按score递减顺序，返回成员m7索引(integer) 1127.0.0.1:6379&gt; ZREVRANK myzset m2(integer) 4# mathscore=&gt;&#123;(xm,90),(xh,95),(xg,87)&#125; 小明、小红、小刚的数学成绩# enscore=&gt;&#123;(xm,70),(xh,93),(xg,90)&#125; 小明、小红、小刚的英语成绩-------------------ZINTERSTORE--ZUNIONSTORE-----------------------------------127.0.0.1:6379&gt; ZINTERSTORE sumscore 2 mathscore enscore # 将mathscore enscore进行合并 结果存放到sumscore(integer) 3127.0.0.1:6379&gt; ZRANGE sumscore 0 -1 withscores # 合并后的score是之前集合中所有score的和1) &quot;xm&quot;2) &quot;160&quot;3) &quot;xg&quot;4) &quot;177&quot;5) &quot;xh&quot;6) &quot;188&quot;127.0.0.1:6379&gt; ZUNIONSTORE lowestscore 2 mathscore enscore AGGREGATE MIN # 取两个集合的成员score最小值作为结果的(integer) 3127.0.0.1:6379&gt; ZRANGE lowestscore 0 -1 withscores1) &quot;xm&quot;2) &quot;70&quot;3) &quot;xg&quot;4) &quot;87&quot;5) &quot;xh&quot;6) &quot;93&quot;\n\n和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如 一个存储全班同学成绩的sorted set，其集合value可以是同学的学号，而score就可以是其考试得分， 这样在数据插入集合的时候，就已经进行了天然的排序。可以用sorted set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让 重要的任务优先执行。\n应用案例：\n\nset排序 存储班级成绩表 工资表排序！\n普通消息，1.重要消息 2.带权重进行判断\n排行榜应用实现，取Top N测试\n\n","tags":["Redis"]},{"title":"Redis之概念和基础","url":"/2022/07/31/Redis%E4%B9%8B%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E7%A1%80/","content":"一、Nosql概述为什么使用Nosql\n1、单机Mysql时代\n\n\n90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题\n\n数据量增加到一定程度，单机数据库就放不下了\n数据的索引（B+ Tree）,一个机器内存也存放不下\n访问量变大后（读写混合），一台服务器承受不住。\n\n\n2、Memcached(缓存) + Mysql + 垂直拆分（读写分离）\n\n网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！\n\n优化过程经历了以下几个过程：\n\n优化数据库的数据结构和索引(难度大)\n文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了\nMemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。\n\n\n3、分库分表 + 水平拆分 + Mysql集群\n\n\n\n4、如今最近的年代\n\n 如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。\n\n目前一个基本的互联网项目\n\n\n\n为什么要用NoSQL ？\n\n用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！\n什么是NosqlNoSQL &#x3D; Not Only SQL（不仅仅是SQL）\nNot Only Structured Query Language\n关系型数据库：列+行，同一个表下数据的结构是一样的。\n非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。\nNoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。\nNosql特点\n方便扩展（数据之间没有关系，很好扩展！）\n\n大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）\n\n数据类型是多样型的！（不需要事先设计数据库，随取随用）\n\n传统的 RDBMS 和 NoSQL\n传统的 RDBMS(关系型数据库)- 结构化组织- SQL- 数据和关系都存在单独的表中 row col- 操作，数据定义语言- 严格的一致性- 基础的事务- ...\n\nNosql- 不仅仅是数据- 没有固定的查询语言- 键值对存储，列存储，文档存储，图形数据库（社交关系）- 最终一致性- CAP定理和BASE- 高性能，高可用，高扩展- ...\n\n\n了解：3V + 3高\n\n大数据时代的3V ：主要是描述问题的\n\n海量Velume\n多样Variety\n实时Velocity\n\n大数据时代的3高 ： 主要是对程序的要求\n\n高并发\n高可扩\n高性能\n\n真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。\n阿里巴巴演进分析推荐阅读：阿里云的这群疯子https://yq.aliyun.com/articles/653511\n\n\n# 商品信息- 一般存放在关系型数据库：Mysql,阿里巴巴使用的Mysql都是经过内部改动的。# 商品描述、评论(文字居多)- 文档型数据库：MongoDB# 图片- 分布式文件系统 FastDFS- 淘宝：TFS- Google: GFS- Hadoop: HDFS- 阿里云: oss# 商品关键字 用于搜索- 搜索引擎：solr,elasticsearch- 阿里：Isearch 多隆# 商品热门的波段信息- 内存数据库：Redis，Memcache# 商品交易，外部支付接口- 第三方应用\n\nNoSQL数据模型简介\n案例设计\n\n&#x3D;&#x3D;以一个电商客户，订单，订购，地址模型来对比下关系型数据库和非关系型数据库&#x3D;&#x3D; \n传统的关系型数据库你如何设计？ \nER图（1:1&#x2F;1:N&#x2F;N:N,主外键等常见） \n\n用户对应多个订单多个地址 \n每个订单对应每个商品、价格、地址 \n每个商品对应产品\n\n\n\nNoSQL你如何设计\n\n可以尝试使用BSON。 \nBSON是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档 对象和数组对象 \n用BSon画出构建的数据模型\n&#123;    &quot;customer&quot;:&#123;        &quot;id&quot;:1000,        &quot;name&quot;:&quot;Z3&quot;,        &quot;billingAddress&quot;:[&#123;&quot;city&quot;:&quot;beijing&quot;&#125;],        &quot;orders&quot;:[            &#123;                &quot;id&quot;:17,                &quot;customerId&quot;:1000,                &quot;orderItems&quot;:[&#123;&quot;productId&quot;:27,&quot;price&quot;:77.5,&quot;productName&quot;:&quot;thinking in java&quot;&#125;],                &quot;shippingAddress&quot;:[&#123;&quot;city&quot;:&quot;beijing&quot;&#125;]                &quot;orderPayment&quot;:[&#123;&quot;ccinfo&quot;:&quot;111-222-                333&quot;,&quot;txnid&quot;:&quot;asdfadcd334&quot;,&quot;billingAddress&quot;:&#123;&quot;city&quot;:&quot;beijing&quot;&#125;&#125;],            &#125;        ]    &#125;&#125;\n\n想想关系模型数据库你如何查？如果按照我们新设计的BSon，是不是查询起来很简单。 \n\n高并发的操作是不太建议有关联查询的，互联网公司用冗余数据来避免关联查询 \n分布式事务是支持不了太多的并发的\n\nNosql的四大分类\nKV键值对\n\n\n新浪：Redis\n美团：Redis + Tair\n阿里、百度：Redis + Memcache\n\n\n文档型数据库（bson数据格式）：\n\n\nMongoDB(掌握)\n基于分布式文件存储的数据库。C++编写，用于处理大量文档。\nMongoDB是RDBMS和NoSQL的中间产品。MongoDB是非关系型数据库中功能最丰富的，NoSQL中最像关系型数据库的数据库。\n\n\nConthDB\n\n\n列存储数据库\n\n\nHBase(大数据必学)\n分布式文件系统\n\n\n图关系数据库\n\n\n它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统 \n\n社交网络，推荐系统等。专注于构建关系图谱 \n\nNeo4J, InfoGrid\n\nNeo4j、InfoGrid\n\n\n\n四者对比\n\n\n\n\n分类\nExamples举例\n典型应用场景\n数据模型\n优点\n缺点\n\n\n\n键值对（key-value）\nTokyo Cabinet&#x2F;Tyrant, Redis, Voldemort, Oracle BDB\n内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。\nKey 指向 Value 的键值对，通常用hash table来实现\n查找速度快\n数据无结构化，通常只被当作字符串或者二进制数据\n\n\n列存储数据库\nCassandra, HBase, Riak\n分布式的文件系统\n以列簇式存储，将同一列数据存在一起\n查找速度快，可扩展性强，更容易进行分布式扩展\n功能相对局限\n\n\n文档型数据库\nCouchDB, MongoDb\nWeb应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）\nKey-Value对应的键值对，Value为结构化数据\n数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构\n查询性能不高，而且缺乏统一的查询语法。\n\n\n图形(Graph)数据库\nNeo4J, InfoGrid, Infinite Graph\n社交网络，推荐系统等。专注于构建关系图谱\n图结构\n利用图结构相关算法。比如最短路径寻址，N度关系查找等\n很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群\n\n\nCAP + BASE\n传统的ACID分别是什么？\n\n关系型数据库遵循ACID规则，事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个 特性： \n\nA (Atomicity) 原子性\n\n原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。\n\n\nC (Consistency) 一致性\n\n事务前后数据的完整性必须保持一致。\n\n\nI (Isolation) 隔离性\n\n所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，所访问的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的\n\n\nD (Durability) 持久性\n\n持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失\n\n\nCAP（三进二）\n\n\nC : Consistency（强一致性） \nA : Availability（可用性） \nP : Partition tolerance（分区容错性）\n\nCAP理论就是说在分布式存储系统中，最多只能实现上面的两点。 \n\n而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容错性是我们必须需要实现的。 \n所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。\n注意：分布式架构的时候必须做出取舍。 \n一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。 \n因此牺牲C换取P，这是目前分布式数据库产品的方向\n\n一致性与可用性的决择 \n\n对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地\n\n数据库事务一致性需求 \n\n很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不高。允许实现最终一致性。\n\n数据库的写实时性和读实时性需求\n\n对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应 用来说，并不要求这么高的实时性，比方说发一条消息之后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。\n\n对复杂的SQL查询，特别是多表关联查询的需求 \n\n任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是SNS类型的网站，从需求以及产品设计角度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。\n\nCAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求， 最多只能同时较好的满足两个。因此，根据 CAP 原理将 NoSQL 数据库分成了满足CA 原则、满足 CP 原则和满足 AP 原则三大类： \n\nCA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。 \nCP - 满足一致性，分区容忍性的系统，通常性能不是特别高。 \nAP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。\n\n\n\nBASE 理论\n\nBASE理论是由eBay架构师提出的。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结，是基于CAP定律逐步演化而来。其核心思想是即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 \nBASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。 \nBASE其实是下面三个术语的缩写： \n\n基本可用(Basically Available)： 基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服 务层也可能只提供降级服务。这就是损失部分可用性的体现。 \n软状态(Soft State)： 软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的 体现。MySQL Replication 的异步复制也是一种体现。 \n最终一致性(Eventual Consistency)： 最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。\n\n它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法！ \n解释：\n\n分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc通信和调用，对外提供服务和组内协作。 \n集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。\n\n二、Redis入门概述\nRedis是什么？\n\nRedis（Remote Dictionary Server )，即远程字典服务。\n是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。\n\nRedis能该干什么？\n\n\n内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）\n高效率、用于高速缓冲\n发布订阅系统\n地图信息分析\n计时器、计数器(eg：浏览量)\n。。。\n\n\n特性\n\n\n多样的数据类型\n\n持久化\n\n集群\n\n事务\n…\n\n\n环境搭建官网：https://redis.io/\n推荐使用Linux服务器学习。\nwindows版本的Redis已经停更很久了…\nWindows安装https://github.com/dmajkic/redis\n\n解压安装包\n\n\n\n开启redis-server.exe\n\n\n\n启动redis-cli.exe测试\n\n\n&#x3D;&#x3D;重要提示&#x3D;&#x3D;\n由于企业里面做Redis开发，99%都是Linux版的运用和安装，几乎不会涉及到Windows版，上一步的讲解只是为了知识的完整性，Windows版不作为重点，大家可以自己玩，企业实战就认一个版：Linux版 http://www.redis.cn/topics/introduction\n\nLinux安装下载地址 http://download.redis.io/releases/redis-5.0.7.tar.gz\n\n\n安装步骤\n\n1、下载获得 redis-5.0.7.tar.gz 后将它放到我们Linux的目录下 &#x2F;opt2、&#x2F;opt 目录下，解压命令 ： tar -zxvf redis-5.0.7.tar.gz3、解压完成后出现文件夹：redis-5.0.74、进入目录： cd redis-5.0.75、在 redis-5.0.7 目录下执行 make 命令\n运行make命令时故意出现的错误解析：1.  安装gcc (gcc是linux下的一个编译程序，是c程序的编译工具)     能上网: yum install gcc-c++     版本测试: gcc-v2. 二次make3. Jemalloc/jemalloc.h: 没有那个文件或目录    运行 make distclean 之后再make4. Redis Test（可以不用执行）\n\n6、如果make完成后继续执行 make install \n7、查看默认安装目录：usr&#x2F;local&#x2F;bin\n/usr 这是一个非常重要的目录，类似于windows下的Program Files,存放用户的程序\n\n8、拷贝配置文件（备用）\ncd /usr/local/binls -l# 在redis的解压目录下备份redis.confmkdir myrediscp redis.conf myredis # 拷一个备份，养成良好的习惯，我们就修改这个文件# 修改配置保证可以后台应用vim redis.conf\n\n\n\nA、redis.conf配置文件中daemonize守护线程，默认是NO。\nB、daemonize是用来指定redis是否要用守护线程的方式启动。\n\ndaemonize 设置yes或者no区别 \n\ndaemonize:yes \nredis采用的是单进程多线程的模式。当redis.conf中选项daemonize设置成yes时，代表开启守护进程模式。在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。\n\n\ndaemonize:no \n当daemonize选项设置成no时，当前界面将进入redis的命令行界面，exit强制退出或者关闭连接工具(putty,xshell等)都会导致redis进程退出。\n\n\n\n9、启动测试一下！\n# 【shell】启动redis服务[root@192 bin]# cd /usr/local/bin[root@192 bin]# redis-server /opt/redis-5.0.7/redis.conf# redis客户端连接===&gt; 观察地址的变化，如果连接ok,是直接连上的，redis默认端口号 6379[root@192 bin]# redis-cli -p 6379127.0.0.1:6379&gt; pingPONG127.0.0.1:6379&gt; set k1 helloworldOK127.0.0.1:6379&gt; get k1&quot;helloworld&quot;# 【shell】ps显示系统当前进程信息[root@192 myredis]# ps -ef|grep redisroot \t16005 1 0 04:45 ? 00:00:00 redis-server127.0.0.1:6379root \t16031 15692 0 04:47 pts/0 00:00:00 redis-cli -p 6379root \t16107 16076 0 04:51 pts/2 00:00:00 grep --color=auto redis# 【redis】关闭连接127.0.0.1:6379&gt; shutdownnot connected&gt; exit# 【shell】ps显示系统当前进程信息[root@192 myredis]# ps -ef|grep redisroot 16140 16076 0 04:53 pts/2 00:00:00 grep --color=auto redis\n\n测试性能\nredis压力测试工具—–Redis-benchmark\n\nRedis-benchmark是官方自带的Redis性能测试工具，可以有效的测试Redis服务的性能。\n\nredis-benchmark：Redis官方提供的性能测试工具，参数选项如下：\n\n\n# 测试一：100个并发连接，100000个请求，检测host为localhost 端口为6379的redis服务器性能redis-benchmark -h localhost -p 6379 -c 100 -n 100000# 测试出来的所有命令只举例一个！====== SET ======100000 requests completed in 1.88 seconds # 对集合写入测试100 parallel clients # 每次请求有100个并发客户端3 bytes payload # 每次写入3个字节的数据，有效载荷keep alive: 1 # 保持一个连接，一台服务器来处理这些请求17.05% &lt;= 1 milliseconds97.35% &lt;= 2 milliseconds99.97% &lt;= 3 milliseconds100.00% &lt;= 3 milliseconds # 所有请求在 3 毫秒内完成53248.14 requests per second # 每秒处理 53248.14 次请求\n\n基础知识\nredis默认有16个数据库\n\n查看 redis.conf ，里面有默认的配置databases 16# Set the number of databases. The default database is DB 0, you can select# a different one on a per-connection basis using SELECT &lt;dbid&gt; where# dbid is a number between 0 and &#x27;databases&#x27;-1databases 16\n\n默认使用的第0个;\n16个数据库为：DB 0~DB 15默认使用DB 0 ，可以使用select n切换到DB n，dbsize可以查看当前数据库的大小，与key数量相关。\n127.0.0.1:6379&gt; config get databases # 命令行查看数据库数量databases1) &quot;databases&quot;2) &quot;16&quot;127.0.0.1:6379&gt; select 8 # 切换数据库 DB 8OK127.0.0.1:6379[8]&gt; dbsize # 查看数据库大小(integer) 0# 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。127.0.0.1:6379&gt; set name sakura OK127.0.0.1:6379&gt; SELECT 8OK127.0.0.1:6379[8]&gt; get name # db8中并不能获取db0中的键值对。(nil)127.0.0.1:6379[8]&gt; DBSIZE #Dbsize查看当前数据库的key的数量(integer) 0127.0.0.1:6379[8]&gt; SELECT 0OK127.0.0.1:6379&gt; keys *1) &quot;counter:__rand_int__&quot;2) &quot;mylist&quot;3) &quot;name&quot;4) &quot;key:__rand_int__&quot;5) &quot;myset:__rand_int__&quot;127.0.0.1:6379&gt; DBSIZE # size和key个数相关(integer) 5\n\nkeys * ：查看当前数据库中所有的key。\nflushdb：清空当前数据库中的键值对。\nflushall：清空所有数据库的键值对。\n\nRedis是单线程的，Redis是基于内存操作的。\n\nRedis的性能瓶颈不是CPU,而是机器内存和网络带宽。\n那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+\n\nRedis为什么单线程还这么快？\n\n\n误区1：高性能的服务器一定是多线程的？\n误区2：多线程（CPU上下文会切换！）一定比单线程效率高！\n\n核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。\n因为一次CPU上下文的切换大概在 1500ns 左右。从内存中读取 1MB 的连续数据，耗时大约为 250us， 假设1MB的数据由多个线程读取了1000次，那么就有1000次时间上下文的切换，那么就有1500ns * 1000 &#x3D; 1500us ，我单线程的读完1MB数据才250us ,你光时间上下文的切换就用了1500us了，我还不算你每次读一点数据的时间。\n","tags":["Redis"]},{"title":"Redis之小进阶","url":"/2022/07/31/Redis%E4%B9%8B%E5%B0%8F%E8%BF%9B%E9%98%B6/","content":"Redis的持久化Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！\nRdb 保存的是 dump.rdb 文件\nRDB（Redis DataBase）\n什么是RDB\n\n在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快 照文件直接读到内存里。\nRedis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。 这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。\n\nFork\n\nFork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量，环境变量，程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。\n配置位置及SNAPSHOTTING解析\n\n这里的触发条件机制，我们可以修改测试一下：\nsave 120 10 # 120秒内修改10次则触发RDB\n\n1\nRDB 是整合内存的压缩过的Snapshot，RDB 的数据结构，可以配置复合的快照触发条件。\n如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。\n若要修改完毕需要立马生效，可以手动使用 save 命令！立马生效 !\nsave不是创建一个新进程去进行持久化\n\n其余命令解析\n\nStop-writes-on-bgsave-error：如果配置为no，表示你不在乎数据不一致或者有其他的手段发现和控制，默认为yes。\nrbdcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用 LZF算法进行压缩，如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。\nrdbchecksum：在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约 10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。默认为yes。\n\n如何触发RDB快照\n\n1、配置文件中默认的快照配置，建议多用一台机子作为备份，复制一份 dump.rdb\n2、命令save或者是bgsave\n\nsave 时只管保存，其他不管，全部阻塞\nbgsave，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave 命令获取最后一次成功执行快照的时间。\n\n3、执行flushall命令，也会产生 dump.rdb 文件，但里面是空的，无意义 !\n4、退出的时候也会产生 dump.rdb 文件！\n\n如何恢复\n\n1、将备份文件（dump.rdb）移动到redis安装目录并启动服务即可\n2、CONFIG GET dir 获取目录\n127.0.0.1:6379&gt; config get dirdir/usr/local/bin\n\n\n优点和缺点\n\n优点：\n1、适合大规模的数据恢复\n2、对数据完整性和一致性要求不高\n缺点：\n1、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改\n2、Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。\n\n小结\n\n\nAOF（Append Only File）\n简介\n\n以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件 的内容将写指令从前到后执行一次以完成数据的恢复工作\nAof保存的是 appendonly.aof 文件\n\n配置\n\n\n\nappendonly no\n是否以append only模式作为持久化方式，默认使用的是rdb方式持久化，这 种方式在许多应用中已经足够用了\n\nappendfilename “appendonly.aof”\nappendfilename AOF 文件名称\n\nappendfsync everysec\nappendfsync aof持久化策略的配置\n\n\n\nno表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。 always表示每次写入都执行fsync，以保证数据同步到磁盘。 everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。\n\n\nNo-appendfsync-on-rewrite\n重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性\n\nAuto-aof-rewrite-min-size\n设置重写的基准值\n\nAuto-aof-rewrite-percentage\n设置重写的基准值\n\n\n\nAOF 启动&#x2F;修复&#x2F;恢复\n\n正常恢复：\n启动：设置Yes，修改默认的appendonly no，改为yes 将有数据的aof文件复制一份保存到对应目录（config get dir） 恢复：重启redis然后重新加载\n异常恢复：\n启动：设置Yes 故意破坏 appendonly.aof 文件！ 修复：命令redis-check-aof --fix appendonly.aof 进行修复 恢复：重启 redis 然后重新加载\n\nRewrite重写\n\nAOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis 就会启动AOF 文件的内容压缩，只保留可以恢复数据的最小指令集，可以 使用命令 bgrewriteaof ！\n重写原理：\nAOF 文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再 rename），遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧 的aof文件，这点和快照有点类似！\n触发机制：\nRedis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的已被且文件大 于64M的触发。\n\n优点和缺点\n\n优点：\n1、每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好\n2、每秒同步： appendfsync everysec 异步操作，每秒记录 ，如果一秒内宕机，有数据丢失\n3、不同步： appendfsync no 从不同步\n缺点：\n1、相同数据集的数据而言，aof 文件要远大于 rdb文件，恢复速度慢于 rdb。\n2、Aof 运行效率要慢于 rdb，每秒同步策略效率较好，不同步效率和rdb相同。\n\n小结\n\n\n\n总结1、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储\n2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。\n3、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化\n4、同时开启两种持久化方式\n\n在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF 文件保存的数据集要比RDB文件保存的数据集要完整。\nRDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有 AOF可能潜在的Bug，留着作为一个万一的手段。\n\n5、性能建议\n\n因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够 了，只保留 save 900 1 这条规则。\n如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自 己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产 生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite 的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重 写可以改到适当的数值。\n如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也 减少了rewrite时带来的系统波动。代价是如果Master&#x2F;Slave 同时倒掉，会丢失十几分钟的数据， 启动脚本也要比较两个 Master&#x2F;Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。\n\nRedis 发布订阅简介Redis 发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。\nRedis 客户端可以订阅任意数量的频道。\n订阅&#x2F;发布消息图：\n\n下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：\n\n\n当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：\n\n\n命令\n下表列出了 redis 发布订阅常用命令：\n\n\n\n序号\n命令及描述\n\n\n\n1\n[PSUBSCRIBE pattern [pattern …]] 订阅一个或多个符合给定模式的频道。\n\n\n2\n[PUBSUB subcommand [argument [argument …]]] 查看订阅与发布系统状态。\n\n\n3\n[PUBLISH channel message] 将信息发送到指定的频道。\n\n\n4\n[PUNSUBSCRIBE [pattern [pattern …]]] 退订所有给定模式的频道。\n\n\n5\n[SUBSCRIBE channel [channel …]] 订阅给定的一个或多个频道的信息。\n\n\n6\n[UNSUBSCRIBE [channel [channel …]]] 指退订给定的频道。\n\n\n测试以下实例演示了发布订阅是如何工作的。\n我们先打开两个 redis-cli 客户端\n在第一个 redis-cli 客户端，创建订阅频道名为 redisChat，输入SUBSCRIBE redisChat\nredis 127.0.0.1:6379&gt; SUBSCRIBE redisChatReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;redisChat&quot;3) (integer) 1\n\n在第二个客户端，发布两次消息，订阅者就能接收 到消息。\nredis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Hello,Redis&quot;(integer) 1redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Hello，java&quot;(integer) 1\n\n订阅者的客户端会显示如下消息\n\n\n“message”\n“redisChat”\n“Hello,Redis”\n“message”\n“redisChat”\n“Hello，java”\n\n\n原理Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，来加深对 Redis 的理解。\nRedis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。\n通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 channel ，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。\n通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。\nPub&#x2F;Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个 key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。\n使用场景：\nRedis的Pub&#x2F;Sub系统可以构建实时的消息系统，比如很多用Pub&#x2F;Sub构建的实时聊天系统的例子。\nRedis主从复制概念主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点 (master&#x2F;leader)，后者称为从节点(slave&#x2F;follower)；数据的复制是单向的，只能由主节点到从节点。 Master以写为主，Slave 以读为主。\n默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。\n主从复制的作用主要包括：\n1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。\n2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。\n3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 （即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。\n4、高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis高可用的基础。\n一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的，原因如下：\n1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较 大；\n2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。\n电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。\n对于这种场景，我们可以使如下这种架构：\n\n环境配置\n基本配置\n\n查看当前库的信息：info replication\n127.0.0.1:6379&gt; info replication# Replicationrole:master\t# 角色connected_slaves:0\t# 从机数量master_failover_state:no-failovermaster_replid:1a6933acf7ec9711bfa0a1848976676557e1e6a0master_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0127.0.0.1:6379&gt; \n\n因为没有多个服务器，就以本地开启3个端口，模拟3个服务\n既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：\n\n端口号（port）\npid文件名（pidfile）\n日志文件名（logfile）\nrdb文件名（dbfilename）\n\n1、拷贝多个redis.conf 文件\n端口分别是6379、6380、6381\n[root@localhost ~]# cd /usr/local/bin/myconfig[root@localhost myconfig]# lsdump.rdb  redis.conf[root@localhost myconfig]# cp redis.conf redis79.conf[root@localhost myconfig]# cp redis.conf redis80.conf[root@localhost myconfig]# cp redis.conf redis81.conf[root@localhost myconfig]# lsdump.rdb  redis79.conf  redis80.conf  redis81.conf  redis.conf\n\n分别修改配置上面四点对应的配置，举例：\n\n\n\n配置好分别启动3个不同端口服务\n\nredis-server myconfig&#x2F;redis79.conf\nredis-server myconfig&#x2F;redis80.conf\nredis-server myconfig&#x2F;redis81.conf\n\nredis-server myconfig&#x2F;redis79.conf\n\n一主二从1、之后我们再分别开启redis连接，redis-cli -p 6379，redis-cli -p 6380，redis-cli -p 6381\n通过指令\n127.0.0.1:6379&gt; info replication\n\n可以发现，默认情况下，开启的每个redis服务器都是主节点\n\n2、配置为一个Master 两个Slave（即一主二从）\n6379为主，6380,6381为从\nslaveof 127.0.0.1 6379\n\n3、在主机设置值，在从机都可以取到！从机不能写值！\n\n我们这里是使用命令搭建，是“暂时的”，也可去配置里进行修改，这样话则是“永久的”\n\n\n\n使用规则\n\n当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。\n当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。\n有两种方式可以产生新的主机：看下文“谋权篡位”\n\n层层链路\n\n上一个Slave 可以是下一个slave 和 Master，Slave 同样可以接收其他 slaves 的连接和同步请求，那么 该 slave 作为了链条中下一个的master，可以有效减轻 master 的写压力！\n\n\n\n谋权篡位\n\n有两种方式可以产生新的主机：\n\n从机手动执行命令slaveof no one,这样执行以后从机会独立出来成为一个主机\n使用哨兵模式（自动选举）\n\n\n复制原理\n\nSlave 启动成功连接到 master 后会发送一个sync命令\nMaster 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行 完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。\n全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。\n增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步\n但是只要是重新连接master，一次完全同步（全量复制）将被自动执行\n哨兵模式更多信息参考博客：https://www.jianshu.com/p/06ab9daf921d\n\n概述\n\n主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工 干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑 哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。\n谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。\n哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独 立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。\n\n\n这里的哨兵有两个作用\n\n通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。\n当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。\n\n然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。 各个哨兵之间还会进行监控，这样就形成了多哨兵模式。\n\n\n假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认 为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一 定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。 切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为 客观下线。\n\n配置测试\n\n1、调整结构，6379带着80、81\n2、自定义的 &#x2F;myconfig 目录下新建 sentinel.conf 文件，名字千万不要错\n3、配置哨兵，填写内容\n\nsentinel monitor 被监控主机名字 127.0.0.1 6379 1\n例如：sentinel monitor mymaster 127.0.0.1 6379 1，\n上面最后一个数字1，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机\n\n\n4、启动哨兵\n\nRedis-sentinel myconfig&#x2F;sentinel.conf\n上述目录依照各自的实际情况配置，可能目录不同\n\n\n成功启动哨兵模式\n\n此时哨兵监视着我们的主机6379，当我们断开主机后：\n\n\n哨兵模式的优缺点\n\n优点\n\n哨兵集群，基于主从复制模式，所有主从复制的优点，它都有\n主从可以切换，故障可以转移，系统的可用性更好\n哨兵模式是主从模式的升级，手动到自动，更加健壮\n\n缺点：\n\nRedis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦\n实现哨兵模式的配置其实是很麻烦的，里面有很多配置项\n\n\n哨兵模式的全部配置\n\n完整的哨兵模式配置文件 sentinel.conf\n# Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379port 26379 # 哨兵sentinel的工作目录dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。# quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了# sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;sentinel monitor mymaster 127.0.0.1 6379 1 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码# sentinel auth-pass &lt;master-name&gt; &lt;password&gt;sentinel auth-pass mymaster MySUPER--secret-0123passw0rd  # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒# sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。# sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;sentinel parallel-syncs mymaster 1   # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。#3.当想要取消一个正在进行的failover所需要的时间。  #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了# 默认三分钟# sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。#对于脚本的运行结果有以下规则：#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，#一个是事件的类型，#一个是事件的描述。#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。#通知脚本# sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;  sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。# 以下参数将会在调用脚本时传给脚本:# &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;# 目前&lt;state&gt;总是“failover”,# &lt;role&gt;是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的# 这个脚本应该是通用的，能被多次调用，不是针对性的。# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;sentinel client-reconfig-script mymaster /var/redis/reconfig.sh\n\n缓存穿透与雪崩缓存穿透（查不到）\n概念\n\n在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。\n\n解决方案\n\n布隆过滤器\n对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。\n\n\n缓存空对象\n一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。\n\n\n这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间\n即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。\n缓存击穿（量太大，缓存过期）\n概念\n\n相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。\n比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。\n\n解决方案\n\n\n设置热点数据永不过期\n这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。\n\n加互斥锁(分布式锁)\n在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。\n\n\n缓存雪崩\n概念\n\n大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。\n产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。\n\n\n其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然 形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就 是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知 的，很有可能瞬间就把数据库压垮。\n\n解决方案\n\n\nredis高可用\n这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群\n\n限流降级\n这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。\n\n数据预热\n数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。\n\n\n","tags":["Redis"]},{"title":"Anylogic之基于ajax实现百度地图多车实时运行","url":"/2022/08/06/Anylogic%E4%B9%8B%E5%9F%BA%E4%BA%8Eajax%E5%AE%9E%E7%8E%B0%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%A4%9A%E8%BD%A6%E5%AE%9E%E6%97%B6%E8%BF%90%E8%A1%8C/","content":"不足：不能随着需求随时变化；这个是用了两个数据库，一个数据库存一个车的 \n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, user-scalable=no&quot; /&gt;    &lt;style&gt;        html, body, #allmap &#123;            height: 100%;            width: 100%;        &#125;        .input-card .btn&#123;            margin-right: 1.2rem;            width: 9rem;        &#125;        .input-card .btn:last-child&#123;            margin-right: 0;        &#125;    &lt;/style&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=GjxdF4HBRYNY0piKp6K7I4U7lOI7Lyor&quot;&gt;    &lt;/script&gt;    &lt;title&gt;单个标注点沿直线的轨迹运动&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery.min.js&quot;&gt;&lt;/script&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://a.amap.com/jsapi_demos/static/demo-center/css/demo-center.css&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;div class=&quot;input-card&quot;&gt;    &lt;h4&gt;轨迹回放控制&lt;/h4&gt;    &lt;div class=&quot;input-item&quot;&gt;        &lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;速度x2&quot; id=&quot;start&quot; onclick=&quot;startAnimation()&quot;/&gt;        &lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;速度÷2&quot; id=&quot;pause&quot; onclick=&quot;pauseAnimation()&quot;/&gt;    &lt;/div&gt;    &lt;div class=&quot;input-item&quot;&gt;        &lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;开始&quot; id=&quot;resume&quot; onClick=&quot;getCars()&quot;/&gt;        &lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;开始&quot; id=&quot;stop&quot; onClick=&quot;getCars1()&quot;/&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    // 百度地图API功能    var map=new BMap.Map(&quot;allmap&quot;); // 创建map实例    map.centerAndZoom(new BMap.Point(116.36239048877775, 39.938322220559), 15);// 初始化地图,设置中心点坐标和地图级别    map.enableScrollWheelZoom(true);//鼠标滚轮缩放    map.addControl(new BMap.MapTypeControl()); //添加切换地图类型附件    var time =500;    var PointArr = []    var PointArrs = &#123;&#125;    var PointArr1 = []    var myIcon=new BMap.Icon(&quot;./car.png&quot;, new BMap.Size(50, 70), &#123;        offset: new BMap.Size(20,20),        //相当于CSS精灵        imageOffset: new BMap.Size(0, 0)        //图片的偏移量。为了是图片底部中心对准坐标点。    &#125;);    var carMk;//先将终点坐标展示的mark对象定义    var carMk1;//先将终点坐标展示的mark对象定义    //小车行驶图标    var drivingPoint = myIcon;    //终点图标    var terminalPoint = myIcon;    function getCars() &#123;         $.ajax(&#123;            async: false,            cache: true,            url: &quot;http://localhost/books&quot;,            type: &#x27;post&#x27;,            dataType: &#x27;json&#x27;,            success: function (result) &#123;                for (var k = 0; k &lt; result.length; k++) &#123;                    staus = result[k].staus;                    id = result[k].id;                    lng = result[k].lng;                    lat = result[k].lat;                    PointArrs = &#123;staus,id,lng,lat&#125;;                    PointArr.push(PointArrs);                &#125;            &#125;,            error:function(e)&#123;                 alert(&quot;获取物资信息失败&quot;);             &#125;         &#125;);         $.ajax(&#123;            async: false,            cache: true,            url: &quot;http://localhost/books1&quot;,            type: &#x27;post&#x27;,            dataType: &#x27;json&#x27;,            success: function (result) &#123;                for (var k = 0; k &lt; result.length; k++) &#123;                    staus = result[k].staus;                    id = result[k].id;                    lng = result[k].lng;                    lat = result[k].lat;                    PointArrs = &#123;staus,id,lng,lat&#125;;                    PointArr1.push(PointArrs);                &#125;            &#125;,            error:function(e)&#123;                 alert(&quot;获取物资信息失败&quot;);             &#125;         &#125;);        // setInterval(function()&#123; //setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。setTimeout() 只执行 code 一次。如果要多次调用，请使用 setInterval() 或者让 code 自身再次调用 setTimeout()。        //          getCars();        //      &#125;, 50);    &#125;    var i = 0;    var j = 0;    function startAnimation () &#123;        time = time/2;    &#125;    function pauseAnimation () &#123;        time = time*2;    &#125;    var interval = setInterval(fn, time);    function fn() &#123;        clearInterval(interval);        drawLine(map,PointArr[i],PointArr[i+1]);//画线调用        drawLine(map,PointArr1[j],PointArr1[j+1]);//画线调用        i = i + 1;        j = j + 1;        if (time &gt; 0) &#123;            interval = setInterval(fn, time);        &#125;    &#125;    // 划线    function drawLine(map,pointArr,pointArrNext) &#123;        if (pointArrNext != undefined) &#123;            if (pointArr.id == &quot;car1&quot;) &#123;                var polyline = new BMap.Polyline(                  [                      new BMap.Point(pointArr.lng, pointArr.lat),                      new BMap.Point(pointArrNext.lng, pointArrNext.lat)                  ],                  &#123;                      strokeColor: &quot;red&quot;,                      strokeWeight: 7,                      strokeOpacity: 1                  &#125;);   //创建折线                map.addOverlay(polyline);//将折线添加到地图上                addMarkerEnd(new BMap.Point(pointArrNext.lng, pointArrNext.lat), pointArrNext.staus, map, pointArrNext, new BMap.Point(pointArr.lng, pointArr.lat), polyline);//添加图标            &#125; else if (pointArr.id == &quot;car2&quot;) &#123;                var polyline1 = new BMap.Polyline(                  [                      new BMap.Point(pointArr.lng, pointArr.lat),                      new BMap.Point(pointArrNext.lng, pointArrNext.lat)                  ],                  &#123;                      strokeColor: &quot;yellow&quot;,                      strokeWeight: 7,                      strokeOpacity: 1                  &#125;);   //创建折线                map.addOverlay(polyline1);//将折线添加到地图上                addMarkerEnd(new BMap.Point(pointArrNext.lng, pointArrNext.lat), pointArrNext.staus, map, pointArrNext, new BMap.Point(pointArr.lng, pointArr.lat), polyline1);//添加图标            &#125;        &#125;    &#125;    function addMarkerEnd(point, name,mapInit,trackUnit,prePoint,p) &#123;        if (trackUnit.id == &quot;car1&quot;) &#123;            if (name == &quot;200&quot;) &#123;                if (carMk) &#123;//先判断第一次进来的时候这个值有没有定义，有的话就清除掉上一次的。然后在进行画图标。第一次进来时候没有定义也就不走这块，直接进行画图标                    mapInit.removeOverlay(carMk);                &#125;                carMk = new BMap.Marker(point, &#123;icon: drivingPoint&#125;);  // 创建标注                getCarAngle(point, prePoint);// js求解两点之间的角度                carMk.setRotation(getCarAngle(point, prePoint) - 90);// 旋转的角度                var label = new BMap.Label(trackUnit.id, &#123;offset: new BMap.Size(0, -30)&#125;);                label.setStyle(&#123;                    border: &quot;1px solid rgb(204, 204, 204)&quot;,                    color: &quot;rgb(0, 0, 0)&quot;,                    borderRadius: &quot;10px&quot;,                    padding: &quot;5px&quot;,                    background: &quot;rgb(255, 255, 255)&quot;,                &#125;);                carMk.setLabel(label);                mapInit.addOverlay(carMk);            &#125; else &#123;                mapInit.removeOverlay(carMk);                var allOverlay = map.getOverlays();                for (var i = 0; i &lt; allOverlay.length; i++)&#123;                    if(allOverlay[i].toString().indexOf(&quot;Polyline&quot;) &gt; 0)                    &#123;//删除折线                        map.removeOverlay(allOverlay[i]);                    &#125;                &#125;            &#125;        &#125; else if (trackUnit.id == &quot;car2&quot;) &#123;            if (name == &quot;200&quot;) &#123;                if (carMk1) &#123;//先判断第一次进来的时候这个值有没有定义，有的话就清除掉上一次的。然后在进行画图标。第一次进来时候没有定义也就不走这块，直接进行画图标                    mapInit.removeOverlay(carMk1);                &#125;                carMk1 = new BMap.Marker(point, &#123;icon: terminalPoint&#125;);  // 创建标注                getCarAngle(point, prePoint);// js求解两点之间的角度                carMk1.setRotation(getCarAngle(point, prePoint) - 90);// 旋转的角度                var label = new BMap.Label(trackUnit.id, &#123;offset: new BMap.Size(0, -30)&#125;);                label.setStyle(&#123;                    border: &quot;1px solid rgb(204, 204, 204)&quot;,                    color: &quot;rgb(0, 0, 0)&quot;,                    borderRadius: &quot;10px&quot;,                    padding: &quot;5px&quot;,                    background: &quot;rgb(255, 255, 255)&quot;,                &#125;);                carMk1.setLabel(label);                mapInit.addOverlay(carMk1);               // 将标注添加到地图中            &#125; else &#123;                mapInit.removeOverlay(carMk1);                var allOverlay = map.getOverlays();                for (var i = 0; i &lt; allOverlay.length; i++)&#123;                    if(allOverlay[i].toString().indexOf(&quot;Polyline1&quot;) &gt; 0)                    &#123;//删除折线                        map.removeOverlay(allOverlay[i]);                    &#125;                &#125;            &#125;        &#125;        //获得角度的函数        function getCarAngle(n, next) &#123;            var ret            var w1 = n.lat / 180 * Math.PI            var j1 = n.lng / 180 * Math.PI            var w2 = next.lat / 180 * Math.PI            var j2 = next.lng / 180 * Math.PI            ret = 4 * Math.pow(Math.sin((w1 - w2) / 2), 2) - Math.pow(Math.sin((j1 - j2) / 2) * (Math.cos(w1) - Math.cos(w2)), 2);            ret = Math.sqrt(ret);            // var temp = Math.sin(Math.abs(j1 - j2) / 2) * (Math.cos(w1) + Math.cos(w2));            var temp = Math.sin((j1 - j2) / 2) * (Math.cos(w1) + Math.cos(w2));            //console.log(temp)            ret = ret / temp;            ret = Math.atan(ret) / Math.PI * 180;            ret += 90;            // 这里用如此臃肿的if..else是为了判定追踪单个点的具体情况,从而调整ret的值            if (j1 - j2 &lt; 0) &#123;                if (w1 - w2 &lt; 0) &#123;                    ret;                &#125; else &#123;                    ret = -ret + 180;                &#125;            &#125; else &#123;                if (w1 - w2 &lt; 0) &#123;                    ret = 180 + ret;                &#125; else &#123;                    ret = -ret;                &#125;            &#125;            return ret;        &#125;    &#125;&lt;/script&gt;\n","tags":["Anylogic"]},{"title":"Anylogic之基于ajax实现百度地图多车实时运行改良","url":"/2022/08/06/Anylogic%E4%B9%8B%E5%9F%BA%E4%BA%8Eajax%E5%AE%9E%E7%8E%B0%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E5%A4%9A%E8%BD%A6%E5%AE%9E%E6%97%B6%E8%BF%90%E8%A1%8C%E6%94%B9%E8%89%AF/","content":"改良后：使用一个数据库存两个车的数据，将公共代码封装成一个函数进行调用\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, user-scalable=no&quot; /&gt;  &lt;style&gt;      html, body, #allmap &#123;          height: 100%;          width: 100%;      &#125;      .input-card .btn&#123;          margin-right: 1.2rem;          width: 9rem;      &#125;      .input-card .btn:last-child&#123;          margin-right: 0;      &#125;  &lt;/style&gt;  &lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=GjxdF4HBRYNY0piKp6K7I4U7lOI7Lyor&quot;&gt;  &lt;/script&gt;  &lt;title&gt;单个标注点沿直线的轨迹运动&lt;/title&gt;  &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery.min.js&quot;&gt;&lt;/script&gt;  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://a.amap.com/jsapi_demos/static/demo-center/css/demo-center.css&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;div class=&quot;input-card&quot;&gt;  &lt;h4&gt;轨迹回放控制&lt;/h4&gt;  &lt;div class=&quot;input-item&quot;&gt;    &lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;速度x2&quot; id=&quot;start&quot; onclick=&quot;startAnimation()&quot;/&gt;    &lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;速度÷2&quot; id=&quot;pause&quot; onclick=&quot;pauseAnimation()&quot;/&gt;  &lt;/div&gt;  &lt;div class=&quot;input-item&quot;&gt;    &lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;开始&quot; id=&quot;resume&quot; onClick=&quot;getCars()&quot;/&gt;    &lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;开始&quot; id=&quot;stop&quot; onClick=&quot;getCars1()&quot;/&gt;  &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    // 百度地图API功能    var map=new BMap.Map(&quot;allmap&quot;); // 创建map实例    map.centerAndZoom(new BMap.Point(116.36239048877775, 39.938322220559), 15);// 初始化地图,设置中心点坐标和地图级别    map.enableScrollWheelZoom(true);//鼠标滚轮缩放    map.addControl(new BMap.MapTypeControl()); //添加切换地图类型附件    var time =500;    var PointArr = []    var PointArr1 = []    var PointArrs = &#123;&#125;    var myIcon=new BMap.Icon(&quot;./car.png&quot;, new BMap.Size(50, 70), &#123;        offset: new BMap.Size(20,20),        //相当于CSS精灵        imageOffset: new BMap.Size(0, 0)        //图片的偏移量。为了是图片底部中心对准坐标点。    &#125;);    var carMks=[1,2];//设置车辆图标    //小车行驶图标    var drivingPoint = myIcon;    //终点图标    var terminalPoint = myIcon;    function getCars() &#123;        $.ajax(&#123;            async: false,            cache: true,            url: &quot;http://localhost/books&quot;,            type: &#x27;post&#x27;,            dataType: &#x27;json&#x27;,            success: function (result) &#123;                for (var k = 0; k &lt; result.length; k++) &#123;                    staus = result[k].staus;                    id = result[k].id;                    lng = result[k].lng;                    lat = result[k].lat;                    PointArrs = &#123;staus,id,lng,lat&#125;;                    if(PointArrs.id == &#x27;car1&#x27;)&#123;                        PointArr.push(PointArrs);                    &#125;else if(PointArrs.id == &#x27;car2&#x27;)&#123;                        PointArr1.push(PointArrs);                    &#125;                &#125;            &#125;,            error:function(e)&#123;                alert(&quot;获取物资信息失败&quot;);            &#125;        &#125;);    &#125;    var i = 0;    function startAnimation () &#123;        time = time/2;    &#125;    function pauseAnimation () &#123;        time = time*2;    &#125;    var interval = setInterval(fn, time);    function fn() &#123;        clearInterval(interval);        drawLine(map,PointArr[i],PointArr[i+1]);//画线调用        drawLine(map,PointArr1[i],PointArr1[i+1]);//画线调用        i = i + 1;        if (time &gt; 0) &#123;            interval = setInterval(fn, time);        &#125;    &#125;    // 划线    function drawLine(map,pointArr,pointArrNext) &#123;        if (pointArrNext != undefined) &#123;            if (pointArr.id == &quot;car1&quot;) &#123;              addpl(1);               &#125; else if (pointArr.id == &quot;car2&quot;) &#123;                addpl(2);            &#125;        &#125;        function addpl(y1)&#123;            var y1 = new BMap.Polyline(                [                    new BMap.Point(pointArr.lng, pointArr.lat),                    new BMap.Point(pointArrNext.lng, pointArrNext.lat)                ],                &#123;                    strokeColor: &quot;red&quot;,                    strokeWeight: 7,                    strokeOpacity: 1                &#125;);   //创建折线            map.addOverlay(y1);//将折线添加到地图上            addMarkerEnd(new BMap.Point(pointArrNext.lng, pointArrNext.lat), pointArrNext.staus, map, pointArrNext, new BMap.Point(pointArr.lng, pointArr.lat), y1);//添加图标        &#125;    &#125;    function addMarkerEnd(point, name,mapInit,trackUnit,prePoint,p) &#123;        if (trackUnit.id == &quot;car1&quot;) &#123;            if (name == &quot;200&quot;) &#123;              car(1);            &#125; else &#123;                cardl(1);            &#125;        &#125; else if (trackUnit.id == &quot;car2&quot;) &#123;            if (name == &quot;200&quot;) &#123;               car(2);            &#125; else &#123;                cardl(2);            &#125;        &#125;        function car(x1)&#123;            if (carMks[x1]) &#123;//先判断第一次进来的时候这个值有没有定义，有的话就清除掉上一次的。然后在进行画图标。第一次进来时候没有定义也就不走这块，直接进行画图标                mapInit.removeOverlay(carMks[x1]);            &#125;            carMks[x1] = new BMap.Marker(point, &#123;icon: terminalPoint&#125;);  // 创建标注            getCarAngle(point, prePoint);// js求解两点之间的角度            carMks[x1].setRotation(getCarAngle(point, prePoint) - 90);// 旋转的角度            var label = new BMap.Label(trackUnit.id, &#123;offset: new BMap.Size(0, -30)&#125;);            label.setStyle(&#123;                border: &quot;1px solid rgb(204, 204, 204)&quot;,                color: &quot;rgb(0, 0, 0)&quot;,                borderRadius: &quot;10px&quot;,                padding: &quot;5px&quot;,                background: &quot;rgb(255, 255, 255)&quot;,            &#125;);            carMks[x1].setLabel(label);            mapInit.addOverlay(carMks[x1]);               // 将标注添加到地图中        &#125;        //小车运行完删除折线        function cardl(x1)&#123;            mapInit.removeOverlay(carMks[x1]);            var allOverlay = map.getOverlays();            for (var i = 0; i &lt; allOverlay.length; i++)&#123;                if(allOverlay[i].toString().indexOf(&quot;Polyline&quot;) &gt; 0)                &#123;//删除折线                    map.removeOverlay(allOverlay[i]);                &#125;            &#125;        &#125;        //获得角度的函数        function getCarAngle(n, next) &#123;            var ret            var w1 = n.lat / 180 * Math.PI            var j1 = n.lng / 180 * Math.PI            var w2 = next.lat / 180 * Math.PI            var j2 = next.lng / 180 * Math.PI            ret = 4 * Math.pow(Math.sin((w1 - w2) / 2), 2) - Math.pow(Math.sin((j1 - j2) / 2) * (Math.cos(w1) - Math.cos(w2)), 2);            ret = Math.sqrt(ret);            // var temp = Math.sin(Math.abs(j1 - j2) / 2) * (Math.cos(w1) + Math.cos(w2));            var temp = Math.sin((j1 - j2) / 2) * (Math.cos(w1) + Math.cos(w2));            //console.log(temp)            ret = ret / temp;            ret = Math.atan(ret) / Math.PI * 180;            ret += 90;            // 这里用如此臃肿的if..else是为了判定追踪单个点的具体情况,从而调整ret的值            if (j1 - j2 &lt; 0) &#123;                if (w1 - w2 &lt; 0) &#123;                    ret;                &#125; else &#123;                    ret = -ret + 180;                &#125;            &#125; else &#123;                if (w1 - w2 &lt; 0) &#123;                    ret = 180 + ret;                &#125; else &#123;                    ret = -ret;                &#125;            &#125;            return ret;        &#125;    &#125;&lt;/script&gt;\n","tags":["Anylogic"]},{"title":"Docker之Compose","url":"/2022/08/17/Docker%E4%B9%8BCompose/","content":"简介Docker \nDockerFile build run 手动操作，单个容器！ \n微服务。100个微服务！依赖关系。 \nDocker Compose 来轻松高效的管理容器i。定义运行多个容器。\n\n官方介绍\n\nCompose 是一个用于定义和运行多容器 Docker 应用程序的工具。借助 Compose，您可以使用 YAML 文件来配置应用程序的服务。然后，使用单个命令，从配置中创建并启动所有服务。要了解有关 Compose 的所有功能的更多信息，请参阅功能列表。\nCompose 适用于所有环境：生产、登台、开发、测试以及 CI 工作流。您可以在Common Use Cases 中了解有关每个案例的更多信息。\n使用 Compose 基本上是一个三步过程：\n\n使用定义您的应用程序的环境，Dockerfile 以便它可以在任何地方复制。\n定义组成您的应用程序的服务，docker-compose.yml 以便它们可以在隔离的环境中一起运行。\n运行 docker compose up 和  Docker compose command 启动并运行你的整个应用程序。您也可以docker-compose up使用 docker-compose 二进制文件运行。\n\n可以用 Docker Compose 来轻松高效的管理容器。定义运行多个容器。\n一个docker-compose.yml看起来像这样：\nversion: &quot;3.9&quot;  # optional since v1.27.0services:  web:    build: .    ports:      - &quot;5000:5000&quot;    volumes:      - .:/code      - logvolume01:/var/log    links:      - redis  redis:    image: redisvolumes:  logvolume01: &#123;&#125;\n\n安装1、下载\n官网：\nsudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose\n\n加速下载\ncurl -L https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose\n\n2、授权\nsudo chmod +x /usr/local/bin/docker-compose\n\n\n\n简单上手\n官方文档https://docs.docker.com/compose/gettingstarted/\n\n构建一个在 Docker Compose 上运行的简单 Python Web 应用程序。该应用程序使用 Flask 框架并在 Redis 中维护一个命中计数器。\n第1 步：设置\n\n为项目创建一个目录：\n\nmkdir composetestcd composetest\n\n\n创建app.py\n\nimport timeimport redisfrom flask import Flaskapp = Flask(__name__)cache = redis.Redis(host=&#x27;redis&#x27;, port=6379)def get_hit_count():    retries = 5    while True:        try:            return cache.incr(&#x27;hits&#x27;)        except redis.exceptions.ConnectionError as exc:            if retries == 0:                raise exc            retries -= 1            time.sleep(0.5)@app.route(&#x27;/&#x27;)def hello():    count = get_hit_count()    return &#x27;Hello World! I have been seen &#123;&#125; times.\\n&#x27;.format(count)\n\n\n在项目目录中创建 requirements.txt\n\nflaskredis   \n\n第 2 步：创建 Dockerfile\n项目目录中，创建 Dockerfile\n# syntax=docker/dockerfile:1FROM python:3.7-alpineWORKDIR /codeENV FLASK_APP=app.pyENV FLASK_RUN_HOST=0.0.0.0RUN apk add --no-cache gcc musl-dev linux-headersCOPY requirements.txt requirements.txtRUN pip install -r requirements.txtEXPOSE 5000COPY . .CMD [&quot;flask&quot;, &quot;run&quot;]\n\n第 3 步：在 Compose 文件中定义服务\n项目目录中创建 docker-compose.yml\nversion: &quot;3.9&quot;services:  web:    build: .    ports:      - &quot;5000:5000&quot;  redis:    image: &quot;redis:alpine&quot;\n\n第 4 步：使用 Compose 构建并运行您的应用程序\n在项目目录中运行 docker-compose up\n[root@VM-0-6-centos composetest]# docker-compose up\n\n如果要后台运行\ndocker-compose up -d\n\n测试：\n[root@VM-0-6-centos ~]# curl localhost:5000Hello World! I have been seen 1 times.[root@VM-0-6-centos ~]# curl localhost:5000Hello World! I have been seen 2 times.[root@VM-0-6-centos ~]# curl localhost:5000Hello World! I have been seen 3 times.\n\n\n名字规则\n\n\n默认的服务名：文件名_服务名 _ num\n\n可以看见多了个网络\n\n[root@VM-0-6-centos ~]# docker network lsNETWORK ID     NAME                  DRIVER    SCOPE4b873066daf7   bridge                bridge    locald87efab51b47   composetest_default   bridge    local86da632adad6   elastic               bridge    local64b606f257e7   host                  host      local34ab4fdb73c0   none                  null      local\n\n项目中的内容都在同个网络下。\n启动compose 项目 （docker-compose up）流程：\n\n创建网络\n执行Docker-compose.yaml\n启动服务\n\n\n其他为演示 Compose 量身定制的示例\n\n这些示例专门针对 Docker Compose：\n\n快速入门：Compose 和 Django - 展示了如何使用 Docker Compose 来设置和运行一个简单的 Django&#x2F;PostgreSQL 应用程序。\n快速入门：Compose 和 Rails - 展示了如何使用 Docker Compose 来设置和运行 Rails&#x2F;PostgreSQL 应用程序。\n快速入门：Compose 和 WordPress - 展示了如何使用 Docker Compose 在具有 Docker 容器的隔离环境中设置和运行 WordPress。\n\n开源项目：博客https://docs.docker.com/compose/wordpress/\n下载程序、安装数据库、配置….\ncompose应用 &#x3D;&gt; 一键启动\n\n下载项目（docker-compse.yaml）\n如果需要文件。Dockerfile\n文件准备齐全，一键启动项目即可\n\nyaml 规则\n官方文档https://docs.docker.com/compose/compose-file/\n\n# 3层！version: &#x27;&#x27; # 版本services: # 服务    服务1: web    # 服务配置    images    build    network        服务2: redis    ....    服务3: redis    ....# 其他配置 网络/卷、全局规则volumes:networks:configs:\n\n\njava测试发布以上实例是用 python 写的，我们写一个 java 版本的测试下\n\n1、编写java代码\n创建一个 springboot demo\n@RestControllerpublic class HelloController &#123;    @Autowired    StringRedisTemplate redisTemplate;    @GetMapping(&quot;/hello&quot;)    public String hello()&#123;        Long views = redisTemplate.opsForValue().increment(&quot;views&quot;);        return &quot;hello world! views:&quot;+ views;    &#125;&#125;\n\n2、添加配置\n\n编写 application.properties 文件\n\nserver.port=8080spring.redis.host=redis\n\n\n编写 Docker 文件\n\nFROM java:8COPY *.jar /app.jarCMD [&quot;--server.port=8080&quot;]EXPOSE 8080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]\n\n\n编写 docker-compose.yml 文件\n\nversion: &quot;3.9&quot;services:  zhiyuanapp:    build: .    image: zhiyuanapp    depends_on:      - redis    ports:      - &quot;8080:8080&quot;  redis:    image: &quot;library/redis:alpine&quot;\n\n3、上传并构建\n把 jar包 、Docker、docker-compose 三个文件上传到一个目录下\n并在此目录下构建：\n[root@VM-0-6-centos zhiyuanapp]# docker-compose up\n\n4、测试：\n[root@VM-0-6-centos ~]# curl localhost:8080/hellohello world! views:1[root@VM-0-6-centos ~]# curl localhost:8080/hellohello world! views:2[root@VM-0-6-centos ~]# curl localhost:8080/hellohello world! views:3\n\n","tags":["Docker"]},{"title":"Docker之Docker 网络讲解","url":"/2022/08/16/Docker%E4%B9%8BDocker-%E7%BD%91%E7%BB%9C%E8%AE%B2%E8%A7%A3/","content":"理解Docker0准备工作：清空所有的容器，清空所有的镜像\ndocker rm -f $(docker ps -a -q) # 删除所有容器docker rmi -f $(docker images -qa) # 删除全部镜像\n\n\n我们先来做个测试\n\n查看本地ip ip addr\n[root@VM-0-6-centos ~]# ip addr#本机回环地址1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever#阿里云的私有IP2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link/ether 52:54:00:9a:88:4d brd ff:ff:ff:ff:ff:ff    inet 172.17.0.6/20 brd 172.17.15.255 scope global eth0       valid_lft forever preferred_lft forever    inet6 fe80::5054:ff:fe9a:884d/64 scope link        valid_lft forever preferred_lft forever# docker网桥3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default     link/ether 02:42:d1:ba:72:7a brd ff:ff:ff:ff:ff:ff    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0       valid_lft forever preferred_lft forever    inet6 fe80::42:d1ff:feba:727a/64 scope link        valid_lft forever preferred_lft forever\n\n\nDocker 是如何处理容器网络访问的？\n\n我们之前安装ES的时候，留过一个问题，就是安装Kibana的问题，Kibana得指定ES的地址！或者我们实际场景中，我们开发了很多微服务项目，那些微服务项目都要连接数据库，需要指定数据库的url地址，通过ip。但是我们用Docker管理的话，假设数据库出问题了，我们重新启动运行一个，这个时候数据库的地址就会发生变化，docker会给每个容器都分配一个ip，且容器和容器之间是可以互相访问的。 我们可以测试下容器之间能不能ping通过。\n# 启动tomcat01[root@VM-0-6-centos ~]# docker run -d -P --name tomcat01 tomcat# 查看tomcat01的ip地址，docker会给每个容器都分配一个ip！[root@VM-0-6-centos ~]#  docker exec -it tomcat01 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever24: eth0@if25: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0       valid_lft forever preferred_lft forever# 思考，我们的linux服务器是否可以ping通容器内的tomcat ？可以[root@VM-0-6-centos ~]# ping 172.18.0.2\n\n\n原理\n\n每一个安装了 Docker 的 linux 主机都有一个 docker0 的虚拟网卡。这是个桥接网卡，使用了 veth-pair 技术！\n\n再次查看主机的 ip addr ：本来有三个网络，启动tomcat容器之后，会多了一个网络！\n\n每启动一个容器，linux主机就会多了一个虚拟网卡。\n#启动一个tomcat01，主机的ip地址多了个  25: veth2b7cb71@if24#然后我们在tomcat01容器中查看容器的ip  24: eth0@if25#我们再启动一个tomcat02观察[root@VM-0-6-centos ~]# docker run -d -P --name tomcat02 tomcat# 然后发现linux主机上又多了一个网卡\t27: veth4d2bd95@if26# 我们看下tomcat02的容器内ip地址是\t  26: eth0@if27[root@VM-0-6-centos ~]# docker exec -it tomcat02 ip addr\n\n可以发现：只要启动一个容器，就有一对网卡\nveth-pair 就是一对的虚拟设备接口，它都是成对出现的。一端连着协议栈，一端彼此相连着。\n正因为有这个特性，它常常充当着一个桥梁，连接着各种虚拟网络设备！\n “Bridge、OVS 之间的连接”，“Docker 容器之间的连接” 等等，以此构建出非常复杂的虚拟网络结构，比如 OpenStack Neutron。\n\n我们来测试下 tomcat01 和 tomcat02 容器间是否可以互相 ping 通\n[root@VM-0-6-centos ~]# docker exec -it tomcat02 ping 172.18.0.2PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.095 ms\n\n所以：容器和容器之间是可以互相访问的。\n\n结论：tomcat1 和 tomcat2 共用一个路由器。是的，他们使用的一个，就是docker0。任何一个容器启动默认都是 docker0 网络。 docker 默认会给容器分配一个可用 ip 。\n\n\n\n小结\n\nDocker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据 Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网 关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。\n\nDocker 容器网络就很好的利用了 Linux 虚拟网络技术，在本地主机和容器内分别创建一个虚拟接口，并让他们彼此联通（这样一对接口叫 veth pair）；\nDocker 中的网络接口默认都是虚拟的接口。虚拟接口的优势就是转发效率极高（因为Linux是在内核中进行数据的复制来实现虚拟接口之间的数据转发，无需通过外部的网络设备交换），对于本地系统和容器系统来说，虚拟接口跟一个正常的以太网卡相比并没有区别，只是他的速度快很多。\nLink参数思考一个场景，我们编写一个微服务，数据库连接地址原来是使用ip的，如果ip变化就不行了，那我们能不能使用服务名访问呢？\n就像 jdbc:mysql://mysql:3306，这样的话哪怕 mysql 重启，我们也不需要修改配置了！\ndocker提供了 --link 的操作！\n# 我们使用tomcat02，直接通过容器名ping,不使用ip[root@VM-0-6-centos ~]# docker exec -it tomcat02 ping tomcat01# ping 不通ping: tomcat01: Name or service not known#我们再启动一个tomcat03，但是启动的时候连接tomcat02[root@VM-0-6-centos ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat80ed9c4e1f9428598a91c727ed13b7d0534d86d569855d4fb8739baabe5d6b91#这个时候，我们就可以使用tomcat03 ping通 tomcat02 了[root@VM-0-6-centos ~]#  docker exec -it tomcat03 ping tomcat02PING tomcat02 (172.18.0.3) 56(84) bytes of data.64 bytes from tomcat02 (172.18.0.3): icmp_seq=1 ttl=64 time=0.092 ms# tomcat3 ping不通 tomcat1[root@VM-0-6-centos ~]# docker exec -it tomcat03 ping tomcat01ping: tomcat01: Name or service not known# tomcat2 ping不通 tomcat3 反向也ping不通[root@VM-0-6-centos ~]# docker exec -it tomcat02 ping tomcat03ping: tomcat03: Name or service not known\n\n这是为什么呢？\n#进入tomcat03中查看下host配置文件[root@VM-0-6-centos ~]# docker exec -it tomcat03 cat /etc/hosts127.0.0.1\tlocalhost::1\tlocalhost ip6-localhost ip6-loopbackfe00::0\tip6-localnetff00::0\tip6-mcastprefixff02::1\tip6-allnodesff02::2\tip6-allrouters#发现tomcat2直接被写在这里172.18.0.3\ttomcat02 cff25f666b32172.18.0.4\t80ed9c4e1f94\n\n所以这里其实就是配置了一个 hosts 地址而已！\n原因：--link 的时候，直接把需要 link 的主机的域名和 ip 直接配置到了 hosts 文件中了\n--link 早都过时了，我们不推荐使用！我们可以使用自定义网络的方式\n自定义网络基本概念指令列表\n[root@VM-0-6-centos ~]# docker network --helpUsage:  docker network COMMANDManage networksCommands:  connect     Connect a container to a network  create      Create a network  disconnect  Disconnect a container from a network  inspect     Display detailed information on one or more networks  ls          List networks  prune       Remove all unused networks  rm          Remove one or more networksRun &#x27;docker network COMMAND --help&#x27; for more information on a command.\n\n查看所有网络\n[root@VM-0-6-centos ~]# docker network lsNETWORK ID     NAME      DRIVER    SCOPE4b873066daf7   bridge    bridge    local86da632adad6   elastic   bridge    local64b606f257e7   host      host      local34ab4fdb73c0   none      null      local\n\n所有网路模式\n\n\n\n网络模式\n配置\n说明\n\n\n\nbridge模式\n–net&#x3D;bridge\n默认值，在 Docker 网桥 docker0 上为容器创建新的网络栈\n\n\nnone模式\n–net&#x3D;none\n不配置网络，用户可以稍后进入容器，自行配置\n\n\ncontainer 模式\n– net&#x3D;container:name&#x2F;id\n容器和另外一个容器共享Network namespace。 kubernetes中的pod就是多个容器共享一个Network namespace。\n\n\nhost模式\n–net&#x3D;host\n容器和宿主机共享Network namespace\n\n\n用户自定义\n–net&#x3D;自定义网络\n用户自己使用network相关命令定义网络，创建容器的 时候可以指定为自己定义的网络，就像 elastic\n\n\n查看一个具体的网络的详细信息\n[root@VM-0-6-centos ~]# docker network inspect 4b873066daf7[    &#123;        &quot;Name&quot;: &quot;bridge&quot;,        &quot;Id&quot;: &quot;4b873066daf7eca3fd7a79ce17b46dff17a89368cb7f43d01c88dd9ee08d9407&quot;,        &quot;Created&quot;: &quot;2021-06-11T18:42:36.937993641+08:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: &#123;            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: null,            &quot;Config&quot;: [                &#123;                //默认 docker0 是管理这个子网范围内的。0~16，                //也就是 255*255，去掉0个255，我们有65534可以分配的ip                //所以 docker0 网络默认可以支持创建6万多个容器ip不重复                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;                &#125;            ]        &#125;,        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Ingress&quot;: false,        &quot;ConfigFrom&quot;: &#123;            &quot;Network&quot;: &quot;&quot;        &#125;,        &quot;ConfigOnly&quot;: false,        &quot;Containers&quot;: &#123;            &quot;220fac5f16f3cf7f2619131502cb6bb4004f334c3b501a0ceff8804c361cf027&quot;: &#123;                &quot;Name&quot;: &quot;tomcat01&quot;,                &quot;EndpointID&quot;: &quot;d54c9b71aff1843c3a1609de8eaa85785ebddd8a419ea5fae346fb538568946f&quot;,                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,                &quot;IPv6Address&quot;: &quot;&quot;            &#125;,            &quot;80ed9c4e1f9428598a91c727ed13b7d0534d86d569855d4fb8739baabe5d6b91&quot;: &#123;                &quot;Name&quot;: &quot;tomcat03&quot;,                &quot;EndpointID&quot;: &quot;a6dd8dd8ba2b5b341cbed8318a2463a4e28f1059cc848504a409fbf75ae21f4f&quot;,                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:04&quot;,                &quot;IPv4Address&quot;: &quot;172.18.0.4/16&quot;,                &quot;IPv6Address&quot;: &quot;&quot;            &#125;,            &quot;cff25f666b32df808923a51e14f2f2686fc9aff161e07c188c28ce15d0b38401&quot;: &#123;                &quot;Name&quot;: &quot;tomcat02&quot;,                &quot;EndpointID&quot;: &quot;b5b18a038166b64a0308cc4a506f543b92d35b9fc50f5758f8d5daccc1df87bd&quot;,                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:03&quot;,                &quot;IPv4Address&quot;: &quot;172.18.0.3/16&quot;,                &quot;IPv6Address&quot;: &quot;&quot;            &#125;        &#125;,        &quot;Options&quot;: &#123;            &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;,            &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;,            &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,            &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;,            &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;,            &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot;        &#125;,        &quot;Labels&quot;: &#123;&#125;    &#125;]\n\n自定义网卡1、先删除之前创建的 tomcat 镜像以及容器\ndocker rm -f $(docker ps -aq)\n\n2、创建容器\n但是我们知道默认创建的容器都是 docker0 网卡的\n#默认我们不配置网络，也就相当于默认值 --net bridge 使用的docker0docker run -d -P --name tomcat01 --net bridge tomcat\n\ndocker0网络的特点\n\n它是默认的 \n\n域名访问不通 \n\n–link 域名通了，但是删了又不行\n\n\n3、我们可以让容器创建的时候使用自定义网络\n自定义创建的默认default “bridge” 一个网络\ndocker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet\n\n[root@VM-0-6-centos ~]# docker network lsNETWORK ID     NAME      DRIVER    SCOPE4b873066daf7   bridge    bridge    local64b606f257e7   host      host      local7f9fbfea6931   mynet     bridge    local34ab4fdb73c0   none      null      local\n\n[root@VM-0-6-centos ~]# docker network inspect mynet[    &#123;        &quot;Name&quot;: &quot;mynet&quot;,        &quot;Id&quot;: &quot;7f9fbfea6931271e917c7a932c47d05f311f2fe6f1e694b95e4ef3fcf060446e&quot;,        &quot;Created&quot;: &quot;2021-06-16T15:56:58.841772626+08:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: &#123;            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: &#123;&#125;,            &quot;Config&quot;: [                &#123;                    &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;,                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;                &#125;            ]        &#125;,        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Ingress&quot;: false,        &quot;ConfigFrom&quot;: &#123;            &quot;Network&quot;: &quot;&quot;        &#125;,        &quot;ConfigOnly&quot;: false,        &quot;Containers&quot;: &#123;&#125;,        &quot;Options&quot;: &#123;&#125;,        &quot;Labels&quot;: &#123;&#125;    &#125;]\n\n我们来启动两个容器测试，使用自己的 mynet\ndocker run -d -P --name tomcat-net-01 --net mynet tomcatdocker run -d -P --name tomcat-net-02 --net mynet tomcat\n\n来测试ping容器名和ip试试\n# 都可以ping通[root@VM-0-6-centos ~]# docker exec -it tomcat-net-01 ping 192.168.0.3PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.118 ms[root@VM-0-6-centos ~]# docker exec -it tomcat-net-01 ping tomcat-net-02PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.059 ms\n\n发现，我们自定义的网络docker都已经帮我们维护好了对应的关系\n所以我们平时都可以这样使用网络，不使用 --link 效果一样，所有东西实时维护好，直接域名 ping 通。\n网络连通\ndocker0和自定义网络肯定不通，我们使用自定义网络的好处就是网络隔离：\n大家公司项目部署的业务都非常多，假设我们有一个商城，我们会有订单业务（操作不同数据），会有订单业务购物车业务（操作不同缓存）。如果在一个网络下，有的程序猿的恶意代码就不能防止了，所以我们就在部署的时候网络隔离，创建两个桥接网卡，比如订单业务（里面的数据库，redis，mq，全部业务都在 order-net 网络下）其他业务在其他网络。\n那关键的问题来了，如何让 tomcat-net-01 访问 tomcat1？\n# 启动默认的容器，在docker0网络下docker run -d -P --name tomcat01 tomcatdocker run -d -P --name tomcat02 tomcat\n\n有个命令 connect 用来连接网络\n# 我们来测试一下！打通mynet-docker0[root@VM-0-6-centos ~]# docker network connect mynet tomcat01[root@VM-0-6-centos ~]# docker network inspect mynet[    &#123;        &quot;Name&quot;: &quot;mynet&quot;,        &quot;Id&quot;: &quot;7f9fbfea6931271e917c7a932c47d05f311f2fe6f1e694b95e4ef3fcf060446e&quot;,        &quot;Created&quot;: &quot;2021-06-16T15:56:58.841772626+08:00&quot;,        &quot;Scope&quot;: &quot;local&quot;,        &quot;Driver&quot;: &quot;bridge&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: &#123;            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: &#123;&#125;,            &quot;Config&quot;: [                &#123;                    &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;,                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;                &#125;            ]        &#125;,        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Ingress&quot;: false,        &quot;ConfigFrom&quot;: &#123;            &quot;Network&quot;: &quot;&quot;        &#125;,        &quot;ConfigOnly&quot;: false,        &quot;Containers&quot;: &#123;            &quot;52395d45d1fcad0170da201db471ea6ac75c25c9f7d91d10b6260dce2739fd54&quot;: &#123;                &quot;Name&quot;: &quot;tomcat-net-01&quot;,                &quot;EndpointID&quot;: &quot;3c1aea820c4276b0d0dbe249ebd6f43547baceb7c3e774f8ee4b61b0e4b0b11f&quot;,                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;,                &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;,                &quot;IPv6Address&quot;: &quot;&quot;            &#125;,            //发现我们的tomcat01就进来这里了            &quot;c159a99201d5b3f0f6be065d562c1a0e6439b316084361937f9eda9a22e997ab&quot;: &#123;                &quot;Name&quot;: &quot;tomcat01&quot;,                &quot;EndpointID&quot;: &quot;e11948dcd704e50b8008ee41546ff7c9f506b636f41fb6e6697081fd9d398dc5&quot;,                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:04&quot;,                &quot;IPv4Address&quot;: &quot;192.168.0.4/16&quot;,                &quot;IPv6Address&quot;: &quot;&quot;            &#125;,            &quot;f2106d157b5ea6c5bdb87e04b9dc18be2b2e25a41d61e25851ea0afbf1e9ea39&quot;: &#123;                &quot;Name&quot;: &quot;tomcat-net-02&quot;,                &quot;EndpointID&quot;: &quot;3cb8b199df4fca69e1a6428ae0536ff3291f9215f8b9d9303a2ec3402bdc704f&quot;,                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;,                &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;,                &quot;IPv6Address&quot;: &quot;&quot;            &#125;        &#125;,        &quot;Options&quot;: &#123;&#125;,        &quot;Labels&quot;: &#123;&#125;    &#125;]\n\n tomcat01 可以ping通了\n[root@VM-0-6-centos ~]# docker exec -it tomcat01 ping tomcat-net-01PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.075 ms\n\ntomcat02 依旧ping不通，大家应该就理解了\n[root@VM-0-6-centos ~]#  docker exec -it tomcat02 ping tomcat-net-01ping: tomcat-net-01: Name or service not known\n\n结论：如果要跨网络操作别人，就需要使用 docker network connect [OPTIONS] NETWORK CONTAINER 连接\n部署 Redis 集群创建网卡\ndocker network create redis --subnet 172.38.0.0/16\n\n通过脚本创建六个redis配置\nfor port in $(seq 1 6); \\do \\mkdir -p /mydata/redis/node-$&#123;port&#125;/conftouch /mydata/redis/node-$&#123;port&#125;/conf/redis.confcat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1$&#123;port&#125;cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdone\n\n启动6个容器\nfor port in $(seq 1 6); \\do \\docker run -p 637$&#123;port&#125;:6379 -p 1637$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \\-v /mydata/redis/node-$&#123;port&#125;/data:/data \\-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf; \\done\n\n进入一个redis，注意这里是 sh命令\ndocker exec -it redis-1 /bin/sh\n\n创建集群\nredis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1\n\n连接集群\nredis-cli -c\n\n# 查看集群信息cluster info# 查看节点cluster nodes\n\n此时，六个 redis 已搭建好\n\n测试集群\n\n先 set 一个数据\n127.0.0.1:6379&gt; set name zhiyuan-&gt; Redirected to slot [5798] located at 172.38.0.12:6379OK172.38.0.12:6379&gt; get name&quot;zhiyuan&quot;\n\n停止到存值的容器 redis-1\n然后再次 get name，发现依旧可以获取值\n查看节点，发现高可用完全没问题\n","tags":["Docker"]},{"title":"Docker之DockerFile","url":"/2022/08/16/Docker%E4%B9%8BDockerFile/","content":"大家想想，Nginx，tomcat，mysql 这些镜像都是哪里来的？官方能写，我们不能写吗？\n我们要研究自己如何做一个镜像，而且我们写的微服务项目以及 springboot 打包上云部署，Docker就是最方便的。\n微服务打包成镜像，任何装了Docker的地方，都可以下载使用，极其的方便。\n流程：开发应用&#x3D;&gt;DockerFile&#x3D;&gt;打包为镜像&#x3D;&gt;上传到仓库（私有仓库，公有仓库）&#x3D;&gt; 下载镜像 &#x3D;&gt; 启动 运行。\n还可以方便移植！\n什么是 DockerFiledockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本\n构建步骤：\n1、编写DockerFile文件 \n2、docker build 构建镜像 \n3、docker run\n查看之前拉取的 centos ：https://hub.docker.com/_/centos\n\n查看Dockerfile 文件\n\nDockerFile 构建过程基础知识：\n1、每条保留字指令都必须为大写字母且后面要跟随至少一个参数\n2、指令按照从上到下，顺序执行\n3、# 表示注释\n4、每条指令都会创建一个新的镜像层，并对镜像进行提交\n流程：\n1、docker从基础镜像运行一个容器\n2、执行一条指令并对容器做出修改\n3、执行类似 docker commit 的操作提交一个新的镜像层\n4、Docker再基于刚提交的镜像运行一个新容器\n5、执行dockerfile中的下一条指令直到所有指令都执行完成！\n说明：\n从应用软件的角度来看，DockerFile，docker镜像 与 docker容器 分别代表软件的三个不同阶段。\n\nDockerFile 是软件的原材料 （代码）\nDocker 镜像则是软件的交付品 （.apk）\nDocker 容器则是软件的运行状态 （客户下载安装执行）\n\nDockerFile 面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可！\n\nDockerFile：需要定义一个DockerFile，DockerFile定义了进程需要的一切东西。DockerFile涉及的内容 包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进 程和内核进程（当引用进行需要和系统服务和内核进程打交道，这时需要考虑如何设计 namespace的权 限控制）等等。\nDocker镜像：在DockerFile 定义了一个文件之后，Docker build 时会产生一个Docker镜像，当运行 Docker 镜像时，会真正开始提供服务；\nDocker容器：容器是直接提供服务的。\nDockerFile 指令\n\n\n关键字\n说明\n\n\n\nFROM\n基础镜像，当前新镜像是基于哪个镜像的\n\n\nMAINTAINER\n镜像维护者的姓名混合邮箱地址\n\n\nRUN\n容器构建时需要运行的命令\n\n\nEXPOSE\n当前容器对外保留出的端口\n\n\nWORKDIR\n指定在创建容器后，终端默认登录的进来工作目录，一个落脚点\n\n\nENV\n用来在构建镜像过程中设置环境变量\n\n\nADD\n将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包\n\n\nCOPY\n类似ADD，拷贝文件和目录到镜像中！\n\n\nVOLUME\n容器数据卷，用于数据保存和持久化工作\n\n\nCMD\n指定一个容器启动时要运行的命令，dockerFile中可以有多个CMD指令，但只有最后一个生效！\n\n\nENTRYPOINT\n指定一个容器启动时要运行的命令！和CMD一样\n\n\nONBUILD\n当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后，父镜像的 ONBUILD被触发\n\n\n\n\nCMD 和 ENTRYPOINT 的区别我们之前说过，两个命令都是指定一个容器启动时要运行的命令\n\nCMD\nDockerfile 中可以有多个CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换！\n\nENTRYPOINT\ndocker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合！\n\n\n\n测试 CMD 命令\n\n1、编写文件\n[root@VM-0-6-centos dockerfile-test]# vim dockerfile-cmd-test[root@VM-0-6-centos dockerfile-test]# cat dockerfile-cmd-testFROM centos CMD [ &quot;ls&quot;, &quot;-a&quot; ]\n\n2、构建并运行\ndocker build -f dockerfile-cmd-test -t cmdtest .docker run cmdtest\n\n3、如果我们希望用 -l 列表展示信息，我们就需要加上 -l参数\n[root@VM-0-6-centos dockerfile-test]#  docker run cmdtest -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: exec: &quot;-l&quot;: executable file not found in $PATH: unknown.\n\n问题：我们可以看到可执行文件找不到的报错，executable file not found。\n之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。\n因此这里的 -l 替换了原来的 CMD，而不是添加在原来的 ls -a 后面。\n而 -l 根本不是命令，所以自然找不到。\n那么如果我们希望加入 -l 这参数，我们就必须重新完整的输入这个命令：\ndocker run cmdtest ls -al\n\n\n测试 ENTRYPOINT 命令\n\n1、编写文件\n[root@VM-0-6-centos dockerfile-test]# vim dockerfile-entrypoint-test[root@VM-0-6-centos dockerfile-test]# cat dockerfile-entrypoint-testFROM centosENTRYPOINT [ &quot;ls&quot;, &quot;-a&quot; ]\n\n2、构建并运行\ndocker build -f dockerfile-entrypoint-test -t entrypointtest .docker run entrypointtest\n\n3、测试 -l 参数，发现可以直接使用，这里就是一种追加\n我们可以明显的知道 CMD 和 ENTRYPOINT 的区别了\ndocker run entrypointtest -l\n\n实战测试CentOS官方默认的 CentOS 的情况不支持 vim 和 ifconfig 指令\n我们自己构建一个支持这些指令的镜像\n1、编写文件\n[root@VM-0-6-centos home]# cd dockerfile-test[root@VM-0-6-centos dockerfile-test]# lsmy-centos[root@VM-0-6-centos dockerfile-test]# cat my-centosFROM centosMAINTAINER zhiyuan&lt;oddfar@163.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;----end-----&quot;CMD /bin/bash\n\n2、构建\n命令最后有一个 . 表示当前目录\ndocker build -f my-centos -t mycentos:1.1 .\n\n3、运行\ndocker run -it mycentos:1.1\n\n测试后，可以看到，我们自己的新镜像已经支持 vim 和 ifconfig的命令了\n\n列出镜像的变更历史：\ndocker history 镜像名\\镜像id\n\n\nTomcat步骤：\n\n将 JDK 和 tomcat 安装的压缩包拷贝/home/build 目录下\n下载地址：\n链接：https://pan.baidu.com/s/1QZEmvAgyh4-8DbebVz7koQ \n提取码：spfo \n\n新建一个 read.txt 文件\n\n新建一个 Dockerfile 文件\n\n\n[root@VM-0-6-centos home]# cd build[root@VM-0-6-centos build]# lsapache-tomcat-9.0.46.tar.gz  Dockerfile  jdk-8u11-linux-x64.tar.gz  read.txt  tomcat\n\nDockerfile  内容\nFROM centosMAINTAINER zhiyuan&lt;test@qq.com&gt;#把宿主机当前上下文的read.txt拷贝到容器/usr/local/路径下COPY read.txt /usr/local/cincontainer.txt#把java与tomcat添加到容器中ADD jdk-8u11-linux-x64.tar.gz /usr/local/ADD apache-tomcat-9.0.46.tar.gz /usr/local/#安装vim编辑器RUN yum -y install vim#变量ENV MYPATH /usr/local#设置工作访问时候的WORKDIR路径，登录落脚点WORKDIR $MYPATH#配置java与tomcat环境变量ENV JAVA_HOME /usr/local/jdk1.8.0_11ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.46ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.46ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin#容器运行时监听的端口EXPOSE 8080#启动时运行tomcat# ENTRYPOINT [&quot;/usr/local/apache-tomcat-9.0.46/bin/startup.sh&quot; ]# CMD [&quot;/usr/local/apache-tomcat-9.0.46/bin/catalina.sh&quot;,&quot;run&quot;]CMD /usr/local/apache-tomcat-9.0.46/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.46/bin/logs/catalina.out\n\n构建镜像：\ndocker build -t diytomcat .\n\n在此目录下默认构建 Dockerfile 文件，所以不需要带上文件名\n启动：\ndocker run -d  -p 9090:8080 --name mydiytomcat -v /home/build/tomcat/test:/usr/local/apache-tomcat-9.0.46/webapps/test -v /home/build/tomcat/logs/:/usr/local/apache-tomcat-9.0.46/logs --privileged=true diytomcat\n\n备注：Docker挂载主机目录Docker访问出现cannot open directory Permission denied\n解决办法：在挂载目录后多加一个–privileged&#x3D;true参数即可\n写个测试网站扔到test目录：\nweb.xml\n&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;  version=&quot;4.0&quot;  metadata-complete=&quot;true&quot;&gt;  &lt;display-name&gt;Test&lt;/display-name&gt;&lt;/web-app&gt;\n\na.jsp\n&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\tHello World!&lt;br/&gt;\t&lt;% System.out.println(&quot;-------my docker tomcat-------&quot;);%&gt;&lt;/body&gt;&lt;/html&gt;\n\n查看日志：\n[root@VM-0-6-centos tomcat]# cd logs[root@VM-0-6-centos logs]# cat catalina.out\n\n\n\n总结\n","tags":["Docker"]},{"title":"Docker之IDEA整合Docker","url":"/2022/08/16/Docker%E4%B9%8BIDEA%E6%95%B4%E5%90%88Docker/","content":"创建项目1、使用 IDEA 构建一个 SpringBoot 项目\n2、编写 Controller\n@RestControllerpublic class HelloController &#123;    @GetMapping(&quot;/hello&quot;)    public String hello()&#123;\t    return &quot;hello,world&quot;;    &#125;&#125;\n\n3、打包成 jar 包\n\n打包镜像1、在项目下编写 Dockerfile 文件，将打包好的 jar 包拷贝到 Dockerfile 同级目录，编写 Dockerfile文件\nFROM java:8# 服务器只有dockerfile和jar在同级目录COPY *.jar /app.jarCMD [&quot;--server.port=8080&quot;]# 指定容器内要暴露的端口EXPOSE 8080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]\n\n2、将Dockerfile 和 项目的 jar 包上传到linux服务器上，构建运行\n# 构建镜像docker build -t idea-ks .# 查看镜像docker images# 运行docker run -d -P --name idea-ks idea-ks\n\n最后测试访问\nIDEA安装插件了解即可！以后CI&#x2F;CD，就完全没必要这样做！ \n1、IDEA安装插件\n\n2、配置docker连接集成\n\n3、集成了docker插件就可以在IDEA中操作Docker内部的容器和镜像了，但是很鸡肋这个功能。\n","tags":["Docker"]},{"title":"Docker之安装","url":"/2022/08/16/Docker%E4%B9%8B%E5%AE%89%E8%A3%85/","content":"环境说明我们使用的是 CentOS 7 (64-bit)\nDocker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。\n查看自己的内核： \n用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型 等）。\nuname -r\n\n查看版本信息：\ncat /etc/os-release-------------------------------------------NAME=&quot;CentOS Linux&quot;VERSION=&quot;7 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;7&quot;PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR=&quot;0;31&quot;CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;HOME_URL=&quot;https://www.centos.org/&quot;BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;\n\n安装步骤官网安装参考手册：https://docs.docker.com/engine/install/centos/\n\nyum安装gcc相关环境（需要确保虚拟机可以上外网 ）\n\nyum -y install gccyum -y install gcc-c++\n\n\n卸载旧版本\n\nsudo yum remove docker \\                  docker-client \\                  docker-client-latest \\                  docker-common \\                  docker-latest \\                  docker-latest-logrotate \\                  docker-logrotate \\                  docker-engine\n\n\n安装需要的软件包\n\nsudo yum install -y yum-utils\n\n\n设置镜像仓库\n官网（国外）：\n\n\nsudo yum-config-manager \\    --add-repo \\    https://download.docker.com/linux/centos/docker-ce.repo\n\n   阿里云（推荐）：\nsudo yum-config-manager \\    --add-repo \\\thttp://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n\n更新yum软件包索引\n\nyum makecache fast\n\n  6.安装 Docker CE\nyum install docker-ce docker-ce-cli containerd.io\n\n\n启动 Docker\n\nsystemctl start docker\n\n   至此，已经安装完\n\n查看版本\n\ndocker version\n\n\n查看安装的镜像\n\ndocker images\n\n\n测试运行hello\n\ndocker run hello-world\n\n卸载docker\nsystemctl stop dockeryum -y remove docker-ce docker-ce-cli containerd.iorm -rf /var/lib/docker\n\n阿里云镜像加速1、介绍：https://www.aliyun.com/product/acr \n2、注册一个属于自己的阿里云账户(可复用淘宝账号) \n3、进入管理控制台设置密码，开通 \n4、查看镜像加速器自己的\n\n5、配置镜像加速\nsudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [&quot;https://cbl6xdl3.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker\n\n\n测试 HelloWorld\n\n启动hello-world\ndocker run hello-world\n\nrun干了什么？\n\n底层原理\nDocker是怎么工作的\n\nDocker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们 前面说到的集装箱。\n\n\n为什么Docker比较 VM 快\n\n1、docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在 docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。 \n2、docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机 一样重新加载一个操作系统内核。从而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建 一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主 机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。\n\n","tags":["Docker"]},{"title":"Docker之Swarm及其他命令","url":"/2022/08/17/Docker%E4%B9%8BSwarm%E5%8F%8A%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/","content":"Docker Swarm集群 \n购买服务器\n4台服务器 2G！\n\n\n\n\n到此，服务器购买完毕！1主，3从！\n四台机器安装docker和我们单机安装一样\n技巧： xshell直接同步操作，省时间！\n工作模式\n搭建集群\n\n私网、公网！ 172.24.82.149 用自己的！\n\n初始化结点docker swarm init\ndocker swarm join 加入一个结点！\n# 获取令牌docker swarm join-token managerdocker swarm join-token worker\n\n[root@iZ2ze58v8acnlxsnjoulk6Z ~]# docker swarm join --token SWMTKN-1-3vovnwb5pkkno2i3u2a42yrxc1dk51zxvto5hrm4asgn37syfn-0xkrprkuyyhrx7cidg381pdir 172.16.250.97:2377This node joined a swarm as a worker.\n\n把后面的结点都搭建进去\n\n100台！\n\n生成主节点init\n加入（管理者，worker）\n\nRaft协议双主双从：假设一个结点挂了！其他结点是否可以用！\nRaft协议：保证大多数结点存活才可以使用，只要&gt;1, 集群至少大于3台！\n实验：\n1、将docker1机器停止。宕机！双主，另外一个结点也不能使用了！\n\n2、可以将其他节点离开docker swarm leave\n\n3、worker就是工作的，管理结点操作！ 3台结点设置为了管理结点。\n十分简单：集群，可用！ 3个主节点。 &gt; 1台管理结点存活！\nRaft协议：保证大多数结点存活，才可以使用，高可用！\n体会弹性、扩缩容！集群！\n以后告别 docker run！\ndocker-compose up！启动一个项目。单机！\n集群： swarm docker-service\nk8s service\n容器 &#x3D;&gt; 服务！\n容器 &#x3D;&gt; 服务！ &#x3D;&gt; 副本！\nredis &#x3D;&gt; 10个副本！（同时开启10个redis容器）\n体验：创建服务、动态扩容服务、动态更新服务\n\n灰度发布：金丝雀发布！\n\ndocker run 容器启动！ 不具有扩缩容器docker service 服务！ 具有扩缩容器，滚动更新！\n\n查看服务 REPLICAS\n\n动态扩缩容\n[root@iZ2ze58v8acnlxsnjoulk5Z ~]# docker service update --replicas 3 my-nginx1/3: running   [==================================================&gt;] 1/3: running   [==================================================&gt;] 2/3: running   [==================================================&gt;] 3/3: running   [==================================================&gt;] verify: Service converged   [root@iZ2ze58v8acnlxsnjoulk5Z ~]# docker service scale my-nginx=5my-nginx scaled to 5overall progress: 3 out of 5 tasks overall progress: 3 out of 5 tasks overall progress: 3 out of 5 tasks overall progress: 5 out of 5 tasks 1/5: running   [==================================================&gt;] 2/5: running   [==================================================&gt;] 3/5: running   [==================================================&gt;] 4/5: running   [==================================================&gt;] 5/5: running   [==================================================&gt;] verify: Service converged   [root@iZ2ze58v8acnlxsnjoulk5Z ~]# docker service scale my-nginx=1my-nginx scaled to 1overall progress: 1 out of 1 tasks 1/1: running   [==================================================&gt;] verify: Service converged  \n\n服务，集群中任意的节点都可以访问。服务可以有多个副本动态扩缩容实现高可用！ \n弹性、扩缩容！ 10台！ 10000台！ 卖给别人！ 虚拟化！ \n服务的高可用，任何企业，云！\n概念的总结swarm\n集群的管理和编号，docker可以初始化一个swarm集群，其他结点可以加入。（管理，工作者）\nNode\n就是一个docker结点，多个结点就组成了一个网络集群（管理、工作者）\nService\n任务，可以在管理结点或者工作结点来运行。核心，用户访问。\nTask\n容器内的命令、细节任务！\n\n逻辑是不变的。\n \n命令 -&gt; 管理 -&gt; api -&gt; 调度 -&gt; 工作节点（创建Task容器维护创建！）\n\n服务副本与全局服务\n\n\n调整service以什么方式运行\n--mode string                        Service mode (replicated or global) (default &quot;replicated&quot;)docker service create --mode replicated --name mytom tomcat:7 默认的docker service create --mode global  --name haha alpine ping www.baidu.com\n\n拓展： 网络模式 “PublishMode”:”ingress”\nSwarm:\nOverlay:\ningress:特殊的Overlay网络！负载均衡的功能！ipvs vip！\n虽然docker在4台机器上，实际网络是同一个！ ingress 网络 ，是一个特殊的 Overlay 网络\n[root@iZ2ze58v8acnlxsnjoulk5Z ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPE74cecd37149f        bridge              bridge              local168d35c86dd5        docker_gwbridge     bridge              local2b8f4eb9c2e5        host                host                localdmddfc14n7r3        ingress             overlay             swarm8e0f5f648e69        none                null                local  [root@iZ2ze58v8acnlxsnjoulk5Z ~]# docker network inspect ingress[    &#123;        &quot;Name&quot;: &quot;ingress&quot;,        &quot;Id&quot;: &quot;dmddfc14n7r3vms5vgw0k5eay&quot;,        &quot;Created&quot;: &quot;2020-08-17T10:29:07.002315919+08:00&quot;,        &quot;Scope&quot;: &quot;swarm&quot;,        &quot;Driver&quot;: &quot;overlay&quot;,        &quot;EnableIPv6&quot;: false,        &quot;IPAM&quot;: &#123;            &quot;Driver&quot;: &quot;default&quot;,            &quot;Options&quot;: null,            &quot;Config&quot;: [                &#123;                    &quot;Subnet&quot;: &quot;10.0.0.0/24&quot;,                    &quot;Gateway&quot;: &quot;10.0.0.1&quot;                &#125;            ]        &#125;,        &quot;Internal&quot;: false,        &quot;Attachable&quot;: false,        &quot;Ingress&quot;: true,        &quot;ConfigFrom&quot;: &#123;            &quot;Network&quot;: &quot;&quot;        &#125;,        &quot;ConfigOnly&quot;: false,        &quot;Containers&quot;: &#123;            &quot;ingress-sbox&quot;: &#123;                &quot;Name&quot;: &quot;ingress-endpoint&quot;,                &quot;EndpointID&quot;: &quot;9d6ec47ec8309eb209f4ff714fbe728abe9d88f9f1cc7e96e9da5ebd95adb1c4&quot;,                &quot;MacAddress&quot;: &quot;02:42:0a:00:00:02&quot;,                &quot;IPv4Address&quot;: &quot;10.0.0.2/24&quot;,                &quot;IPv6Address&quot;: &quot;&quot;            &#125;        &#125;,        &quot;Options&quot;: &#123;            &quot;com.docker.network.driver.overlay.vxlanid_list&quot;: &quot;4096&quot;        &#125;,        &quot;Labels&quot;: &#123;&#125;,        &quot;Peers&quot;: [            &#123;                &quot;Name&quot;: &quot;cea454a89163&quot;,                &quot;IP&quot;: &quot;172.16.250.96&quot;            &#125;,            &#123;                &quot;Name&quot;: &quot;899a05b64e09&quot;,                &quot;IP&quot;: &quot;172.16.250.99&quot;            &#125;,            &#123;                &quot;Name&quot;: &quot;81d65a0e8c03&quot;,                &quot;IP&quot;: &quot;172.16.250.97&quot;            &#125;,            &#123;                &quot;Name&quot;: &quot;36b31096f7e2&quot;,                &quot;IP&quot;: &quot;172.16.250.98&quot;            &#125;        ]    &#125;]\n\n其他命令学习方式Docker Stackdocker-compose 单机部署项目docker stack 集群部署 # 单机docker-compose up -d wordpress.yaml# 集群docker stack deploy wordpress.yaml\n\nDocker Secret安全！配置密码！证书！ [root@iZ2ze58v8acnlxsnjoulk5Z ~]# docker secret --help Usage:  docker secret COMMAND Manage Docker secrets Commands:  create      Create a secret from a file or STDIN as content  inspect     Display detailed information on one or more secrets  ls          List secrets  rm          Remove one or more secrets\n\nDocker Config配置！[root@iZ2ze58v8acnlxsnjoulk5Z ~]# docker config --help Usage:  docker config COMMAND Manage Docker configs Commands:  create      Create a config from a file or STDIN  inspect     Display detailed information on one or more configs  ls          List configs  rm          Remove one or more configs\n\n","tags":["Docker"]},{"title":"Docker之容器数据卷","url":"/2022/08/16/Docker%E4%B9%8B%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/","content":"什么是数据卷数据卷(Data Volume)\ndocker的理念回顾：\n将应用和运行的环境打包形成容器运行，运行可以伴随着容器，但是我们对于数据的要求，是希望能够 持久化的！\n就好比，你安装一个MySQL，结果你把容器删了，就相当于删库跑路了，这TM也太扯了吧！\n所以我们希望容器之间有可能可以共享数据，Docker容器产生的数据，如果不通过 docker commit 生成新的镜像，使得数据作为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了！这样是行不通的！\n为了能保存数据在Docker中我们就可以使用卷！让数据挂载到我们本地！这样数据就不会因为容器删除而丢失了！\n作用：\n卷就是目录或者文件，存在一个或者多个容器中，由 docker 挂载到容器，但不属于联合文件系统，因此能够绕过 Union File System ， 提供一些用于持续存储或共享数据的特性。\n卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此 Docker 不会在容器删除时删除其挂载的数据卷。\n特点：\n\n数据卷可在容器之间共享或重用数据\n卷中的更改可以直接生效\n数据卷中的更改不会包含在镜像的更新中\n数据卷的生命周期一直持续到没有容器使用它为止\n\n一句话： 就是容器的持久化，以及容器间的继承和数据共享！\n使用数据卷指令 v 方式\n方式一：容器中直接使用命令来添加\n\n在用 docker run 命令的时候，使用 -v 标记来创建一个数据卷并挂载到容器里。\ndocker run -it -v 宿主机绝对路径目录:容器内目录 镜像名\n\n测试：\ndocker run -it -v /home/d-test:/home centos /bin/bash\n\n查看数据卷是否挂载成功 docker inspect 容器id\n[root@VM-0-6-centos ~]# docker psCONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES05fa819084c9   centos    &quot;/bin/bash&quot;   20 seconds ago   Up 20 seconds             friendly_keller[root@VM-0-6-centos ~]#  docker inspect 05fa819084c9\n\n\n\n测试容器和宿主机之间数据共享：可以发现，在容器中，创建的会在宿主机中看到！\n\n容器：\n[root@05fa819084c9 /]# lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  s[root@05fa819084c9 /]# cd home[root@05fa819084c9 home]# ls[root@05fa819084c9 home]# touch test.java\n\n主机：\n[root@VM-0-6-centos ~]# cd /home/d-test[root@VM-0-6-centos d-test]# lstest.java\n\n\n测试容器停止退出后，主机修改数据是否会同步！\n\n\n停止容器 \n在宿主机上修改文件，增加些内容 \n启动刚才停止的容器 \n然后查看对应的文件，发现数据依旧同步！\n\n主机：\n[root@VM-0-6-centos d-test]# lstest.java[root@VM-0-6-centos d-test]# touch new.java[root@VM-0-6-centos d-test]# lsnew.java  test.java\n\n容器：\ndocker ps -a 查看所有容器\n[root@VM-0-6-centos home]# docker start 05fa819084c905fa819084c9[root@VM-0-6-centos home]# docker attach 05fa819084c9[root@05fa819084c9 /]# cd /home[root@05fa819084c9 home]# lsnew.java  test.java\n\n\n安装 mysql 测试\n\n1、安装\ndocker pull mysql:5.7\n\n2、启动容器 ，-e 为环境变量\nmysql 的数据不应该放在容器内，应放主机内！先体验下 -v 挂载卷！\n参考官方文档\ndocker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7\n\n连接 mysql 并创建一个数据库\n[root@VM-0-6-centos data]# mysql -h 127.0.0.1 -P 3310 -u root -pmysql&gt; create database test;Query OK, 1 row affected (0.00 sec)mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || sys                || test               |+--------------------+5 rows in set (0.00 sec)\n\n文件 Docker File 方式\n方式二：通过Docker File 来添加\n\nDockerFile 是用来构建Docker镜像的构建文件，是由一些列命令和参数构成的脚本。\n这里先了解体验一下，后面有详细介绍\n1、编写DockerFile文件\n我们在宿主机 &#x2F;home 目录下新建一个 docker-test-volume文件夹\nmkdir docker-test-volume\n\n出于可移植和分享的考虑，之前使用的 -v 主机目录:容器目录 这种方式不能够直接在 DockerFile 中实现。\n[root@VM-0-6-centos docker-test-volume]# pwd/home/docker-test-volume[root@VM-0-6-centos docker-test-volume]# vim dockerfile1[root@VM-0-6-centos docker-test-volume]# cat dockerfile1FROM centosVOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;]CMD echo &quot;-------end------&quot;CMD /bin/bash\n\n说明：在编写DockerFile文件中使用 VOLUME 来给镜像添加一个或多个数据卷\n2、build生成镜像\nbuild生成镜像，获得一个新镜像 test-centos，注意最后面有个 .\ndocker build -f /home/docker-test-volume/dockerfile1 -t test-centos .\n\n然后启动容器：\ndocker run -it test-centos /bin/bash\n\n通过上述步骤，容器内的卷目录地址就已经知道了，但是对应的主机目录地址在哪里呢？\n3、查看数据目录\n我们在数据卷中新建一个文件\n[root@93343e21a67b /]# cd dataVolumeContainer1[root@93343e21a67b dataVolumeContainer1]# touch container.txt\n\n查看下这个容器的信息\ndocker inspect 93343e21a67b# 查看输出的Volumes&quot;Volumes&quot;: &#123;&quot;/dataVolumeContainer1&quot;: &#123;&#125;,&quot;/dataVolumeContainer2&quot;: &#123;&#125;&#125;,\n\n可以看到挂载的路径\n在主机目录里看到之前在容器里创建的文件\n[root@VM-0-6-centos ~]# cd /var/lib/docker/volumes/7adb0e2e33503b17abfd453fded4b0cd9d9e8b05e064d248dc47de0da6456788/_data[root@VM-0-6-centos _data]# lscontainer.txt\n\n注意：如果访问出现了 cannot open directory: Permission denied\n解决办法：在挂载目录后多加一个 –privileged&#x3D;true参数即可\n匿名和具名挂载匿名挂载-v 容器内路径\ndocker run -d -P --name nginx01 -v /etc/nginx nginx\n\n可通过命令 docker volume ls 查看挂载的列表\n[root@VM-0-6-centos ~]# docker volume lsDRIVER    VOLUME NAMElocal     4d0221bc0d8b9e44fb2e878cd3efcacb9b4bd51c8e135d79c549f7a6345f3a24local     7a1e6924fed1cc5ea6a386d9b2542c0ffc53fada1755bc7d09601274dff6ddd0local     7adb0e2e33503b17abfd453fded4b0cd9d9e8b05e064d248dc47de0da6456788local     adaa3053cb2ff95afc7bab51451f4b1167aa1b9056398ed44b0d4cae9580db52\n\n这些没指定名字的都是匿名挂载，我们 -v 只写了容器内路径，并没写容器外路径\n挂载目录是： /var/lib/docker/volumes/VOLUME-NAME/_data\n匿名挂载的缺点，就是不好维护，不清楚目录挂载的是哪个容器\n具名挂载-v 卷名:/容器内路径\n例如取名为 juming 来挂载\n[root@VM-0-6-centos ~]# docker run -d -P --name nginx02 -v juming:/etc/nginx nginx112f36599f077eada56197c22dd3b3a3eaba2e5bb38bf2cb19adc783163991e7[root@VM-0-6-centos ~]# docker volume lsDRIVER    VOLUME NAMElocal     4d0221bc0d8b9e44fb2e878cd3efcacb9b4bd51c8e135d79c549f7a6345f3a24local     7a1e6924fed1cc5ea6a386d9b2542c0ffc53fada1755bc7d09601274dff6ddd0local     7adb0e2e33503b17abfd453fded4b0cd9d9e8b05e064d248dc47de0da6456788local     adaa3053cb2ff95afc7bab51451f4b1167aa1b9056398ed44b0d4cae9580db52local     juming\n\n查看挂载的目录：docker volume VOLUME-NAME\n[root@VM-0-6-centos ~]# docker volume inspect juming[    &#123;        &quot;CreatedAt&quot;: &quot;2021-06-05T16:32:10+08:00&quot;,        &quot;Driver&quot;: &quot;local&quot;,        &quot;Labels&quot;: null,        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming/_data&quot;,        &quot;Name&quot;: &quot;juming&quot;,        &quot;Options&quot;: null,        &quot;Scope&quot;: &quot;local&quot;    &#125;]# 怎么判断挂载的是卷名而不是本机目录名？不是/开始就是卷名，是/开始就是目录名\n\n挂载操作中，没指定目录名情况下，默认在 /var/lib/docker/volumes/ 目录下\n\n改变文件的读写权限\n\n指定容器对我们挂载出来的内容的读写权限\ndocker run -d -P --name nginx02 -v nginxconfig:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v nginxconfig:/etc/nginx:rw nginx\n\nro: readonly 只读\nrw: readwrite 可读可写\n数据卷容器之前的是主机和容器之间共享数据，那么如何实现容器和容器之间的共享数据呢？\n命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器(Data Volume Container)\n\n 测试容器间传递共享\n\n使用之前的镜像：test-centos 为模板，运行容器 docker01（父容器），docker02，docker03\n他们都会具有容器卷 /dataVolumeContainer1 和 /dataVolumeContainer2\n1、先启动一个父容器docker01，然后在 dataVolumeContainer2 新增文件\n[root@VM-0-6-centos _data]# docker run -it --name docker01 test-centos[root@cd87cb3eb33b /]# ls -ltotal 56lrwxrwxrwx   1 root root    7 Nov  3  2020 bin -&gt; usr/bindrwxr-xr-x   2 root root 4096 Jun  5 08:56 dataVolumeContainer1drwxr-xr-x   2 root root 4096 Jun  5 08:56 dataVolumeContainer2............[root@cd87cb3eb33b /]# cd dataVolumeContainer2[root@cd87cb3eb33b dataVolumeContainer2]# touch docker01.txt\n\n退出且不停止容器运行：ctrl+P+Q\n2、创建docker02，docker03 让他们继承docker01\n可以看到 docker01 创建的文件存在\n[root@VM-0-6-centos _data]# docker run -it --name docker02 --volumes-from docker01 test-centos[root@f81238516f65 /]#  cd dataVolumeContainer2[root@f81238516f65 dataVolumeContainer2]# lsdocker01.txt[root@f81238516f65 dataVolumeContainer2]# touch docker02.txt[root@VM-0-6-centos _data]# docker run -it --name docker03 --volumes-from docker01 test-centos[root@c8c41a2a0831 /]# lsbin  dataVolumeContainer1  dataVolumeContainer2  dev  etc  home  lib  lib64  lost+found  media\tmnt  opt  proc\troot  run  sbin  srv  sys  tmp\tusr  var[root@c8c41a2a0831 /]# cd dataVolumeContainer2[root@c8c41a2a0831 dataVolumeContainer2]# lsdocker01.txt  docker02.txt\n\n3、回到docker01发现可以看到 02 和 03 添加的共享文件\n[root@VM-0-6-centos ~]#  docker attach docker01[root@cd87cb3eb33b dataVolumeContainer2]# ls -ltotal 0-rw-r--r-- 1 root root 0 Jun  5 08:56 docker01.txt-rw-r--r-- 1 root root 0 Jun  5 08:58 docker02.txt-rw-r--r-- 1 root root 0 Jun  5 09:00 docker03.txt\n\n\n删除 docker01 后 ，docker02 修改文件后， docker03 还可以正常共享数据\n删除docker02 ，docker03能访问\n新建docker04继承docker03，然后再删除docker03，可以访问\n\n\n得出结论\n\n容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。 存储在本机的文件则会一直保留！\n","tags":["Docker"]},{"title":"Docker之常用命令","url":"/2022/08/16/Docker%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"帮助命令docker version # 显示 Docker 版本信息。docker info # 显示 Docker 系统信息，包括镜像和容器数。docker --help # 帮助\n\n镜像命令docker images列出本地主机上的镜像\n\n# 解释REPOSITORY             镜像的仓库源TAG                              镜像的标签IMAGE ID                     镜像的IDCREATED                    镜像创建时间SIZE                             镜像大小\n\n# 同一个仓库源可以有多个 TAG，代表这个仓库源的不同版本，我们使用REPOSITORY：TAG 定义不同的镜像，如果你不定义镜像的标签版本，docker将默认使用 lastest 镜像！# 可选项-a：\t\t 列出本地所有镜像-q：\t\t 只显示镜像id--digests： 显示镜像的摘要信息\n\ndocker search搜索镜像：\ndocker search 某个镜像的名称 对应DockerHub仓库中的镜像\ndocker search mysql\n\n可选项：\n列出收藏数不小于指定值的镜像，例如\ndocker search mysql --filter=stars=1000\n\n\n\nNAME: 镜像仓库源的名称\nDESCRIPTION: 镜像的描述\nOFFICIAL: 是否 docker 官方发布\nSTARS: 类似 Github 里面的 star，表示点赞、喜欢的意思。\nAUTOMATED: 自动构建。\n\n也通过Docker Hub 进行查找\n比如https://hub.docker.com/search?q=mysql&amp;type=image\ndocker pull下载镜像\n不写tag，默认是latest\ndocker pull mysql\n\n指定版本下载\ndocker pull mysql:5.7\n\ndocker rmi删除镜像\ndocker rmi -f 镜像id # 删除单个docker rmi -f 镜像名:tag 镜像名:tag # 删除多个\n\n删除全部\ndocker rmi -f $(docker images -qa)\n\n容器命令有镜像才能创建容器，我们这里使用 centos 的镜像来测试，就是虚拟一个 centos ！\ndocker pull centos\n\n容器启动docker run [OPTIONS] IMAGE [COMMAND][ARG...]\n\n常用参数说明\n\n\n\n参数\n说明\n\n\n\n–name&#x3D;”Name”\n给容器指定一个名字之后再对容器操作，可以用这个name，相当于“别名”\n\n\n-d\n后台方式运行容器，并返回容器的id！\n\n\n-i\n以交互模式运行容器，通过和 -t 一起使用\n\n\n-t\n给容器重新分配一个终端，通常和 -i 一起使用\n\n\n-P\n随机端口映射（大写）\n\n\n-p\n指定端口映射（小写），一般可以有四种写法\n\n\n查看镜像：\n\n启动一个容器，使用centos进行用交互模式启动容器，在容器内执行&#x2F;bin&#x2F;bash命令！\ndocker run -it centos /bin/bash\n\n\n退出容器\n容器查看docker ps [OPTIONS]\n\n常用参数说明\n\n\n\n参数\n说明\n\n\n\n-a\n列出当前所有正在运行的容器 + 历史运行过的容器\n\n\n-l\n显示最近创建的容器\n\n\n-n&#x3D;?\n显示最近n个创建的容器\n\n\n-q\n静默模式，只显示容器编号。\n\n\n退出容器\n\n\n指令\n说明\n\n\n\nexit\n容器停止退出\n\n\nctrl+P+Q\n容器不停止退出\n\n\n启动停止容器\n\n\n指令\n说明\n\n\n\ndocker start (容器id or 容器名)\n启动容器\n\n\ndocker restart (容器id or 容器名)\n重启容器\n\n\ndocker stop (容器id or 容器名)\n停止容器\n\n\ndocker kill (容器id or 容器名)\n强制停止容器\n\n\n删除容器\n\n\n指令\n说明\n\n\n\ndocker rm 容器id\n删除指定容器\n\n\ndocker rm -f $(docker ps -a -q)\n删除所有容器\n\n\ndocker ps -a -q|xargs docker rm\n删除所有容器\n\n\n容器再启动\n命令\n\ndocker start id/name\n\n启动之前停止关闭的容器\n后台启动容器docker run -d 容器名\n\n启动centos，使用后台方式启动，例如：\ndocker run -d centos\n\n问题： 使用docker ps 查看，发现容器已经退出了！\n 解释：Docker容器后台运行，就必须有一个前台进程，容器运行的命令如果不是那些一直挂起的命 令，就会自动退出。\n比如，你运行了nginx服务，但是docker前台没有运行应用，这种情况下，容器启动后，会立即自杀，因为他觉得没有程序了，所以最好的情况是，将你的应用使用前台进程的方式运行启动。\n清理停止的容器清理停止的容器: \ndocker container prune\n\n\n查看日志docker logs -f -t --tail 容器id\n\n例子：我们启动 centos，并编写一段脚本来测试玩玩！最后查看日志\ndocker run -d centos /bin/sh -c &quot;while true;do echo hello;sleep 1;done&quot;\n\n\n查看日志：\ndocker logs 容器id\n\n\n\n\n参数\n说明\n\n\n\n-t\n显示时间戳\n\n\n-f\n打印最新的日志\n\n\n–tail\n数字显示多少条！\n\n\ndocker logs -tf --tail 10 87f5e5a2954e\n\n\n\n停止运行\n\ndocker stop 87f5e5a2954e\n\n\n\n查看正在运行容器的进程信息\n\ndocker top 容器id\n\n\n查看容器&#x2F;镜像的元数据\n\ndocker inspect 容器id\n\n\n进入正在运行的容器命令一：\ndocker exec -it 容器id bashShell\n\n例如：\n[root@VM-0-6-centos ~]# docker psCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES[root@VM-0-6-centos ~]# docker run -d centos /bin/sh -c &quot;while true;do echo hello;sleep 1;done&quot;a9b967bdbc870bb039b69c76ddc3d3ce6aa87d57c51a8040e32224fb45576b28[root@VM-0-6-centos ~]# docker psCONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMESa9b967bdbc87   centos    &quot;/bin/sh -c &#x27;while t…&quot;   8 seconds ago   Up 7 seconds             upbeat_haibt[root@VM-0-6-centos ~]# docker exec -it a9b967bdbc87 /bin/bash[root@a9b967bdbc87 /]# ps -efUID        PID  PPID  C STIME TTY          TIME CMDroot         1     0  0 10:01 ?        00:00:00 /bin/sh -c while true;do echo hello;sleep 1;doneroot        37     0  0 10:02 pts/0    00:00:00 /bin/bashroot        59     1  0 10:02 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1root        60    37  0 10:02 pts/0    00:00:00 ps -ef\n\n退出容器终端，不会导致容器的停止\n[root@a9b967bdbc87 /]# exitexit[root@VM-0-6-centos ~]# docker psCONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMESa9b967bdbc87   centos    &quot;/bin/sh -c &#x27;while t…&quot;   7 minutes ago   Up 7 minutes             upbeat_haibt\n\n命令二：\ndocker attach 容器id\n\n测试：\n[root@VM-0-6-centos ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED        SIZEhello-world   latest    d1165f221234   2 months ago   13.3kBcentos        latest    300e315adb2f   5 months ago   209MB[root@VM-0-6-centos ~]# docker  run -it -d  centos /bin/bash7f9ead6f906b3c691d29866236414e1808d194462ed0839c8ee5c947d731ed57[root@VM-0-6-centos ~]# docker psCONTAINER ID   IMAGE     COMMAND       CREATED          STATUS         PORTS     NAMES7f9ead6f906b   centos    &quot;/bin/bash&quot;   10 seconds ago   Up 9 seconds             nervous_mcclintock[root@VM-0-6-centos ~]# docker attach 7f9ead6f906b[root@7f9ead6f906b /]# echo &quot;hello&quot;hello[root@7f9ead6f906b /]# exitexit[root@VM-0-6-centos ~]# docker psCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES[root@VM-0-6-centos ~]# \n\n区别 ：\n\nexec 是在容器中打开新的终端，并且可以启动新的进程 \n\nattach 直接进入容器启动命令的终端，不会启动新的进程\n\n\n推荐大家使用 docker exec 命令，\n容器内拷贝文件到主机上docker cp 容器id:容器内路径 目的主机路径\n\n例如：\ndocker cp 7f9ead6f906b:/home/f1 /home\n\n\n\n常用命令总结\n\n\n\n命令\n官方说明\n解释\n\n\n\nattach\nAttach local standard input, output, and error streams to a running container\n当前 shell 下 attach 连接指定运行镜像\n\n\nbuild\nBuild an image from a Dockerfile\n通过 Dockerfile 定制镜像\n\n\ncommit\nCreate a new image from a container’s changes\n提交当前容器为新的镜像\n\n\ncp\nCopy files&#x2F;folders between a container and the local filesystem\n从容器中拷贝指定文件或者目录到宿主机中\n\n\ncreate\nCreate a new container\n创建一个新的容器，同 run，但不启动容器\n\n\ndiff\nInspect changes to files or directories on a container’s filesystem\n查看 docker 容器变化\n\n\nevents\nGet real time events from the server\n从 docker 服务获取容 器实时事件\n\n\nexec\nRun a command in a running container\n在已存在的容器上运行命令\n\n\nexport\nExport a container’s filesystem as a tar archive\n导出容器的内 容流作为一个 tar 归档文件[对应 import ]\n\n\nhistory\nShow the history of an image\n展示一个镜像形成历史\n\n\nimages\nList images\n列出系统当前镜像\n\n\nimport\nImport the contents from a tarball to create a filesystem image\n从 tar包中的内容创建一个新的文件系统映像[对应export]\n\n\ninfo\nDisplay system-wide information\n显示系统相关信息\n\n\ninspect\nReturn low-level information on Docker objects\n查看容器详细信息\n\n\nkill\nKill one or more running containers\n杀掉 指定 docker 容器\n\n\nload\nLoad an image from a tar archive or STDIN\n从一个 tar 包中加载一 个镜像[对应 save]\n\n\nlogin\nLog in to a Docker registry\n登陆一个 docker 源服务器\n\n\nlogout\nLog out from a Docker registry\n从当前 Docker registry 退出\n\n\nlogs\nFetch the logs of a container\n输出当前容器日志信息\n\n\npause\nPause all processes within one or more containers\n暂停容器\n\n\nport\nList port mappings or a specific mapping for the container\n查看映射端口对应的容器内部源端口\n\n\nps\nList containers\n列出容器列表\n\n\npull\nPull an image or a repository from a registry\n从docker镜像源服务器拉取指定镜像或者库镜像\n\n\npush\nPush an image or a repository to a registry\n推送指定镜像或者库镜像至docker源服务器\n\n\nrename\nRename a container\n给一个容器改名\n\n\nrestart\nRestart one or more containers\n重启运行的容器\n\n\nrm\nRemove one or more containers\n移除一个或者多个容器\n\n\nrmi\nRemove one or more images\n移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\n\n\nrun\nRun a command in a new container\n创建一个新的容器并运行 一个命令\n\n\nsave\nSave one or more images to a tar archive (streamed to STDOUT by default)\n保存一个镜像为一个 tar 包[对应 load]\n\n\nsearch\nSearch the Docker Hub for images\n在 docker hub 中搜 索镜像\n\n\nstart\nStart one or more stopped containers\n启动容器\n\n\nstats\nDisplay a live stream of container(s) resource usage statistics\n显示容器资源使用统计信息的实时信息\n\n\nstop\nStop one or more running containers\n停止容器\n\n\ntag\nCreate a tag TARGET_IMAGE that refers to SOURCE_IMAGE\n给源中镜像打标签\n\n\ntop\nDisplay the running processes of a container\n查看容器中运行的进程信 息\n\n\nunpause\nUnpause all processes within one or more containers\n取消暂停容器\n\n\nupdate\nUpdate configuration of one or more containers\n更新容器配置\n\n\nversion\nShow the Docker version information\n查看 docker 版本号\n\n\nwait\nBlock until one or more containers stop, then print their exit codes\n截取容器停止时的退出状态值\n\n\n","tags":["Docker"]},{"title":"Docker之练习和可视化","url":"/2022/08/16/Docker%E4%B9%8B%E7%BB%83%E4%B9%A0%E5%92%8C%E5%8F%AF%E8%A7%86%E5%8C%96/","content":"练习安装nginx1.搜索镜像：\n$docker search nginx\n\n2.拉取镜像：\n$ docker pull nginx\n\n3.启动容器：\n-d  后台启动\ndocker run -d --name mynginx -p 3500:80 nginx\n\n4.进入容器：\n[root@VM-0-6-centos ~]# docker exec -it mynginx /bin/bash# 寻找nginxroot@511741b161de:/# whereis nginxnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginxroot@511741b161de:/# cd /usr/share/nginxroot@511741b161de:/usr/share/nginx# lshtmlroot@511741b161de:/usr/share/nginx# cd htmlroot@511741b161de:/usr/share/nginx/html# ls50x.html  index.html#可看到之前访问的内容是 index.htmlroot@511741b161de:/usr/share/nginx/html# cat index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;    body &#123;        width: 35em;        margin: 0 auto;        font-family: Tahoma, Verdana, Arial, sans-serif;    &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n\n安装tomcat在 docker hub 官网搜索 tomcat：https://hub.docker.com/_/tomcat\n# 官方文档解释# -it ：交互模式# --rm：容器启动成功并退出以后容器就自动移除，一般在测试情况下使用！docker run -it --rm tomcat:9.0\n\n1、下载tomcat镜像：\ndocker pull tomcat\n\n2、启动\ndocker run -d -p 8080:8080 --name tomcat9 tomcat\n\n3、进入tomcat\ndocker exec -it tomcat9 /bin/bash\n\n进入后发现，webapps 里什么也没有\nroot@a1801a340333:/usr/local/tomcat# lsBUILDING.txt  CONTRIBUTING.md  LICENSE\tNOTICE\tREADME.md  RELEASE-NOTES  RUNNING.txt  bin  conf  lib  logs  native-jni-lib  temp  webapps  webapps.dist  workroot@a1801a340333:/usr/local/tomcat# cd webappsroot@a1801a340333:/usr/local/tomcat/webapps# lsroot@a1801a340333:/usr/local/tomcat/webapps# \n\n若部署一个 jsp 网站，需要把文件复制到容器里，非常麻烦。\n我们可以通过“数据卷”技术，将容器内文件和我们 Linux 文件进行映射挂载。\n部署ElasticSearch官网：https://hub.docker.com/_/elasticsearch\n# 我们启动es这种容器需要考虑几个问题1、端口暴露问题 9200、93002、数据卷的挂载问题 data、plugins、conf3、吃内存 - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;# 扩展命令docker stats 容器id # 查看容器的cpu内存和网络状态\n\n1、启动：\ndocker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2\n\n2、查看状态\n# 启动之后很卡，使用 docker stats 容器id 查看下cpu状态 ，发现占用的很大docker stats 容器id \n\n3、增加上内存限制启动\ndocker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2\n\n启动时，报错：名字已经存在\n可通过指令删除\n\ndocker rm  name_of_the_docker_container\n\ndocker rm elasticsearch\n\n我们可通过 docker ps -a  显示所有容器信息\n再次启动后，发现内存变小了\n访问成功：\n[root@VM-0-6-centos ~]# curl localhost:9200&#123;  &quot;name&quot; : &quot;d49fb1463f0a&quot;,  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,  &quot;cluster_uuid&quot; : &quot;ycGNdXS0TpC2lcOfIFlPkQ&quot;,  &quot;version&quot; : &#123;    &quot;number&quot; : &quot;7.6.2&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;docker&quot;,    &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;,    &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;8.4.0&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;  &#125;,  &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;\n\n关于名字的作用：\n以后我们想启动上次配置的 ElasticSearch，用  docker start 容器名字 即可，不需要在重新配置\n[root@VM-0-6-centos ~]# docker start elasticsearchelasticsearch[root@VM-0-6-centos ~]# docker psCONTAINER ID   IMAGE                 COMMAND                  CREATED             STATUS         PORTS                                                                                  NAMESd49fb1463f0a   elasticsearch:7.6.2   &quot;/usr/local/bin/dock…&quot;   About an hour ago   Up 5 seconds   0.0.0.0:9200-&gt;9200/tcp, :::9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp, :::9300-&gt;9300/tcp   elasticsearch[root@VM-0-6-centos ~]# \n\n如果我们要使用 kibana , 如果配置连接上我们的es呢？网络该如何配置呢？\n\n可视化Portainer是Docker的图形化管理工具，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷 的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm集群和 服务等集中管理和操作、登录用户管理和控制等功能。功能十分全面，基本能满足中小型单位对容器管理的全部需求。\n如果仅有一个docker宿主机，则可使用单机版运行，Portainer单机版运行十分简单，只需要一条语句即可启动容器，来管理该机器上的 docker 镜像、容器等数据。\n\n安装并运行Portainer：\n\ndocker run -d -p 8088:9000 \\--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer\n\n\n访问：\n\nhttp://IP:8088\n首次加载比较慢，且登陆需要注册用户，给admin用户设置密码：\n\n单机版这里选择local即可，选择完毕，点击Connect即可连接到本地docker：\n\n\n也可以使用这个Rancher（CI&#x2F;CD再用这个）\n\n#安装rancher-serverdocker run --name rancher-server -p 8000:8080 -v/etc/localtime:/etc/localtime:ro -d rancher/server#安装agentdocker run --rm --privileged -v /var/run/docker.sock:/var/run/docker.sock -v/var/lib/rancher:/var/lib/rancher rancher/agent:v1.2.11http://39.101.191.131:8000/v1/scripts/D3DBD43F263109BB881F:1577750400000:7M0yBzCw4XSxJklD7TpysYIpI\n\n","tags":["Docker"]},{"title":"Docker之概述","url":"/2022/08/16/Docker%E4%B9%8B%E6%A6%82%E8%BF%B0/","content":"Docker为什么出现一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要 关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员是极大的考验！ \n环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题， 软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。解决开发人员说的“ 在我的机器上可正常工作”的问题。 \n之前在服务器配置一个应用的运行环境，要安装各种软件，就拿一个基本的工程项目的环境来说吧， Java&#x2F;Tomcat&#x2F;MySQL&#x2F;JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。 \n传统上认为，软件编码开发&#x2F;测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码文件 等（Java为例）。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得 以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。 \nDocker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。 \nDocker镜像的设计，使得Docker得以打破过去「程序即应用」的观念。通过Docker镜像 ( images ) 将应用程序所需要的系统环境，由下而上打包，达到应用程序跨平台间的无缝接轨运作。\n\nDocker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并 且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水 果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他 们都运走。 docker就是类似的理念。\n\n历史\n\n2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。\n这家公司主要提供基于PaaS的云计算技术服务。具体来说，是和LXC有关的容器技术。\n后来，dotCloud公司将自己的容器技术进行了简化和标准化，并命名为——Docker。\nDocker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。\n正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。\n什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。\n有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。\n2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes正式决定，将Docker项目开源。不开则已，一开惊人。\n越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入Docker开源社区。\nDocker的人气迅速攀升，速度之快，令人瞠目结舌。\n开源当月，Docker 0.1 版本发布。此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0 版本正式发布。\n此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。\nDocker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。\n在容器技术之前，业界的网红是虚拟机。虚拟机技术的代表，是VMWare和OpenStack。\n相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。\n在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是相互隔离的，互不影响。\n虚拟机属于虚拟化技术。而Docker这样的容器技术，也是虚拟化技术，属于轻量级的虚拟化。\n虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。\n而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。\n它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。\n正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。\n\ndocker 理念\n\nDocker是基于Go语言实现的云开源项目。\nDocker的主要目标是“Build，Ship and Run Any App , Anywhere”，也就是通过对应用组件的封装、分 发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。\nLinux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需 要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。\n什么是虚拟化技术什么是虚拟化在计算机技术中，虚拟化（Virtualization）是一种资源管理技术。它是将计算机的各种实体资源，如：服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以用更好的方式来利用这些资源。\n虚拟化的目的是为了在同一个主机上运行多个系统或应用，从而提高系统资源的利用率，并带来降低成本、方便管理和容错容灾等好处。\n虚拟化技术分类从实现形式来分，虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化。\n硬件虚拟化硬件虚拟化就是硬件物理平台本身提供了对特殊指令的截获和重定向的支持。支持虚拟化的硬件，也是一些基于硬件实现软件虚拟化技术的关键。在基于硬件实现软件虚拟化的技术中，在硬件是实现虚拟化的基础，硬件(主要是CPU)会为虚拟化软件提供支持，从而实现硬件资源的虚拟化。\n支持虚拟化的硬件有：\n\n**Intel-VT-(Intel Virtualization Technology)**，Intel公司为解决纯软件虚拟化解决方案在可靠性、安全性和性能上的不足而引进的技术。它可以让一个CPU工作起来像多个CPU在并行运行，从而使得在一部电脑内同时运行多个操作系统成为可能\n**AMD-V-(AMD Virtualization)**，是AMD公司的虚拟化技术。它是对x86处理器系统架构的一组硬件扩展和硬件辅助虚拟化技术，可以简化纯软件的虚拟化解决方案，改进VMM（虚拟机监视器）的设计，更充分地利用硬件资源，提高服务器和数据中心的虚拟化效率\n\n软件虚拟化软件虚拟化就是利用软件技术，在现有的物理平台上实现对物理平台访问的截获和模拟。在软件虚拟化技术中，有些技术不需要硬件支持，如：QEMU；而有些软件虚拟化技术，则依赖硬件支持，如：VMware、KVM。\n对软件虚拟化进行细分，又可以分为以下几类：\n\n完全虚拟化：（Full Virtualization）虚拟机模拟完整的底层硬件环境和特权指令的执行过程，使客户机操作系统可以独立运行。支持完全虚拟化的软件有：Parallels Workstation、VirtualBox、Virtual Iron、Oracle VM、Virtual PC、Virtual Server、Hyper-V、VMware Workstation、QEMU等\n硬件辅助虚拟化：（Hardware-assisted Virtualization）是指通过硬件辅助支持模拟运行环境，使客户机操作系统可以独立运行，实现完全虚拟化的功能。支持硬件辅助虚拟化的软件有：Linux KVM、VMware Workstation、VMware Fusion、Virtual PC、Xen、VirtualBox、Parallels Workstation等\n部分虚拟化：（Partial Virtualization）只针对部分硬件资源进行虚拟化，虚拟机模拟部分底层硬件环境，特别是地址空间。这样的环境支持资源共享和线程独立，但是不允许建立独立的客户机操作系统。\n平行虚拟化：（Para-Virtualization）虚拟机不需要模拟硬件，而是将部分硬件接口以软件的形式提供给客户机操作系统。如：早期的Xen。\n操作系统层虚拟化：（OS-level virtualization）这种技术将操作系统内核虚拟化，可以允许使用者空间软件实例被分割成几个独立的单元，在内核中运行，而不是只有一个单一实例运行。这个软件实例，也被称为是一个容器（containers）、虚拟引擎（Virtualization engine）、虚拟专用服务器（virtual private servers）。每个容器的进程是独立的，对于使用者来说，就像是在使用自己的专用服务器。 Docker容器技术就是属于操作系统层虚拟化的范畴。\n\n几种虚拟化技术虚拟化是通过软件的方式模拟实体服务器，其初衷是为了解决“一种应用占用一台服务器”模式所带来的服务器数量剧增的问题，从而降低数据中心复杂度，简化管理难度。在虚拟化的发展过程中，出现过以下主要虚拟化技术或产品：\n\nXen - 由剑桥大学开发的，一款开源的虚拟机监视器。采用ICA协议，它通过一种叫做准虚拟化的技术来获取高性能，甚至在一些与传统虚拟技术极度不友好的架构上（如：x86），Xen也有极佳的表现。Xen属于半虚拟化的技术，所以其性能损失非常小。Xen没有指令翻译，其或者使用使能理解和翻译虚拟操作系统发出的未修改指令的CPU（即：完全虚拟化）；或者修改操作系统，使它发出的指令最优化，便于在虚拟化环境中执行（即：准虚拟化）。\nKVM - KVM是一个Linux kernel模块，可以使用modprobe来加载KVM，加载后还需要通过其他工具创建虚拟机。KVM是一个全虚拟化的解决方案，但需要CPU支持虚拟化功能。相比Xen来说，KVM可以更加方便的整合进Linux内核，但它还需要其它虚拟化软件（如：QEMU）才能实现虚拟化功能。\nLXC - 即：Linux Container，Linux容器，是一种轻量级的虚拟化的手段。它可以提供轻量级的虚拟化，以隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。容器会有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。\nOpenVZ - 是SWsoft公司开发的开源软件，是该公司Virtuozzo软件的基础产品，是基于Linux平台的操作系统级服务器虚拟化解决方案。通过OpenVZ，可以在单个物理服务器上创建多个相互隔离的虚拟专用服务器(VPS)并以最大的效率共享硬件和管理资源。其上运行虚拟服务器被称为VPS（Virtual Private Serve），每个VPS的运行环境和独立服务器完全一致。OpenVZ基于Linux系统内核及作业系统提供操作系统级虚拟化，在虚拟化过程中资源消耗非常小，官方宣称约1-2%。\nHyper-V - 是微软件推出的一种虚拟化技术，可以采用半虚拟化或全虚拟的方式创建虚拟机。虽然它可以创建Windows或Linux操作系统，但其本身只能运行在Windows系统下，使用范围较为有限。\nOracle VM - Oracle推出的服务器虚拟化软件，基于开源的Xen技术，包括Oracle VM Server和Oracle VM Manager两部分。\nVMWare - 是一家非常出名虚拟化软件公司，其产品涵盖服务器、桌面等各种虚拟化领域，如：VMware Workstation - 是一款桌面虚拟机软件，可以在一台实体机器上模拟完整的网络环境，并可运行多个Windows、DOS、Linux或Mac系统，是非常好的开发、测试、部署解决方案。从技术角度来说，VMware Workstation是一款完全虚拟化产品，可借助硬件辅助在不修改用户操作系统的情况下完整虚拟化操作系统。\nVMware ESX Server - 是一款适用于任何系统环境的企业级的虚拟机软件，可以认为是VMware Server的升级版。相比VMware Workstation来说，其功能更加强大，可以用于构建高伸缩和高可靠企业级服务器，并可实现远程管理、高级资源管理控制等高级功能。\n\nDocker虚拟化什么是Docker？Docker是一个开源的应用容器引擎，它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何 Linux 发行版本的机器上。Docker基于LXC来实现类似VM的功能，可以在更有限的硬件资源上提供给用户更多的计算资源。与同VM等虚拟化的方式不同，LXC不属于全虚拟化、部分虚拟化或半虚拟化中的任何一个分类，而是一个操作系统级虚拟化。\nDocker是直接运行在宿主操作系统之上的一个容器，使用沙箱机制完全虚拟出一个完整的操作，容器之间不会有任何接口，从而让容器与宿主机之间、容器与容器之间隔离的更加彻底。每个容器会有自己的权限管理，独立的网络与存储栈，及自己的资源管理能，使同一台宿主机上可以友好的共存多个容器。\nDocker借助Linux的内核特性，如：控制组（Control Group）、命名空间（Namespace）等，并直接调用操作系统的系统调用接口。从而降低每个容器的系统开销，并实现降低容器复杂度、启动快、资源占用小等特征。\nDocker能干什么？\n简化配置\n\n这是Docker公司宣传的Docker的主要使用场景。虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。它能让你将运行环境和配置放在代码中然后部署，同一个Docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。\n\n代码流水线（Code Pipeline）管理\n\n前一个场景对于管理代码的流水线起到了很大的帮助。代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。\n\n提高开发效率\n\n这就带来了一些额外的好处：Docker能提升开发者的开发效率。详细一点的例子，可以参考Aater在DevOpsDays Austin 2014大会或者是DockerCon上的演讲。\n不同的开发环境中，我们都想把两件事做好。一是我们想让开发环境尽量贴近生产环境，二是我们想快速搭建开发环境。\n理想状态中，要达到第一个目标，我们需要将每一个服务都跑在独立的虚拟机中以便监控生产环境中服务的运行状态。然而，我们却不想每次都需要网络连接，每次重新编译的时候远程连接上去特别麻烦。这就是Docker做的特别好的地方，开发环境的机器通常内存比较小，之前使用虚拟的时候，我们经常需要为开发环境的机器加内存，而现在Docker可以轻易的让几十个服务在Docker中跑起来。\n\n隔离应用\n\n有很多种原因会让你选择在一个机器上运行不同的应用，比如之前提到的提高开发效率的场景等。\n我们经常需要考虑两点，一是因为要降低成本而进行服务器整合，二是将一个整体式的应用拆分成松耦合的单个服务（译者注：微服务架构）。如果你想了解为什么松耦合的应用这么重要，请参考Steve Yege的这篇论文，文中将Google和亚马逊做了比较。\n\n整合服务器\n\n正如通过虚拟机来整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占用，以及能在多个实例之间共享没有使用的内存，Docker可以比虚拟机提供更好的服务器整合解决方案。\n\n调适能力\n\nDocker提供了很多的工具，这些工具不一定只是针对容器，但是却适用于容器。它们提供了很多的功能，包括可以为容器设置检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试Bug。你可以在《Docker拯救世界》的文章中找到这一点的例证。\n\n多租户\n\n另外一个Docker有意思的使用场景是在多租户的应用中，它可以避免关键应用的重写。我们一个特别的关于这个场景的例子是为IoT（物联网）的应用开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间，也浪费金钱。\n使用Docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于Docker环境的启动速度和其高效的diff命令。\n\n快速部署\n\n在虚拟机之前，引入新的硬件资源需要消耗几天的时间。Docker的虚拟化技术将这个时间降到了几分钟，Docker只是创建一个容器进程而无需启动操作系统，这个过程只需要秒级的时间。这正是Google和Facebook都看重的特性。\n你可以在数据中心创建销毁资源而无需担心重新启动带来的开销。通常数据中心的资源利用率只有30%，通过使用Docker并进行有效的资源分配可以提高资源的利用率。\nDocker的基本组成仓库，镜像，容器的关系（这是官网的图）\n\n\n镜像（image）\n\nDocker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很 多容器。 就好似 Java 中的 类和对象，类就是镜像，容器就是对象！\n\n容器（container）：\n\nDocker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。\n它可以被启动、开始、停止、删除。每个容器都是相互隔离的，保证安全的平台。\n可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等） 和运行在其中的应用程序\n容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。\n\n仓库（repository）：\n\n仓库（Repository）是集中存放镜像文件的场所。\n仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓 库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。\n仓库分为公开仓库（Public）和私有仓库（Private）两种形式\n最大的公开仓库是 Docker Hub(https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。 国内的公开仓库包括阿里云 、网易云 等\n小结：\nDocker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个 可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生 成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。 同一个 image 文件，可以生成多个同时运行的容器实例。\nimage 文件生成的容器实例，本身也是一个文件，称为镜像文件\n一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例， 也就是我们的容器\n至于仓库，就是放了一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候从仓库中拉下来 就可以了。\nDocker和虚拟机的区别？\n虚拟机Virtual Machine与容器化技术（代表Docker）都是虚拟化技术，两者的区别在于虚拟化的程度不同。\n\n基本对比\n\n虚拟机\n基础设施（Infrastructure）。它可以是你的个人电脑，数据中心的服务器，或者是云主机。\n主操作系统（Host Operating System）。你的个人电脑之上，运行的可能是MacOS，Windows或者某个Linux发行版。\n虚拟机管理系统（Hypervisor）。利用Hypervisor，可以在主操作系统之上运行多个不同的从操作系统。类型1的Hypervisor有支持MacOS的HyperKit，支持Windows的Hyper-V以及支持Linux的KVM。类型2的Hypervisor有VirtualBox和VMWare。\n操作系统（Guest Operating System）。假设你需要运行3个相互隔离的应用，则需要使用Hypervisor启动3个从操作系统，也就是3个虚拟机。这些虚拟机都非常大，也许有700MB，这就意味着它们将占用2.1GB的磁盘空间。更糟糕的是，它们还会消耗很多CPU和内存。\n各种依赖。每一个从操作系统都需要安装许多依赖。如果你的的应用需要连接PostgreSQL的话，则需要安装libpq-dev；如果你使用Ruby的话，应该需要安装gems；如果使用其他编程语言，比如Python或者Node.js，都会需要安装对应的依赖库。\n\n\nDocker容器\n主操作系统（Host Operating System）。所有主流的Linux发行版都可以运行Docker。对于MacOS和Windows，也有一些办法”运行”Docker。\nDocker守护进程（Docker Daemon）。Docker守护进程取代了Hypervisor，它是运行在操作系统之上的后台进程，负责管理Docker容器。\n各种依赖。对于Docker，应用的所有依赖都打包在Docker镜像中，Docker容器是基于Docker镜像创建的。\n应用。应用的源代码与它的依赖都打包在Docker镜像中，不同的应用需要不同的Docker镜像。不同的应用运行在不同的Docker容器中，它们是相互隔离的。\n\n\n\n虚拟机是在物理资源层面实现的隔离，相对于虚拟机，Docker是你APP层面实现的隔离，并且省去了虚拟机操作系统（Guest OS）），从而节省了一部分的系统资源；Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，Docker可以节省大量的磁盘空间以及其他系统资源。\n虚拟机与容器docker的区别，在于vm多了一层guest OS，虚拟机的Hypervisor会对硬件资源也进行虚拟化，而容器Docker会直接使用宿主机的硬件资源。\n下面我们采用形象的比喻区分两者的隔离级别：\n\n服务器：比作一个大型的仓管基地，包含场地与零散的货物——相当于各种服务器资源。\n虚拟机技术：比作仓库，拥有独立的空间堆放各种货物或集装箱，仓库之间完全独立——仓库相当于各种系统，独立的应用系统和操作系统。\nDocker：比作集装箱，操作各种货物的打包——将各种应用程序和他们所依赖的运行环境打包成标准的容器，容器之间隔离。\n\n虚拟技术对比\n隔离性\n\n在于隔离性上面，由于vm对操作系统也进行了虚拟化，隔离的更加彻底。而Docker共享宿主机的操作系统，隔离性较差。\n\n运行效率\n\n由于vm的隔离操作，导致生成虚拟机的速率大大低于容器Docker生成的速度，因为Docker直接利用宿主机的系统内核。比如openstack能够以10台&#x2F;min的速度创建虚拟机，而docker可以做到在几秒钟之内创建大量容器，它们的启动速度是在数量级上的差距。\n因为虚拟机增加了一层虚拟硬件层，运行在虚拟机上的应用程序在进行数值计算时是运行在Hypervisor虚拟的CPU上的；另外一方面是由于计算程序本身的特性导致的差异。虚拟机虚拟的cpu架构不同于实际cpu架构，数值计算程序一般针对特定的cpu架构有一定的优化措施，虚拟化使这些措施作废，甚至起到反效果。\n\n资源利用率\n\n在资源利用率上虚拟机由于隔离更彻底，因此利用率也会相对较低。\n因为虚拟机增加了一层虚拟硬件层，运行在虚拟机上的应用程序在进行数值计算时是运行在Hypervisor虚拟的CPU上的；另外一方面是由于计算程序本身的特性导致的差异。虚拟机虚拟的cpu架构不同于实际cpu架构，数值计算程序一般针对特定的cpu架构有一定的优化措施，虚拟化使这些措施作废，甚至起到反效果。比如对于本次实验的平台，实际的CPU架构是2块物理CPU。\nDocker官方：\nDocker 官方主页: https://www.docker.com\n\nDocker 官方博客: https://blog.docker.com\n\nDocker 官方文档: https://docs.docker.com\n\nDocker Store: https://store.docker.com\n\nDocker Cloud: https://cloud.docker.com\n\nDocker Hub: https://hub.docker.com\n\n\n","tags":["Docker"]},{"title":"Docker之镜像和仓库","url":"/2022/08/16/Docker%E4%B9%8B%E9%95%9C%E5%83%8F%E5%92%8C%E4%BB%93%E5%BA%93/","content":"Docker 镜像镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含 运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。\nDocker镜像加载原理\nUnionFS （联合文件系统）\n\nUnionFS 是一种分层、轻量级并且高性能的文件系统， 它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。\n特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录\n\nDocker镜像加载原理\n\ndocker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。\n典型的Linux文件系统由bootfs和rootfs两部分组成\nbootfs(boot file system)主要包含 bootloader 和 kernel , bootloader 主要是引导加载 kernel, Linux 刚启动时会加载bootfs文件系统，在Docker镜像的最底层是 bootfs。这一层与我们典型的 Linux&#x2F;Unix 系统是 一样的，包含boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。\nrootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。\n\n平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？\n对于一个精简的系统，rootfs 可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就可以了。由此可见对于不同的 linux 发行版, bootfs 基本是一 致的, rootfs 会有差别, 因此不同的发行版可以公用 bootfs。\n分层理解\n分层的镜像\n\n我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层一层的在下载！\n为什么Docker镜像要采用这种分层的结构呢？\n最大的好处，莫过于是资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。\n查看镜像分层的方式可以通过 docker image inspect命令！\ndocker image inspect tomcat:latest\n\n所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。\n举一个简单的例子，假如基于 Ubuntu Linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。\n该镜像当前已经包含 3 个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。\n\n在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了 一个简单的例子，每个镜像层包含 3 个文件，而镜像包含了来自两个镜像层的 6 个文件。\n\n上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。\n下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有 6 个文件，这是因为最上层中的文件 7 是文件 5 的一个更新版本。\n\n这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。\nDocker 通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统 一的文件系统。\nLinux 上可用的存储引擎有 AUFS、Overlay2、Device Mapper、Btrfs 以及 ZFS。顾名思义，每种存储引擎都基于 Linux 中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。\nDocker 在 Windows 上仅支持 windowsfilter 一种存储引擎，该引擎基于 NTFS 文件系统之上实现了分层和 CoW。\n下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。\n\n\n特点\n\nDocker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！\n这一层就是我们通常说的容器层，容器之下的都叫镜像层！\n提交镜像docker commit 从容器创建一个新的镜像。\n\n语法：\n\ndocker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 要创建的目标镜像名:[标签名]\n\n\n测试\n\n1、从Docker Hub 下载 tomcat 镜像到本地并运行 \n-it 交互终端 -p 端口映射\ndocker run -it -p 8080:8080 tomcat\n\n2、访问地址\ndocker启动官方tomcat镜像的容器，发现404是因为使用了加速器，而加速器里的 tomcat的webapps下没有root等文件！\n[root@VM-0-6-centos ~]# docker psCONTAINER ID   IMAGE     COMMAND             CREATED         STATUS         PORTS                                       NAMESa8b6aff64fa3   tomcat    &quot;catalina.sh run&quot;   8 minutes ago   Up 8 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   silly_feynman[root@VM-0-6-centos ~]# docker exec -it a8b6aff64fa3 /bin/bashroot@a8b6aff64fa3:/usr/local/tomcat# lsBUILDING.txt  CONTRIBUTING.md  LICENSE\tNOTICE\tREADME.md  RELEASE-NOTES  RUNNING.txt  bin  conf  lib  logs  native-jni-lib  temp  webapps  webapps.dist  work\n\n进入 tomcat 查看 cd 到 webapps 下发现全部空的，反而有个 webapps.dist 里有对应文件\nroot@a8b6aff64fa3:/usr/local/tomcat# cd webapps.distroot@a8b6aff64fa3:/usr/local/tomcat/webapps.dist# lsROOT  docs  examples  host-manager  manager\n\n我们可以 cp -r  复制文件到webapps下！\nroot@a8b6aff64fa3:/usr/local/tomcat# cp -r webapps.dist/* webappsroot@a8b6aff64fa3:/usr/local/tomcat# cd webappsroot@a8b6aff64fa3:/usr/local/tomcat/webapps# lsROOT  docs  examples  host-manager  manager\n\n此时再次访问，则不是404\n**3、提交修改后的镜像为 tomcat02 **\n下次则可以直接启动这个\n注意：commit的时候，容器的名字不能有大写，否则报错：invalid reference format\n[root@VM-0-6-centos ~]# docker ps -lCONTAINER ID   IMAGE     COMMAND             CREATED          STATUS          PORTS                                       NAMESa8b6aff64fa3   tomcat    &quot;catalina.sh run&quot;   16 minutes ago   Up 16 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   silly_feynman##提交镜像[root@VM-0-6-centos ~]# docker commit -a=&quot;zhiyuan&quot; -m=&quot;new tomcat&quot; a8b6aff64fa3 tomcat02:1.1sha256:620813976effbc8a7e36398a9b801891d1654dea37a50927b36a950ffe21a63b[root@VM-0-6-centos ~]# docker imagesREPOSITORY            TAG       IMAGE ID       CREATED         SIZEtomcat02              1.1       620813976eff   8 seconds ago   672MB\n\n停止后再启动看看，首页可访问\n[root@VM-0-6-centos ~]# docker stop a8b6aff64fa3a8b6aff64fa3[root@VM-0-6-centos ~]# docker run -it -p 8080:8080 tomcat02:1.1\n\nDocker 仓库DockerHub注册dockerhub https://hub.docker.com/signup\n1、登录\ndocker login -u oddfar\n\n2、将镜像发布出去\n[root@VM-0-6-centos logs]# docker push hello-worldUsing default tag: latestThe push refers to repository [docker.io/library/hello-world]f22b99068db9: Layer already exists errors:denied: requested access to the resource is deniedunauthorized: authentication required\n\n错误：请求的资源访问被拒绝\n问题：本地镜像名无帐号信息，解决加 tag 即可\n[root@VM-0-6-centos logs]# docker imagesREPOSITORY            TAG       IMAGE ID       CREATED             SIZEhello-world           latest    d1165f221234   3 months ago        13.3kB[root@VM-0-6-centos logs]# docker tag d1165f221234 oddfar/hello-world:1.0\n\noddfar 是我的用户名\n3、再次push\n[root@VM-0-6-centos logs]# docker push oddfar/hello-world:1.0\n\n访问：https://hub.docker.com/ 可看到提交的镜像\n阿里云镜像服务登录阿里云 -&gt; 找到容器镜像服务 -&gt; 创建命名空间 -&gt; 创建镜像仓库\n点击进入这个镜像仓库，可以看到所有的信息\n\n测试：推送 hello-world\n[root@VM-0-6-centos ~]# docker login --username=a_zhiyuan registry.cn-hangzhou.aliyuncs.com[root@VM-0-6-centos ~]# docker tag d1165f221234 registry.cn-hangzhou.aliyuncs.com/zhiyuan/study:1.0[root@VM-0-6-centos ~]# docker push registry.cn-hangzhou.aliyuncs.com/zhiyuan/study:1.0\n\n提交成功\n\n","tags":["Docker"]},{"title":"RabbitMQ之RabbitMQ 其他知识点","url":"/2022/08/05/RabbitMQ%E4%B9%8BRabbitMQ-%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"幂等性概念用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。 举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常， 此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱 了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等\n消息重复消费消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断， 故 MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。\n解决思路MQ 消费者的幂等性的解决一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过。\n消费端的幂等性保障在海量订单生成的业务高峰期，生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性， 这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。\n业界主流的幂等性有两种操作:a. 唯一 ID+指纹码机制,利用数据库主键去重, b.利用 redis 的原子性去实现\n唯一ID+指纹码机制指纹码：我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个 id 是否存在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。\nnote Redis 原子性利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费\n优先级队列使用场景在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧。\n但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用 RabbitMQ 进行改造和优化，如果发现是大客户的订单给一个相对比较高的优先级， 否则就是默认优先级。\n如何添加？a.控制台页面添加\n\nb.队列中代码添加优先级\nMap&lt;String, Object&gt; params = new HashMap();params.put(&quot;x-max-priority&quot;, 10);channel.queueDeclare(&quot;hello&quot;, true, false, false, params);\n\nc.消息中代码添加优先级\nAMQP.BasicProperties properties = new AMQP.BasicProperties().builder().priority(10).build();\n\n注意事项：\n要让队列实现优先级需要做的事情有如下事情：队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费因为，这样才有机会对消息进行排序\n实战生产者：\npublic class PriorityProducer &#123;    private static final String QUEUE_NAME = &quot;hello&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        //给消息赋予一个 priority 属性        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().priority(10).build();        for (int i = 1; i &lt; 11; i++) &#123;            String message = &quot;info&quot; + i;            if (i == 5) &#123;                channel.basicPublish(&quot;&quot;, QUEUE_NAME, properties, message.getBytes());            &#125; else &#123;                channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());            &#125;            System.out.println(&quot;发送消息完成:&quot; + message);        &#125;    &#125;&#125;\n\n消费者：\npublic class PriorityConsumer &#123;    private final static String QUEUE_NAME = &quot;hello&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        //设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU        Map&lt;String, Object&gt; params = new HashMap();        params.put(&quot;x-max-priority&quot;, 10);        channel.queueDeclare(QUEUE_NAME, true, false, false, params);        //推送的消息如何进行消费的接口回调        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;            String message = new String(delivery.getBody());            System.out.println(message);        &#125;;        //取消消费的一个回调接口 如在消费的时候队列被删除掉了        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;            System.out.println(&quot;消息消费被中断&quot;);        &#125;;        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);    &#125;&#125;\n\n\n惰性队列使用场景RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。\n默认情况下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中， 这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然 RabbitMQ 的开发者们一直在升级相关的算法， 但是效果始终不太理想，尤其是在消息量特别大的时候。\n两种模式队列具备两种模式：default 和 lazy。默认的为default 模式，在3.6.0 之前的版本无需做任何变更。lazy 模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过 Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级。 如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。\n在队列声明的时候可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”。下面示例中演示了一个惰性队列的声明细节：\nMap&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();args.put(&quot;x-queue-mode&quot;, &quot;lazy&quot;);channel.queueDeclare(&quot;myqueue&quot;, false, false, false, args);\n\n内存开销对比\n在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅 占用 1.5MB\n","tags":["RabbitMQ"]},{"title":"RabbitMQ之RabbitMQ 集群","url":"/2022/08/05/RabbitMQ%E4%B9%8BRabbitMQ-%E9%9B%86%E7%BE%A4/","content":"clustering使用集群的原因最开始我们介绍了如何安装及运行 RabbitMQ 服务，不过这些是单机版的，无法满足目前真实应用的 要求。如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？单台 RabbitMQ 服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要 RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？购买昂贵的服务器来增强单机 RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是解决实际问题的关键.\n搭建步骤#1.修改 3 台机器的主机名称vim /etc/hostname#2.配置各个节点的 hosts 文件，让各个节点都能互相识别对方vim /etc/hosts10.211.55.74 node110.211.55.75 node210.211.55.76 node3#3.以确保各个节点的 cookie 文件使用的是同一个值#在 node1 上执行远程操作命令scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/.erlang.cookiescp /var/lib/rabbitmq/.erlang.cookie root@node3:/var/lib/rabbitmq/.erlang.cookie#4.启动 RabbitMQ 服务,顺带启动 Erlang 虚拟机和 RbbitMQ 应用服务(在三台节点上分别执行以下命令)rabbitmq-server -detached#5.在节点 2 执行rabbitmqctl stop_app(rabbitmqctl stop 会将Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务)rabbitmqctl resetrabbitmqctl join_cluster rabbit@node1rabbitmqctl start_app(只启动应用服务)#6.在节点 3 执行rabbitmqctl stop_apprabbitmqctl resetrabbitmqctl join_cluster rabbit@node2rabbitmqctl start_app#7.集群状态rabbitmqctl cluster_status#8.需要重新设置用户创建账号rabbitmqctl add_user admin 123设置用户角色rabbitmqctl set_user_tags admin administrator设置用户权限rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;#9.解除集群节点(node2 和 node3 机器分别执行)rabbitmqctl stop_apprabbitmqctl resetrabbitmqctl start_apprabbitmqctl cluster_statusrabbitmqctl forget_cluster_node rabbit@node2(node1 机器上执行)\n\n镜像队列使用镜像的原因如果 RabbitMQ 集群中只有一个 Broker 节点，那么该节点的失效将导致整体服务的临时性不可用，并 且也可能会导致消息的丢失。可以将所有消息都设置为持久化，并且对应队列的durable属性也设置为true，但 是这样仍然无法避免由于缓存导致的问题：因为消息在发送之后和被写入磁盘井执行刷盘动作之间存在一 个短暂却会产生问题的时间窗。通过 publisherconfirm 机制能够确保客户端知道哪些消息己经存入磁盘，尽管如此，一般不希望遇到因单点故障导致的服务不可用。\n引入镜像队列(Mirror Queue)的机制，可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中 的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。\n搭建步骤1.启动三台集群节点2.随便找一个节点添加 policy\n\n\n3.在 node1 上创建一个队列发送一条消息，队列存在镜像队列\n\n\n4.停掉 node1 之后发现 node2 成为镜像队列\n\n\n5.就算整个集群只剩下一台机器了 依然能消费队列里面的消息说明队列里面的消息被镜像队列传递到相应机器里面了\n\nHaproxy+Keepalive 实现高可用负载均衡整体架构图\nHaproxy 实现负载均衡HAProxy 提供高可用性、负载均衡及基于TCPHTTP 应用的代理，支持虚拟主机，它是免费、快速并 且可靠的一种解决方案，包括 Twitter,Reddit,StackOverflow,GitHub 在内的多家知名互联网公司在使用。 HAProxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数。 扩展 nginx,lvs,haproxy 之间的区别: http://www.ha97.com/5646.html\n搭建步骤#1.下载 haproxy(在 node1 和 node2)yum -y install haproxy#2.修改 node1 和 node2 的 haproxy.cfgvim /etc/haproxy/haproxy.cfg#需要修改红色 IP 为当前机器 IP\n\n\n#3.在两台节点启动 haproxyhaproxy -f /etc/haproxy/haproxy.cfgps -ef | grep haproxy#4.访问地址http://10.211.55.71:8888/stats\n\nKeepalived 实现双机(主备)热备试想如果前面配置的 HAProxy 主机突然宕机或者网卡失效，那么虽然 RbbitMQ 集群没有任何故障但是 对于外界的客户端来说所有的连接都会被断开结果将是灾难性的为了确保负载均衡服务的可靠性同样显得 十分重要，这里就要引入 Keepalived 它能够通过自身健康检查、资源接管功能做高可用(双机热备)，实现故障转移.\n搭建步骤#1.下载 keepalivedyum -y install keepalived#2.节点 node1 配置文件vim /etc/keepalived/keepalived.conf把资料里面的 keepalived.conf 修改之后替换#3.节点 node2 配置文件需要修改global_defs 的 router_id,如:nodeB其次要修改 vrrp_instance_VI 中 state 为&quot;BACKUP&quot;；最后要将priority 设置为小于 100 的值#4.添加 haproxy_chk.sh(为了防止 HAProxy 服务挂掉之后 Keepalived 还在正常工作而没有切换到 Backup 上，所以这里需要编写一个脚本来检测 HAProxy 务的状态,当 HAProxy 服务挂掉之后该脚本会自动重启HAProxy 的服务，如果不成功则关闭 Keepalived 服务，这样便可以切换到 Backup 继续工作)vim /etc/keepalived/haproxy_chk.sh(可以直接上传文件)修改权限 chmod 777 /etc/keepalived/haproxy_chk.sh#5.启动 keepalive 命令(node1 和 node2 启动)systemctl start keepalived#6. 观察 Keepalived 的日志tail -f /var/log/messages -n 200#7.观察最新添加的 vipip add show#8. node1 模拟 keepalived 关闭状态systemctl stop keepalived#9. 使用 vip 地址来访问 rabbitmq 集群\n\nFederation Exchange使用它的原因(broker 北京)，(broker 深圳)彼此之间相距甚远，网络延迟是一个不得不面对的问题。有一个在北京 的业务(Client 北京) 需要连接(broker 北京)，向其中的交换器 exchangeA 发送消息，此时的网络延迟很小， (Client 北京)可以迅速将消息发送至 exchangeA 中，就算在开启了 publisherconfirm 机制或者事务机制的情 况下，也可以迅速收到确认信息。此时又有个在深圳的业务(Client 深圳)需要向 exchangeA 发送消息， 那 么(Client 深圳) (broker 北京)之间有很大的网络延迟，(Client 深圳) 将发送消息至 exchangeA 会经历一定 的延迟，尤其是在开启了 publisherconfirm 机制或者事务机制的情况下，(Client 深圳) 会等待很长的延迟 时间来接收(broker 北京)的确认信息，进而必然造成这条发送线程的性能降低，甚至造成一定程度上的阻塞。 \n将业务(Client 深圳)部署到北京的机房可以解决这个问题，但是如果(Client 深圳)调用的另些服务都部 署在深圳，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？ 这里 使用 Federation 插件就可以很好地解决这个问题.\n\n搭建步骤#1.需要保证每台节点单独运行#2.在每台机器上开启 federation 相关插件rabbitmq-plugins enable rabbitmq_federationrabbitmq-plugins enable rabbitmq_federation_management#3.原理图(先运行 consumer 在 node2 创建 fed_exchange)\n\n\n4.在 downstream(node2)配置 upstream(node1)\n\n\n5.添加 policy\n\n\n6.成功的前提\n\n\nFederation QueueFederation Queue联邦队列可以在多个 Broker 节点(或者集群)之间为单个队列提供均衡负载的功能。一个联邦队列可以 连接一个或者多个上游队列(upstream queue)，并从这些上游队列中获取消息以满足本地消费者消费消息 的需求。\n搭建步骤\n1.原理图\n\n\n\n2.添加 upstream(同上) \n3.添加 policy\n\n\nShovel使用它的原因Federation 具备的数据转发功能类似，Shovel 够可靠、持续地从一个 Broker 中的队列(作为源端，即 source)拉取数据并转发至另一个 Broker 中的交换器(作为目的端，即 destination)。作为源端的队列和作为 目的端的交换器可以同时位于同一个 Broker，也可以位于不同的 Broker 上。Shovel 可以翻译为”铲子”，是 一种比较形象的比喻，这个”铲子”可以将消息从一方”铲子”另一方。Shovel 行为就像优秀的客户端应用程 序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。\n搭建步骤\n#1.开启插件(需要的机器都开启)rabbitmq-plugins enable rabbitmq_shovelrabbitmq-plugins enable rabbitmq_shovel_management\n\n\n2.原理图(在源头发送的消息直接回进入到目的地队列)\n\n\n\n3.添加 shovel 源和目的地\n\n\n","tags":["RabbitMQ"]},{"title":"RabbitMQ之Work Queues","url":"/2022/08/05/RabbitMQ%E4%B9%8BWork-Queues/","content":"Work Queues——工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进 程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。\n\n轮训分发消息在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程是如何工作的。\n1、抽取工具类\npackage com.oddfar.utils;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;public class RabbitMqUtils &#123;    //得到一个连接的 channel    public static Channel getChannel() throws Exception &#123;        //创建一个连接工厂        ConnectionFactory factory = new ConnectionFactory();        factory.setHost(&quot;42.192.149.71&quot;);        factory.setUsername(&quot;admin&quot;);        factory.setPassword(&quot;123456&quot;);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        return channel;    &#125;&#125;\n\n2、启动两个工作线程来接受消息\npackage com.oddfar.two;import com.oddfar.utils.RabbitMqUtils;import com.rabbitmq.client.CancelCallback;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;/** * 这是一个工作线程，相当于之前的消费者 * * @author zhiyuan */public class Worker01 &#123;    private static final String QUEUE_NAME = &quot;hello&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        //消息接受        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;            String receivedMessage = new String(delivery.getBody());            System.out.println(&quot;接收到消息:&quot; + receivedMessage);        &#125;;        //消息被取消        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;            System.out.println(consumerTag + &quot;消费者取消消费接口回调逻辑&quot;);        &#125;;        System.out.println(&quot;C1 消费者启动等待消费.................. &quot;);        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);    &#125;&#125;\n\n选中 Allow multiple instances\n启动后\n\n3、启动一个发送消息线程\npublic class Task01 &#123;    public static final String QUEUE_NAME = &quot;hello&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        Scanner scanner = new Scanner(System.in);        while (scanner.hasNext()) &#123;            String message = scanner.next();            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());            System.out.println(&quot;消息发送完成：&quot; + message);        &#125;    &#125;&#125;\n\n\n结果展示\n\n通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息\n\n消息应答概念消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。\n为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。 \n自动应答消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失 了,当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使 得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以 某种速率能够处理这些消息的情况下使用。\n手动消息应答的方法\nChannel.basicAck(用于肯定确认)\nRabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了 \n\nChannel.basicNack(用于否定确认) \n\nChannel.basicReject(用于否定确认)\n与 Channel.basicNack 相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了\n\n\nMultiple 的解释：\n手动应答的好处是可以批量应答并且减少网络拥堵 \n\n\ntrue 代表批量应答 channel 上未应答的消息\n比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答\n\nfalse 同上面相比只会应答 tag&#x3D;8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答\n\n\n\n消息自动重新入队如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。\n\n消息手动应答代码默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答\n消费者在上面代码的基础上增加了以下内容\nchannel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n\n消息生产者：\npackage com.oddfar.three;import com.oddfar.utils.RabbitMqUtils;import com.rabbitmq.client.Channel;import java.util.Scanner;/** * 消息生产者,消息在手动应答时是不丢失的，放回队列重新消费 * * @author zhiyuan */public class Task02 &#123;    private static final String TASK_QUEUE_NAME = &quot;ack_queue&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        //声明队列        channel.queueDeclare(TASK_QUEUE_NAME, false, false, false, null);        Scanner sc = new Scanner(System.in);        System.out.println(&quot;请输入信息&quot;);        while (sc.hasNext()) &#123;            String message = sc.nextLine();            //发布消息            channel.basicPublish(&quot;&quot;, TASK_QUEUE_NAME, null, message.getBytes(&quot;UTF-8&quot;));            System.out.println(&quot;生产者发出消息&quot; + message);        &#125;    &#125;&#125;\n\n消费者 01：\npackage com.oddfar.three;import com.oddfar.utils.RabbitMqUtils;import com.rabbitmq.client.CancelCallback;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;/** * 消费者01 * * @author zhiyuan */public class Work03 &#123;    private static final String TASK_QUEUE_NAME = &quot;ack_queue&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        System.out.println(&quot;C1 等待接收消息处理时间较 短&quot;);        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;            String message = new String(delivery.getBody());            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;接收到消息:&quot; + message);            /**             * 1.消息标记 tag             * 2.是否批量应答未应答消息             */            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);        &#125;;        CancelCallback cancelCallback = (s) -&gt; &#123;            System.out.println(s + &quot;消费者取消消费接口回调逻辑&quot;);        &#125;;        //采用手动应答        boolean autoAck = false;        channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);    &#125;&#125;\n\n消费者 02：\n把时间改成30秒\npublic class Work04 &#123;    private static final String ACK_QUEUE_NAME=&quot;ack_queue&quot;;    public static void main(String[] args) throws Exception     &#123;Channel channel = RabbitMqUtils.getChannel();     System.out.println(&quot;C2 等待接收消息处理时间较长&quot;);     //消息消费的时候如何处理消息     DeliverCallback deliverCallback=(consumerTag,delivery)-         &gt;&#123;String message= new String(delivery.getBody());           SleepUtils.sleep(30);           System.out.println(&quot;接收到消息:&quot;+message);           /*** 1.消息标记 tag* 2.是否批量应答未应答消息 */           channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);          &#125;;     //采用手动应答     boolean autoAck=false;     channel.basicConsume(ACK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag)-&gt;&#123;         System.out.println(consumerTag+&quot;消费者取消消费接口回调逻辑&quot;);     &#125;);    &#125;&#125;\n\n睡眠工具类     public class SleepUtils &#123;        public static void sleep(int second)&#123;            try &#123;                Thread.sleep(1000*second);            &#125; catch (InterruptedException _ignored)             &#123;Thread.currentThread().interrupt();            &#125;        &#125;    &#125;\n\n手动应答效果演示正常情况下消息发送方发送两个消息 C1 和 C2 分别接收到消息并进行处理\n\n在发送者发送消息 dd，发出消息之后的把 C2 消费者停掉，按理说该 C2 来处理该消息，但是由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了， 此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了\n\n\nRabbitMQ 持久化概念当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：我们需要将队列和消息都标记为持久化。\n队列如何实现持久化之前我们创建的队列都是非持久化的，rabbitmq 如果重启的化，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为持久化\n//让队列持久化boolean durable = true;//声明队列channel.queueDeclare(TASK_QUEUE_NAME, durable, false, false, null);\n\n注意：如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误\n\n以下为控制台中持久化与非持久化队列的 UI 显示区、\n\n消息实现持久化需要在消息生产者修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN 添加这个属性。\n\n将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没 有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要更强有力的持久化策略，参考后边课件发布确认章节。\n不公平分发在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮训分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者 2 处理速度却很慢，这个时候我们还是采用轮训分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。\n为了避免这种情况，在消费者中消费之前，我们可以设置参数 channel.basicQos(1);\n//不公平分发int prefetchCount = 1;channel.basicQos(prefetchCount);//采用手动应答boolean autoAck = false;channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);\n\n\n\n意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个 任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完 成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加 新的 worker 或者改变其他存储任务的策略。\n预取值分发本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费 者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。这个时候就可以通过使用 basic.qos 方法设 置“预取计数”值来完成的。\n该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。\n通常，增加预取将提高 向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。\n预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。\n\n","tags":["RabbitMQ"]},{"title":"RabbitMQ之初体验","url":"/2022/08/05/RabbitMQ%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/","content":"我们将用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者\n在下图中，“ P” 是我们的生产者，“ C” 是我们的消费者。中间的框是一个队列 RabbitMQ 代表使用者保留的消息缓冲区\n\n连接的时候，需要开启 5672 端口\n\n\n依赖\n\npom.xml\n&lt;!--指定 jdk 编译版本--&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;source&gt;8&lt;/source&gt;                &lt;target&gt;8&lt;/target&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;&lt;dependencies&gt;    &lt;!--rabbitmq 依赖客户端--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;        &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;        &lt;version&gt;5.8.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--操作文件流的一个依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-io&lt;/groupId&gt;        &lt;artifactId&gt;commons-io&lt;/artifactId&gt;        &lt;version&gt;2.6&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\n消息生产者\n\nimport com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;public class Producer &#123;    private final static String QUEUE_NAME = &quot;hello&quot;;    public static void main(String[] args) throws Exception &#123;        //创建一个连接工厂        ConnectionFactory factory = new ConnectionFactory();        factory.setHost(&quot;42.192.149.71&quot;);        factory.setUsername(&quot;admin&quot;);        factory.setPassword(&quot;123456&quot;);        //channel 实现了自动 close 接口 自动关闭 不需要显示关闭        //创建连接        Connection connection = factory.newConnection();        //获取信道        Channel channel = connection.createChannel();        /**         * 生成一个队列         * 1.队列名称         * 2.队列里面的消息是否持久化 也就是是否用完就删除         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除         * 5.其他参数         */        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        String message = &quot;hello world&quot;;        /**         * 发送一个消息         * 1.发送到那个交换机         * 2.路由的 key 是哪个         * 3.其他的参数信息         * 4.发送消息的消息体         */        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());        System.out.println(&quot;消息发送完毕&quot;);    &#125;    &#125;\n\n\n消息消费者\n\npackage com.oddfar.one;import com.rabbitmq.client.*;/** * @author zhiyuan */public class Consumer &#123;    private final static String QUEUE_NAME = &quot;hello&quot;;    public static void main(String[] args) throws Exception &#123;        ConnectionFactory factory = new ConnectionFactory();        factory.setHost(&quot;42.192.149.71&quot;);        factory.setUsername(&quot;admin&quot;);        factory.setPassword(&quot;123456&quot;);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        System.out.println(&quot;等待接收消息.........&quot;);        //推送的消息如何进行消费的接口回调        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;            String message = new String(delivery.getBody());            System.out.println(message);        &#125;;        //取消消费的一个回调接口 如在消费的时候队列被删除掉了        CancelCallback cancelCallback = (consumerTag) -&gt; &#123;            System.out.println(&quot;消息消费被中断&quot;);        &#125;;        /**         * 消费者消费消息 - 接受消息         * 1.消费哪个队列         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答         * 3.消费者未成功消费的回调         * 4.消息被取消时的回调         */        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);    &#125;&#125;\n\n","tags":["RabbitMQ"]},{"title":"RabbitMQ之交换机","url":"/2022/08/05/RabbitMQ%E4%B9%8B%E4%BA%A4%E6%8D%A2%E6%9C%BA/","content":"Exchanges概念RabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。\n相反，**生产者只能将消息发送到交换机(exchange)**，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。\n\nExchanges 的类型​\t直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)\n无名exchange​\t在前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的 原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。\n\n第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的，如果它存在的话\n临时队列之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们来说至关重要，我们需要指定我们的消费者去消费哪个队列的消息。\n每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。\n创建临时队列的方式如下: \nString queueName = channel.queueDeclare().getQueue();\n\n\n绑定 bindings什么是 bingding 呢，binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定\n\n\nFanout exchangeFanout 介绍Fanout 这种类型非常简单。正如从名称中猜到的那样，它是将接收到的所有消息广播到它知道的 所有队列中。系统中默认有些 exchange 类型\n\nFanout 实战\nLogs 和临时队列的绑定关系如下图\n\n为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消 息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，\nReceiveLogs01 将接收到的消息打印在控制台\npackage com.oddfar.five;import com.oddfar.utils.RabbitMqUtils;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;/** * @author zhiyuan */public class ReceiveLogs01 &#123;    private static final String EXCHANGE_NAME = &quot;logs&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);        /**         * 生成一个临时的队列 队列的名称是随机的         * 当消费者断开和该队列的连接时 队列自动删除         */        String queueName = channel.queueDeclare().getQueue();        //把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串        channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);        System.out.println(&quot;等待接收消息,把接收到的消息打印在屏幕........... &quot;);        //发送回调        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);            System.out.println(&quot;控制台打印接收到的消息&quot; + message);        &#125;;        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; &#123;&#125;);    &#125;&#125;\n\nReceiveLogs02 把消息写出到文件\npublic class ReceiveLogs02 &#123;    private static final String EXCHANGE_NAME = &quot;logs&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);        /**         * 生成一个临时的队列 队列的名称是随机的         * 当消费者断开和该队列的连接时 队列自动删除         */        String queueName = channel.queueDeclare().getQueue();        //把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串        channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);        System.out.println(&quot;等待接收消息,把接收到的消息写到文件........... &quot;);        //发送回调        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);            File file = new File(&quot;D:\\\\test\\\\rabbitmq_info.txt&quot;);            FileUtils.writeStringToFile(file,message,&quot;UTF-8&quot;);            System.out.println(&quot;数据写入文件成功&quot;);        &#125;;        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; &#123;&#125;);    &#125;&#125;\n\nEmitLog 发送消息给两个消费者接收：\npublic class EmitLog &#123;    private static final String EXCHANGE_NAME = &quot;logs&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        /**         * 声明一个 exchange         * 1.exchange 的名称         * 2.exchange 的类型         */        channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);        Scanner sc = new Scanner(System.in);        System.out.println(&quot;请输入信息&quot;);        while (sc.hasNext()) &#123;            String message = sc.nextLine();            channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes(&quot;UTF-8&quot;));            System.out.println(&quot;生产者发出消息&quot; + message);        &#125;    &#125;    &#125;\n\nDirect exchange在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能——让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。\n我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解： 队列只对它绑定的交换机的消息感兴趣。绑定用参数：routingKey 来表示也可称该参数为 binding key， 创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);\n绑定之后的意义由其交换类型决定。\nDirect 介绍上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希 望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去。\n\n在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green.\n在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。\n多重绑定\n当然如果 exchange 的绑定类型是direct，但是它绑定的多个队列的 key 如果都相同，在这种情况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了，就跟广播差不多，如上图所示。\nDirect 实战关系：\n\n交换机：\n\nc2：绑定disk，routingKey为error\nc1：绑定console，routingKey为info、warning\n1、\nimport com.oddfar.utils.RabbitMqUtils;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.DeliverCallback;/** * @author zhiyuan */public class ReceiveLogsDirect01 &#123;    private static final String EXCHANGE_NAME = &quot;direct_logs&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);        String queueName = &quot;disk&quot;;        //队列声明        channel.queueDeclare(queueName, false, false, false, null);        //队列绑定        channel.queueBind(queueName, EXCHANGE_NAME, &quot;error&quot;);        System.out.println(&quot;等待接收消息...&quot;);        //发送回调        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);            message = &quot;接收绑定键:&quot; + delivery.getEnvelope().getRoutingKey() + &quot;,消息:&quot; + message;            System.out.println(&quot;error 消息已经接收：\\n&quot; + message);        &#125;;        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; &#123;        &#125;);    &#125;&#125;\n\n2、\npublic class ReceiveLogsDirect02 &#123;    private static final String EXCHANGE_NAME = &quot;direct_logs&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);        String queueName = &quot;console&quot;;        //队列声明        channel.queueDeclare(queueName, false, false, false, null);        //队列绑定        channel.queueBind(queueName, EXCHANGE_NAME, &quot;info&quot;);        channel.queueBind(queueName, EXCHANGE_NAME, &quot;warning&quot;);        System.out.println(&quot;等待接收消息...&quot;);        //发送回调        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);            message = &quot;接收绑定键:&quot; + delivery.getEnvelope().getRoutingKey() + &quot;,消息:&quot; + message;            System.out.println(&quot;info和warning 消息已经接收：\\n&quot; + message);        &#125;;        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; &#123;        &#125;);    &#125;&#125;\n\n3、\npublic class EmitLogDirect &#123;    private static final String EXCHANGE_NAME = &quot;direct_logs&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);        //创建多个 bindingKey        Map&lt;String, String&gt; bindingKeyMap = new HashMap&lt;&gt;();        bindingKeyMap.put(&quot;info&quot;, &quot;普通 info 信息&quot;);        bindingKeyMap.put(&quot;warning&quot;, &quot;警告 warning 信息&quot;);        bindingKeyMap.put(&quot;error&quot;, &quot;错误 error 信息&quot;);        //debug 没有消费这接收这个消息 所有就丢失了        bindingKeyMap.put(&quot;debug&quot;, &quot;调试 debug 信息&quot;);        for (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;            //获取 key value            String bindingKey = bindingKeyEntry.getKey();            String message = bindingKeyEntry.getValue();            channel.basicPublish(EXCHANGE_NAME, bindingKey, null, message.getBytes(&quot;UTF-8&quot;));            System.out.println(&quot;生产者发出消息:&quot; + message);        &#125;    &#125;&#125;\n\nTopics exchangeTopic 的介绍在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。\n尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性——比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 topic 类型\nTopic的要求发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词\n比如说：”stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”.这种类型的。\n当然这个单词列表最多不能超过 255 个字节。\n在这个规则列表中，其中有两个替换符是大家需要注意的：\n\n***(星号)可以代替一个单词**\n#(井号)可以替代零个或多个单词\n\nTopic 匹配案例下图绑定关系如下\n\n\nQ1–&gt;绑定的是\n\n中间带 orange 带 3 个单词的字符串 (*.orange.*)\n\n\nQ2–&gt;绑定的是\n\n最后一个单词是 rabbit 的 3 个单词 (*.*.rabbit)\n第一个单词是 lazy 的多个单词 (lazy.#)\n\n\n\n上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的\n\n\n\n例子\n说明\n\n\n\nquick.orange.rabbit\n被队列 Q1Q2 接收到\n\n\nazy.orange.elephant\n被队列 Q1Q2 接收到\n\n\nquick.orange.fox\n被队列 Q1 接收到\n\n\nlazy.brown.fox\n被队列 Q2 接收到\n\n\nlazy.pink.rabbit\n虽然满足两个绑定但只被队列 Q2 接收一次\n\n\nquick.brown.fox\n不匹配任何绑定不会被任何队列接收到会被丢弃\n\n\nquick.orange.male.rabbit\n是四个单词不匹配任何绑定会被丢弃\n\n\nlazy.orange.male.rabbit\n是四个单词但匹配 Q2\n\n\n注意：\n\n当一个队列绑定键是#，那么这个队列将接收所有数据，就有点像 fanout 了\n如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了\n\nTopic 实战\n代码如下：\npackage com.oddfar.seven;import com.oddfar.utils.RabbitMqUtils;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import java.util.HashMap;import java.util.Map;/** * 发送端 * * @author zhiyuan */public class EmitLogTopic &#123;    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);        /**         * Q1--&gt;绑定的是         *      中间带 orange 带 3 个单词的字符串(*.orange.*)         * Q2--&gt;绑定的是         *      最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)         *      第一个单词是 lazy 的多个单词(lazy.#)         *         */        Map&lt;String, String&gt; bindingKeyMap = new HashMap&lt;&gt;();        bindingKeyMap.put(&quot;quick.orange.rabbit&quot;, &quot;被队列 Q1Q2 接收到&quot;);        bindingKeyMap.put(&quot;lazy.orange.elephant&quot;, &quot;被队列 Q1Q2 接收到&quot;);        bindingKeyMap.put(&quot;quick.orange.fox&quot;, &quot;被队列 Q1 接收到&quot;);        bindingKeyMap.put(&quot;lazy.brown.fox&quot;, &quot;被队列 Q2 接收到&quot;);        bindingKeyMap.put(&quot;lazy.pink.rabbit&quot;, &quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;);        bindingKeyMap.put(&quot;quick.brown.fox&quot;, &quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;);        bindingKeyMap.put(&quot;quick.orange.male.rabbit&quot;, &quot;是四个单词不匹配任何绑定会被丢弃&quot;);        bindingKeyMap.put(&quot;lazy.orange.male.rabbit&quot;, &quot;是四个单词但匹配 Q2&quot;);        for (Map.Entry&lt;String, String&gt; bindingKeyEntry : bindingKeyMap.entrySet()) &#123;            String bindingKey = bindingKeyEntry.getKey();            String message = bindingKeyEntry.getValue();            channel.basicPublish(EXCHANGE_NAME, bindingKey, null, message.getBytes(&quot;UTF-8&quot;));            System.out.println(&quot;生产者发出消息：&quot; + message);        &#125;    &#125;&#125;\n\n\n\npublic class ReceiveLogsTopic01 &#123;    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);        //声明 Q1 队列与绑定关系        String queueName = &quot;Q1&quot;;        //声明        channel.queueDeclare(queueName, false, false, false, null);        //绑定        channel.queueBind(queueName, EXCHANGE_NAME, &quot;*.orange.*&quot;);        System.out.println(&quot;等待接收消息........... &quot;);        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);            System.out.println(&quot; 接收队列:&quot; + queueName + &quot; 绑定键:&quot; + delivery.getEnvelope().getRoutingKey() + &quot;,消息:&quot; + message);        &#125;;        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; &#123;        &#125;);    &#125;&#125;\n\n\n\npublic class ReceiveLogsTopic02 &#123;    private static final String EXCHANGE_NAME = &quot;topic_logs&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);        //声明 Q2 队列与绑定关系        String queueName = &quot;Q2&quot;;        //声明        channel.queueDeclare(queueName, false, false, false, null);        //绑定        channel.queueBind(queueName, EXCHANGE_NAME, &quot;*.*.rabbit&quot;);        channel.queueBind(queueName, EXCHANGE_NAME, &quot;lazy.#&quot;);        System.out.println(&quot;等待接收消息........... &quot;);        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);            System.out.println(&quot; 接收队列:&quot; + queueName + &quot; 绑定键:&quot; + delivery.getEnvelope().getRoutingKey() + &quot;,消息:&quot; + message);        &#125;;        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; &#123;        &#125;);    &#125;&#125;\n\n","tags":["RabbitMQ"]},{"title":"RabbitMQ之发布确认","url":"/2022/08/05/RabbitMQ%E4%B9%8B%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4/","content":"发布确认逻辑生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。\nconfirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。\n发布确认的策略开启发布确认的方法:发布确认默认是没有开启的，如果要开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法\n//开启发布确认channel.confirmSelect();\n\n单个确认发布这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，waitForConfirmsOrDie(long) 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。\n这种确认方式有一个最大的缺点就是：发布速度特别的慢，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。\n/** * 单个发送 */public static void publishMessageIndividually() throws Exception &#123;    Channel channel = RabbitMqUtils.getChannel();    //队列声明    String queueName = UUID.randomUUID().toString();    channel.queueDeclare(queueName, true, false, false, null);    //开启发布确认    channel.confirmSelect();    long begin = System.currentTimeMillis();    for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123;        String message = i + &quot;&quot;;        channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes());        //服务端返回 false 或超时时间内未返回，生产者可以消息重发        boolean flag = channel.waitForConfirms();        if (flag) &#123;            System.out.println(&quot;消息发送成功&quot;);        &#125;    &#125;    long end = System.currentTimeMillis();    System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;个单独确认消息,耗时&quot; + (end - begin) + &quot;ms&quot;);&#125;\n\n批量确认发布上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出 问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。\n/** * 批量 */public static void publishMessageBatch() throws Exception &#123;    Channel channel = RabbitMqUtils.getChannel();    //队列声明    String queueName = UUID.randomUUID().toString();    channel.queueDeclare(queueName, true, false, false, null);    //开启发布确认    channel.confirmSelect();    //批量确认消息大小    int batchSize = 100;    //未确认消息个数    int outstandingMessageCount = 0;    long begin = System.currentTimeMillis();    for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123;        String message = i + &quot;&quot;;        channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes());        outstandingMessageCount++;        if (outstandingMessageCount == batchSize) &#123;            channel.waitForConfirms();            outstandingMessageCount = 0;        &#125;    &#125;    //为了确保还有剩余没有确认消息 再次确认    if (outstandingMessageCount &gt; 0) &#123;        channel.waitForConfirms();    &#125;    long end = System.currentTimeMillis();    System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;个批量确认消息,耗时&quot; + (end - begin) + &quot;ms&quot;);&#125;\n\n异步确认发布异步确认虽然编程逻辑比上两个要复杂，但是性价比最高，无论是可靠性还是效率都没得说， 他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功， 下面就让我们来详细讲解异步确认是怎么实现的。\n\npublic static void publishMessageAsync() throws Exception &#123;    try (Channel channel = RabbitMqUtils.getChannel()) &#123;        String queueName = UUID.randomUUID().toString();        channel.queueDeclare(queueName, false, false, false, null);        //开启发布确认        channel.confirmSelect();        /**         * 线程安全有序的一个哈希表，适用于高并发的情况         * 1.轻松的将序号与消息进行关联         * 2.轻松批量删除条目 只要给到序列号         * 3.支持并发访问         */        ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = new ConcurrentSkipListMap&lt;&gt;();        /**         * 确认收到消息的一个回调         * 1.消息序列号         * 2.true 可以确认小于等于当前序列号的消息         * false 确认当前序列号消息         */        ConfirmCallback ackCallback = (sequenceNumber, multiple) -&gt; &#123;            if (multiple) &#123;                //返回的是小于等于当前序列号的未确认消息 是一个 map                ConcurrentNavigableMap&lt;Long, String&gt; confirmed =                        outstandingConfirms.headMap(sequenceNumber, true);                //清除该部分未确认消息                confirmed.clear();            &#125; else &#123;                //只清除当前序列号的消息                outstandingConfirms.remove(sequenceNumber);            &#125;        &#125;;        ConfirmCallback nackCallback = (sequenceNumber, multiple) -&gt;        &#123;            String message = outstandingConfirms.get(sequenceNumber);            System.out.println(&quot;发布的消息&quot; + message + &quot;未被确认，序列号&quot; + sequenceNumber);        &#125;;        /**         * 添加一个异步确认的监听器         * 1.确认收到消息的回调         * 2.未收到消息的回调         */        channel.addConfirmListener(ackCallback, null);        long begin = System.currentTimeMillis();        for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123;            String message = &quot;消息&quot; + i;            /**             * channel.getNextPublishSeqNo()获取下一个消息的序列号             * 通过序列号与消息体进行一个关联             * 全部都是未确认的消息体             */            outstandingConfirms.put(channel.getNextPublishSeqNo(), message);            channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes());        &#125;    &#125;    long end = System.currentTimeMillis();    System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;个异步确认消息,耗时&quot; + (end - begin) + &quot;ms&quot;);&#125;\n\n如何处理异步未确认消息?最好的解决的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列， 比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。\n以上 3 种发布确认速度对比 :\n单独发布消息\n同步等待确认，简单，但吞吐量非常有限。\n\n批量发布消息\n批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。\n\n异步处理\n最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些\n\n\npublic static void main(String[] args) throws Exception &#123;    //这个消息数量设置为 1000 好些 不然花费时间太长    publishMessagesIndividually();    publishMessagesInBatch();    handlePublishConfirmsAsynchronously();&#125;//运行结果    发布 1,000 个单独确认消息耗时 50,278 ms    发布 1,000 个批量确认消息耗时 635 ms    发布 1,000 个异步确认消息耗时 92 ms\n","tags":["RabbitMQ"]},{"title":"RabbitMQ之发布确认高级","url":"/2022/08/05/RabbitMQ%E4%B9%8B%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E9%AB%98%E7%BA%A7/","content":"在生产环境中由于一些不明原因，导致 RabbitMQ  重启，在 RabbitMQ 重启期间生产者消息投递失败， 导致消息丢失，需要手动处理和恢复。于是，我们开始思考，如何才能进行 RabbitMQ 的消息可靠投递呢？ \n发布确认 springboot 版本确认机制方案：\n代码架构图\n在配置文件当中需要添加\nspring.rabbitmq.publisher-confirm-type=correlated\n\n\nNONE 值是禁用发布确认模式，是默认值\n\nCORRELATED 值是发布消息成功到交换器后会触发回调方法\n\nSIMPLE 值经测试有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是 waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker;\n\n\n添加配置类@Configurationpublic class ConfirmConfig &#123;    public static final String CONFIRM_EXCHANGE_NAME = &quot;confirm.exchange&quot;;    public static final String CONFIRM_QUEUE_NAME = &quot;confirm.queue&quot;;    //声明业务 Exchange    @Bean(&quot;confirmExchange&quot;)    public DirectExchange confirmExchange() &#123;        return new DirectExchange(CONFIRM_EXCHANGE_NAME);    &#125;    // 声明确认队列    @Bean(&quot;confirmQueue&quot;)    public Queue confirmQueue() &#123;        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();    &#125;    // 声明确认队列绑定关系    @Bean    public Binding queueBinding(@Qualifier(&quot;confirmQueue&quot;) Queue queue,                                @Qualifier(&quot;confirmExchange&quot;) DirectExchange exchange) &#123;        return BindingBuilder.bind(queue).to(exchange).with(&quot;key1&quot;);    &#125;&#125;\n\n消息生产者的回调接口@Component@Slf4jpublic class MyCallBack implements RabbitTemplate.ConfirmCallback &#123;    /**     * 交换机不管是否收到消息的一个回调方法     *     * @param correlationData 消息相关数据     * @param ack             交换机是否收到消息     * @param cause           为收到消息的原因     */    @Override    public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123;        String id = correlationData != null ? correlationData.getId() : &quot;&quot;;        if (ack) &#123;            log.info(&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;, id);        &#125; else &#123;            log.info(&quot;交换机还未收到 id 为:&#123;&#125;消息，原因:&#123;&#125;&quot;, id, cause);        &#125;    &#125;&#125;\n\n消息生产者@RestController@RequestMapping(&quot;/confirm&quot;)@Slf4jpublic class ProducerController &#123;    public static final String CONFIRM_EXCHANGE_NAME = &quot;confirm.exchange&quot;;    @Autowired    private RabbitTemplate rabbitTemplate;    @Autowired    private MyCallBack myCallBack;    //依赖注入 rabbitTemplate 之后再设置它的回调对象    @PostConstruct    public void init() &#123;        rabbitTemplate.setConfirmCallback(myCallBack);    &#125;        /**     * 消息回调和退回     *     * @param message     */    @GetMapping(&quot;sendMessage/&#123;message&#125;&quot;)    public void sendMessage(@PathVariable String message) &#123;        //指定消息 id 为 1        CorrelationData correlationData1 = new CorrelationData(&quot;1&quot;);        String routingKey = &quot;key1&quot;;        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData1);        log.info(routingKey + &quot;发送消息内容:&#123;&#125;&quot;, message + routingKey);        CorrelationData correlationData2 = new CorrelationData(&quot;2&quot;);        routingKey = &quot;key2&quot;;        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message + routingKey, correlationData2);        log.info(routingKey + &quot;发送消息内容:&#123;&#125;&quot;, message + routingKey);    &#125;&#125;\n\n消息消费者@Component@Slf4jpublic class ConfirmConsumer &#123;    public static final String CONFIRM_QUEUE_NAME = &quot;confirm.queue&quot;;    @RabbitListener(queues = CONFIRM_QUEUE_NAME)    public void receiveMsg(Message message) &#123;        String msg = new String(message.getBody());        log.info(&quot;接受到队列 confirm.queue 消息:&#123;&#125;&quot;, msg);    &#125;&#125;\n\n访问： http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD\n结果分析：\n可以看到，发送了两条消息，第一条消息的 RoutingKey 为 “key1”，第二条消息的 RoutingKey 为 “key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。\n丢弃的消息交换机是不知道的，需要解决告诉生产者消息传送失败\n回退消息Mandatory 参数rabbitTemplate.setReturnsCallback(myCallBack);\n\n在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。\n那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。\n修改配置#消息退回spring.rabbitmq.publisher-returns=true\n\n修改回调接口@Component@Slf4jpublic class MyCallBack implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnsCallback &#123;    /**     * 交换机不管是否收到消息的一个回调方法     *     * @param correlationData 消息相关数据     * @param ack             交换机是否收到消息     * @param cause           为收到消息的原因     */    @Override    public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123;        String id = correlationData != null ? correlationData.getId() : &quot;&quot;;        if (ack) &#123;            log.info(&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;, id);        &#125; else &#123;            log.info(&quot;交换机还未收到 id 为:&#123;&#125;消息，原因:&#123;&#125;&quot;, id, cause);        &#125;    &#125;    //当消息无法路由的时候的回调方法    @Override    public void returnedMessage(ReturnedMessage returned) &#123;        log.error(&quot;消息：&#123;&#125;，被交换机 &#123;&#125; 退回，原因：&#123;&#125;，路由key：&#123;&#125;,code:&#123;&#125;&quot;,                new String(returned.getMessage().getBody()), returned.getExchange(),                returned.getReplyText(), returned.getRoutingKey(),                returned.getReplyCode());    &#125;&#125;\n\n低版本可能没有 RabbitTemplate.ReturnsCallback 请用 RabbitTemplate.ReturnCallback\n@Overridepublic void returnedMessage(Message message, int replyCode, String replyText, Stringexchange, String routingKey) &#123;\tlog.info(&quot;消息:&#123;&#125;被服务器退回，退回原因:&#123;&#125;, 交换机是:&#123;&#125;, 路由 key:&#123;&#125;&quot;,new String(message.getBody()),replyText, exchange, routingKey);&#125;\n\n修改发送者 ProducerController//依赖注入 rabbitTemplate 之后再设置它的回调对象@PostConstructpublic void init() &#123;    //消息回调    rabbitTemplate.setConfirmCallback(myCallBack);    /**     * true：交换机无法将消息进行路由时，会将该消息返回给生产者     * false：如果发现消息无法进行路由，则直接丢弃     */    rabbitTemplate.setMandatory(true);    //设置回退消息交给谁处理    rabbitTemplate.setReturnsCallback(myCallBack);&#125;\n\n访问： http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD\n结果分析：\n备份交换机有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？\n前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。 在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。\n什么是备份交换机呢？备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进 入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。\n代码架构图修改配置类@Configurationpublic class ConfirmConfig &#123;    public static final String CONFIRM_EXCHANGE_NAME = &quot;confirm.exchange&quot;;    public static final String CONFIRM_QUEUE_NAME = &quot;confirm.queue&quot;;    //关于备份的    public static final String BACKUP_EXCHANGE_NAME = &quot;backup.exchange&quot;;    public static final String BACKUP_QUEUE_NAME = &quot;backup.queue&quot;;    public static final String WARNING_QUEUE_NAME = &quot;warning.queue&quot;;    /*    //声明业务 Exchange    @Bean(&quot;confirmExchange&quot;)    public DirectExchange confirmExchange() &#123;        return new DirectExchange(CONFIRM_EXCHANGE_NAME);    &#125;    */    // 声明确认队列    @Bean(&quot;confirmQueue&quot;)    public Queue confirmQueue() &#123;        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();    &#125;    // 声明确认队列绑定关系    @Bean    public Binding queueBinding(@Qualifier(&quot;confirmQueue&quot;) Queue queue,                                @Qualifier(&quot;confirmExchange&quot;) DirectExchange exchange) &#123;        return BindingBuilder.bind(queue).to(exchange).with(&quot;key1&quot;);    &#125;    //************************以下是关于备份的******************************    //声明备份 Exchange    @Bean(&quot;backupExchange&quot;)    public FanoutExchange backupExchange() &#123;        return new FanoutExchange(BACKUP_EXCHANGE_NAME);    &#125;    //声明确认 Exchange 交换机的备份交换机    @Bean(&quot;confirmExchange&quot;)    public DirectExchange confirmExchange() &#123;        ExchangeBuilder exchangeBuilder = ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME)                .durable(true)                //设置该交换机的备份交换机                .withArgument(&quot;alternate-exchange&quot;, BACKUP_EXCHANGE_NAME);        return exchangeBuilder.build();    &#125;    // 声明警告队列    @Bean(&quot;warningQueue&quot;)    public Queue warningQueue() &#123;        return QueueBuilder.durable(WARNING_QUEUE_NAME).build();    &#125;    // 声明报警队列绑定关系    @Bean    public Binding warningBinding(@Qualifier(&quot;warningQueue&quot;) Queue queue,                                  @Qualifier(&quot;backupExchange&quot;) FanoutExchange backupExchange) &#123;        return BindingBuilder.bind(queue).to(backupExchange);    &#125;    // 声明备份队列    @Bean(&quot;backQueue&quot;)    public Queue backQueue() &#123;        return QueueBuilder.durable(BACKUP_QUEUE_NAME).build();    &#125;    // 声明备份队列绑定关系    @Bean    public Binding backupBinding(@Qualifier(&quot;backQueue&quot;) Queue queue,                                 @Qualifier(&quot;backupExchange&quot;) FanoutExchange backupExchange) &#123;        return BindingBuilder.bind(queue).to(backupExchange);    &#125;&#125;\n\n报警消费者@Component@Slf4jpublic class WarningConsumer &#123;    public static final String WARNING_QUEUE_NAME = &quot;warning.queue&quot;;    @RabbitListener(queues = WARNING_QUEUE_NAME)    public void receiveWarningMsg(Message message) &#123;        String msg = new String(message.getBody());        log.error(&quot;报警发现不可路由消息：&#123;&#125;&quot;, msg);    &#125;&#125;\n\n之前已写过 confirm.exchange 交换机，由于更改配置，需要删掉，不然会报错\n\n\n访问： http://localhost:8080/confirm/sendMessage/%E4%BD%A0%E5%A5%BD\n\n\nmandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是备份交换机优先级高。\n","tags":["RabbitMQ"]},{"title":"RabbitMQ之延迟队列","url":"/2022/08/05/RabbitMQ%E4%B9%8B%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/","content":"延迟队列概念：延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。\n延迟队列使用场景：1.订单在十分钟之内未支付则自动取消2.新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。3.用户注册成功后，如果三天内没有登陆则进行短信提醒。4.用户发起退款，如果三天内没有得到处理则通知相关运营人员。5.预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议\n这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如： 发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；那我们一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？\n如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求， 如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。\n\nRabbitMQ 中的 TTLTTL 是什么呢？TTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。\n换句话说，如果一条消息设置了 TTL 属性或者进入了设置TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为”死信”。如果同时配置了队列的TTL 和消息的 TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。\n队列设置TTL在创建队列的时候设置队列的“x-message-ttl”属性\n\n消息设置TTL是针对每条消息设置TTL\n\n两者的区别如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；\n另外，还需要注意的一点是，如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。\n整合 springboot前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，TTL 则刚好能让消息在延迟多久之后成为死信，另一方面， 成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息。\n1、创建一个空项目：\n\n2、添加依赖：\n&lt;dependencies&gt;   &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--RabbitMQ 依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;        &lt;version&gt;1.2.47&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!--swagger--&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.springfox&lt;/groupId&gt;        &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;        &lt;version&gt;3.0.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.springfox&lt;/groupId&gt;        &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;        &lt;version&gt;3.0.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--RabbitMQ 测试依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;        &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n3、修改配置文件\nspring.rabbitmq.host=42.192.149.71spring.rabbitmq.port=5672spring.rabbitmq.username=adminspring.rabbitmq.password=123456\n\n4、添加Swagger 配置类 \npackage com.oddfar.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class SwaggerConfig &#123;    @Bean    public Docket webApiConfig() &#123;        return new Docket(DocumentationType.SWAGGER_2)                .groupName(&quot;webApi&quot;)                .apiInfo(webApiInfo())                .select()                .build();    &#125;    private ApiInfo webApiInfo() &#123;        return new ApiInfoBuilder()                .title(&quot;rabbitmq 接口文档&quot;)                .description(&quot;本文档描述了 rabbitmq 微服务接口定义&quot;)                .version(&quot;1.0&quot;)                .contact(new Contact(&quot;zhiyuan&quot;, &quot;http://oddfar.com&quot;, &quot;test@qq.com&quot;))                .build();    &#125;&#125;\n\n队列 TTL代码架构图创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交 换机 Y，它们的类型都是direct，创建一个死信队列 QD，它们的绑定关系如下：\n\n原先配置队列信息，写在了生产者和消费者代码中，现在可写咋配置类中，生产者只发消息，消费者只接受消息\n配置文件类代码 ：package com.oddfar.config;import org.springframework.amqp.core.*;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.HashMap;import java.util.Map;/** * @author zhiyuan */@Configurationpublic class TtlQueueConfig &#123;    public static final String X_EXCHANGE = &quot;X&quot;;    public static final String QUEUE_A = &quot;QA&quot;;    public static final String QUEUE_B = &quot;QB&quot;;    //死信交换机    public static final String Y_DEAD_LETTER_EXCHANGE = &quot;Y&quot;;    //死信队列    public static final String DEAD_LETTER_QUEUE = &quot;QD&quot;;    // 声明 xExchange    @Bean(&quot;xExchange&quot;)    public DirectExchange xExchange() &#123;        return new DirectExchange(X_EXCHANGE);    &#125;    // 声明 死信队列交换机    @Bean(&quot;yExchange&quot;)    public DirectExchange yExchange() &#123;        return new DirectExchange(Y_DEAD_LETTER_EXCHANGE);    &#125;    //声明队列 A ttl 为 10s 并绑定到对应的死信交换机    @Bean(&quot;queueA&quot;)    public Queue queueA() &#123;        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;(3);        //声明当前队列绑定的死信交换机        args.put(&quot;x-dead-letter-exchange&quot;, Y_DEAD_LETTER_EXCHANGE);        //声明当前队列的死信路由 key        args.put(&quot;x-dead-letter-routing-key&quot;, &quot;YD&quot;);        //声明队列的 TTL        args.put(&quot;x-message-ttl&quot;, 10000);        return QueueBuilder.durable(QUEUE_A).withArguments(args).build();    &#125;    // 声明队列 A 绑定 X 交换机    @Bean    public Binding queueaBindingX(@Qualifier(&quot;queueA&quot;) Queue queueA,                                  @Qualifier(&quot;xExchange&quot;) DirectExchange xExchange) &#123;        return BindingBuilder.bind(queueA).to(xExchange).with(&quot;XA&quot;);    &#125;    //声明队列 B ttl 为 40s 并绑定到对应的死信交换机    @Bean(&quot;queueB&quot;)    public Queue queueB() &#123;        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;(3);        //声明当前队列绑定的死信交换机        args.put(&quot;x-dead-letter-exchange&quot;, Y_DEAD_LETTER_EXCHANGE);        //声明当前队列的死信路由 key        args.put(&quot;x-dead-letter-routing-key&quot;, &quot;YD&quot;);        //声明队列的 TTL        args.put(&quot;x-message-ttl&quot;, 40000);        return QueueBuilder.durable(QUEUE_B).withArguments(args).build();    &#125;    //声明队列 B 绑定 X 交换机    @Bean    public Binding queuebBindingX(@Qualifier(&quot;queueB&quot;) Queue queue1B,                                  @Qualifier(&quot;xExchange&quot;) DirectExchange xExchange) &#123;        return BindingBuilder.bind(queue1B).to(xExchange).with(&quot;XB&quot;);    &#125;    //声明死信队列 QD    @Bean(&quot;queueD&quot;)    public Queue queueD() &#123;        return new Queue(DEAD_LETTER_QUEUE);    &#125;    //声明死信队列 QD 绑定关系    @Bean    public Binding deadLetterBindingQAD(@Qualifier(&quot;queueD&quot;) Queue queueD,                                        @Qualifier(&quot;yExchange&quot;) DirectExchange yExchange) &#123;        return BindingBuilder.bind(queueD).to(yExchange).with(&quot;YD&quot;);    &#125;&#125;\n\n消息生产者代码package com.oddfar.contorller;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Date;/** * @author zhiyuan */@Slf4j@RequestMapping(&quot;ttl&quot;)@RestControllerpublic class SendMsgController &#123;    @Autowired    private RabbitTemplate rabbitTemplate;    @GetMapping(&quot;sendMsg/&#123;message&#125;&quot;)    public void sendMsg(@PathVariable String message) &#123;        log.info(&quot;当前时间：&#123;&#125;,发送一条信息给两个 TTL 队列:&#123;&#125;&quot;, new Date(), message);        rabbitTemplate.convertAndSend(&quot;X&quot;, &quot;XA&quot;, &quot;消息来自 ttl 为 10S 的队列: &quot; + message);        rabbitTemplate.convertAndSend(&quot;X&quot;, &quot;XB&quot;, &quot;消息来自 ttl 为 40S 的队列: &quot; + message);    &#125;    &#125;\n\n消息消费者代码package com.oddfar.consumer;import com.rabbitmq.client.Channel;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.core.Message;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;import java.io.IOException;import java.util.Date;/** * 消费者 - 死信队列 * @author zhiyuan */@Slf4j@Componentpublic class DeadLetterQueueConsumer &#123;    @RabbitListener(queues = &quot;QD&quot;)    public void receiveD(Message message, Channel channel) throws IOException &#123;        String msg = new String(message.getBody());        log.info(&quot;当前时间：&#123;&#125;,收到死信队列信息&#123;&#125;&quot;, new Date().toString(), msg);    &#125;&#125;\n\n发起一个请求 http://localhost:8080/ttl/sendMsg/嘻嘻嘻\n\n第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息， 然后被消费掉，这样一个延时队列就打造完成了。\n不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S 两个时间选项，如果需要一个小时后处理，那么就需要增加TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？\n延时队列TTL优化代码架构图在这里新增了一个队列 QC,绑定关系如下,该队列不设置TTL 时间\n\n配置文件类代码@Configurationpublic class MsgTtlQueueConfig &#123;    public static final String Y_DEAD_LETTER_EXCHANGE = &quot;Y&quot;;    public static final String QUEUE_C = &quot;QC&quot;;    //声明队列 C 死信交换机    @Bean(&quot;queueC&quot;)    public Queue queueB() &#123;        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;(3);        //声明当前队列绑定的死信交换机        args.put(&quot;x-dead-letter-exchange&quot;, Y_DEAD_LETTER_EXCHANGE);        //声明当前队列的死信路由 key        args.put(&quot;x-dead-letter-routing-key&quot;, &quot;YD&quot;);        //没有声明 TTL 属性        return QueueBuilder.durable(QUEUE_C).withArguments(args).build();    &#125;    //声明队列 B 绑定 X 交换机    @Bean    public Binding queuecBindingX(@Qualifier(&quot;queueC&quot;) Queue queueC,                                  @Qualifier(&quot;xExchange&quot;) DirectExchange xExchange) &#123;        return BindingBuilder.bind(queueC).to(xExchange).with(&quot;XC&quot;);    &#125;&#125;\n\n生产者代码/** * 延时队列优化 * @param message 消息 * @param ttlTime 延时的毫秒 */@GetMapping(&quot;sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)public void sendMsg(@PathVariable String message, @PathVariable String ttlTime) &#123;    rabbitTemplate.convertAndSend(&quot;X&quot;, &quot;XC&quot;, message, correlationData -&gt; &#123;        correlationData.getMessageProperties().setExpiration(ttlTime);        return correlationData;    &#125;);    log.info(&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒 TTL 信息给队列 C:&#123;&#125;&quot;, new Date(), ttlTime, message);&#125;\n\n发起请求\nhttp://localhost:8080/ttl/sendExpirationMsg/你好1/20000\nhttp://localhost:8080/ttl/sendExpirationMsg/你好2/2000\n\n看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“\n因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。\n这也就是为什么第二个延时2秒，却后执行。\nRabbitmq 插件实现延迟队列上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的 TTL，并使其在设置的TTL 时间及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。\n安装延时队列插件可去官网下载 rabbitmq_delayed_message_exchange 插件，放置到 RabbitMQ 的插件目录。\n进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ\n[root@VM-0-6-centos software]# lserlang-21.3.8.21-1.el7.x86_64.rpm  rabbitmq_delayed_message_exchange-3.8.0.ez  rabbitmq-server-3.8.8-1.el7.noarch.rpm#移动cp rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins#安装rabbitmq-plugins enable rabbitmq_delayed_message_exchange#重启服务systemctl restart rabbitmq-server\n\n\n代码架构图在这里新增了一个队列delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:\n\n配置文件类代码：在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。\n@Configurationpublic class DelayedQueueConfig &#123;    public static final String DELAYED_QUEUE_NAME = &quot;delayed.queue&quot;;    public static final String DELAYED_EXCHANGE_NAME = &quot;delayed.exchange&quot;;    public static final String DELAYED_ROUTING_KEY = &quot;delayed.routingkey&quot;;    @Bean    public Queue delayedQueue() &#123;        return new Queue(DELAYED_QUEUE_NAME);    &#125;    //自定义交换机 我们在这里定义的是一个延迟交换机    @Bean    public CustomExchange delayedExchange() &#123;        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();        //自定义交换机的类型        args.put(&quot;x-delayed-type&quot;, &quot;direct&quot;);        return new CustomExchange(DELAYED_EXCHANGE_NAME, &quot;x-delayed-message&quot;, true, false, args);    &#125;    @Bean    public Binding bindingDelayedQueue(@Qualifier(&quot;delayedQueue&quot;) Queue queue,                                       @Qualifier(&quot;delayedExchange&quot;) CustomExchange delayedExchange) &#123;        return BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();    &#125;&#125;\n\n生产者代码@GetMapping(&quot;sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)public void sendMsg(@PathVariable String message, @PathVariable Integer delayTime) &#123;    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message,            correlationData -&gt; &#123;                correlationData.getMessageProperties().setDelay(delayTime);                return correlationData;            &#125;);    log.info(&quot; 当 前 时 间 ： &#123;&#125;, 发 送 一 条 延 迟 &#123;&#125; 毫秒的信息给队列 delayed.queue:&#123;&#125;&quot;, new Date(), delayTime, message);&#125;\n\n消费者代码/** * 消费者 - 基于插件的延时队列 * * @author zhiyuan */@Slf4j@ComponentScanpublic class DelayQueueConsumer &#123;    public static final String DELAYED_QUEUE_NAME = &quot;delayed.queue&quot;;    @RabbitListener(queues = DELAYED_QUEUE_NAME)    public void receiveDelayedQueue(Message message) &#123;        String msg = new String(message.getBody());        log.info(&quot;当前时间：&#123;&#125;,收到延时队列的消息：&#123;&#125;&quot;, new Date().toString(), msg);    &#125;&#125;\n\n发送请求：\n\nhttp://localhost:8080/ttl/sendDelayMsg/hello1/20000\nhttp://localhost:8080/ttl/sendDelayMsg/hello2/2000\n\n\n第二个消息被先消费掉了，符合预期\n总结延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。\n当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景\n","tags":["RabbitMQ"]},{"title":"RabbitMQ之死信队列","url":"/2022/08/05/RabbitMQ%E4%B9%8B%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/","content":"死信的概念先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理 解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。\n应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效\n死信的来源\n消息 TTL 过期\nTTL是Time To Live的缩写, 也就是生存时间\n\n队列达到最大长度\n队列满了，无法再添加数据到 mq 中\n\n消息被拒绝\n(basic.reject 或 basic.nack) 并且 requeue&#x3D;false.\n\n\n死信实战代码架构图\n死信之消息TTL 过期消费者 C1 代码：\n/** * 死信队列 - 消费者01 * * @author zhiyuan */public class Consumer01 &#123;    //普通交换机名称    private static final String NORMAL_EXCHANGE = &quot;normal_exchange&quot;;    //死信交换机名称    private static final String DEAD_EXCHANGE = &quot;dead_exchange&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        //声明死信和普通交换机 类型为 direct        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);        //声明死信队列        String deadQueue = &quot;dead-queue&quot;;        channel.queueDeclare(deadQueue, false, false, false, null);        //死信队列绑定：队列、交换机、路由键（routingKey）        channel.queueBind(deadQueue, DEAD_EXCHANGE, &quot;lisi&quot;);        //正常队列绑定死信队列信息        Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();        //正常队列设置死信交换机 参数 key 是固定值        params.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);        //正常队列设置死信 routing-key 参数 key 是固定值        params.put(&quot;x-dead-letter-routing-key&quot;, &quot;lisi&quot;);        //正常队列        String normalQueue = &quot;normal-queue&quot;;        channel.queueDeclare(normalQueue, false, false, false, params);        channel.queueBind(normalQueue, NORMAL_EXCHANGE, &quot;zhangsan&quot;);        System.out.println(&quot;等待接收消息........... &quot;);        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);            System.out.println(&quot;Consumer01 接收到消息&quot; + message);        &#125;;        channel.basicConsume(normalQueue, true, deliverCallback, consumerTag -&gt; &#123;        &#125;);    &#125;&#125;\n\n生产者代码\npublic class Producer &#123;    private static final String NORMAL_EXCHANGE = &quot;normal_exchange&quot;;    public static void main(String[] argv) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);        //设置消息的 TTL 时间 10s        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();        //该信息是用作演示队列个数限制        for (int i = 1; i &lt; 11; i++) &#123;            String message = &quot;info&quot; + i;            channel.basicPublish(NORMAL_EXCHANGE, &quot;zhangsan&quot;, properties, message.getBytes());            System.out.println(&quot;生产者发送消息:&quot; + message);        &#125;    &#125;&#125;\n\n启动 C1 ，之后关闭消费者，模拟其接收不到消息。再启动 Producer\n\n消费者 C2 代码：\n以上步骤完成后，启动 C2 消费者，它消费死信队列里面的消息\npublic class Consumer02 &#123;    //死信交换机名称    private static final String DEAD_EXCHANGE = &quot;dead_exchange&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        //声明交换机        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);        //声明队列        String deadQueue = &quot;dead-queue&quot;;        channel.queueDeclare(deadQueue, false, false, false, null);        channel.queueBind(deadQueue, DEAD_EXCHANGE, &quot;lisi&quot;);        System.out.println(&quot;等待接收死信消息........... &quot;);        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);            System.out.println(&quot;Consumer02 接收到消息&quot; + message);        &#125;;        channel.basicConsume(deadQueue, true, deliverCallback, consumerTag -&gt; &#123;        &#125;);    &#125;&#125;\n\n\n死信之最大长度1、消息生产者代码去掉 TTL 属性\n\n2、C1 消费者修改以下代码**(启动之后关闭该消费者 模拟其接收不到消息)**\n\n//设置正常队列的长度限制，例如发10个，4个则为死信params.put(&quot;x-max-length&quot;,6);\n\n注意此时需要把原先队列删除 因为参数改变了\n3、C2 消费者代码不变(启动 C2 消费者) \n\n死信之消息被拒1、消息生产者代码同上生产者一致\n2、C1 消费者代码(启动之后关闭该消费者 模拟其接收不到消息)\n拒收消息 “info5” \npublic class Consumer01 &#123;    //普通交换机名称    private static final String NORMAL_EXCHANGE = &quot;normal_exchange&quot;;    //死信交换机名称    private static final String DEAD_EXCHANGE = &quot;dead_exchange&quot;;    public static void main(String[] args) throws Exception &#123;        Channel channel = RabbitMqUtils.getChannel();        //声明死信和普通交换机 类型为 direct        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);        //声明死信队列        String deadQueue = &quot;dead-queue&quot;;        channel.queueDeclare(deadQueue, false, false, false, null);        //死信队列绑定：队列、交换机、路由键（routingKey）        channel.queueBind(deadQueue, DEAD_EXCHANGE, &quot;lisi&quot;);                //正常队列绑定死信队列信息        Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();        //正常队列设置死信交换机 参数 key 是固定值        params.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);        //正常队列设置死信 routing-key 参数 key 是固定值        params.put(&quot;x-dead-letter-routing-key&quot;, &quot;lisi&quot;);//        //设置正常队列的长度限制，例如发10个，4个则为死信//        params.put(&quot;x-max-length&quot;,6);                //正常队列        String normalQueue = &quot;normal-queue&quot;;        channel.queueDeclare(normalQueue, false, false, false, params);        channel.queueBind(normalQueue, NORMAL_EXCHANGE, &quot;zhangsan&quot;);        System.out.println(&quot;等待接收消息........... &quot;);                DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);            if (message.equals(&quot;info5&quot;)) &#123;                System.out.println(&quot;Consumer01 接收到消息&quot; + message + &quot;并拒绝签收该消息&quot;);                //requeue 设置为 false 代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);            &#125; else &#123;                System.out.println(&quot;Consumer01 接收到消息&quot; + message);                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);            &#125;        &#125;;        //开启手动应答        channel.basicConsume(normalQueue, false, deliverCallback, consumerTag -&gt; &#123;        &#125;);    &#125;&#125;\n\n\n3、C2 消费者代码不变\n启动消费者 1 然后再启动消费者 2 \n\n","tags":["RabbitMQ"]},{"title":"RabbitMQ之消息队列","url":"/2022/08/05/RabbitMQ%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","content":"MQ 的相关概念什么是MQMQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。\n为什么要用MQ\n流量消峰\n\n举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。\n\n应用解耦\n\n以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合 调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于 消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在 这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流 系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。\n\n\n异步处理\n\n有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。\n以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅。\n使用消息总线，可以很方便解决这个问题， A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用 做这些操作。A 服务还能及时的得到异步处理成功的消息。\n\nMQ 的分类\nActiveMQ\n\n优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据\n缺点：官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。\n\nKafka\n\n大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件， 以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥 着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。\n优点：性能卓越，单机写入 TPS 约在百万条&#x2F;秒，最大的优点，就是吞吐量高。时效性 ms 级可用性非 常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采 用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持： 功能 较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用\n缺点：Kafka 单机超过 64 个队列&#x2F;分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消 息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序， 但是一台代理宕机后，就会产生消息乱序，社区更新较慢；\n\nRocketMQ\n\nRocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一 些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场 景。\n优点：单机吞吐量十万级,可用性非常高，分布式架构，消息可以做到 0 丢失,MQ 功能较为完善，还是分 布式的，扩展性好,支持 10 亿级别的消息堆积，不会因为堆积导致性能下降,源码是 java 我们可以自己阅 读源码，定制自己公司的 MQ\n缺点：支持的客户端语言不多，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在MQ 核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码\n\nRabbitMQ\n\n2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。\n优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易 用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高\n官网更新：https://www.rabbitmq.com/news.html(opens new window)\n缺点：商业版需要收费,学习成本较高\nMQ 的选择\nKafka\n\nKafka 主要特点是基于Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集 和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能， 肯定是首选 kafka 了。\n\nRocketMQ\n\n天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削 峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务 场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。\n\nRabbitMQ\n\n结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。\nRabbitMQRabbitMQ 的概念RabbitMQ 是一个消息中间件：它接受并转发消息。\n你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。\nRabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。\n\n官网：https://www.rabbitmq.com/#features\n四大核心概念\n生产者\n\n产生数据发送消息的程序是生产者\n\n交换机\n\n交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推 送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定\n\n队列\n\n队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存 储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可 以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式\n\n消费者\n\n消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费 者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。\nRabbitMQ 核心部分\n各个名词介绍\n\nBroker\n\n接收和分发消息的应用，RabbitMQ Server 就是 Message Broker\n\nVirtual host\n\n出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似 于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出 多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等\n\nConnection\n\npublisher／consumer 和 broker 之间的 TCP 连接\n\nChannel\n\n如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销 \n\nExchange\n\nmessage 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)\n\nQueue\n\n消息最终被送到这里等待 consumer 取走\n\nBinding\n\nexchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据\nLinux安装1、下载\n官网下载地址：https://www.rabbitmq.com/download.html\n这里我们选择的版本号（注意这两版本要求）\n\nrabbitmq-server-3.8.8-1.el7.noarch.rpm\nGitHub：https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.8.8\n加载下载：https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.8-1.el7.noarch.rpm\n\nerlang-21.3.8.21-1.el7.x86_64.rpm\n官网：https://www.erlang-solutions.com/downloads/\n加速：https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-21.3.8.21-1.el7.x86_64.rpm\n\n\nRed Hat 8, CentOS 8 和 modern Fedora 版本，把 “el7” 替换成 “el8”\n2、上传文件\n上传到&#x2F;usr&#x2F;local&#x2F;software 目录下(如果没有 software 需要自己创建)\n\n3、安装\n上传到 /usr/local/software 目录下(如果没有 software 需要自己创建)\nrpm -ivh erlang-21.3.8.21-1.el7.x86_64.rpmyum install socat -yrpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm\n\n4、启动\n#添加开机启动 RabbitMQ 服务 chkconfig rabbitmq-server on# 启动服务systemctl start rabbitmq-server# 查看服务状态systemctl status rabbitmq-server# 开机自启动systemctl enable rabbitmq-server# 停止服务systemctl stop rabbitmq-server# 重启服务systemctl restart rabbitmq-server\n\nWeb管理界面及授权操作1、安装\n默认情况下，是没有安装web端的客户端插件，需要安装才可以生效\nrabbitmq-plugins enable rabbitmq_management\n\n安装完毕以后，重启服务即可\nsystemctl restart rabbitmq-server\n\n访问 http://42.192.149.71:15672 ，用默认账号密码(guest)登录，出现权限问题\n\n默认情况只能在 localhost 本机下访问，所以需要添加一个远程登录的用户\n2、添加用户\n# 创建账号和密码rabbitmqctl add_user admin 123456# 设置用户角色rabbitmqctl set_user_tags admin administrator# 为用户添加资源权限# set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;# 添加配置、写、读权限#当前用户和角色 rabbitmqctl list_users\n\n用户级别：\n\nadministrator：可以登录控制台、查看所有信息、可以对 rabbitmq 进行管理\nmonitoring：监控者 登录控制台，查看所有信息\npolicymaker：策略制定者 登录控制台，指定策略\nmanagment：普通管理员 登录控制台\n\n再次登录，用 admin 用户\n\n重置命令\n\n关闭应用的命令为：rabbitmqctl stop_app\n清除的命令为：rabbitmqctl reset\n重新启动命令为：rabbitmqctl start_app\nDocker 安装官网：https://registry.hub.docker.com/_/rabbitmq/\ndocker run -id --name myrabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=123456 -p 15672:15672 rabbitmq:3-management\n\n","tags":["RabbitMQ"]},{"title":"Jenkins之介绍","url":"/2022/08/17/Jenkins%E4%B9%8B%E4%BB%8B%E7%BB%8D/","content":"Jenkins是什么？ Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续、自动的构建&#x2F;测试软件项目、监控外部任务的运行。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。\n官网： http://jenkins-ci.org/。\nJenkins的特征：\n\n开源的Java语言开发持续集成工具，支持持续集成，持续部署。\n易于安装部署配置：可通过yum安装,或下载war包以及通过docker容器等快速实现安装部署，可方便web界面配置管理。\n消息通知及测试报告：集成RSS&#x2F;E-mail通过RSS发布构建结果或当构建完成时通过e-mail通知，生成JUnit&#x2F;TestNG测试报告。\n分布式构建：支持Jenkins能够让多台计算机一起构建&#x2F;测试\n文件识别：Jenkins能够跟踪哪次构建生成哪些jar，哪次构建使用哪个版本的jar等。\n丰富的插件支持：支持扩展插件，你可以开发适合自己团队使用的工具，如git，svn，maven， docker等。\n\n相关概念介绍软件开发生命周期\n\n需求分析\n这是生命周期的第一阶段，根据项目需求，团队执行一个可行性计划的分析。项目需求可能是公司内部或者客户提出的。这阶段主要是对信息的收集，也有可能是对现有项目的改善和重新做一个新的项目。 还要分析项目的预算多长，可以从哪方面受益及布局，这也是项目创建的目标。\n\n设计\n第二阶段就是设计阶段，系统架构和满意状态（就是要做成什么样子，有什么功能），和创建一个项目 计划。计划可以使用图表，布局设计或者文者的方式呈现。\n\n实现\n第三阶段就是实现阶段，项目经理创建和分配工作给开者，开发者根据任务和在设计阶段定义的目标进 行开发代码。依据项目的大小和复杂程度，可以需要数月或更长时间才能完成。\n\n测试\n测试人员进行代码测试 ，包括功能测试、代码测试、压力测试等\n\n进化\n最后进阶段就是对产品不断的进化改进和维护阶段，根据用户的使用情况，可能需要对某功能进行修 改，bug修复，功能增加等。\n\n\n软件开发瀑布模型瀑布模型是最著名和最常使用的软件开发模型。瀑布模型就是一系列的软件开发过程。它是由制造业繁衍出来的。一个高度化的结构流程在一个方向上流动，有点像生产线一样。在瀑布模型创建之初，没有其它开发的模型，有很多东西全靠开发人员去猜测，去开发。这样的模型仅适用于那些简单的软件开发， 但是已经不适合现在的开发了。\n\n优势：\n\n简单易用和理解\n当前一阶段完成后，您只需要 去关注后续阶段。\n为项目提供了按阶段划分的检 查节点\n\n劣势：\n\n各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量。\n由于开发模型是线性的，用户只有等到整个过程的末期才能见 到开发成果，从而增加了开发风险。\n瀑布模型的突出缺点是不适应用户需求的变化。\n\n软件的敏捷开发\n什么是敏捷开发？\n\n敏捷开发（Agile Development） 的核心是迭代开发（Iterative Development） 与 增量开发 （Incremental Development） 。\n\n 何为迭代开发？\n\n对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次”大开发”；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次”大开发”变成多次”小开发”，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。\n举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨道。然后，开发了中型火箭 Falcon 9，九年中发射了70次。最后，才开发 Falcon 重型火箭。如果 SpaceX 不采用迭代开发，它可能直到现在还无法上天。\n\n何为增量开发？\n\n软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。\n举例来说，房产公司开发一个10栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一号楼，第二个迭代交付二号楼……每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好10栋楼的地基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶……\n\n敏捷开发如何迭代？\n\n虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按 照软件工程的方法论，进行正规的流程管理。\n\n\n敏捷开发有什么好处？\n\n\n早期交付\n\n敏捷开发的第一个好处，就是早期交付，从而大大降低成本。 还是以上一节的房产公司为例，如果按照传统的”瀑布开发模式”，先挖10栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完成后开始，可能需要两年才能一次性交付10栋楼。也就是说，如果不考虑预售，该项目必须等到两年后才能回款。 敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后面每个月都会有现金流，资金压力就大大减轻了。\n\n降低风险\n\n敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。 请想一想，哪一种情况损失比较小：10栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后面9栋楼？\n什么是持续集成持续集成（ Continuous integration ， 简称 CI ）指的是，频繁地（一天多次）将代码集成到主干\n持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。\n通过持续集成， 团队可以快速的从一个功能到另一个功能，简而言之，敏捷软件开发很大一部分都要归功于持续集成。\n持续集成的流程\n\n\n根据持续集成的设计，代码从提交到生产，整个过程有以下几步。\n\n\n提交\n流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交 （commit）。\n\n测试（第一轮）\n代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试\n\n构建\n通过第一轮测试，代码就可以合并进主干，就算可以交付了。\n交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。\n\n测试（第二轮）\n构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时 构建步骤也要移到第一轮测试前面。\n\n部署\n过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。\n\n回滚\n一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指 向上一个版本的目录。\n\n\n持续集成的组成要素\n一个自动构建过程， 从检出代码、 编译构建、 运行测试、 结果记录、 测试统计等都是自动完成 的， 无需人工干预\n一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库，一般 使用SVN或Git\n一个持续集成服务器， Jenkins 就是一个配置简单和使用方便的持续集成服务器。\n\n\n持续集成的好处1、降低风险，由于持续集成不断去构建，编译和测试，可以很早期发现问题，所以修复的代价就少； \n2、对系统健康持续检查，减少发布风险带来的问题； \n3、减少重复性工作； \n4、持续部署，提供可部署单元包； \n5、持续交付可供使用的版本； \n6、增强团队信心；\n参考资料\nhttps://www.jianshu.com/p/5f671aca2b5a\nhttps://www.bilibili.com/video/BV1kJ411p7mV\n\n","tags":["Jenkins"]},{"title":"Jenkins之自动构建部署SpringBoot项目","url":"/2022/08/17/Jenkins%E4%B9%8B%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2SpringBoot%E9%A1%B9%E7%9B%AE/","content":"前提条件\n一台服务器\n建议配置2h4g以上（1h2g的属实有点低了）\n\nsspringboot项目手动用maven打包，且jar包可正常运行\n如果你的是多模块项目（如图），需要配置好打包，否则启动失败\n\n\n就像这样的项目，可浏览文章：SpringBoot多模块打包方式\n\n\n安装Jenkins安装教程可看视频：https://www.bilibili.com/video/BV1wA411c7aS\n1、安装\ndocker pull jenkins/jenkins:lts\n\n2、创建目录\n[root@localhost data]# mkdir jenkins_home[root@localhost data]# lsdocker  jenkins_home\n\n3、启动\ndocker run -di --name=jenkins -p 8080:8080 -v /data/jenkins_home:/var/jenkins_home jenkins/jenkins:lts\n\n启动失败：\n[root@localhost data]# docker logs  d6b5baf89d6btouch: cannot touch &#x27;/var/jenkins_home/copy_reference_file.log&#x27;: Permission deniedCan not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?touch: cannot touch &#x27;/var/jenkins_home/copy_reference_file.log&#x27;: Permission deniedCan not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?\n\n权限：\nchown -R 1000 /data/jenkins_home\n\n再重新启动，等启动工作完毕后\n\n查看容器日志：\ndocker logs jenkins\n\n\n箭头所指就是密码\n\n方法二：\n\n[root@localhost data]# cd jenkins_home/secrets/[root@localhost secrets]# ll总用量 20drwxr-xr-x 2 www www  29 9月  14 18:45 filepath-filters.d-rw-r----- 1 www www  33 9月  14 18:45 initialAdminPassword-rw-r--r-- 1 www www  32 9月  14 18:45 jenkins.model.Jenkins.crumbSalt-rw-r--r-- 1 www www 256 9月  14 18:45 master.key-rw-r--r-- 1 www www 272 9月  14 18:45 org.jenkinsci.main.modules.instance_identity.InstanceIdentity.KEY-rw-r--r-- 1 www www   5 9月  14 18:45 slave-to-master-security-kill-switchdrwxr-xr-x 2 www www  26 9月  14 18:45 whitelisted-callables.d[root@localhost secrets]# cat initialAdminPassword730edbb8adcd4ae7b58f14ac3ccd001d\n\nJenkins修改初始密码:https://blog.csdn.net/John_z1/article/details/88972490\n5、进入页面后，选择推荐的插件\n\n\n全部安装成功后：\n\n\n有一些会安装失败（我用的服务器，用虚拟机的由于有墙可能访问不到github）\n\n\n点击重试后\n\n大部分都装上了，有几个可能会装不上，到时候可以手动安装，先点确定\n然后创建用户\n\n下一步，URL为，jenkins的IP:端口\n\n插件安装\n搜索插件 ssh（红色代表与jenkins版本不匹配）\n\n安装失败重新安装即可！\n第一行表示之前的安装的日志，等图标变成蓝色代表安装成功\n安装jdk全局工具配置\n\n点新增JDK，选择版本，登录下oracle账号：&#x32;&#x36;&#57;&#54;&#54;&#55;&#49;&#50;&#56;&#x35;&#64;&#113;&#113;&#x2e;&#99;&#x6f;&#109; Oracle123\n账号为up主提供的：https://www.bilibili.com/video/BV1wA411c7aS\n\n之后安装maven（如果你的项目不是maven则安装别的插件）\n安装maven点击保存\n\n配置ssh\n搜索 ssh\n\n添加ssh的ip和端口 ， 点击添加\n\n\n添加服务器的账号和密码\n\n检测连接是否成功\n\n\n构建项目1、新建项目\n\n\n2、输入任务名称，选择maven\n没有这个项目则下载maven插件（百度即可）\nMaven Integration plugin\n\n3、设置源码管理\n\n\n记得添加你的gitee账号密码的凭据\n4、设置Maven\n\n\n设置\nclean package\n\n\n然后我们先构建下，等待结束\n\n\n但是maven下载依赖速度太慢，我们可以手动关闭构建，把镜像配置为阿里云镜像\n5、修改maven配置\n配置文件在你的jenkins数据目录下，例如我的就是：\n/data/jenkins_home/tools/hudson.tasks.Maven_MavenInstallation\n按照原先方法修改配置文件，把maven远程仓库地址改成阿里云的。\n6、重新构建\n点击 立即构建\n这次下载速度就快了，构建好的jar包目录在：\n/data/jenkins_home/workspace/jekins-test/service/target\njekins-test：是任务名称（我创建任务时，少打了个n）\n选中查看控制台输出\n\n根据输出就能看到jar的生成目录\n\n然后我们启动看看是否正常\ncd /data/jenkins_home/workspace/jekins-test/service/targetnohup java -jar service-0.0.1-SNAPSHOT.jar &gt; /data/journalism/logs.txt &amp;\n\n构建后自动部署8160是我的springboot服务端口\nnetstat  -nlp|grep 8160\n\n强制杀死某个端口进程命令，关闭jar包\nsudo fuser -k -n tcp 8160\n\n请先把刚才开启的jar包服务关掉\n设置构建环境配置，构建后操作（构建前就不用设置，测试过，填了就出现错误）\n\nGit提交后自动构建1、配置URL构建触发器\n令牌随便输，URL格式就是下面那个英文说明，根据自己的修改\n\n2、配置Gitee的WebHooks\n我这里用的Gitee（学校网进GitHub很不稳定，就选择Gitee了）\nGitee项目里设置URL和秘钥\n为了安全自己写个服务用来访问触发Jenkins构建的URL，不直接输入之前的URL\n例如：我用的php，代码在下方\n\n3、添加用户token\n\n生成，保存token信息\n\n修改url，例如我的，根据自己规则设置\nhttp://用户名:token@ip:端口/job/jekins-test/build?token=设置的token\n详情访问：通过URL触发Jenkins构建\nphp代码如下（修改URL和秘钥）：\n&lt;?php//接收头信息 function em_getallheaders()&#123;   foreach ($_SERVER as $name =&gt; $value)   &#123;       if (substr($name, 0, 5) == &#x27;HTTP_&#x27;)       &#123;           $headers[str_replace(&#x27; &#x27;, &#x27;-&#x27;, ucwords(strtolower(str_replace(&#x27;_&#x27;, &#x27; &#x27;, substr($name, 5)))))] = $value;       &#125;   &#125;   return $headers;&#125;//发送请求function getSslPage($url) &#123;    $ch = curl_init();    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);    curl_setopt($ch, CURLOPT_HEADER, false);    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);    curl_setopt($ch, CURLOPT_URL, $url);    curl_setopt($ch, CURLOPT_REFERER, $url);    curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);    $result = curl_exec($ch);    curl_close($ch);    return $result;&#125;$url = &quot;你的URL&quot;;$headers = em_getallheaders();//是否等于Gitee设置的秘钥if($headers[&#x27;X-Gitee-Token&#x27;] == &quot;你设置的秘钥&quot;)&#123;    //调用    getSslPage($url);    echo &quot;ok&quot;;&#125;else&#123;    echo &quot;no&quot;;&#125;print_r($headers[&#x27;X-Gitee-Token&#x27;]) ;\n\n4、完成测试\n更改代码，push到Gitee\n\nGitee请求成功\n\njenkins构建成功\n\n","tags":["Jenkins"]},{"title":"k8s之Kubeadm和使用kubeadm-ha脚本一键安装K8S","url":"/2022/08/24/README/","content":"使用kubeadm-ha脚本一键安装K8S\nGithub地址：https://github.com/TimeBye/kubeadm-ha\n\n环境准备官网的安装说明也很简单但是还有些细节还是没有提到，所以我自己照着官网的教程 补充了一些细节\n硬件系统要求\nMaster节点：2C4G +\nWorker节点：2C4G +\n\n使用centos7.7安装请按上面配置准备好3台centos,1台作为Master节点,2台Worker节点\n本方式为1主2worker的配置\n这是我的各个节点的配置\n\n\n\n主机名\nip\n配置\n\n\n\nk8s-master\n192.168.177.130\n2C4G\n\n\nk8s-node1\n192.168.177.131\n2C2G\n\n\nk8s-node2\n192.168.177.132\n2C2G\n\n\ncentos准备在安装之前需要准备一些基础的软件环境用于下载一键安装k8s的脚本和编辑配置\ncentos网络准备安装时需要连接互联网下载各种软件 所以需要保证每个节点都可以访问外网\nping baidu.com\n\n建议关闭 CentOS 的防火墙\nsystemctl stop firewalld  &amp;&amp; systemctl disable firewalld &amp;&amp; systemctl status firewalld \n\n同时需要保证各个节点间可以相互ping通\nping 其他节点ip\n\nCentOS软件准备用 ssh 连接到 Master 节点上安装 Git\nyum install git -y\n\n部署k8s前配置下载部署脚本在Master节点clone安装脚本 脚本地址\ngit clone --depth 1 https://github.com/TimeBye/kubeadm-ha\n\n进入到下载的部署脚本的目录\ncd kubeadm-ha\n\n安装 Ansible 运行环境在master节点安装Ansible环境\nsudo ./install-ansible.sh\n\n修改安装的配置文件由于我是一个master两个node的方式构建的centos所以我们需要修改example&#x2F;hosts.s-master.ip.ini 文件\nvi example/hosts.s-master.ip.ini \n\n具体要修改的就是 ip 和密码 其他的保持默认\n我的hosts.s-master.ip.ini 文件预览\n; 将所有节点信息在这里填写;    第一个字段                  为远程服务器内网IP;    第二个字段 ansible_port     为节点 sshd 监听端口;    第三个字段 ansible_user     为节点远程登录用户名;    第四个字段 ansible_ssh_pass 为节点远程登录用户密码[all]192.168.177.130 ansible_port=22 ansible_user=&quot;root&quot; ansible_ssh_pass=&quot;moxi&quot;192.168.177.131 ansible_port=22 ansible_user=&quot;root&quot; ansible_ssh_pass=&quot;moxi&quot;192.168.177.132 ansible_port=22 ansible_user=&quot;root&quot; ansible_ssh_pass=&quot;moxi&quot;; 单 master 节点不需要进行负载均衡，lb节点组留空。[lb]; 注意etcd集群必须是1,3,5,7...奇数个节点[etcd]192.168.177.130192.168.177.131192.168.177.132[kube-master]192.168.177.130[kube-worker]192.168.177.130192.168.177.131192.168.177.132; 预留组，后续添加master节点使用[new-master]; 预留组，后续添加worker节点使用[new-worker]; 预留组，后续添加etcd节点使用[new-etcd]; 预留组，后续删除worker角色使用[del-worker]; 预留组，后续删除master角色使用[del-master]; 预留组，后续删除etcd角色使用[del-etcd]; 预留组，后续删除节点使用[del-node];-------------------------------------- 以下为基础信息配置 ------------------------------------;[all:vars]; 是否跳过节点物理资源校验，Master节点要求2c2g以上，Worker节点要求2c4g以上skip_verify_node=true; kubernetes版本kube_version=&quot;1.18.14&quot;; 负载均衡器;   有 nginx、openresty、haproxy、envoy  和 slb 可选，默认使用 nginx;   为什么单 master 集群 apiserver 也使用了负载均衡请参与此讨论： https://github.com/TimeBye/kubeadm-ha/issues/8lb_mode=&quot;nginx&quot;; 使用负载均衡后集群 apiserver ip，设置 lb_kube_apiserver_ip 变量，则启用负载均衡器 + keepalived; lb_kube_apiserver_ip=&quot;192.168.56.15&quot;; 使用负载均衡后集群 apiserver portlb_kube_apiserver_port=&quot;8443&quot;; 网段选择：pod 和 service 的网段不能与服务器网段重叠，; 若有重叠请配置 `kube_pod_subnet` 和 `kube_service_subnet` 变量设置 pod 和 service 的网段，示例参考：;    如果服务器网段为：10.0.0.1/8;       pod 网段可设置为：192.168.0.0/18;       service 网段可设置为 192.168.64.0/18;    如果服务器网段为：172.16.0.1/12;       pod 网段可设置为：10.244.0.0/18;       service 网段可设置为 10.244.64.0/18;    如果服务器网段为：192.168.0.1/16;       pod 网段可设置为：10.244.0.0/18;       service 网段可设置为 10.244.64.0/18; 集群pod ip段，默认掩码位 18 即 16384 个ipkube_pod_subnet=&quot;10.244.0.0/18&quot;; 集群service ip段kube_service_subnet=&quot;10.244.64.0/18&quot;; 分配给节点的 pod 子网掩码位，默认为 24 即 256 个ip，故使用这些默认值可以纳管 16384/256=64 个节点。kube_network_node_prefix=&quot;24&quot;; node节点最大 pod 数。数量与分配给节点的 pod 子网有关，ip 数应大于 pod 数。; https://cloud.google.com/kubernetes-engine/docs/how-to/flexible-pod-cidrkube_max_pods=&quot;110&quot;; 集群网络插件，目前支持flannel,caliconetwork_plugin=&quot;calico&quot;; 若服务器磁盘分为系统盘与数据盘，请修改以下路径至数据盘自定义的目录。; Kubelet 根目录kubelet_root_dir=&quot;/var/lib/kubelet&quot;; docker容器存储目录docker_storage_dir=&quot;/var/lib/docker&quot;; Etcd 数据根目录etcd_data_dir=&quot;/var/lib/etcd&quot;\n\n升级内核修改完配置文件后建议升级内核\nansible-playbook -i example/hosts.s-master.ip.ini 00-kernel.yml\n\n内核升级完毕后重启所有节点 在master node1 node2上执行\nreboot\n\n开始部署k8s等待所有的节点重启完成后进入脚本目录\ncd kubeadm-ha\n\n执行一键部署命令ansible-playbook -i example/hosts.s-master.ip.ini 90-init-cluster.yml\n\n查看节点运行情况kubectl get nodes\n\n等待所有节点ready 即为创建成功\t\nNAME             STATUS   ROLES                AGE     VERSION192.168.28.128   Ready    etcd,worker          2m57s   v1.18.14192.168.28.80    Ready    etcd,master,worker   3m29s   v1.18.14192.168.28.89    Ready    etcd,worker          2m57s   v1.18.14\n\n集群重置如果部署失败了，想要重置整个集群【包括数据】，执行下面脚本\nansible-playbook -i example/hosts.s-master.ip.ini 99-reset-cluster.yml\n\n部署kuboard安装Docker因为我们需要拉取镜像，所以需要在服务器提前安装好Docker，首先配置一下Docker的阿里yum源\ncat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;EOF[docker-ce-edge]name=Docker CE Edge - \\$basearchbaseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\\$basearch/edgeenabled=1gpgcheck=1gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpgEOF\n\n然后yum方式安装docker\n# yum安装yum -y install docker-ce# 查看docker版本docker --version  # 开机自启systemctl enable docker# 启动dockersystemctl start docker\n\n配置docker的镜像源\ncat &gt;&gt; /etc/docker/daemon.json &lt;&lt; EOF&#123;  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]&#125;EOF\n\n然后重启docker\nsystemctl restart docker\n\n安装Kuboard【可选】简介Kuboard 是一款免费的 Kubernetes 图形化管理工具，力图帮助用户快速在 Kubernetes 上落地微服务。\nKuboard文档：https://kuboard.cn/\n安装在master节点执行\nkubectl apply -f https://kuboard.cn/install-script/kuboard.yamlkubectl apply -f https://addons.kuboard.cn/metrics-server/0.3.7/metrics-server.yaml\n\n查看 Kuboard 运行状态\nkubectl get pods -l k8s.kuboard.cn/name=kuboard -n kube-system\n\n输出结果如下所示。注意：如果是 ContainerCreating 那么需要等待一会\nNAME                       READY   STATUS    RESTARTS   AGEkuboard-74c645f5df-cmrbc   1/1     Running   0          80s\n\n访问KuboardKuboard Service 使用了 NodePort 的方式暴露服务，NodePort 为 32567；您可以按如下方式访问 Kuboard。\n# 格式http://任意一个Worker节点的IP地址:32567/# 例如，我的访问地址如下所示http://192.168.177.130:32567/\n\n页面如下所示：\n\n第一次访问需要输入token 我们获取一下 token， 在master节点执行\necho $(kubectl -n kube-system get secret $(kubectl -n kube-system get secret | grep kuboard-user | awk &#x27;&#123;print $1&#125;&#x27;) -o go-template=&#x27;&#123;&#123;.data.token&#125;&#125;&#x27; | base64 -d)\n\n获取到的 token，然后粘贴到框中，我的 token 格式如下：\neyJhbGciOiJSUzI1NiIsImtpZCI6ImY1eUZlc0RwUlZha0E3LWZhWXUzUGljNDM3SE0zU0Q4dzd5R3JTdXM2WEUifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJrdWJvYXJkLXVzZXItdG9rZW4tMmJsamsiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoia3Vib2FyZC11c2VyIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiYzhlZDRmNDktNzM0Zi00MjU1LTljODUtMWI5MGI4MzU4ZWMzIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmUtc3lzdGVtOmt1Ym9hcmQtdXNlciJ9.MujbwGnkL_qa3H14oKDT1zZ5Fzt16pWoaY52nT7fV5B2nNIRsB3Esd18S8ztHUJZLRGxAhBwu-utToi2YBb8pH9RfIeSXMezFZ6QhBbp0n5xYWeYETQYKJmes2FRcW-6jrbpvXlfUuPXqsbRX8qrnmSVEbcAms22CSSVhUbTz1kz8C7b1C4lpSGGuvdpNxgslNFZTFrcImpelpGSaIGEMUk1qdjKMROw8bV83pga4Y41Y6rJYE3hdnCkUA8w2SZOYuF2kT1DuZuKq3A53iLsvJ6Ps-gpli2HcoiB0NkeI_fJORXmYfcj5N2Csw6uGUDiBOr1T4Dto-i8SaApqmdcXg\n\n最后即可进入 kuboard 的 dashboard 界面\n\n卸载Kuboard当我们 kuboard 不想使用的时候，我们就可以直接卸载\nkubectl delete -f https://kuboard.cn/install-script/kuboard.yamlkubectl delete -f https://addons.kuboard.cn/metrics-server/0.3.7/metrics-server.yaml\n\nRancher部署【可选】\nkuboard和rancher建议部署其中一个\n\nhelm安装使用helm部署rancher会方便很多，所以需要安装helm\ncurl -O http://rancher-mirror.cnrancher.com/helm/v3.2.4/helm-v3.2.4-linux-amd64.tar.gztar -zxvf helm-v3.2.4-linux-amd64.tar.gzmv linux-amd64/helm /usr/local/bin\n\n验证helm version\n\n输入以下内容说明helm安装成功\nversion.BuildInfo&#123;Version:&quot;v3.2.4&quot;, GitCommit:&quot;0ad800ef43d3b826f31a5ad8dfbb4fe05d143688&quot;, GitTreeState:&quot;clean&quot;, GoVersion:&quot;go1.13.12&quot;&#125;\n\n添加rancher chart仓库helm repo add rancher-stable http://rancher-mirror.oss-cn-beijing.aliyuncs.com/server-charts/stablehelm repo update\n\n安装rancherhelm install rancher rancher-stable/rancher \\ --create-namespace\t\\ --namespace cattle-system \\ --set hostname=rancher.local.com\n\n等待 Rancher 运行：kubectl -n cattle-system rollout status deploy/rancher\n\n输出信息：\nWaiting for deployment &quot;rancher&quot; rollout to finish: 0 of 3 updated replicas are available...deployment &quot;rancher&quot; successfully rolled out\n\n\n\n","tags":["k8s"]},{"title":"k8s之YAML文件详解","url":"/2022/08/22/k8s%E4%B9%8BYAML%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/","content":"概述k8s 集群中对资源管理和资源对象编排部署都可以通过声明样式（YAML）文件来解决，也就是可以把需要对资源对象操作编辑到YAML 格式文件中，我们把这种文件叫做资源清单文件，通过kubectl 命令直接使用资源清单文件就可以实现对大量的资源对象进行编排部署了。一般在我们开发的时候，都是通过配置YAML文件来部署集群的。\nYAML文件：就是资源清单文件，用于资源编排\nYAML文件介绍YAML概述YAML ：仍是一种标记语言。为了强调这种语言以数据做为中心，而不是以标记语言为重点。\nYAML 是一个可读性高，用来表达数据序列的格式。\nYAML 基本语法\n使用空格做为缩进\n缩进的空格数目不重要，只要相同层级的元素左侧对齐即可\n低版本缩进时不允许使用Tab 键，只允许使用空格\n使用#标识注释，从这个字符一直到行尾，都会被解释器忽略\n使用 — 表示新的yaml文件开始\n\nYAML 支持的数据结构对象键值对的集合，又称为映射(mapping) &#x2F; 哈希（hashes） &#x2F; 字典（dictionary）\n# 对象类型：对象的一组键值对，使用冒号结构表示name: Tomage: 18# yaml 也允许另一种写法，将所有键值对写成一个行内对象hash: &#123;name: Tom, age: 18&#125;\n\n数组# 数组类型：一组连词线开头的行，构成一个数组People- Tom- Jack# 数组也可以采用行内表示法People: [Tom, Jack]\n\n\n\nYAML文件组成部分主要分为了两部分，一个是控制器的定义 和 被控制的对象\n控制器的定义\n被控制的对象包含一些 镜像，版本、端口等\n\n属性说明在一个YAML文件的控制器定义中，有很多属性名称\n\n\n\n属性名称\n介绍\n\n\n\napiVersion\nAPI版本\n\n\nkind\n资源类型\n\n\nmetadata\n资源元数据\n\n\nspec\n资源规格\n\n\nreplicas\n副本数量\n\n\nselector\n标签选择器\n\n\ntemplate\nPod模板\n\n\nmetadata\nPod元数据\n\n\nspec\nPod规格\n\n\ncontainers\n容器配置\n\n\n如何快速编写YAML文件一般来说，我们很少自己手写YAML文件，因为这里面涉及到了很多内容，我们一般都会借助工具来创建\n使用kubectl create命令这种方式一般用于资源没有部署的时候，我们可以直接创建一个YAML配置文件\n# 尝试运行,并不会真正的创建镜像kubectl create deployment web --image=nginx -o yaml --dry-run\n\n或者我们可以输出到一个文件中\nkubectl create deployment web --image=nginx -o yaml --dry-run &gt; hello.yaml\n\n然后我们就在文件中直接修改即可\n使用kubectl get命令导出yaml文件可以首先查看一个目前已经部署的镜像\nkubectl get deploy\n\n\n然后我们导出 nginx的配置\nkubectl get deploy nginx -o=yaml --export &gt; nginx.yaml\n\n然后会生成一个 nginx.yaml 的配置文件\n\n","tags":["k8s"]},{"title":"k8s之Kubeadm和二进制方式对比","url":"/2022/08/22/k8s%E4%B9%8BKubeadm%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/","content":"Kubeadm方式搭建K8S集群\n安装虚拟机，在虚拟机安装Linux操作系统【3台虚拟机】\n\n对操作系统初始化操作\n\n所有节点安装Docker、kubeadm、kubelet、kubectl【包含master和slave节点】\n\n安装docker、使用yum，不指定版本默认安装最新的docker版本\n修改docker仓库地址，yum源地址，改为阿里云地址\n安装kubeadm，kubelet 和 kubectl\nk8s已经发布最新的1.19版本，可以指定版本安装，不指定安装最新版本\nyum install -y kubelet kubeadm kubectl\n\n\n\n\n在master节点执行初始化命令操作\n\nkubeadm init\n默认拉取镜像地址 K8s.gcr.io国内地址，需要使用国内地址\n\n\n安装网络插件(CNI)\n\nkubectl apply -f kube-flannel.yml\n\n\n\n在所有的node节点上，使用join命令，把node添加到master节点上\n\n测试kubernetes集群\n\n\n二进制方式搭建K8S集群\n安装虚拟机和操作系统，对操作系统进行初始化操作\n生成cfssl 自签证书\nca-key.pem、ca.pem\nserver-key.pem、server.pem\n\n\n部署Etcd集群\n部署的本质，就是把etcd集群交给 systemd 管理\n把生成的证书复制过来，启动，设置开机启动\n\n\n为apiserver自签证书，生成过程和etcd类似\n部署master组件，主要包含以下组件\napiserver\ncontroller-manager\nscheduler\n交给systemd管理，并设置开机启动\n如果要安装最新的1.19版本，下载二进制文件进行安装\n\n\n部署node组件\ndocker\nkubelet\nkube-proxy【需要批准kubelet证书申请加入集群】\n交给systemd管理组件- 组件启动，设置开机启动\n\n\n批准kubelet证书申请 并加入集群\n部署CNI网络插件\n测试Kubernets集群【安装nginx测试】\n\n","tags":["k8s"]},{"title":"k8s之kubernetes 集群搭建(二进制方式)","url":"/2022/08/21/k8s%E4%B9%8Bkubernetes-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F/","content":"准备工作在开始之前，部署Kubernetes集群机器需要满足以下几个条件\n\n一台或多台机器，操作系统CentOS 7.x\n硬件配置：2GB ，2个CPU，硬盘30GB\n集群中所有机器之间网络互通\n可以访问外网，需要拉取镜像，如果服务器不能上网，需要提前下载镜像导入节点\n禁止swap分区\n\n步骤\n创建多台虚拟机，安装Linux系统\n操作系统的初始化\n为etcd 和 apiserver 自签证书\n部署etcd集群\n部署master组件【安装docker、kube-apiserver、kube-controller-manager、kube-scheduler、etcd】\n部署node组件【安装kubelet、kube-proxy、docker、etcd】\n部署集群网络\n\n准备环境（1）软件环境：\n\n\n\n软件\n版本\n\n\n\n操作系统\nCentOS7.8_x64 （mini）\n\n\nDocker\n19-ce\n\n\nKubernetes\n1.19\n\n\n（2）服务器规划：\n\n\n\n主机名\nip\n组件\n\n\n\nk8s-master\n192.168.177.140\nkube-apiserver，kube-controller-manager，kube -scheduler，etcd\n\n\nk8s-node1\n192.168.177.141\nkubelet，kube-proxy，docker etcd\n\n\n操作系统的初始化然后我们需要进行一些系列的初始化操作\n# 关闭防火墙systemctl stop firewalldsystemctl disable firewalld# 关闭selinux# 永久关闭sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config  # 临时关闭setenforce 0  # 关闭swap# 临时swapoff -a # 永久关闭sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab# 根据规划设置主机名【master节点上操作】hostnamectl set-hostname k8s-master# 根据规划设置主机名【node1节点操作】hostnamectl set-hostname k8s-node1# 在master添加hostscat &gt;&gt; /etc/hosts &lt;&lt; EOF192.168.177.140 k8s-master192.168.177.141 k8s-node1EOF# 将桥接的IPv4流量传递到iptables的链cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF# 生效sysctl --system  # 时间同步yum install ntpdate -yntpdate time.windows.com\n\n部署Etcd集群Etcd是一个分布式键值存储系统，Kubernetes使用Etcd进行数据存储，所以先准备一个Etcd数据库，为了解决Etcd单点故障，应采用集群方式部署，这里使用3台组建集群，可容忍一台机器故障，当然也可以使用5台组件集群，可以容忍2台机器故障\n自签证书提到证书，我们想到的就是下面这个情况\n\n这个https证书，其实就是服务器颁发给网站的，代表这是一个安全可信任的网站。\n而在我们K8S集群的内部，其实也是有证书的，如果不带证书，那么访问就会受限\n\n同时在集群内部 和外部的访问，我们也需要签发证书\n\n如果我们使用二进制的方式，那么就需要自己手动签发证书。\n自签证书：我们可以想象成在一家公司上班，然后会颁发一个门禁卡，同时一般门禁卡有两种，一个是内部员工的门禁卡，和外部访客门禁卡。这两种门禁卡的权限可能不同，员工的门禁卡可以进入公司的任何地方，而访客的门禁卡是受限的，这个门禁卡其实就是自签证书\n\n准备cfssl证书生成工具cfssl是一个开源的证书管理工具，使用json文件生成证书，相比openssl 更方便使用。找任意一台服务器操作，这里用Master节点。\nwget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64chmod +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64mv cfssl_linux-amd64 /usr/local/bin/cfsslmv cfssljson_linux-amd64 /usr/local/bin/cfssljsonmv cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo\n\n生成 Etcd 证书（1）自签证书颁发机构（CA）\n创建工作目录：\nmkdir -p ~/TLS/&#123;etcd,k8s&#125;cd TLS/etcd\n\n自签 CA:\ncat &gt; ca-config.json&lt;&lt; EOF&#123;    &quot;signing&quot;: &#123;            &quot;default&quot;: &#123;            \t&quot;expiry&quot;: &quot;87600h&quot;            &#125;,            &quot;profiles&quot;: &#123;                &quot;www&quot;: &#123;                    &quot;expiry&quot;: &quot;87600h&quot;,                    &quot;usages&quot;: [                        &quot;signing&quot;,                        &quot;key encipherment&quot;,                        &quot;server auth&quot;,                        &quot;client auth&quot;                    ]                &#125;            &#125;    &#125;&#125;EOFcat &gt; ca-csr.json&lt;&lt; EOF&#123;    &quot;CN&quot;: &quot;etcd CA&quot;,    &quot;key&quot;: &#123;        &quot;algo&quot;: &quot;rsa&quot;,        &quot;size&quot;: 2048    &#125;,    &quot;names&quot;: [        &#123;            &quot;C&quot;: &quot;CN&quot;,            &quot;L&quot;: &quot;Beijing&quot;,            &quot;ST&quot;: &quot;Beijing&quot;        &#125;    ]&#125;EOF\t\n\n生成证书：\ncfssl gencert -initca ca-csr.json | cfssljson -bare ca -ls *peca-key.pem  ca.pem\n\n（2）使用自签 CA 签发 Etcd HTTPS 证书 \n创建证书申请文件：\ncat &gt; server-csr.json&lt;&lt; EOF&#123;    &quot;CN&quot;: &quot;etcd&quot;,    &quot;hosts&quot;: [        &quot;192.168.31.71&quot;,        &quot;192.168.31.72&quot;,        &quot;192.168.31.73&quot;    ],    &quot;key&quot;: &#123;        &quot;algo&quot;: &quot;rsa&quot;,        &quot;size&quot;: 2048    &#125;,    &quot;names&quot;: [        &#123;            &quot;C&quot;: &quot;CN&quot;,            &quot;L&quot;: &quot;BeiJing&quot;,            &quot;ST&quot;: &quot;BeiJing&quot;        &#125;    ]&#125;EOF\n\n注：上述文件 hosts 字段中 IP 为所有 etcd 节点的集群内部通信 IP，一个都不能少！为了 方便后期扩容可以多写几个预留的 IP。\n生成证书：\ncfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www server-csr.json | cfssljson -bare serverls server*pemserver-key.pem   server.pem\n\n从 Github 下载二进制文件下载地址：https://github.com/etcd-io/etcd/releases/download/v3.4.9/etcd-v3.4.9-linux-amd64.tar.gz\n部署 Etcd 集群以下在节点 1 上操作，为简化操作，待会将节点 1 生成的所有文件拷贝到节点 2 和节点 3。\n（1）创建工作目录并解压二进制包\nmkdir /opt/etcd/&#123;bin,cfg,ssl&#125; –ptar zxvf etcd-v3.4.9-linux-amd64.tar.gzmv etcd-v3.4.9-linux-amd64/&#123;etcd,etcdctl&#125; /opt/etcd/bin/\n\n（2）创建 etcd 配置文件\ncat &gt; /opt/etcd/cfg/etcd.conf &lt;&lt; EOF#[Member]ETCD_NAME=&quot;etcd-1&quot;ETCD_DATA_DIR=&quot;/var/lib/etcd/default.etcd&quot;ETCD_LISTEN_PEER_URLS=&quot;https://192.168.31.71:2380&quot;ETCD_LISTEN_CLIENT_URLS=&quot;https://192.168.31.71:2379&quot;#[Clustering]ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;https://192.168.31.71:2380&quot;ETCD_ADVERTISE_CLIENT_URLS=&quot;https://192.168.31.71:2379&quot;ETCD_INITIAL_CLUSTER=&quot;etcd-1=https://192.168.31.71:2380,etcd\u00022=https://192.168.31.72:2380,etcd-3=https://192.168.31.73:2380&quot;ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;EOF\n\n\nETCD_NAME：节点名称，集群中唯一 \nETCD_DATA_DIR：数据目录 \nETCD_LISTEN_PEER_URLS：集群通信监听地址 \nETCD_LISTEN_CLIENT_URLS：客户端访问监听地址 \nETCD_INITIAL_ADVERTISE_PEER_URLS：集群通告地址 \nETCD_ADVERTISE_CLIENT_URLS：客户端通告地址 \nETCD_INITIAL_CLUSTER：集群节点地址 \nETCD_INITIAL_CLUSTER_TOKEN：集群Token \nETCD_INITIAL_CLUSTER_STATE：加入集群的当前状态，new 是新集群，existing 表示加入 已有集群\n\n（3）systemd 管理 etcd\ncat &gt; /usr/lib/systemd/system/etcd.service &lt;&lt; EOF[Unit]Description=Etcd ServerAfter=network.targetAfter=network-online.targetWants=network-online.target[Service]Type=notifyEnvironmentFile=/opt/etcd/cfg/etcd.confExecStart=/opt/etcd/bin/etcd \\--cert-file=/opt/etcd/ssl/server.pem \\--key-file=/opt/etcd/ssl/server-key.pem \\--peer-cert-file=/opt/etcd/ssl/server.pem \\--peer-key-file=/opt/etcd/ssl/server-key.pem \\--trusted-ca-file=/opt/etcd/ssl/ca.pem --peer-trusted-ca-file=/opt/etcd/ssl/ca.pem \\--logger=zapRestart=on-failureLimitNOFILE=65536[Install]WantedBy=multi-user.targetEOF\n\n（4）拷贝刚才生成的证书\n把刚才生成的证书拷贝到配置文件中的路径:\ncp ~/TLS/etcd/ca*pem ~/TLS/etcd/server*pem /opt/etcd/ssl/\n\n（5）启动并设置开机启动\nsystemctl daemon-reloadsystemctl start etcdsystemctl enable etc\n\n（6）将上面节点 1 所有生成的文件拷贝到节点 2 和\nscp -r /opt/etcd/ root@192.168.31.72:/opt/scp /usr/lib/systemd/system/etcd.service  root@192.168.31.72:/usr/lib/systemd/system/scp -r /opt/etcd/ root@192.168.31.73:/opt/scp /usr/lib/systemd/system/etcd.service  root@192.168.31.73:/usr/lib/systemd/system/\n\n然后在节点 2 和节点 3 分别修改 etcd.conf 配置文件中的节点名称和当前服务器 IP：\nvi /opt/etcd/cfg/etcd.conf#[Member]ETCD_NAME=&quot;etcd-1&quot; # 修改此处，节点 2 改为 etcd-2，节点 3 改为 etcd-3ETCD_DATA_DIR=&quot;/var/lib/etcd/default.etcd&quot;ETCD_LISTEN_PEER_URLS=&quot;https://192.168.31.71:2380&quot; # 修改此处为当前服务器 IPETCD_LISTEN_CLIENT_URLS=&quot;https://192.168.31.71:2379&quot; # 修改此处为当前服务器 IP#[Clustering]ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;https://192.168.31.71:2380&quot; # 修改此处为当前服务器 IPETCD_ADVERTISE_CLIENT_URLS=&quot;https://192.168.31.71:2379&quot; # 修改此处为当前服务器IPETCD_INITIAL_CLUSTER=&quot;etcd-1=https://192.168.31.71:2380,etcd\u00022=https://192.168.31.72:2380,etcd-3=https://192.168.31.73:2380&quot;ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;\n\n最后启动 etcd 并设置开机启动，同上。\n（7）查看集群状态\nETCDCTL_API=3 /opt/etcd/bin/etcdctl --cacert=/opt/etcd/ssl/ca.pem --cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem --endpoints=&quot;https://192.168.31.71:2379,https://192.168.31.72:2379,https://192.168.31.73:2379&quot; endpoint healthhttps://192.168.31.71:2379 is healthy: successfully committed proposal: took =8.154404mshttps://192.168.31.73:2379 is healthy: successfully committed proposal: took =9.044117mshttps://192.168.31.72:2379 is healthy: successfully committed proposal: took =10.000825ms\n\n如果输出上面信息，就说明集群部署成功。如果有问题第一步先看日志： &#x2F;var&#x2F;log&#x2F;message 或 journalctl -u etcd\n安装 Docker下载地址：https://download.docker.com/linux/static/stable/x86_64/docker19.03.9.tgz \n以下在所有节点操作。这里采用二进制安装，用 yum 安装也一样。\n（1）解压二进制包\ntar zxvf docker-19.03.9.tgzmv docker/* /usr/bin\n\n（2） systemd 管理 dock\ncat &gt; /usr/lib/systemd/system/docker.service &lt;&lt; EOF[Unit]Description=Docker Application Container EngineDocumentation=https://docs.docker.comAfter=network-online.target firewalld.serviceWants=network-online.target[Service]Type=notifyExecStart=/usr/bin/dockerdExecReload=/bin/kill -s HUP $MAINPIDLimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinityTimeoutStartSec=0Delegate=yesKillMode=processRestart=on-failureStartLimitBurst=3StartLimitInterval=60s[Install]WantedBy=multi-user.targetEOF\n\n（3）创建配置文件\nmkdir /etc/dockercat &gt; /etc/docker/daemon.json &lt;&lt; EOF&#123;\t&quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]&#125;EOF\n\nregistry-mirrors 阿里云镜像加速器\n（4）启动并设置开机启动\nsystemctl daemon-reloadsystemctl start dockersystemctl enable docke\n\n部署 Master Node生成 kube-apiserver 证书（1）自签证书颁发机构（CA）\ncat &gt; ca-config.json&lt;&lt; EOF&#123;    &quot;signing&quot;: &#123;        &quot;default&quot;: &#123;        \t&quot;expiry&quot;: &quot;87600h&quot;        &#125;,        &quot;profiles&quot;: &#123;            &quot;kubernetes&quot;: &#123;                &quot;expiry&quot;: &quot;87600h&quot;,                &quot;usages&quot;: [                    &quot;signing&quot;,                    &quot;key encipherment&quot;,                    &quot;server auth&quot;,                    &quot;client auth&quot;                ]            &#125;        &#125;    &#125;&#125;EOFcat &gt; ca-csr.json&lt;&lt; EOF&#123;    &quot;CN&quot;: &quot;kubernetes&quot;,    &quot;key&quot;: &#123;        &quot;algo&quot;: &quot;rsa&quot;,        &quot;size&quot;: 2048    &#125;,    &quot;names&quot;: [        &#123;            &quot;C&quot;: &quot;CN&quot;,            &quot;L&quot;: &quot;Beijing&quot;,            &quot;ST&quot;: &quot;Beijing&quot;,            &quot;O&quot;: &quot;k8s&quot;,            &quot;OU&quot;: &quot;System&quot;        &#125;    ]&#125;EOF\n\n（2）生成证书:\ncfssl gencert -initca ca-csr.json | cfssljson -bare ca -ls *pemca-key.pem ca.pem\n\n（3）使用自签 CA 签发 kube-apiserver HTTPS 证书 \n创建证书申请文件：\ncd TLS/k8scat &gt; server-csr.json&lt;&lt; EOF&#123;    &quot;CN&quot;: &quot;kubernetes&quot;,    &quot;hosts&quot;: [        &quot;10.0.0.1&quot;,        &quot;127.0.0.1&quot;,        &quot;192.168.31.71&quot;,        &quot;192.168.31.72&quot;,        &quot;192.168.31.73&quot;,        &quot;192.168.31.74&quot;,        &quot;192.168.31.81&quot;,        &quot;192.168.31.82&quot;,        &quot;192.168.31.88&quot;,        &quot;kubernetes&quot;,        &quot;kubernetes.default&quot;,        &quot;kubernetes.default.svc&quot;,        &quot;kubernetes.default.svc.cluster&quot;,        &quot;kubernetes.default.svc.cluster.local&quot;    ],    &quot;key&quot;: &#123;        &quot;algo&quot;: &quot;rsa&quot;,        &quot;size&quot;: 2048    &#125;,    &quot;names&quot;: [        &#123;            &quot;C&quot;: &quot;CN&quot;,            &quot;L&quot;: &quot;BeiJing&quot;,            &quot;ST&quot;: &quot;BeiJing&quot;,            &quot;O&quot;: &quot;k8s&quot;,            &quot;OU&quot;: &quot;System&quot;        &#125;    ]&#125;EOF\n\n生成证书：\ncfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare serverls server*pemserver-key.pem server.pe\n\n从 Github 下载二进制文下载地址： https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG1.18.md#v1183 \n注：打开链接你会发现里面有很多包，下载一个 server 包就够了，包含了 Master 和 Worker \n解压二进制包mkdir -p /opt/kubernetes/&#123;bin,cfg,ssl,logs&#125;tar zxvf kubernetes-server-linux-amd64.tar.gzcd kubernetes/server/bincp kube-apiserver kube-scheduler kube-controller-manager /opt/kubernetes/bincp kubectl /usr/bin/\n\n部署 kube-apiserver\n创建配置文件\n\ncat &gt; /opt/kubernetes/cfg/kube-apiserver.conf &lt;&lt; EOFKUBE_APISERVER_OPTS=&quot;--logtostderr=false \\\\--v=2 \\\\--log-dir=/opt/kubernetes/logs \\\\--etcd\u0002servers=https://192.168.31.71:2379,https://192.168.31.72:2379,https://192.168.31.73:2379 \\\\--bind-address=192.168.31.71 \\\\--secure-port=6443 \\\\--advertise-address=192.168.31.71 \\\\--allow-privileged=true \\\\--service-cluster-ip-range=10.0.0.0/24 \\\\--enable-admission\u0002plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,ResourceQuota,NodeRestriction \\\\--authorization-mode=RBAC,Node \\\\--enable-bootstrap-token-auth=true \\\\--token-auth-file=/opt/kubernetes/cfg/token.csv \\\\--service-node-port-range=30000-32767 \\\\--kubelet-client-certificate=/opt/kubernetes/ssl/server.pem \\\\--kubelet-client-key=/opt/kubernetes/ssl/server-key.pem \\\\--tls-cert-file=/opt/kubernetes/ssl/server.pem \\\\--tls-private-key-file=/opt/kubernetes/ssl/server-key.pem \\\\--client-ca-file=/opt/kubernetes/ssl/ca.pem \\\\--service-account-key-file=/opt/kubernetes/ssl/ca-key.pem \\\\--etcd-cafile=/opt/etcd/ssl/ca.pem \\\\--etcd-certfile=/opt/etcd/ssl/server.pem \\\\--etcd-keyfile=/opt/etcd/ssl/server-key.pem \\\\--audit-log-maxage=30 \\\\--audit-log-maxbackup=3 \\\\--audit-log-maxsize=100 \\\\--audit-log-path=/opt/kubernetes/logs/k8s-audit.log&quot;EOF\n\n\n\n注：上面两个\\ \\ 第一个是转义符，第二个是换行符，使用转义符是为了使用 EOF 保留换行符。 \n\n–logtostderr：启用日志 \n—v：日志等级 \n–log-dir：日志目录 \n–etcd-servers：etcd 集群地址 \n–bind-address：监听地址 \n–secure-port：https 安全端口 \n–advertise-address：集群通告地址 \n–allow-privileged：启用授权 \n–service-cluster-ip-range：Service 虚拟 IP 地址段 \n–enable-admission-plugins：准入控制模块 \n–authorization-mode：认证授权，启用 RBAC 授权和节点自管理 \n–enable-bootstrap-token-auth：启用 TLS bootstrap 机制 \n–token-auth-file：bootstrap token 文件 \n–service-node-port-range：Service nodeport 类型默认分配端口范围 \n–kubelet-client-xxx：apiserver 访问 kubelet 客户端证书 \n–tls-xxx-file：apiserver https 证书 \n–etcd-xxxfile：连接 Etcd 集群证书 \n–audit-log-xxx：审计日志\n\n\n拷贝刚才生成的证书\n\n把刚才生成的证书拷贝到配置文件中的路径：\ncp ~/TLS/k8s/ca*pem ~/TLS/k8s/server*pem /opt/kubernetes/ssl/\n\n\n启用 TLS Bootstrapping 机制\n\nTLS Bootstraping：Master apiserver 启用 TLS 认证后，Node 节点 kubelet 和 kube- proxy 要与 kube-apiserver 进行通信，必须使用 CA 签发的有效证书才可以，当 Node 节点很多时，这种客户端证书颁发需要大量工作，同样也会增加集群扩展复杂度。为了简化流程，Kubernetes 引入了 TLS bootstraping 机制来自动颁发客户端证书，kubelet 会以一个低权限用户自动向 apiserver 申请证书，kubelet 的证书由 apiserver动态签署。所以强烈建议在 Node 上使用这种方式，目前主要用于 kubelet，kube-proxy 还是由我 们统一颁发一个证书。 \nTLS bootstraping 工作\n\n创建上述配置文件中 token 文件:\ncat &gt; /opt/kubernetes/cfg/token.csv &lt;&lt; EOFc47ffb939f5ca36231d9e3121a252940,kubelet-bootstrap,10001,&quot;system:node\u0002bootstrapper&quot;EOF\n\n格式：token，用户名，UID，用户组 \ntoken 也可自行生成替换：\nhead -c 16 /dev/urandom | od -An -t x | tr -d &#x27; &#x27;\n\n\nsystemd 管理 apiserver\n\ncat &gt; /usr/lib/systemd/system/kube-apiserver.service &lt;&lt; EOF[Unit]Description=Kubernetes API ServerDocumentation=https://github.com/kubernetes/kubernetes[Service]EnvironmentFile=/opt/kubernetes/cfg/kube-apiserver.confExecStart=/opt/kubernetes/bin/kube-apiserver \\$KUBE_APISERVER_OPTSRestart=on-failure[Install]WantedBy=multi-user.targetEOF\n\n\n启动并设置开机启动\n\nsystemctl daemon-reloadsystemctl start kube-apiserversystemctl enable kube-apiserve\n\n\n授权 kubelet-bootstrap 用户允许请求证书\n\nkubectl create clusterrolebinding kubelet-bootstrap \\--clusterrole=system:node-bootstrapper \\--user=kubelet-bootstrap\n\n部署 kube-controller-manager\n创建配置文件\n\ncat &gt; /opt/kubernetes/cfg/kube-controller-manager.conf &lt;&lt; EOFKUBE_CONTROLLER_MANAGER_OPTS=&quot;--logtostderr=false \\\\--v=2 \\\\--log-dir=/opt/kubernetes/logs \\\\--leader-elect=true \\\\--master=127.0.0.1:8080 \\\\--bind-address=127.0.0.1 \\\\--allocate-node-cidrs=true \\\\--cluster-cidr=10.244.0.0/16 \\\\--service-cluster-ip-range=10.0.0.0/24 \\\\--cluster-signing-cert-file=/opt/kubernetes/ssl/ca.pem \\\\--cluster-signing-key-file=/opt/kubernetes/ssl/ca-key.pem \\\\--root-ca-file=/opt/kubernetes/ssl/ca.pem \\\\--service-account-private-key-file=/opt/kubernetes/ssl/ca-key.pem \\\\--experimental-cluster-signing-duration=87600h0m0s&quot;EOF\n\n\n–master：通过本地非安全本地端口 8080 连接 apiserver。\n–leader-elect：当该组件启动多个时，自动选举（HA） \n–cluster-signing-cert-file&#x2F;–cluster-signing-key-file：自动为 kubelet 颁发证书 的 CA，与 apiserver 保持一致\n\n\nsystemd 管理 controller-manager\n\ncat &gt; /usr/lib/systemd/system/kube-controller-manager.service &lt;&lt; EOF[Unit]Description=Kubernetes Controller ManagerDocumentation=https://github.com/kubernetes/kubernetes[Service]EnvironmentFile=/opt/kubernetes/cfg/kube-controller-manager.confExecStart=/opt/kubernetes/bin/kube-controller-manager\\$KUBE_CONTROLLER_MANAGER_OPTSRestart=on-failure[Install]WantedBy=multi-user.targetEOF\n\n\n启动并设置开机启动\n\nsystemctl daemon-reloadsystemctl start kube-controller-managersystemctl enable kube-controller-manager\n\n部署 kube-scheduler\n创建配置文件\n\ncat &gt; /opt/kubernetes/cfg/kube-scheduler.conf &lt;&lt; EOFKUBE_SCHEDULER_OPTS=&quot;--logtostderr=false \\--v=2 \\--log-dir=/opt/kubernetes/logs \\--leader-elect \\--master=127.0.0.1:8080 \\--bind-address=127.0.0.1&quot;EOF\n\n\n–master：通过本地非安全本地端口 8080 连接 apiserver。 \n–leader-elect：当该组件启动多个时，自动选举（HA）\n\n\nsystemd 管理 scheduler\n\ncat &gt; /usr/lib/systemd/system/kube-scheduler.service &lt;&lt; EOF[Unit]Description=Kubernetes SchedulerDocumentation=https://github.com/kubernetes/kubernetes[Service]EnvironmentFile=/opt/kubernetes/cfg/kube-scheduler.confExecStart=/opt/kubernetes/bin/kube-scheduler \\$KUBE_SCHEDULER_OPTSRestart=on-failure[Install]WantedBy=multi-user.targetEOF\n\n\n启动并设置开机启动\n\nsystemctl daemon-reloadsystemctl start kube-schedulersystemctl enable kube-scheduler\n\n\n查看集群状态\n\n所有组件都已经启动成功，通过 kubectl 工具查看当前集群组件状态：\nkubectl get csNAME\t\t\t \tSTATUS\t\t\t MESSAGE \t\t\t ERRORscheduler \t\t\t      Healthy\t\t\t  okcontroller-manager\t\t Healthy \t\t\t oketcd-2 \t\t\t \t      Healthy \t\t\t &#123;&quot;health&quot;:&quot;true&quot;&#125;etcd-1 \t\t\t\t    Healthy \t\t      &#123;&quot;health&quot;:&quot;true&quot;&#125;etcd-0\t\t\t\t   Healthy \t\t\t   &#123;&quot;health&quot;:&quot;true&quot;&#125;\n\n如上输出说明 Master 节点组件运行正常\n部署 Worker Node下面还是在 Master Node 上操作，即同时作为 Worker Node\n创建工作目录并拷贝二进制文件在所有 worker node 创建工作目录\nmkdir -p /opt/kubernetes/&#123;bin,cfg,ssl,logs&#125;\n\n从 master 节点拷贝:\ncd kubernetes/server/bincp kubelet kube-proxy /opt/kubernetes/bin # 本地拷贝\n\n部署 kubelet\n创建配置文件\n\ncat &gt; /opt/kubernetes/cfg/kubelet.conf &lt;&lt; EOFKUBELET_OPTS=&quot;--logtostderr=false \\\\--v=2 \\\\--log-dir=/opt/kubernetes/logs \\\\--hostname-override=k8s-master \\\\--network-plugin=cni \\\\--kubeconfig=/opt/kubernetes/cfg/kubelet.kubeconfig \\\\--bootstrap-kubeconfig=/opt/kubernetes/cfg/bootstrap.kubeconfig \\\\--config=/opt/kubernetes/cfg/kubelet-config.yml \\\\--cert-dir=/opt/kubernetes/ssl \\\\--pod-infra-container-image=lizhenliang/pause-amd64:3.0&quot;EOF\n\n\n–hostname-override：显示名称，集群中唯一 \n–network-plugin：启用 CNI \n–kubeconfig：空路径，会自动生成，后面用于连接 apiserver \n–bootstrap-kubeconfig：首次启动向 apiserver 申请证书 \n–config：配置参数文件 \n–cert-dir：kubelet 证书生成目录 \n–pod-infra-container-image：管理 Pod 网络容器的镜像\n\n\n配置参数文件\n\ncat &gt; /opt/kubernetes/cfg/kubelet-config.yml &lt;&lt; EOFkind: KubeletConfigurationapiVersion: kubelet.config.k8s.io/v1beta1address: 0.0.0.0port: 10250readOnlyPort: 10255cgroupDriver: cgroupfsclusterDNS:- 10.0.0.2clusterDomain: cluster.localfailSwapOn: falseauthentication:    anonymous:   \t enabled: false    webhook:   \t cacheTTL: 2m0s   \t enabled: true    x509:\tclientCAFile: /opt/kubernetes/ssl/ca.pemauthorization:    mode: Webhook    webhook:        cacheAuthorizedTTL: 5m0s        cacheUnauthorizedTTL: 30sevictionHard:imagefs.available: 15%memory.available: 100Minodefs.available: 10%nodefs.inodesFree: 5%maxOpenFiles: 1000000maxPods: 110EOF\n\n\n生成 bootstrap.kubeconfig 文件\n\nKUBE_APISERVER=&quot;https://192.168.31.71:6443&quot; # apiserver IP:PORTTOKEN=&quot;c47ffb939f5ca36231d9e3121a252940&quot; # 与 token.csv 里保持一致# 生成 kubelet bootstrap kubeconfig 配置文件kubectl config set-cluster kubernetes \\    --certificate-authority=/opt/kubernetes/ssl/ca.pem \\    --embed-certs=true \\    --server=$&#123;KUBE_APISERVER&#125; \\    --kubeconfig=bootstrap.kubeconfigkubectl config set-credentials &quot;kubelet-bootstrap&quot; \\    --token=$&#123;TOKEN&#125; \\    --kubeconfig=bootstrap.kubeconfigkubectl config set-context default \\    --cluster=kubernetes \\    --user=&quot;kubelet-bootstrap&quot; \\    --kubeconfig=bootstrap.kubeconfigkubectl config use-context default --kubeconfig=bootstrap.kubeconfig\n\n拷贝到配置文件路径：\ncp bootstrap.kubeconfig /opt/kubernetes/cfg\n\n\nsystemd 管理 kubelet\n\ncat &gt; /usr/lib/systemd/system/kubelet.service &lt;&lt; EOF[Unit]Description=Kubernetes KubeletAfter=docker.service[Service]EnvironmentFile=/opt/kubernetes/cfg/kubelet.confExecStart=/opt/kubernetes/bin/kubelet \\$KUBELET_OPTSRestart=on-failureLimitNOFILE=65536[Install]WantedBy=multi-user.targetEOF\n\n\n启动并设置开机启动\n\nsystemctl daemon-reloadsystemctl start kubeletsystemctl enable kubelet\n\n批准 kubelet 证书申请并加入集群# 查看 kubelet 证书请求kubectl get csrNAME AGE SIGNERNAMEREQUESTOR CONDITIONnode-csr-uCEGPOIiDdlLODKts8J658HrFq9CZ--K6M4G7bjhk8A 6m3skubernetes.io/kube-apiserver-client-kubelet kubelet-bootstrap Pending# 批准申请kubectl certificate approve node-csr-uCEGPOIiDdlLODKts8J658HrFq9CZ--K6M4G7bjhk8A# 查看节点kubectl get node\n\n注：由于网络插件还没有部署，节点会没有准备就绪 NotReady\n部署 kube-proxy\n创建配置文件\n\ncat &gt; /opt/kubernetes/cfg/kube-proxy.conf &lt;&lt; EOFKUBE_PROXY_OPTS=&quot;--logtostderr=false \\\\--v=2 \\\\--log-dir=/opt/kubernetes/logs \\\\--config=/opt/kubernetes/cfg/kube-proxy-config.yml&quot;EOF\n\n\n配置参数文件\n\ncat &gt; /opt/kubernetes/cfg/kube-proxy-config.yml &lt;&lt; EOFkind: KubeProxyConfigurationapiVersion: kubeproxy.config.k8s.io/v1alpha1bindAddress: 0.0.0.0metricsBindAddress: 0.0.0.0:10249clientConnection:    kubeconfig: /opt/kubernetes/cfg/kube-proxy.kubeconfighostnameOverride: k8s-masterclusterCIDR: 10.0.0.0/24EOF\n\n\n生成 kube-proxy.kubeconfig 文件\n\n生成 kube-proxy 证书:\n# 切换工作目录cd TLS/k8s# 创建证书请求文件cat &gt; kube-proxy-csr.json&lt;&lt; EOF&#123;    &quot;CN&quot;: &quot;system:kube-proxy&quot;,    &quot;hosts&quot;: [],    &quot;key&quot;: &#123;        &quot;algo&quot;: &quot;rsa&quot;,        &quot;size&quot;: 2048    &#125;,    &quot;names&quot;: [        &#123;            &quot;C&quot;: &quot;CN&quot;,            &quot;L&quot;: &quot;BeiJing&quot;,            &quot;ST&quot;: &quot;BeiJing&quot;,            &quot;O&quot;: &quot;k8s&quot;,            &quot;OU&quot;: &quot;System&quot;        &#125;    ]&#125;EOF# 生成证书cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxyls kube-proxy*pemkube-proxy-key.pem kube-proxy.pem\n\n生成 kubeconfig 文件：\nKUBE_APISERVER=&quot;https://192.168.31.71:6443&quot;kubectl config set-cluster kubernetes \\    --certificate-authority=/opt/kubernetes/ssl/ca.pem \\    --embed-certs=true \\    --server=$&#123;KUBE_APISERVER&#125; \\    --kubeconfig=kube-proxy.kubeconfigkubectl config set-credentials kube-proxy \\    --client-certificate=./kube-proxy.pem \\    --client-key=./kube-proxy-key.pem \\    --embed-certs=true \\    --kubeconfig=kube-proxy.kubeconfigkubectl config set-context default \\    --cluster=kubernetes \\    --user=kube-proxy \\    --kubeconfig=kube-proxy.kubeconfigkubectl config use-context default --kubeconfig=kube-proxy.kubeconfig\n\n拷贝到配置文件指定路径：\ncp kube-proxy.kubeconfig /opt/kubernetes/cfg/\n\n\nsystemd 管理 kube-proxy\n\ncat &gt; /usr/lib/systemd/system/kube-proxy.service &lt;&lt; EOF[Unit]Description=Kubernetes ProxyAfter=network.target[Service]EnvironmentFile=/opt/kubernetes/cfg/kube-proxy.confExecStart=/opt/kubernetes/bin/kube-proxy \\$KUBE_PROXY_OPTSRestart=on-failureLimitNOFILE=65536[Install]WantedBy=multi-user.targetEOF\n\n\n启动并设置开机启动\n\nsystemctl daemon-reloadsystemctl start kube-proxysystemctl enable kube-proxy\n\n部署 CNI 网络先准备好 CNI 二进制文件： \n下载地址： https://github.com/containernetworking/plugins/releases/download/v0.8.6/cni-plugins-linux-amd64-v0.8.6.tgz \n解压二进制包并移动到默认工作目录：\nmkdir /opt/cni/bintar zxvf cni-plugins-linux-amd64-v0.8.6.tgz -C\n\n部署 CNI 网络：\nwgethttps://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube\u0002flannel.ymlsed -i -r &quot;s#quay.io/coreos/flannel:.*-amd64#lizhenliang/flannel:v0.12.0-amd64#g&quot; kube-flannel.yml\n\n默认镜像地址无法访问，修改为 docker hub 镜像仓库。\nkubectl apply -f kube-flannel.ymlkubectl get pods -n kube-systemkubectl get node\n\n部署好网络插件，Node 准备就绪。\n授权 apiserver 访问 kubeletcat &gt; apiserver-to-kubelet-rbac.yaml&lt;&lt; EOFapiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata:    annotations:        rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;    labels:        kubernetes.io/bootstrapping: rbac-defaults    name: system:kube-apiserver-to-kubeletrules:    - apiGroups:        - &quot;&quot;    resources:        - nodes/proxy        - nodes/stats        - nodes/log        - nodes/spec        - nodes/metrics        - pods/log    verbs:    \t- &quot;*&quot;---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata:    name: system:kube-apiserver    namespace: &quot;&quot;roleRef:    apiGroup: rbac.authorization.k8s.io    kind: ClusterRole    name: system:kube-apiserver-to-kubeletsubjects:    - apiGroup: rbac.authorization.k8s.io        kind: User        name: kubernetesEOFkubectl apply -f apiserver-to-kubelet-rbac.yaml\n\n新增加 Worker Node\n拷贝已部署好的 Node 相关文件到新节点\n\n在 master 节点将 Worker Node 涉及文件拷贝到新节点 192.168.31.72&#x2F;73\nscp -r /opt/kubernetes root@192.168.31.72:/opt/scp -r /usr/lib/systemd/system/&#123;kubelet,kube-proxy&#125;.service root@192.168.31.72:/usr/lib/systemd/systemscp -r /opt/cni/ root@192.168.31.72:/opt/scp /opt/kubernetes/ssl/ca.pem root@192.168.31.72:/opt/kubernetes/ssl\n\n\n删除 kubelet 证书和 kubeconfig 文件\n\nrm /opt/kubernetes/cfg/kubelet.kubeconfigrm -f /opt/kubernetes/ssl/kubelet*\n\n注：这几个文件是证书申请审批后自动生成的，每个 Node 不同，必须删除重新生成。\n\n修改主机名\n\nvi /opt/kubernetes/cfg/kubelet.conf--hostname-override=k8s-node1vi /opt/kubernetes/cfg/kube-proxy-config.ymlhostnameOverride: k8s-node1\n\n\n启动并设置开机启动\n\nsystemctl daemon-reloadsystemctl start kubeletsystemctl enable kubeletsystemctl start kube-proxysystemctl enable kube-proxy\n\n\n在 Master 上批准新 Node kubelet 证书申请\n\nkubectl get csrNAME\t\t\t AGE \t\t\t\tSIGNERNAMEREQUESTOR\t\t\t CONDITIONnode-csr-4zTjsaVSrhuyhIGqsefxzVoZDCNKei-aE2jyTP81Uro \t89skubernetes.io/kube-apiserver-client-kubelet \t\tkubelet-bootstrap\t\t Pendingkubectl certificate approve node-csr-4zTjsaVSrhuyhIGqsefxzVoZDCNKei\u0002aE2jyTP81Uro\n\n\n查看 Node状态\n\nKubectl get node\n\nNode2（192.168.31.73 ）节点同上。记得修改主机名！\n","tags":["k8s"]},{"title":"k8s之kubernetes概述","url":"/2022/08/20/k8s%E4%B9%8Bkubernetes%E6%A6%82%E8%BF%B0/","content":"介绍K8S主要讲的就是Kubernetes，首先Kubernetes首字母为K，末尾为s，中间一共有8个字母，所以简称K8s\n前置知识\nLinux操作系统\nDocker\n\n课程简介\nK8s概念和架构\n\n从零搭建K8s集群\n\n基于客户端工具kubeadm搭建（简单，最多半小时）\n基于二进制包方式（能看到内部的架构）\n\n\nK8s核心概念\n\nPod：K8s管理的最小单位级，是所有业务类型的基础\nController：控制器，有状态，无状态，一次任务，定时任务，守护进程\nService Ingress：对外暴露端口\nRBAC：安全机制，权限模型\nHelm：下载机制\n持久化存储\n\n\n搭建集群监控平台系统\n\n从零搭建高可用K8s集群\n\n在集群环境部署项目\n\n\nK8S概念和特性部署发展历程我们的项目部署也在经历下面的这样一个历程\n\n传统部署 -&gt; 虚拟化部署时代 -&gt; 容器部署时代\n\n\n\n传统部署时代：早期，组织在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。例如，如果在物理服务器上运行多个应用程序，则可能会出现-一个应用程序占用大部分资源的情况，结果可能导致其他应用程序的性能下降。–种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展，并且组织维护许多物理服务器的成本很高。\n虚拟化部署时代：作为解决方案，引入了虚拟化功能，它允许您在单个物理服务器的CPU.上运行多个虚拟机（VM）。虚拟化功能允许应用程序在VM之间隔离，并提供安全级别，因为一一个应用程序的信息不能被另一应用程序自由地访问。因为虚拟化可以轻松地添加或更新应用程序、降低硬件成本等等，所以虚拟化可以更好地利用物理服务器中的资源，并可以实现更好的可伸缩性。每个VM是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。\n容器部署时代：容器类似于VM，但是它们具有轻量级的隔离属性，可以在应用程序之间共享操作系统（OS），因此，容器被认为是轻量级的。容器与VM类似，具有自己的文件系统、CPU、内存、进程空间等。由于它们与基础架构分离，因此可以跨云和OS分发进行移植。\n\n容器因具有许多优势而变得流行起来。下面列出了容器的一些好处：\n\n敏捷应用程序的创建和部署：与使用VM镜像相比，提高了容器镜像创建的简便性和效率。\n持续开发、集成和部署：通过简单的回滚（由于镜像不可变性），提供可靠且频繁的容器镜像构建和部署。\n关注开发与运维的分离：在构建&#x2F;时而不是在部署时创建应用程序容器镜像，将应用程序与基础架构分离。\n可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。\n跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。\n云和操作系统分发的可移植性：可在Ubuntu、RHEL、RHEL、CoreOS、本地、Google Kubernetes Engine和其它任何其它地方运行。\n以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行OS到使用逻辑资源在OS上运行应用程序。\n松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分，并且可以动态部署和管理-而不是在一台大型单机上器体运行。\n资源隔离：可预测的应用程序性能。\n\nK8S概述kubernetes，简称K8s，是用8 代替8 个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes 提供了应用部署，规划，更新，维护的一种机制。\n传统的应用部署方式是通过插件或脚本来安装应用。这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新&#x2F;回滚等操作，当然也可以通过创建虚拟机的方式来实现某些功能，但是虚拟机非常重，并不利于可移植性。\n新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能快速部署，由于容器与底层设施、机器文件系统解耦的。\n\n总结：\n\nK8s是谷歌在2014年发布的容器化集群管理系统\n使用k8s进行容器化应用部署\n使用k8s利于应用扩展\nk8s目标实施让部署容器化应用更加简洁和高效\n\n\nK8S概述Kubernetes 是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过Kubernetes 能够进行应用的自动化部署和扩缩容。在Kubernetes 中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。\nKubernetes 积累了作为Google 生产环境运行工作负载15 年的经验，并吸收了来自于社区的最佳想法和实践。\nK8S功能自动装箱基于容器对应用运行环境的资源配置要求自动部署应用容器\n自我修复(自愈能力)当容器失败时，会对容器进行重启\n当所部署的Node节点有问题时，会对容器进行重新部署和重新调度\n当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务\n\n如果某个服务器上的应用不响应了，Kubernetes会自动在其它的地方创建一个\n\n水平扩展通过简单的命令、用户UI 界面或基于CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁\n\n当我们有大量的请求来临时，我们可以增加副本数量，从而达到水平扩展的效果\n\n当黄色应用过度忙碌，会来扩展一个应用\n\n服务发现用户不需使用额外的服务发现机制，就能够基于Kubernetes 自身能力实现服务发现和负载均衡\n\n对外提供统一的入口，让它来做节点的调度和负载均衡， 相当于微服务里面的网关？\n\n\n滚动更新可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新\n\n添加应用的时候，不是加进去就马上可以进行使用，而是需要判断这个添加进去的应用是否能够正常使用\n\n版本回退可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退\n\n类似于Git中的回滚\n\n密钥和配置管理在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署。\n存储编排自动实现存储系统挂载及应用，特别对有状态应用实现数据持久化非常重要\n存储系统可以来自于本地目录、网络存储(NFS、Gluster、Ceph 等)、公共云存储服务\n批处理提供一次性任务，定时任务；满足批量数据处理和分析的场景\nK8S架构组件完整架构图\n\n架构细节K8S架构主要包含两部分：Master（主控节点）和 node（工作节点）\nmaster节点架构图\n\nNode节点架构图\n\nk8s 集群控制节点，对集群进行调度管理，接受集群外用户去集群操作请求；\n\nmaster：主控节点\n\nAPI Server：集群统一入口，以restful风格进行操作，同时交给etcd存储\n提供认证、授权、访问控制、API注册和发现等机制\n\n\nscheduler：节点的调度，选择node节点应用部署\ncontroller-manager：处理集群中常规后台任务，一个资源对应一个控制器\netcd：存储系统，用于保存集群中的相关数据\n\n\nWork node：工作节点\n\nKubelet：master派到node节点代表，管理本机容器\n一个集群中每个节点上运行的代理，它保证容器都运行在Pod中\n负责维护容器的生命周期，同时也负责Volume(CSI) 和 网络(CNI)的管理\n\n\nkube-proxy：提供网络代理，负载均衡等操作\n\n\n容器运行环境【Container Runtime】\n\n容器运行环境是负责运行容器的软件\nKubernetes支持多个容器运行环境：Docker、containerd、cri-o、rktlet以及任何实现Kubernetes CRI (容器运行环境接口) 的软件。\n\n\nfluentd：是一个守护进程，它有助于提升 集群层面日志\n\n\nK8S核心概念Pod\nPod是K8s中最小的单元\n一组容器的集合\n共享网络【一个Pod中的所有容器共享同一网络】\n生命周期是短暂的（服务器重启后，就找不到了）\n\nVolume\n声明在Pod容器中可访问的文件目录\n可以被挂载到Pod中一个或多个容器指定路径下\n支持多种后端存储抽象【本地存储、分布式存储、云存储】\n\nController\n确保预期的pod副本数量【ReplicaSet】\n无状态应用部署【Deployment】\n无状态就是指，不需要依赖于网络或者ip\n\n\n有状态应用部署【StatefulSet】\n有状态需要特定的条件\n\n\n确保所有的node运行同一个pod 【DaemonSet】\n一次性任务和定时任务【Job和CronJob】\n\nDeployment\n定义一组Pod副本数目，版本等\n通过控制器【Controller】维持Pod数目【自动回复失败的Pod】\n通过控制器以指定的策略控制版本【滚动升级、回滚等】\n\n\nService\n定义一组pod的访问规则\nPod的负载均衡，提供一个或多个Pod的稳定访问地址\n支持多种方式【ClusterIP、NodePort、LoadBalancer】\n\n\n可以用来组合pod，同时对外提供服务\nLabellabel：标签，用于对象资源查询，筛选\n\nNamespace命名空间，逻辑隔离\n\n一个集群内部的逻辑隔离机制【鉴权、资源】\n每个资源都属于一个namespace\n同一个namespace所有资源不能重复\n不同namespace可以资源名重复\n\nAPI我们通过Kubernetes的API来操作整个集群\n同时我们可以通过 kubectl 、ui、curl 最终发送 http + json&#x2F;yaml 方式的请求给API Server，然后控制整个K8S集群，K8S中所有的资源对象都可以采用 yaml 或 json 格式的文件定义或描述\n如下：使用yaml部署一个nginx的pod\n\n完整流程\n\n通过Kubectl提交一个创建RC（Replication Controller）的请求，该请求通过APlserver写入etcd\n此时Controller Manager通过API Server的监听资源变化的接口监听到此RC事件\n分析之后，发现当前集群中还没有它所对应的Pod实例\n于是根据RC里的Pod模板定义一个生成Pod对象，通过APIServer写入etcd\n此事件被Scheduler发现，它立即执行执行一个复杂的调度流程，为这个新的Pod选定一个落户的Node，然后通过API Server讲这一结果写入etcd中\n目标Node上运行的Kubelet进程通过APiserver监测到这个”新生的Pod.并按照它的定义，启动该Pod并任劳任怨地负责它的下半生，直到Pod的生命结束\n随后，我们通过Kubectl提交一个新的映射到该Pod的Service的创建请求\nControllerManager通过Label标签查询到关联的Pod实例，然后生成Service的Endpoints信息，并通过APIServer写入到etod中，\n接下来，所有Node上运行的Proxy进程通过APIServer查询并监听Service对象与其对应的Endponts信息，建立一个软件方式的负载均衡器来实现Service访问到后端Pod的流量转发功能\n\n","tags":["k8s"]},{"title":"k8s之使用kubeadm方式搭建K8S集群","url":"/2022/08/20/k8s%E4%B9%8B%E4%BD%BF%E7%94%A8kubeadm%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4/","content":"使用kubeadm方式搭建K8S集群kubeadm是官方社区推出的一个用于快速部署kubernetes集群的工具。\n这个工具能通过两条指令完成一个kubernetes集群的部署：\n# 创建一个 Master 节点kubeadm init# 将一个 Node 节点加入到当前集群中kubeadm join &lt;Master节点的IP和端口 &gt;\n\nKubeadm方式搭建K8S集群使用kubeadm方式搭建K8s集群主要分为以下几步\n\n准备三台虚拟机，同时安装操作系统CentOS 7.x\n对三个安装之后的操作系统进行初始化操作\n在三个节点安装 docker kubelet kubeadm kubectl\n在master节点执行kubeadm init命令初始化\n在node节点上执行 kubeadm join命令，把node节点添加到当前集群\n配置CNI网络插件，用于节点之间的连通【失败了可以多试几次】\n通过拉取一个nginx进行测试，能否进行外网测试\n\n安装要求在开始之前，部署Kubernetes集群机器需要满足以下几个条件：\n\n一台或多台机器，操作系统 CentOS7.x-86_x64\n硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多【注意master需要两核】\n可以访问外网，需要拉取镜像，如果服务器不能上网，需要提前下载镜像并导入节点\n禁止swap分区\n\n准备环境\n\n\n角色\nIP\n\n\n\nmaster\n192.168.177.130\n\n\nnode1\n192.168.177.131\n\n\nnode2\n192.168.177.132\n\n\n然后开始在每台机器上执行下面的命令\n# 关闭防火墙systemctl stop firewalldsystemctl disable firewalld# 关闭selinux# 永久关闭sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config  # 临时关闭setenforce 0  # 关闭swap# 临时swapoff -a # 永久关闭sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab# 根据规划设置主机名【master节点上操作】hostnamectl set-hostname k8smaster# 根据规划设置主机名【node1节点操作】hostnamectl set-hostname k8snode1# 根据规划设置主机名【node2节点操作】hostnamectl set-hostname k8snode2# 在master添加hostscat &gt;&gt; /etc/hosts &lt;&lt; EOF192.168.177.130 k8smaster192.168.177.131 k8snode1192.168.177.132 k8snode2EOF# 将桥接的IPv4流量传递到iptables的链cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF# 生效sysctl --system  # 时间同步yum install ntpdate -yntpdate time.windows.com\n\n安装Docker&#x2F;kubeadm&#x2F;kubelet所有节点安装Docker&#x2F;kubeadm&#x2F;kubelet ，Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker\n安装Docker首先配置一下Docker的阿里yum源\ncat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;EOF[docker-ce-edge]name=Docker CE Edge - \\$basearchbaseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\\$basearch/edgeenabled=1gpgcheck=1gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpgEOF\n\n然后yum方式安装docker\n# yum安装yum -y install docker-ce# 查看docker版本docker --version  # 启动dockersystemctl enable dockersystemctl start docker\n\n配置docker的镜像源\ncat &gt;&gt; /etc/docker/daemon.json &lt;&lt; EOF&#123;  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]&#125;EOF\n\n然后重启docker\nsystemctl restart docker\n\n添加kubernetes软件源然后我们还需要配置一下yum的k8s软件源\ncat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF\n\n安装kubeadm，kubelet和kubectl由于版本更新频繁，这里指定版本号部署：\n# 安装kubelet、kubeadm、kubectl，同时指定版本yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0# 设置开机启动systemctl enable kubelet\n\n部署Kubernetes Master【master节点】在   192.168.177.130  执行，也就是master节点\nkubeadm init --apiserver-advertise-address=192.168.177.130 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16\n\n由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址，【执行上述命令会比较慢，因为后台其实已经在拉取镜像了】，我们 docker images 命令即可查看已经拉取的镜像\n\n当我们出现下面的情况时，表示kubernetes的镜像已经安装成功\n\n使用kubectl工具 【master节点操作】\nmkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config\n\n执行完成后，我们使用下面命令，查看我们正在运行的节点\nkubectl get nodes\n\n\n能够看到，目前有一个master节点已经运行了，但是还处于未准备状态\n下面我们还需要在Node节点执行其它的命令，将node1和node2加入到我们的master节点上\n加入Kubernetes Node【Slave节点】下面我们需要到 node1 和 node2服务器，执行下面的代码向集群添加新节点\n执行在kubeadm init输出的kubeadm join命令：\n\n注意，以下的命令是在master初始化完成后，每个人的都不一样！！！需要复制自己生成的\n\nkubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf \\    --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500\n\n默认token有效期为24小时，当过期之后，该token就不可用了。这时就需要重新创建token，操作如下：\nkubeadm token create --print-join-command\n\n当我们把两个节点都加入进来后，我们就可以去Master节点 执行下面命令查看情况\nkubectl get node\n\n\n部署CNI网络插件上面的状态还是NotReady，下面我们需要网络插件，来进行联网访问\n# 下载网络插件配置wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml\n\n默认镜像地址无法访问，sed命令修改为docker hub镜像仓库。\n# 添加kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml##①首先下载v0.13.1-rc2-amd64 镜像##参考博客：https://www.cnblogs.com/pyxuexi/p/14288591.html##② 导入镜像，命令，，特别提示，3个机器都需要导入，3个机器都需要导入，3个机器都需要导入，3个机器都需要导入，重要的事情说3遍。不然抱错。如果没有操作，报错后，需要删除节点，重置，在导入镜像，重新加入才行。本地就是这样操作成功的！docker load &lt; flanneld-v0.13.1-rc2-amd64.docker#####下载本地，替换将image: quay.io/coreos/flannel:v0.13.1-rc2 替换为 image: quay.io/coreos/flannel:v0.13.1-rc2-amd64# 查看状态 【kube-system是k8s中的最小单元】kubectl get pods -n kube-system\n\n运行后的结果\n\n运行完成后，我们查看状态可以发现，已经变成了Ready状态了\n\n如果上述操作完成后，还存在某个节点处于NotReady状态，可以在Master将该节点删除\n# master节点将该节点删除##20210223 yan 查阅资料添加###kubectl drain k8snode1 --delete-local-data --force --ignore-daemonsetskubectl delete node k8snode1 # 然后到k8snode1节点进行重置 kubeadm reset# 重置完后在加入kubeadm join 192.168.177.130:6443 --token 8j6ui9.gyr4i156u30y80xf     --discovery-token-ca-cert-hash sha256:eda1380256a62d8733f4bddf926f148e57cf9d1a3a58fb45dd6e80768af5a500\n\n测试kubernetes集群我们都知道K8S是容器化技术，它可以联网去下载镜像，用容器的方式进行启动\n在Kubernetes集群中创建一个pod，验证是否正常运行：\n# 下载nginx 【会联网拉取nginx镜像】kubectl create deployment nginx --image=nginx# 查看状态kubectl get pod\n\n如果我们出现Running状态的时候，表示已经成功运行了\n\n下面我们就需要将端口暴露出去，让其它外界能够访问\n# 暴露端口kubectl expose deployment nginx --port=80 --type=NodePort# 查看一下对外的端口kubectl get pod,svc\n\n能够看到，我们已经成功暴露了 80端口  到 30529上\n\n我们到我们的宿主机浏览器上，访问如下地址\nhttp://192.168.177.130:30529/\n\n发现我们的nginx已经成功启动了\n\n到这里为止，我们就搭建了一个单master的k8s集群\n\n错误汇总错误一在执行Kubernetes  init方法的时候，出现这个问题\nerror execution phase preflight: [preflight] Some fatal errors occurred:\t[ERROR NumCPU]: the number of available CPUs 1 is less than the required 2\n\n是因为VMware设置的核数为1，而K8S需要的最低核数应该是2，调整核数重启系统即可\n错误二我们在给node1节点使用 kubernetes join命令的时候，出现以下错误\nerror execution phase preflight: [preflight] Some fatal errors occurred:\t[ERROR Swap]: running with swap on is not supported. Please disable swap\n\n错误原因是我们需要关闭swap\n# 关闭swap# 临时swapoff -a # 临时sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab\n\n错误三在给node1节点使用 kubernetes join命令的时候，出现以下错误\nThe HTTP call equal to &#x27;curl -sSL http://localhost:10248/healthz&#x27; failed with error: Get http://localhost:10248/healthz: dial tcp [::1]:10248: connect: connection refused\n\n解决方法，首先需要到 master 节点，创建一个文件\n# 创建文件夹mkdir /etc/systemd/system/kubelet.service.d# 创建文件vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf# 添加如下内容Environment=&quot;KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true --fail-swap-on=false&quot;# 重置kubeadm reset\n\n然后删除刚刚创建的配置目录\nrm -rf $HOME/.kube\n\n然后 在master重新初始化\nkubeadm init --apiserver-advertise-address=202.193.57.11 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.18.0 --service-cidr=10.96.0.0/12  --pod-network-cidr=10.244.0.0/16\n\n初始完成后，我们再到 node1节点，执行 kubeadm join命令，加入到master\nkubeadm join 202.193.57.11:6443 --token c7a7ou.z00fzlb01d76r37s \\    --discovery-token-ca-cert-hash sha256:9c3f3cc3f726c6ff8bdff14e46b1a856e3b8a4cbbe30cab185f6c5ee453aeea5\n\n添加完成后，我们使用下面命令，查看节点是否成功添加\nkubectl get nodes\n\n错误四我们再执行查看节点的时候，  kubectl get nodes 会出现问题\nUnable to connect to the server: x509: certificate signed by unknown authority (possibly because of &quot;crypto/rsa: verification error&quot; while trying to verify candidate authority certificate &quot;kubernetes&quot;)\n\n这是因为我们之前创建的配置文件还存在，也就是这些配置\nmkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config\n\n我们需要做的就是把配置文件删除，然后重新执行一下\nrm -rf $HOME/.kube\n\n然后再次创建一下即可\nmkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config\n\n这个问题主要是因为我们在执行 kubeadm reset 的时候，没有把 $HOME&#x2F;.kube 给移除掉，再次创建时就会出现问题了\n错误五安装的时候，出现以下错误\nAnother app is currently holding the yum lock; waiting for it to exit...\n\n是因为yum上锁占用，解决方法\nyum -y install docker-ce\n\n错误六在使用下面命令，添加node节点到集群上的时候\nkubeadm join 192.168.177.130:6443 --token jkcz0t.3c40t0bqqz5g8wsb  --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5\n\n然后出现了这个错误\n[root@k8smaster ~]# kubeadm join 192.168.177.130:6443 --token jkcz0t.3c40t0bqqz5g8wsb     --discovery-token-ca-cert-hash sha256:bc494eeab6b7bac64c0861da16084504626e5a95ba7ede7b9c2dc7571ca4c9e5W1117 06:55:11.220907   11230 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not set.[preflight] Running pre-flight checks\t[WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/error execution phase preflight: [preflight] Some fatal errors occurred:\t[ERROR FileContent--proc-sys-net-ipv4-ip_forward]: /proc/sys/net/ipv4/ip_forward contents are not set to 1[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`To see the stack trace of this error execute with --v=5 or higher\n\n出于安全考虑，Linux系统默认是禁止数据包转发的。所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的ip地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包。这通常就是路由器所要实现的功能。也就是说  &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward 文件的值不支持转发\n\n0：禁止\n1：转发\n\n所以我们需要将值修改成1即可\necho “1” &gt; /proc/sys/net/ipv4/ip_forward\n\n修改完成后，重新执行命令即可\n","tags":["k8s"]},{"title":"k8s之容器交付","url":"/2022/08/24/k8s%E4%B9%8B%E5%AE%B9%E5%99%A8%E4%BA%A4%E4%BB%98/","content":"如何在k8s集群中部署Java项目\n容器交付流程\n开发代码阶段\n编写代码\n编写Dockerfile【打镜像做准备】\n\n\n持续交付&#x2F;集成\n代码编译打包\n制作镜像\n上传镜像仓库\n\n\n应用部署\n环境准备\nPod\nService\nIngress\n\n\n运维\n监控\n故障排查\n应用升级\n\n\n\nk8s部署Java项目流程\n制作镜像【Dockerfile】\n上传到镜像仓库【Dockerhub、阿里云、网易】\n控制器部署镜像【Deployment】\n对外暴露应用【Service、Ingress】\n运维【监控、升级】\n\nk8s部署Java项目准备Java项目第一步，准备java项目，把java进行打包【jar包或者war包】\n\n依赖环境在打包java项目的时候，我们首先需要两个环境\n\njava环境【JDK】\nmaven环境\n\n然后把java项目打包成jar包\nmvn clean install\n\n\n编写Dockerfile文件Dockerfile 内容如下所示\nFROM openjdk:8-jdk-alpineVOLUME /tmpADD ./target/demojenkins.jar demojenkins.jarENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/demojenkins.jar&quot;, &quot;&amp;&quot;]\n\n制作镜像在我们创建好Dockerfile文件后，我们就可以制作镜像了\n我们首先将我们的项目，放到我们的服务器上\n\n然后执行下面命令打包镜像\ndocker build -t java-demo-01:latest .\n\n等待一段后，即可制作完成我们的镜像\n\n最后通过下面命令，即可查看我们的镜像了\ndocker images;\n\n启动镜像在我们制作完成镜像后，我们就可以启动我们的镜像了\ndocker run -d -p 8111:8111 java-demo-01:latest -t\n\n启动完成后，我们通过浏览器进行访问，即可看到我们的java程序\nhttp://192.168.177.130:8111/user\n\n推送镜像下面我们需要将我们制作好的镜像，上传到镜像服务器中【阿里云、DockerHub】\n首先我们需要到 阿里云 容器镜像服务，然后开始创建镜像仓库\n\n然后选择本地仓库\n\n我们点击我们刚刚创建的镜像仓库，就能看到以下的信息\n\n登录镜像服务器使用命令登录\ndocker login --username=XXXXXXX@163.com registry.cn-shenzhen.aliyuncs.com\n\n然后输入刚刚我们开放时候的注册的密码\n镜像添加版本号下面为我们的镜像添加版本号\n# 实例docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/mogublog/java-project-01:[镜像版本号]# 举例docker tag 33f11349c27d registry.cn-shenzhen.aliyuncs.com/mogublog/java-project-01:1.0.0\n\n操作完成后\n\n推送镜像在我们添加版本号信息后，我们就可以推送我们的镜像到阿里云了\ndocker push registry.cn-shenzhen.aliyuncs.com/mogublog/java-project-01:1.0.0\n\n\n操作完成后，我们在我们的阿里云镜像服务，就能看到推送上来的镜像了\n\n控制器部署镜像在我们推送镜像到服务器后，就可以通过控制器部署镜像了\n首先我们需要根据刚刚的镜像，导出yaml\n# 导出yamlkubectl create deployment  javademo1 --image=registry.cn-shenzhen.aliyuncs.com/mogublog/java-project-01:1.0.0 --dry-run -o yaml &gt; javademo1.yaml\n\n导出后的 javademo1.yaml 如下所示\napiVersion: apps/v1kind: Deploymentmetadata:  creationTimestamp: null  labels:    app: javademo1  name: javademo1spec:  replicas: 1  selector:    matchLabels:      app: javademo1  strategy: &#123;&#125;  template:    metadata:      creationTimestamp: null      labels:        app: javademo1    spec:      containers:      - image: registry.cn-shenzhen.aliyuncs.com/mogublog/java-project-01:1.0.0        name: java-project-01        resources: &#123;&#125;status: &#123;&#125;\n\n然后通过下面命令，通过yaml创建我们的deployment\n# 创建kubectl apply -f javademo1.yaml# 查看 pods\n\n\n或者我们可以进行扩容，多创建几个副本\nkubectl scale deployment javademo1 --replicas=3\n\n\n然后我们还需要对外暴露端口【通过service 或者 Ingress】\n# 对外暴露端口kubectl expose deployment javademo1 --port=8111  --target-port=8111 --type=NodePort# 查看对外端口号kubectl get svc\n\n\n然后通过下面的地址访问\n# 对内访问curl http://10.106.103.242:8111/user# 对外访问http://192.168.177.130:32190/user\n\n运维….\n","tags":["k8s"]},{"title":"k8s之持久化存储","url":"/2022/08/24/k8s%E4%B9%8B%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8/","content":"前言之前我们有提到数据卷：emptydir ，是本地存储，pod重启，数据就不存在了，需要对数据持久化存储\n对于数据持久化存储【pod重启，数据还存在】，有两种方式\n\nnfs：网络存储【通过一台服务器来存储】\n\n步骤持久化服务器上操作\n找一台新的服务器nfs服务端，安装nfs\n设置挂载路径\n\n使用命令安装nfs\nyum install -y nfs-utils\n\n首先创建存放数据的目录\nmkdir -p /data/nfs\n\n设置挂载路径\n# 打开文件vim /etc/exports# 添加如下内容/data/nfs *(rw,no_root_squash)\n\n执行完成后，即部署完我们的持久化服务器\nNode节点上操作然后需要在k8s集群node节点上安装nfs，这里需要在 node1 和 node2节点上安装\nyum install -y nfs-utils\n\n执行完成后，会自动帮我们挂载上\n启动nfs服务端下面我们回到nfs服务端，启动我们的nfs服务\n# 启动服务systemctl start nfs# 或者使用以下命令进行启动service nfs-server start\n\n\nK8s集群部署应用最后我们在k8s集群上部署应用，使用nfs持久化存储\n# 创建一个pv文件mkdir pv# 进入cd pv\n\n然后创建一个yaml文件  nfs-nginx.yaml\n\n通过这个方式，就挂载到了刚刚我们的nfs数据节点下的 &#x2F;data&#x2F;nfs 目录\n最后就变成了：  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html    -&gt;  192.168.44.134&#x2F;data&#x2F;nfs   内容是对应的\n我们通过这个 yaml文件，创建一个pod\nkubectl apply -f nfs-nginx.yaml\n\n创建完成后，我们也可以查看日志\nkubectl describe pod nginx-dep1\n\n\n可以看到，我们的pod已经成功创建出来了，同时下图也是出于Running状态\n\n下面我们就可以进行测试了，比如现在nfs服务节点上添加数据，然后在看数据是否存在 pod中\n# 进入pod中查看kubectl exec -it nginx-dep1 bash\n\n\nPV和PVC对于上述的方式，我们都知道，我们的ip 和端口是直接放在我们的容器上的，这样管理起来可能不方便\n\n所以这里就需要用到 pv  和 pvc的概念了，方便我们配置和管理我们的 ip 地址等元信息\nPV：持久化存储，对存储的资源进行抽象，对外提供可以调用的地方【生产者】\nPVC：用于调用，不需要关心内部实现细节【消费者】\nPV 和 PVC 使得 K8S 集群具备了存储的逻辑抽象能力。使得在配置Pod的逻辑里可以忽略对实际后台存储技术的配置，而把这项配置的工作交给PV的配置者，即集群的管理者。存储的PV和PVC的这种关系，跟计算的Node和Pod的关系是非常类似的；PV和Node是资源的提供者，根据集群的基础设施变化而变化，由K8s集群管理员配置；而PVC和Pod是资源的使用者，根据业务服务的需求变化而变化，由K8s集群的使用者即服务的管理员来配置。\n实现流程\nPVC绑定PV\n定义PVC\n定义PV【数据卷定义，指定数据存储服务器的ip、路径、容量和匹配模式】\n\n举例创建一个 pvc.yaml\n\n第一部分是定义一个 deployment，做一个部署\n\n副本数：3\n挂载路径\n调用：是通过pvc的模式\n\n然后定义pvc\n\n然后在创建一个 pv.yaml\n\n然后就可以创建pod了\nkubectl apply -f pv.yaml\n\n然后我们就可以通过下面命令，查看我们的 pv  和 pvc之间的绑定关系\nkubectl get pv, pvc\n\n\n到这里为止，我们就完成了我们 pv 和 pvc的绑定操作，通过之前的方式，进入pod中查看内容\nkubect exec -it nginx-dep1 bash\n\n然后查看  &#x2F;usr&#x2F;share&#x2F;nginx.html\n\n也同样能看到刚刚的内容，其实这种操作和之前我们的nfs是一样的，只是多了一层pvc绑定pv的操作\n","tags":["k8s"]},{"title":"k8s之控制器Controller详解","url":"/2022/08/23/k8s%E4%B9%8B%E6%8E%A7%E5%88%B6%E5%99%A8Controller%E8%AF%A6%E8%A7%A3/","content":"StatefulsetStatefulset主要是用来部署有状态应用\n对于StatefulSet中的Pod，每个Pod挂载自己独立的存储，如果一个Pod出现故障，从其他节点启动一个同样名字的Pod，要挂载上原来Pod的存储继续以它的状态提供服务。\n无状态应用我们原来使用 deployment，部署的都是无状态的应用，那什么是无状态应用？\n\n认为Pod都是一样的\n没有顺序要求\n不考虑应用在哪个node上运行\n能够进行随意伸缩和扩展\n\n有状态应用上述的因素都需要考虑到\n\n让每个Pod独立的\n让每个Pod独立的，保持Pod启动顺序和唯一性\n唯一的网络标识符，持久存储\n有序，比如mysql中的主从\n\n适合StatefulSet的业务包括数据库服务MySQL 和 PostgreSQL，集群化管理服务Zookeeper、etcd等有状态服务\nStatefulSet的另一种典型应用场景是作为一种比普通容器更稳定可靠的模拟虚拟机的机制。传统的虚拟机正是一种有状态的宠物，运维人员需要不断地维护它，容器刚开始流行时，我们用容器来模拟虚拟机使用，所有状态都保存在容器里，而这已被证明是非常不安全、不可靠的。\n使用StatefulSet，Pod仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性，StatefulSet做的只是将确定的Pod与确定的存储关联起来保证状态的连续性。\n部署有状态应用无头service， ClusterIp：none\n这里就需要使用 StatefulSet部署有状态应用\n\n\n然后通过查看pod，能否发现每个pod都有唯一的名称\n\n然后我们在查看service，发现是无头的service\n\n这里有状态的约定，肯定不是简简单单通过名称来进行约定，而是更加复杂的操作\n\ndeployment：是有身份的，有唯一标识\nstatefulset：根据主机名 + 按照一定规则生成域名\n\n每个pod有唯一的主机名，并且有唯一的域名\n\n格式：主机名称.service名称.名称空间.svc.cluster.local\n举例：nginx-statefulset-0.default.svc.cluster.local\n\nDaemonSetDaemonSet 即后台支撑型服务，主要是用来部署守护进程\n长期伺服型和批处理型的核心在业务应用，可能有些节点运行多个同类业务的Pod，有些节点上又没有这类的Pod运行；而后台支撑型服务的核心关注点在K8S集群中的节点(物理机或虚拟机)，要保证每个节点上都有一个此类Pod运行。节点可能是所有集群节点，也可能是通过 nodeSelector选定的一些特定节点。典型的后台支撑型服务包括：存储、日志和监控等。在每个节点上支撑K8S集群运行的服务。\n守护进程在我们每个节点上，运行的是同一个pod，新加入的节点也同样运行在同一个pod里面\n\n例子：在每个node节点安装数据采集工具\n\n\n这里是不是一个FileBeat镜像，主要是为了做日志采集工作\n\n进入某个 Pod里面，进入\nkubectl exec -it ds-test-cbk6v bash\n\n通过该命令后，我们就能看到我们内部收集的日志信息了\n\nJob和CronJob一次性任务 和 定时任务\n\n一次性任务：一次性执行完就结束\n定时任务：周期性执行\n\nJob是K8S中用来控制批处理型任务的API对象。批处理业务与长期伺服业务的主要区别就是批处理业务的运行有头有尾，而长期伺服业务在用户不停止的情况下永远运行。Job管理的Pod根据用户的设置把任务成功完成就自动退出了。成功完成的标志根据不同的 spec.completions 策略而不同：单Pod型任务有一个Pod成功就标志完成；定数成功行任务保证有N个任务全部成功；工作队列性任务根据应用确定的全局成功而标志成功。\nJobJob也即一次性任务\n\n使用下面命令，能够看到目前已经存在的Job\nkubectl get jobs\n\n\n在计算完成后，通过命令查看，能够发现该任务已经完成\n\n我们可以通过查看日志，查看到一次性任务的结果\nkubectl logs pi-qpqff\n\n\nCronJob定时任务，cronjob.yaml如下所示\n\n这里面的命令就是每个一段时间，这里是通过 cron 表达式配置的，通过 schedule字段\n然后下面命令就是每个一段时间输出 \n我们首先用上述的配置文件，创建一个定时任务\nkubectl apply -f cronjob.yaml\n\n创建完成后，我们就可以通过下面命令查看定时任务\nkubectl get cronjobs\n\n\n我们可以通过日志进行查看\nkubectl logs hello-1599100140-wkn79\n\n\n然后每次执行，就会多出一个 pod\n\n删除svc 和 statefulset使用下面命令，可以删除我们添加的svc 和 statefulset\nkubectl delete svc webkubectl delete statefulset --all\n\nReplication ControllerReplication Controller 简称 RC，是K8S中的复制控制器。RC是K8S集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。指定的数目可以是多个也可以是1个；少于指定数目，RC就会启动新的Pod副本；多于指定数目，RC就会杀死多余的Pod副本。\n即使在指定数目为1的情况下，通过RC运行Pod也比直接运行Pod更明智，因为RC也可以发挥它高可用的能力，保证永远有一个Pod在运行。RC是K8S中较早期的技术概念，只适用于长期伺服型的业务类型，比如控制Pod提供高可用的Web服务。\nReplica SetReplica Set 检查 RS，也就是副本集。RS是新一代的RC，提供同样高可用能力，区别主要在于RS后来居上，能够支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为Deployment的理想状态参数来使用\n","tags":["k8s"]},{"title":"k8s之搭建K8S集群前置知识","url":"/2022/08/20/k8s%E4%B9%8B%E6%90%AD%E5%BB%BAK8S%E9%9B%86%E7%BE%A4%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/","content":"搭建k8s环境平台规划单master集群单个master节点，然后管理多个node节点\n\n多master集群多个master节点，管理多个node节点，同时中间多了一个负载均衡的过程\n\n服务器硬件配置要求测试环境master：2核  4G  20G\nnode：   4核  8G  40G\n生产环境master：8核  16G  100G\nnode：   16核  64G  200G\n目前生产部署Kubernetes集群主要有两种方式\nkubeadmkubeadm是一个K8S部署工具，提供kubeadm init 和 kubeadm join，用于快速部署Kubernetes集群\n官网地址：点我传送\n二进制包从github下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。\nKubeadm降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署Kubernetes集群，虽然手动部署麻烦点，期间可以学习很多工作原理，也利于后期维护。\nKubeadm部署集群kubeadm 是官方社区推出的一个用于快速部署kubernetes 集群的工具，这个工具能通过两条指令完成一个kubernetes 集群的部署：\n\n创建一个Master 节点kubeadm init\n将Node 节点加入到当前集群中$ kubeadm join &lt;Master 节点的IP 和端口&gt;\n\n安装要求在开始之前，部署Kubernetes集群机器需要满足以下几个条件\n\n一台或多台机器，操作系统为Centos7.X\n硬件配置：2GB或更多GAM，2个CPU或更多CPU，硬盘30G\n集群中所有机器之间网络互通\n可以访问外网，需要拉取镜像\n禁止swap分区\n\n","tags":["k8s"]},{"title":"k8s之搭建高可用集群","url":"/2022/08/24/k8s%E4%B9%8B%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/","content":"前言之前我们搭建的集群，只有一个master节点，当master节点宕机的时候，通过node将无法继续访问，而master主要是管理作用，所以整个集群将无法提供服务\n\n高可用集群下面我们就需要搭建一个多master节点的高可用集群，不会存在单点故障问题\n但是在node 和 master节点之间，需要存在一个 LoadBalancer组件，作用如下：\n\n负载\n检查master节点的状态\n\n\n对外有一个统一的VIP：虚拟ip来对外进行访问\n高可用集群技术细节高可用集群技术细节如下所示：\n\n\nkeepalived：配置虚拟ip，检查节点的状态\nhaproxy：负载均衡服务【类似于nginx】\napiserver：\ncontroller：\nmanager：\nscheduler：\n\n高可用集群步骤我们采用2个master节点，一个node节点来搭建高可用集群，下面给出了每个节点需要做的事情\n\n初始化操作我们需要在这三个节点上进行操作\n# 关闭防火墙systemctl stop firewalldsystemctl disable firewalld# 关闭selinux# 永久关闭sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config  # 临时关闭setenforce 0  # 关闭swap# 临时swapoff -a # 永久关闭sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab# 根据规划设置主机名【master1节点上操作】hostnamectl set-hostname master1# 根据规划设置主机名【master2节点上操作】hostnamectl set-hostname master1# 根据规划设置主机名【node1节点操作】hostnamectl set-hostname node1# r添加hostscat &gt;&gt; /etc/hosts &lt;&lt; EOF192.168.44.158  k8smaster192.168.44.155 master01.k8s.io master1192.168.44.156 master02.k8s.io master2192.168.44.157 node01.k8s.io node1EOF# 将桥接的IPv4流量传递到iptables的链【3个节点上都执行】cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF# 生效sysctl --system  # 时间同步yum install ntpdate -yntpdate time.windows.com\n\n部署keepAlived下面我们需要在所有的master节点【master1和master2】上部署keepAlive\n安装相关包# 安装相关工具yum install -y conntrack-tools libseccomp libtool-ltdl# 安装keepalivedyum install -y keepalived\n\n配置master节点添加master1的配置\ncat &gt; /etc/keepalived/keepalived.conf &lt;&lt;EOF ! Configuration File for keepalivedglobal_defs &#123;   router_id k8s&#125;vrrp_script check_haproxy &#123;    script &quot;killall -0 haproxy&quot;    interval 3    weight -2    fall 10    rise 2&#125;vrrp_instance VI_1 &#123;    state MASTER     interface ens33     virtual_router_id 51    priority 250    advert_int 1    authentication &#123;        auth_type PASS        auth_pass ceb1b3ec013d66163d6ab    &#125;    virtual_ipaddress &#123;        192.168.44.158    &#125;    track_script &#123;        check_haproxy    &#125;&#125;EOF\n\n添加master2的配置\ncat &gt; /etc/keepalived/keepalived.conf &lt;&lt;EOF ! Configuration File for keepalivedglobal_defs &#123;   router_id k8s&#125;vrrp_script check_haproxy &#123;    script &quot;killall -0 haproxy&quot;    interval 3    weight -2    fall 10    rise 2&#125;vrrp_instance VI_1 &#123;    state BACKUP     interface ens33     virtual_router_id 51    priority 200    advert_int 1    authentication &#123;        auth_type PASS        auth_pass ceb1b3ec013d66163d6ab    &#125;    virtual_ipaddress &#123;        192.168.44.158    &#125;    track_script &#123;        check_haproxy    &#125;&#125;EOF\n\n启动和检查在两台master节点都执行\n# 启动keepalivedsystemctl start keepalived.service# 设置开机启动systemctl enable keepalived.service# 查看启动状态systemctl status keepalived.service\n\n启动后查看master的网卡信息\nip a s ens33\n\n\n部署haproxyhaproxy主要做负载的作用，将我们的请求分担到不同的node节点上\n安装在两个master节点安装 haproxy\n# 安装haproxyyum install -y haproxy# 启动 haproxysystemctl start haproxy# 开启自启systemctl enable haproxy\n\n启动后，我们查看对应的端口是否包含 16443\nnetstat -tunlp | grep haproxy\n\n\n配置两台master节点的配置均相同，配置中声明了后端代理的两个master节点服务器，指定了haproxy运行的端口为16443等，因此16443端口为集群的入口\ncat &gt; /etc/haproxy/haproxy.cfg &lt;&lt; EOF#---------------------------------------------------------------------# Global settings#---------------------------------------------------------------------global    # to have these messages end up in /var/log/haproxy.log you will    # need to:    # 1) configure syslog to accept network log events.  This is done    #    by adding the &#x27;-r&#x27; option to the SYSLOGD_OPTIONS in    #    /etc/sysconfig/syslog    # 2) configure local2 events to go to the /var/log/haproxy.log    #   file. A line like the following can be added to    #   /etc/sysconfig/syslog    #    #    local2.*                       /var/log/haproxy.log    #    log         127.0.0.1 local2        chroot      /var/lib/haproxy    pidfile     /var/run/haproxy.pid    maxconn     4000    user        haproxy    group       haproxy    daemon            # turn on stats unix socket    stats socket /var/lib/haproxy/stats#---------------------------------------------------------------------# common defaults that all the &#x27;listen&#x27; and &#x27;backend&#x27; sections will# use if not designated in their block#---------------------------------------------------------------------  defaults    mode                    http    log                     global    option                  httplog    option                  dontlognull    option http-server-close    option forwardfor       except 127.0.0.0/8    option                  redispatch    retries                 3    timeout http-request    10s    timeout queue           1m    timeout connect         10s    timeout client          1m    timeout server          1m    timeout http-keep-alive 10s    timeout check           10s    maxconn                 3000#---------------------------------------------------------------------# kubernetes apiserver frontend which proxys to the backends#--------------------------------------------------------------------- frontend kubernetes-apiserver    mode                 tcp    bind                 *:16443    option               tcplog    default_backend      kubernetes-apiserver    #---------------------------------------------------------------------# round robin balancing between the various backends#---------------------------------------------------------------------backend kubernetes-apiserver    mode        tcp    balance     roundrobin    server      master01.k8s.io   192.168.44.155:6443 check    server      master02.k8s.io   192.168.44.156:6443 check#---------------------------------------------------------------------# collection haproxy statistics message#---------------------------------------------------------------------listen stats    bind                 *:1080    stats auth           admin:awesomePassword    stats refresh        5s    stats realm          HAProxy\\ Statistics    stats uri            /admin?statsEOF\n\n安装Docker、Kubeadm、kubectl所有节点安装Docker&#x2F;kubeadm&#x2F;kubelet ，Kubernetes默认CRI（容器运行时）为Docker，因此先安装Docker\n安装Docker首先配置一下Docker的阿里yum源\ncat &gt;/etc/yum.repos.d/docker.repo&lt;&lt;EOF[docker-ce-edge]name=Docker CE Edge - \\$basearchbaseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/\\$basearch/edgeenabled=1gpgcheck=1gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpgEOF\n\n然后yum方式安装docker\n# yum安装yum -y install docker-ce# 查看docker版本docker --version  # 启动dockersystemctl enable dockersystemctl start docker\n\n配置docker的镜像源\ncat &gt;&gt; /etc/docker/daemon.json &lt;&lt; EOF&#123;  &quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]&#125;EOF\n\n然后重启docker\nsystemctl restart docker\n\n添加kubernetes软件源然后我们还需要配置一下yum的k8s软件源\ncat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF\n\n安装kubeadm，kubelet和kubectl由于版本更新频繁，这里指定版本号部署：\n# 安装kubelet、kubeadm、kubectl，同时指定版本yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0# 设置开机启动systemctl enable kubelet\n\n部署Kubernetes Master【master节点】创建kubeadm配置文件在具有vip的master上进行初始化操作，这里为master1\n# 创建文件夹mkdir /usr/local/kubernetes/manifests -p# 到manifests目录cd /usr/local/kubernetes/manifests/# 新建yaml文件vi kubeadm-config.yaml\n\nyaml内容如下所示：\napiServer:  certSANs:    - master1    - master2    - master.k8s.io    - 192.168.44.158    - 192.168.44.155    - 192.168.44.156    - 127.0.0.1  extraArgs:    authorization-mode: Node,RBAC  timeoutForControlPlane: 4m0sapiVersion: kubeadm.k8s.io/v1beta1certificatesDir: /etc/kubernetes/pkiclusterName: kubernetescontrolPlaneEndpoint: &quot;master.k8s.io:16443&quot;controllerManager: &#123;&#125;dns:   type: CoreDNSetcd:  local:        dataDir: /var/lib/etcdimageRepository: registry.aliyuncs.com/google_containerskind: ClusterConfigurationkubernetesVersion: v1.16.3networking:   dnsDomain: cluster.local    podSubnet: 10.244.0.0/16  serviceSubnet: 10.1.0.0/16scheduler: &#123;&#125;\n\n然后我们在 master1 节点执行\nkubeadm init --config kubeadm-config.yaml\n\n执行完成后，就会在拉取我们的进行了【需要等待…】\n\n按照提示配置环境变量，使用kubectl工具\n# 执行下方命令mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config# 查看节点kubectl get nodes# 查看podkubectl get pods -n kube-system\n\n按照提示保存以下内容，一会要使用：\nkubeadm join master.k8s.io:16443 --token jv5z7n.3y1zi95p952y9p65 \\    --discovery-token-ca-cert-hash sha256:403bca185c2f3a4791685013499e7ce58f9848e2213e27194b75a2e3293d8812 \\    --control-plane \n\n\n–control-plane ： 只有在添加master节点的时候才有\n\n查看集群状态\n# 查看集群状态kubectl get cs# 查看podkubectl get pods -n kube-system\n\n安装集群网络从官方地址获取到flannel的yaml，在master1上执行\n# 创建文件夹mkdir flannelcd flannel# 下载yaml文件wget -c https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml\n\n安装flannel网络\nkubectl apply -f kube-flannel.yml \n\n检查\nkubectl get pods -n kube-system\n\nmaster2节点加入集群复制密钥及相关文件从master1复制密钥及相关文件到master2\n# ssh root@192.168.44.156 mkdir -p /etc/kubernetes/pki/etcd# scp /etc/kubernetes/admin.conf root@192.168.44.156:/etc/kubernetes   # scp /etc/kubernetes/pki/&#123;ca.*,sa.*,front-proxy-ca.*&#125; root@192.168.44.156:/etc/kubernetes/pki   # scp /etc/kubernetes/pki/etcd/ca.* root@192.168.44.156:/etc/kubernetes/pki/etcd\n\nmaster2加入集群执行在master1上init后输出的join命令,需要带上参数--control-plane表示把master控制节点加入集群\nkubeadm join master.k8s.io:16443 --token ckf7bs.30576l0okocepg8b     --discovery-token-ca-cert-hash sha256:19afac8b11182f61073e254fb57b9f19ab4d798b70501036fc69ebef46094aba --control-plane\n\n检查状态\nkubectl get nodekubectl get pods --all-namespaces\n\n加入Kubernetes Node在node1上执行\n向集群添加新节点，执行在kubeadm init输出的kubeadm join命令：\nkubeadm join master.k8s.io:16443 --token ckf7bs.30576l0okocepg8b     --discovery-token-ca-cert-hash sha256:19afac8b11182f61073e254fb57b9f19ab4d798b70501036fc69ebef46094aba\n\n集群网络重新安装，因为添加了新的node节点\n检查状态\nkubectl get nodekubectl get pods --all-namespaces\n\n测试kubernetes集群在Kubernetes集群中创建一个pod，验证是否正常运行：\n# 创建nginx deploymentkubectl create deployment nginx --image=nginx# 暴露端口kubectl expose deployment nginx --port=80 --type=NodePort# 查看状态kubectl get pod,svc\n\n然后我们通过任何一个节点，都能够访问我们的nginx页面\n","tags":["k8s"]},{"title":"k8s之核心技术Controller","url":"/2022/08/23/k8s%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFController/","content":"内容\n什么是Controller\nPod和Controller的关系\nDeployment控制器应用场景\nyaml文件字段说明\nDeployment控制器部署应用\n升级回滚\n弹性伸缩\n\n什么是ControllerController是在集群上管理和运行容器的对象，Controller是实际存在的，Pod是虚拟机的\nPod和Controller的关系Pod是通过Controller实现应用的运维，比如弹性伸缩，滚动升级等\nPod 和 Controller之间是通过label标签来建立关系，同时Controller又被称为控制器工作负载\n\nDeployment控制器应用\nDeployment控制器可以部署无状态应用\n管理Pod和ReplicaSet\n部署，滚动升级等功能\n应用场景：web服务，微服务\n\nDeployment表示用户对K8S集群的一次更新操作。Deployment是一个比RS( Replica Set, RS) 应用模型更广的 API 对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新 RS 中副本数增加到理想状态，将旧RS中的副本数减少到0的复合操作。\n这样一个复合操作用一个RS是不好描述的，所以用一个更通用的Deployment来描述。以K8S的发展方向，未来对所有长期伺服型的业务的管理，都会通过Deployment来管理。\nDeployment部署应用之前我们也使用Deployment部署过应用，如下代码所示\nkubectrl create deployment web --image=nginx\n\n但是上述代码不是很好的进行复用，因为每次我们都需要重新输入代码，所以我们都是通过YAML进行配置\n但是我们可以尝试使用上面的代码创建一个镜像【只是尝试，不会创建】\nkubectl create deployment web --image=nginx --dry-run -o yaml &gt; nginx.yaml\n\n然后输出一个yaml配置文件 nginx.yml ，配置文件如下所示\napiVersion: apps/v1kind: Deploymentmetadata:  creationTimestamp: null  labels:    app: web  name: webspec:  replicas: 1  selector:    matchLabels:      app: web  strategy: &#123;&#125;  template:    metadata:      creationTimestamp: null      labels:        app: web    spec:      containers:      - image: nginx        name: nginx        resources: &#123;&#125;status: &#123;&#125;\n\n\n使用YAML创建Pod通过刚刚的代码，我们已经生成了YAML文件，下面我们就可以使用该配置文件快速创建Pod镜像了\nkubectl apply -f nginx.yaml\n\n\n但是因为这个方式创建的，我们只能在集群内部进行访问，所以我们还需要对外暴露端口\nkubectl expose deployment web --port=80 --type=NodePort --target-port=80 --name=web1\n\n关于上述命令，有几个参数\n\n–port：就是我们内部的端口号\n–target-port：就是暴露外面访问的端口号\n–name：名称\n–type：类型\n\n同理，我们一样可以导出对应的配置文件\nkubectl expose deployment web --port=80 --type=NodePort --target-port=80 --name=web1 -o yaml &gt; web1.yaml\n\n得到的web1.yaml如下所示\napiVersion: v1kind: Servicemetadata:  creationTimestamp: &quot;2020-11-16T02:26:53Z&quot;  labels:    app: web  managedFields:  - apiVersion: v1    fieldsType: FieldsV1    fieldsV1:      f:metadata:        f:labels:          .: &#123;&#125;          f:app: &#123;&#125;      f:spec:        f:externalTrafficPolicy: &#123;&#125;        f:ports:          .: &#123;&#125;          k:&#123;&quot;port&quot;:80,&quot;protocol&quot;:&quot;TCP&quot;&#125;:            .: &#123;&#125;            f:port: &#123;&#125;            f:protocol: &#123;&#125;            f:targetPort: &#123;&#125;        f:selector:          .: &#123;&#125;          f:app: &#123;&#125;        f:sessionAffinity: &#123;&#125;        f:type: &#123;&#125;    manager: kubectl    operation: Update    time: &quot;2020-11-16T02:26:53Z&quot;  name: web2  namespace: default  resourceVersion: &quot;113693&quot;  selfLink: /api/v1/namespaces/default/services/web2  uid: d570437d-a6b4-4456-8dfb-950f09534516spec:  clusterIP: 10.104.174.145  externalTrafficPolicy: Cluster  ports:  - nodePort: 32639    port: 80    protocol: TCP    targetPort: 80  selector:    app: web  sessionAffinity: None  type: NodePortstatus:  loadBalancer: &#123;&#125;\n\n然后我们可以通过下面的命令来查看对外暴露的服务\nkubectl get pods,svc\n\n\n然后我们访问对应的url，即可看到 nginx了 http://192.168.177.130:32639/\n\n升级回滚和弹性伸缩\n升级：  假设从版本为1.14 升级到 1.15 ，这就叫应用的升级【升级可以保证服务不中断】\n回滚：从版本1.15 变成 1.14，这就叫应用的回滚\n弹性伸缩：我们根据不同的业务场景，来改变Pod的数量对外提供服务，这就是弹性伸缩\n\n应用升级和回滚首先我们先创建一个 1.14版本的Pod\napiVersion: apps/v1kind: Deploymentmetadata:  creationTimestamp: null  labels:    app: web  name: webspec:  replicas: 1  selector:    matchLabels:      app: web  strategy: &#123;&#125;  template:    metadata:      creationTimestamp: null      labels:        app: web    spec:      containers:      - image: nginx:1.14        name: nginx        resources: &#123;&#125;status: &#123;&#125;\n\n我们先指定版本为1.14，然后开始创建我们的Pod\nkubectl apply -f nginx.yaml\n\n同时，我们使用docker images命令，就能看到我们成功拉取到了一个 1.14版本的镜像\n\n我们使用下面的命令，可以将nginx从 1.14 升级到 1.15\nkubectl set image deployment web nginx=nginx:1.15\n\n在我们执行完命令后，能看到升级的过程\n\n\n首先是开始的nginx 1.14版本的Pod在运行，然后 1.15版本的在创建\n然后在1.15版本创建完成后，就会暂停1.14版本\n最后把1.14版本的Pod移除，完成我们的升级\n\n我们在下载 1.15版本，容器就处于ContainerCreating状态，然后下载完成后，就用 1.15版本去替换1.14版本了，这么做的好处就是：升级可以保证服务不中断\n\n我们到我们的node2节点上，查看我们的 docker images;\n\n能够看到，我们已经成功拉取到了 1.15版本的nginx了\n查看升级状态下面可以，查看升级状态\nkubectl rollout status deployment web\n\n\n查看历史版本我们还可以查看历史版本\nkubectl rollout history deployment web\n\n应用回滚我们可以使用下面命令，完成回滚操作，也就是回滚到上一个版本\nkubectl rollout undo deployment web\n\n然后我们就可以查看状态\nkubectl rollout status deployment web\n\n\n同时我们还可以回滚到指定版本\nkubectl rollout undo deployment web --to-revision=2\n\n弹性伸缩弹性伸缩，也就是我们通过命令一下创建多个副本\nkubectl scale deployment web --replicas=10\n\n能够清晰看到，我们一下创建了10个副本\n\n","tags":["k8s"]},{"title":"k8s之核心技术Helm","url":"/2022/08/24/k8s%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFHelm/","content":"Helm就是一个包管理工具【类似于npm】\n\n为什么引入Helm首先在原来项目中都是基于yaml文件来进行部署发布的，而目前项目大部分微服务化或者模块化，会分成很多个组件来部署，每个组件可能对应一个deployment.yaml,一个service.yaml,一个Ingress.yaml还可能存在各种依赖关系，这样一个项目如果有5个组件，很可能就有15个不同的yaml文件，这些yaml分散存放，如果某天进行项目恢复的话，很难知道部署顺序，依赖关系等，而所有这些包括\n\n基于yaml配置的集中存放\n基于项目的打包\n组件间的依赖\n\n但是这种方式部署，会有什么问题呢？\n\n如果使用之前部署单一应用，少数服务的应用，比较合适\n但如果部署微服务项目，可能有几十个服务，每个服务都有一套yaml文件，需要维护大量的yaml文件，版本管理特别不方便\n\nHelm的引入，就是为了解决这个问题\n\n使用Helm可以把这些YAML文件作为整体管理\n实现YAML文件高效复用\n使用helm应用级别的版本管理\n\nHelm介绍Helm是一个Kubernetes的包管理工具，就像Linux下的包管理器，如yum&#x2F;apt等，可以很方便的将之前打包好的yaml文件部署到kubernetes上。\nHelm有三个重要概念\n\nhelm：一个命令行客户端工具，主要用于Kubernetes应用chart的创建、打包、发布和管理\nChart：应用描述，一系列用于描述k8s资源相关文件的集合\nRelease：基于Chart的部署实体，一个chart被Helm运行后将会生成对应的release，将在K8S中创建出真实的运行资源对象。也就是应用级别的版本管理\nRepository：用于发布和存储Chart的仓库\n\nHelm组件及架构Helm采用客户端&#x2F;服务端架构，有如下组件组成\n\nHelm CLI是Helm客户端，可以在本地执行\nTiller是服务器端组件，在Kubernetes集群上运行，并管理Kubernetes应用程序\nRepository是Chart仓库，Helm客户端通过HTTP协议来访问仓库中Chart索引文件和压缩包\n\n\nHelm v3变化2019年11月13日，Helm团队发布了Helm v3的第一个稳定版本\n该版本主要变化如下\n\n架构变化\n\n最明显的变化是Tiller的删除\nV3版本删除Tiller\nrelesase可以在不同命名空间重用\n\n\n\nV3之前\n\n V3版本\n\nhelm配置首先我们需要去 官网下载\n\n第一步，下载helm安装压缩文件，上传到linux系统中\n第二步，解压helm压缩文件，把解压后的helm目录复制到 usr&#x2F;bin 目录中\n使用命令：helm\n\n我们都知道yum需要配置yum源，那么helm就就要配置helm源\nhelm仓库添加仓库\nhelm repo add 仓库名  仓库地址 \n\n例如\n# 配置微软源helm repo add stable http://mirror.azure.cn/kubernetes/charts# 配置阿里源helm repo add aliyun https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts# 配置google源helm repo add google https://kubernetes-charts.storage.googleapis.com/# 更新helm repo update\n\n然后可以查看我们添加的仓库地址\n# 查看全部helm repo list# 查看某个helm search repo stable\n\n\n或者可以删除我们添加的源\nhelm repo remove stable\n\nhelm基本命令\nchart install\nchart upgrade\nchart rollback\n\n使用helm快速部署应用使用命令搜索应用首先我们使用命令，搜索我们需要安装的应用\n# 搜索 weave仓库helm search repo weave\n\n\n根据搜索内容选择安装搜索完成后，使用命令进行安装\nhelm install ui aliyun/weave-scope\n\n可以通过下面命令，来下载yaml文件【如果】\nkubectl apply -f weave-scope.yaml\n\n安装完成后，通过下面命令即可查看\nhelm list\n\n\n同时可以通过下面命令，查看更新具体的信息\nhelm status ui\n\n但是我们通过查看 svc状态，发现没有对象暴露端口\n\n所以我们需要修改service的yaml文件，添加NodePort\nkubectl edit svc ui-weave-scope\n\n\n这样就可以对外暴露端口了\n\n然后我们通过 ip + 32185 即可访问\n如果自己创建Chart使用命令，自己创建Chart\nhelm create mychart\n\n创建完成后，我们就能看到在当前文件夹下，创建了一个 mychart目录\n\n目录格式\ntemplates：编写yaml文件存放到这个目录\nvalues.yaml：存放的是全局的yaml文件\nchart.yaml：当前chart属性配置信息\n\n在templates文件夹创建两个文件我们创建以下两个\n\ndeployment.yaml\nservice.yaml\n\n我们可以通过下面命令创建出yaml文件\n# 导出deployment.yamlkubectl create deployment web1 --image=nginx --dry-run -o yaml &gt; deployment.yaml# 导出service.yaml 【可能需要创建 deployment，不然会报错】kubectl expose deployment web1 --port=80 --target-port=80 --type=NodePort --dry-run -o yaml &gt; service.yaml\n\n安装mychart执行命令创建\nhelm install web1 mychart\n\n\n应用升级当我们修改了mychart中的东西后，就可以进行升级操作\nhelm upgrade web1 mychart\n\nchart模板使用通过传递参数，动态渲染模板，yaml内容动态从传入参数生成\n\n刚刚我们创建mychart的时候，看到有values.yaml文件，这个文件就是一些全局的变量，然后在templates中能取到变量的值，下面我们可以利用这个，来完成动态模板\n\n在values.yaml定义变量和值\n具体yaml文件，获取定义变量值\nyaml文件中大题有几个地方不同\nimage\ntag\nlabel\nport\nreplicas\n\n\n\n定义变量和值在values.yaml定义变量和值\n\n获取变量和值我们通过表达式形式 使用全局变量  &#123;&#123;.Values.变量名称&#125;&#125; \n例如： &#123;&#123;.Release.Name&#125;&#125;\n\n安装应用在我们修改完上述的信息后，就可以尝试的创建应用了\nhelm install --dry-run web2 mychart\n\n\n","tags":["k8s"]},{"title":"k8s之核心技术Ingress","url":"/2022/08/23/k8s%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFIngress/","content":"前言原来我们需要将端口号对外暴露，通过 ip + 端口号就可以进行访问\n原来是使用Service中的NodePort来实现\n\n在每个节点上都会启动端口\n在访问的时候通过任何节点，通过ip + 端口号就能实现访问\n\n但是NodePort还存在一些缺陷\n\n因为端口不能重复，所以每个端口只能使用一次，一个端口对应一个应用\n实际访问中都是用域名，根据不同域名跳转到不同端口服务中\n\nIngress和Pod关系pod 和 ingress 是通过service进行关联的，而ingress作为统一入口，由service关联一组pod中\n\n\n首先service就是关联我们的pod\n然后ingress作为入口，首先需要到service，然后发现一组pod\n发现pod后，就可以做负载均衡等操作\n\nIngress工作流程在实际的访问中，我们都是需要维护很多域名， a.com  和  b.com\n然后不同的域名对应的不同的Service，然后service管理不同的pod\n\n需要注意，ingress不是内置的组件，需要我们单独的安装\n使用Ingress步骤如下所示\n\n部署ingress Controller【需要下载官方的】\n创建ingress规则【对哪个Pod、名称空间配置规则】\n\n创建Nginx Pod创建一个nginx应用，然后对外暴露端口\n# 创建podkubectl create deployment web --image=nginx# 查看kubectl get pods\n\n对外暴露端口\nkubectl expose deployment web --port=80 --target-port=80 --type:NodePort\n\n部署 ingress controller下面我们来通过yaml的方式，部署我们的ingress，配置文件如下所示\n\n这个文件里面，需要注意的是 hostNetwork: true，改成ture是为了让后面访问到\nkubectl apply -f ingress-con.yaml\n\n通过这种方式，其实我们在外面就能访问，这里还需要在外面添加一层\nkubectl apply -f ingress-con.yaml\n\n\n最后通过下面命令，查看是否成功部署 ingress\nkubectl get pods -n ingress-nginx\n\n\n创建ingress规则文件创建ingress规则文件，ingress-h.yaml\n\n添加域名访问规则在windows 的 hosts文件，添加域名访问规则【因为我们没有域名解析，所以只能这样做】\n\n最后通过域名就能访问\n\n","tags":["k8s"]},{"title":"k8s之核心技术Pod","url":"/2022/08/22/k8s%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFPod/","content":"Pod概述Pod是K8S系统中可以创建和管理的最小单元，是资源对象模型中由用户创建或部署的最小资源对象模型，也是在K8S上运行容器化应用的资源对象，其它的资源对象都是用来支撑或者扩展Pod对象功能的，比如控制器对象是用来管控Pod对象的，Service或者Ingress资源对象是用来暴露Pod引用对象的，PersistentVolume资源对象是用来为Pod提供存储等等，K8S不会直接处理容器，而是Pod，Pod是由一个或多个container组成。\nPod是Kubernetes的最重要概念，每一个Pod都有一个特殊的被称为 “根容器”的Pause容器。Pause容器对应的镜像属于Kubernetes平台的一部分，除了Pause容器，每个Pod还包含一个或多个紧密相关的用户业务容器。\n\nPod基本概念\n最小部署的单元\nPod里面是由一个或多个容器组成【一组容器的集合】\n一个pod中的容器是共享网络命名空间\nPod是短暂的\n每个Pod包含一个或多个紧密相关的用户业务容器\n\nPod存在的意义\n创建容器使用docker，一个docker对应一个容器，一个容器运行一个应用进程\nPod是多进程设计，运用多个应用程序，也就是一个Pod里面有多个容器，而一个容器里面运行一个应用程序\n\n\n\nPod的存在是为了亲密性应用\n两个应用之间进行交互\n网络之间的调用【通过127.0.0.1 或 socket】\n两个应用之间需要频繁调用\n\n\n\nPod是在K8S集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。同时Pod对多容器的支持是K8S中最基础的设计理念。在生产环境中，通常是由不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一个微服务对外提供服务。\nPod是K8S集群中所有业务类型的基础，可以把Pod看作运行在K8S集群上的小机器人，不同类型的业务就需要不同类型的小机器人去执行。目前K8S的业务主要可以分为以下几种\n\n长期伺服型：long-running\n批处理型：batch\n节点后台支撑型：node-daemon\n有状态应用型：stateful application\n\n上述的几种类型，分别对应的小机器人控制器为：Deployment、Job、DaemonSet 和 StatefulSet  (后面将介绍控制器)\nPod实现机制主要有以下两大机制\n\n共享网络\n共享存储\n\n共享网络容器本身之间相互隔离的，一般是通过 namespace 和 group 进行隔离，那么Pod里面的容器如何实现通信？\n\n首先需要满足前提条件，也就是容器都在同一个namespace之间\n\n关于Pod实现原理，首先会在Pod会创建一个根容器： pause容器，然后我们在创建业务容器 【nginx，redis 等】，在我们创建业务容器的时候，会把它添加到 info容器 中\n而在 info容器 中会独立出  ip地址，mac地址，port 等信息，然后实现网络的共享\n\n完整步骤如下\n\n通过 Pause 容器，把其它业务容器加入到Pause容器里，让所有业务容器在同一个名称空间中，可以实现网络共享\n\n共享存储Pod持久化数据，专门存储到某个地方中\n\n使用 Volumn数据卷进行共享存储，案例如下所示\n\nPod镜像拉取策略我们以具体实例来说，拉取策略就是 imagePullPolicy\n\n拉取策略主要分为了以下几种\n\nIfNotPresent：默认值，镜像在宿主机上不存在才拉取\nAlways：每次创建Pod都会重新拉取一次镜像\nNever：Pod永远不会主动拉取这个镜像\n\nPod资源限制也就是我们Pod在进行调度的时候，可以对调度的资源进行限制，例如我们限制 Pod调度是使用的资源是 2C4G，那么在调度对应的node节点时，只会占用对应的资源，对于不满足资源的节点，将不会进行调度\n\n示例我们在下面的地方进行资源的限制\n\n这里分了两个部分\n\nrequest：表示调度所需的资源\nlimits：表示最大所占用的资源\n\nPod重启机制因为Pod中包含了很多个容器，假设某个容器出现问题了，那么就会触发Pod重启机制\n\n重启策略主要分为以下三种\n\nAlways：当容器终止退出后，总是重启容器，默认策略 【nginx等，需要不断提供服务】\nOnFailure：当容器异常退出（退出状态码非0）时，才重启容器。\nNever：当容器终止退出，从不重启容器 【批量任务】\n\nPod健康检查通过容器检查，原来我们使用下面的命令来检查\nkubectl get pod\n\n但是有的时候，程序可能出现了 Java 堆内存溢出，程序还在运行，但是不能对外提供服务了，这个时候就不能通过 容器检查来判断服务是否可用了\n这个时候就可以使用应用层面的检查\n# 存活检查，如果检查失败，将杀死容器，根据Pod的restartPolicy【重启策略】来操作livenessProbe# 就绪检查，如果检查失败，Kubernetes会把Pod从Service endpoints中剔除readinessProbe\n\n\nProbe支持以下三种检查方式\n\nhttp Get：发送HTTP请求，返回200 - 400 范围状态码为成功\nexec：执行Shell命令返回状态码是0为成功\ntcpSocket：发起TCP Socket建立成功\n\nPod调度策略创建Pod流程\n首先创建一个pod，然后创建一个API Server 和 Etcd【把创建出来的信息存储在etcd中】\n然后创建 Scheduler，监控API Server是否有新的Pod，如果有的话，会通过调度算法，把pod调度某个node上\n在node节点，会通过 kubelet -- apiserver  读取etcd 拿到分配在当前node节点上的pod，然后通过docker创建容器\n\n\n影响Pod调度的属性Pod资源限制对Pod的调度会有影响\n根据request找到足够node节点进行调度\n节点选择器标签影响Pod调度\n关于节点选择器，其实就是有两个环境，然后环境之间所用的资源配置不同\n\n我们可以通过以下命令，给我们的节点新增标签，然后节点选择器就会进行调度了\nkubectl label node node1 env_role=prod\n\n\n\n节点亲和性节点亲和性 nodeAffinity 和 之前nodeSelector 基本一样的，根据节点上标签约束来决定Pod调度到哪些节点上\n\n硬亲和性：约束条件必须满足\n软亲和性：尝试满足，不保证\n\n\n支持常用操作符：in、NotIn、Exists、Gt、Lt、DoesNotExists\n反亲和性：就是和亲和性刚刚相反，如 NotIn、DoesNotExists等\n污点和污点容忍概述nodeSelector 和 NodeAffinity，都是Prod调度到某些节点上，属于Pod的属性，是在调度的时候实现的。\nTaint 污点：节点不做普通分配调度，是节点属性\n场景\n专用节点【限制ip】\n配置特定硬件的节点【固态硬盘】\n基于Taint驱逐【在node1不放，在node2放】\n\n查看污点情况kubectl describe node k8smaster | grep Taint\n\n\n污点值有三个\n\nNoSchedule：一定不被调度\nPreferNoSchedule：尽量不被调度【也有被调度的几率】\nNoExecute：不会调度，并且还会驱逐Node已有Pod\n\n未节点添加污点kubectl taint node [node] key=value:污点的三个值\n\n举例：\nkubectl taint node k8snode1 env_role=yes:NoSchedule\n\n删除污点kubectl taint node k8snode1 env_role:NoSchedule-\n\n\n演示我们现在创建多个Pod，查看最后分配到Node上的情况\n首先我们创建一个 nginx 的pod\nkubectl create deployment web --image=nginx\n\n然后使用命令查看\nkubectl get pods -o wide\n\n\n我们可以非常明显的看到，这个Pod已经被分配到 k8snode1 节点上了\n下面我们把pod复制5份，在查看情况pod情况\nkubectl scale deployment web --replicas=5\n\n我们可以发现，因为master节点存在污点的情况，所以节点都被分配到了 node1 和 node2节点上\n\n我们可以使用下面命令，把刚刚我们创建的pod都删除\nkubectl delete deployment web\n\n现在给了更好的演示污点的用法，我们现在给 node1节点打上污点\nkubectl taint node k8snode1 env_role=yes:NoSchedule\n\n然后我们查看污点是否成功添加\nkubectl describe node k8snode1 | grep Taint\n\n\n然后我们在创建一个 pod\n# 创建nginx podkubectl create deployment web --image=nginx# 复制五次kubectl scale deployment web --replicas=5\n\n然后我们在进行查看\nkubectl get pods -o wide\n\n我们能够看到现在所有的pod都被分配到了 k8snode2上，因为刚刚我们给node1节点设置了污点\n\n最后我们可以删除刚刚添加的污点\nkubectl taint node k8snode1 env_role:NoSchedule-\n\n污点容忍污点容忍就是某个节点可能被调度，也可能不被调度\n\n","tags":["k8s"]},{"title":"k8s之核心技术Service","url":"/2022/08/23/k8s%E4%B9%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AFService/","content":"前言前面我们了解到 Deployment 只是保证了支撑服务的微服务Pod的数量，但是没有解决如何访问这些服务的问题。一个Pod只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节点以一个新的IP启动一个新的Pod，因此不能以确定的IP和端口号提供服务。\n要稳定地提供服务需要服务发现和负载均衡能力。服务发现完成的工作，是针对客户端访问的服务，找到对应的后端服务实例。在K8S集群中，客户端需要访问的服务就是Service对象。每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务。\n在K8S集群中，微服务的负载均衡是由kube-proxy实现的。kube-proxy是k8s集群内部的负载均衡器。它是一个分布式代理服务器，在K8S的每个节点上都有一个；这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的kube-proxy就越多，高可用节点也随之增多。与之相比，我们平时在服务器端使用反向代理作负载均衡，还要进一步解决反向代理的高可用问题。\nService存在的意义防止Pod失联【服务发现】因为Pod每次创建都对应一个IP地址，而这个IP地址是短暂的，每次随着Pod的更新都会变化，假设当我们的前端页面有多个Pod时候，同时后端也多个Pod，这个时候，他们之间的相互访问，就需要通过注册中心，拿到Pod的IP地址，然后去访问对应的Pod\n\n定义Pod访问策略【负载均衡】页面前端的Pod访问到后端的Pod，中间会通过Service一层，而Service在这里还能做负载均衡，负载均衡的策略有很多种实现策略，例如：\n\n随机\n轮询\n响应比\n\n\nPod和Service的关系这里Pod 和 Service 之间还是根据 label 和 selector 建立关联的 【和Controller一样】\n\n我们在访问service的时候，其实也是需要有一个ip地址，这个ip肯定不是pod的ip地址，而是 虚拟IP vip \nService常用类型Service常用类型有三种\n\nClusterIp：集群内部访问\nNodePort：对外访问应用使用\nLoadBalancer：对外访问应用使用，公有云\n\n举例我们可以导出一个文件 包含service的配置信息\nkubectl expose deployment web --port=80 --target-port=80 --dry-run -o yaml &gt; service.yaml\n\nservice.yaml 如下所示\napiVersion: v1kind: Servicemetadata:  creationTimestamp: null  labels:    app: web  name: webspec:  ports:  - port: 80    protocol: TCP    targetPort: 80  selector:    app: webstatus:  loadBalancer: &#123;&#125;\n\n如果我们没有做设置的话，默认使用的是第一种方式 ClusterIp，也就是只能在集群内部使用，我们可以添加一个type字段，用来设置我们的service类型\napiVersion: v1kind: Servicemetadata:  creationTimestamp: null  labels:    app: web  name: webspec:  ports:  - port: 80    protocol: TCP    targetPort: 80  selector:    app: web  type: NodePortstatus:  loadBalancer: &#123;&#125;\n\n修改完命令后，我们使用创建一个pod\nkubectl apply -f service.yaml\n\n然后能够看到，已经成功修改为 NodePort类型了，最后剩下的一种方式就是LoadBalanced：对外访问应用使用公有云\nnode一般是在内网进行部署，而外网一般是不能访问到的，那么如何访问的呢？\n\n找到一台可以通过外网访问机器，安装nginx，反向代理\n手动把可以访问的节点添加到nginx中\n\n如果我们使用LoadBalancer，就会有负载均衡的控制器，类似于nginx的功能，就不需要自己添加到nginx上\n","tags":["k8s"]},{"title":"k8s之配置管理","url":"/2022/08/23/k8s%E4%B9%8B%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/","content":"SecretSecret的主要作用就是加密数据，然后存在etcd里面，让Pod容器以挂载Volume方式进行访问\n场景：用户名 和 密码进行加密\n一般场景的是对某个字符串进行base64编码 进行加密\necho -n &#x27;admin&#x27; | base64\n\n\n变量形式挂载到Pod\n创建secret加密数据的yaml文件    secret.yaml\n\n\n然后使用下面命令创建一个pod\nkubectl create -f secret.yaml\n\n通过get命令查看\nkubectl get pods\n\n\n然后我们通过下面的命令，进入到我们的容器内部\nkubectl exec -it mypod bash\n\n然后我们就可以输出我们的值，这就是以变量的形式挂载到我们的容器中\n# 输出用户echo $SECRET_USERNAME# 输出密码echo $SECRET_PASSWORD\n\n\n最后如果我们要删除这个Pod，就可以使用这个命令\nkubectl delete -f secret-val.yaml\n\n数据卷形式挂载首先我们创建一个 secret-val.yaml 文件\n\n然后创建我们的 Pod\n# 根据配置创建容器kubectl apply -f secret-val.yaml# 进入容器kubectl exec -it mypod bash# 查看ls /etc/foo\n\n\nConfigMapConfigMap作用是存储不加密的数据到etcd中，让Pod以变量或数据卷Volume挂载到容器中\n应用场景：配置文件\n创建配置文件首先我们需要创建一个配置文件 redis.properties\nredis.port=127.0.0.1redis.port=6379redis.password=123456\n\n创建ConfigMap我们使用命令创建configmap\nkubectl create configmap redis-config --from-file=redis.properties\n\n然后查看详细信息\nkubectl describe cm redis-config\n\n\nVolume数据卷形式挂载首先我们需要创建一个 cm.yaml\n\n然后使用该yaml创建我们的pod\n# 创建kubectl apply -f cm.yaml# 查看kubectl get pods\n\n\n最后我们通过命令就可以查看结果输出了\nkubectl logs mypod\n\n\n以变量的形式挂载Pod首先我们也有一个 myconfig.yaml文件，声明变量信息，然后以configmap创建\n\n然后我们就可以创建我们的配置文件\n# 创建podkubectl apply -f myconfig.yaml# 获取kubectl get cm\n\n\n然后我们创建完该pod后，我们就需要在创建一个  config-var.yaml 来使用我们的配置信息\n\n最后我们查看输出\nkubectl logs mypod\n\n\n","tags":["k8s"]},{"title":"k8s之集群安全机制","url":"/2022/08/23/k8s%E4%B9%8B%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/","content":"概述当我们访问K8S集群时，需要经过三个步骤完成具体操作\n\n认证\n鉴权【授权】\n准入控制\n\n进行访问的时候，都需要经过 apiserver， apiserver做统一协调，比如门卫\n\n访问过程中，需要证书、token、或者用户名和密码\n如果访问pod需要serviceAccount\n\n\n认证对外不暴露8080端口，只能内部访问，对外使用的端口6443\n客户端身份认证常用方式\n\nhttps证书认证，基于ca证书\nhttp token认证，通过token来识别用户\nhttp基本认证，用户名 + 密码认证\n\n鉴权基于RBAC进行鉴权操作\n基于角色访问控制\n准入控制就是准入控制器的列表，如果列表有请求内容就通过，没有的话 就拒绝\nRBAC介绍基于角色的访问控制，为某个角色设置访问内容，然后用户分配该角色后，就拥有该角色的访问权限\n\nk8s中有默认的几个角色\n\nrole：特定命名空间访问权限\nClusterRole：所有命名空间的访问权限\n\n角色绑定\n\nroleBinding：角色绑定到主体\nClusterRoleBinding：集群角色绑定到主体\n\n主体\n\nuser：用户\ngroup：用户组\nserviceAccount：服务账号\n\nRBAC实现鉴权\n创建命名空间\n\n创建命名空间我们可以首先查看已经存在的命名空间\nkubectl get namespace\n\n\n然后我们创建一个自己的命名空间  roledemo\nkubectl create ns roledemo\n\n命名空间创建Pod为什么要创建命名空间？因为如果不创建命名空间的话，默认是在default下\nkubectl run nginx --image=nginx -n roledemo\n\n创建角色我们通过 rbac-role.yaml进行创建\n\ntip：这个角色只对pod 有 get、list权限\n然后通过 yaml创建我们的role\n# 创建kubectl apply -f rbac-role.yaml# 查看kubectl get role -n roledemo\n\n\n创建角色绑定我们还是通过 role-rolebinding.yaml 的方式，来创建我们的角色绑定\n\n然后创建我们的角色绑定\n# 创建角色绑定kubectl apply -f rbac-rolebinding.yaml# 查看角色绑定kubectl get role, rolebinding -n roledemo\n\n\n使用证书识别身份我们首先得有一个 rbac-user.sh 证书脚本\n\n\n这里包含了很多证书文件，在TSL目录下，需要复制过来\n通过下面命令执行我们的脚本\n./rbac-user.sh\n\n最后我们进行测试\n# 用get命令查看 pod 【有权限】kubectl get pods -n roledemo# 用get命令查看svc 【没权限】kubectl get svc -n roledmeo\n\n\n","tags":["k8s"]},{"title":"k8s之集群管理工具kubectl","url":"/2022/08/22/k8s%E4%B9%8B%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7kubectl/","content":"概述kubectl是Kubernetes集群的命令行工具，通过kubectl能够对集群本身进行管理，并能够在集群上进行容器化应用的安装和部署\n命令格式命令格式如下\nkubectl [command] [type] [name] [flags]\n\n参数\n\ncommand：指定要对资源执行的操作，例如create、get、describe、delete\ntype：指定资源类型，资源类型是大小写敏感的，开发者能够以单数 、复数 和 缩略的形式\n\n例如：\nkubectl get pod pod1kubectl get pods pod1kubectl get po pod1\n\n\n\nname：指定资源的名称，名称也是大小写敏感的，如果省略名称，则会显示所有的资源，例如\n\nkubectl get pods\n\n\nflags：指定可选的参数，例如，可用 -s 或者 -server参数指定Kubernetes API server的地址和端口\n\n常见命令kubectl help 获取更多信息通过 help命令，能够获取帮助信息\n# 获取kubectl的命令kubectl --help# 获取某个命令的介绍和使用kubectl get --help\n\n基础命令常见的基础命令\n\n\n\n命令\n介绍\n\n\n\ncreate\n通过文件名或标准输入创建资源\n\n\nexpose\n将一个资源公开为一个新的Service\n\n\nrun\n在集群中运行一个特定的镜像\n\n\nset\n在对象上设置特定的功能\n\n\nget\n显示一个或多个资源\n\n\nexplain\n文档参考资料\n\n\nedit\n使用默认的编辑器编辑一个资源\n\n\ndelete\n通过文件名，标准输入，资源名称或标签来删除资源\n\n\n部署命令\n\n\n命令\n介绍\n\n\n\nrollout\n管理资源的发布\n\n\nrolling-update\n对给定的复制控制器滚动更新\n\n\nscale\n扩容或缩容Pod数量，Deployment、ReplicaSet、RC或Job\n\n\nautoscale\n创建一个自动选择扩容或缩容并设置Pod数量\n\n\n集群管理命令\n\n\n命令\n介绍\n\n\n\ncertificate\n修改证书资源\n\n\ncluster-info\n显示集群信息\n\n\ntop\n显示资源(CPU&#x2F;M)\n\n\ncordon\n标记节点不可调度\n\n\nuncordon\n标记节点可被调度\n\n\ndrain\n驱逐节点上的应用，准备下线维护\n\n\ntaint\n修改节点taint标记\n\n\n\n\n\n\n故障和调试命令\n\n\n命令\n介绍\n\n\n\ndescribe\n显示特定资源或资源组的详细信息\n\n\nlogs\n在一个Pod中打印一个容器日志，如果Pod只有一个容器，容器名称是可选的\n\n\nattach\n附加到一个运行的容器\n\n\nexec\n执行命令到容器\n\n\nport-forward\n转发一个或多个\n\n\nproxy\n运行一个proxy到Kubernetes API Server\n\n\ncp\n拷贝文件或目录到容器中\n\n\nauth\n检查授权\n\n\n其它命令\n\n\n命令\n介绍\n\n\n\napply\n通过文件名或标准输入对资源应用配置\n\n\npatch\n使用补丁修改、更新资源的字段\n\n\nreplace\n通过文件名或标准输入替换一个资源\n\n\nconvert\n不同的API版本之间转换配置文件\n\n\nlabel\n更新资源上的标签\n\n\nannotate\n更新资源上的注释\n\n\ncompletion\n用于实现kubectl工具自动补全\n\n\napi-versions\n打印受支持的API版本\n\n\nconfig\n修改kubeconfig文件（用于访问API，比如配置认证信息）\n\n\nhelp\n所有命令帮助\n\n\nplugin\n运行一个命令行插件\n\n\nversion\n打印客户端和服务版本信息\n\n\n目前使用的命令# 创建一个nginx镜像kubectl create deployment nginx --image=nginx# 对外暴露端口kubectl expose deployment nginx --port=80 --type=NodePort# 查看资源kubectl get pod, svc\n","tags":["k8s"]},{"title":"k8s之集群资源监控","url":"/2022/08/24/k8s%E4%B9%8B%E9%9B%86%E7%BE%A4%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7/","content":"概述监控指标一个好的系统，主要监控以下内容\n\n集群监控\n节点资源利用率\n节点数\n运行Pods\n\n\nPod监控\n容器指标\n应用程序【程序占用多少CPU、内存】\n\n\n\n监控平台使用普罗米修斯【prometheus】 + Grafana 搭建监控平台\n\nprometheus【定时搜索被监控服务的状态】\n\n开源的\n监控、报警、数据库\n以HTTP协议周期性抓取被监控组件状态\n不需要复杂的集成过程，使用http接口接入即可\n\n\nGrafana\n\n开源的数据分析和可视化工具\n支持多种数据源\n\n\n\n\n部署prometheus首先需要部署一个守护进程\n\n---apiVersion: apps/v1kind: DaemonSetmetadata:  name: node-exporter  namespace: kube-system  labels:    k8s-app: node-exporterspec:  selector:    matchLabels:      k8s-app: node-exporter  template:    metadata:      labels:        k8s-app: node-exporter    spec:      containers:      - image: prom/node-exporter        name: node-exporter        ports:        - containerPort: 9100          protocol: TCP          name: http---apiVersion: v1kind: Servicemetadata:  labels:    k8s-app: node-exporter  name: node-exporter  namespace: kube-systemspec:  ports:  - name: http    port: 9100    nodePort: 31672    protocol: TCP  type: NodePort  selector:    k8s-app: node-exporter\n\n然后执行下面命令\nkubectl create -f node-exporter.yaml\n\n执行完，发现会报错\n\n这是因为版本不一致的问题，因为发布的正式版本，而这个属于测试版本\n所以我们找到第一行，然后把内容修改为如下所示\n# 修改前apiVersion: extensions/v1beta1# 修改后 【正式版本发布后，测试版本不能使用】apiVersion: apps/v1\n\n创建完成后的效果\n\n然后通过yaml的方式部署prometheus\n\n\nconfigmap：定义一个configmap：存储一些配置文件【不加密】\nprometheus.deploy.yaml：部署一个deployment【包括端口号，资源限制】\nprometheus.svc.yaml：对外暴露的端口\nrbac-setup.yaml：分配一些角色的权限\n\n下面我们进入目录下，首先部署 rbac-setup.yaml\nkubectl create -f rbac-setup.yaml\n\n\n然后分别部署\n# 部署configmapkubectl create -f configmap.yaml# 部署deploymentkubectl create -f prometheus.deploy.yml# 部署svckubectl create -f prometheus.svc.yml\n\n部署完成后，我们使用下面命令查看\nkubectl get pods -n kube-system\n\n\n在我们部署完成后，即可看到 prometheus 的 pod了，然后通过下面命令，能够看到对应的端口\nkubectl get svc -n kube-system\n\n\n通过这个，我们可以看到 prometheus 对外暴露的端口为 30003，访问页面即可对应的图形化界面\nhttp://192.168.177.130:30003\n\n\n在上面我们部署完prometheus后，我们还需要来部署grafana\nkubectl create -f grafana-deploy.yaml\n\n然后执行完后，发现下面的问题\nerror: unable to recognize &quot;grafana-deploy.yaml&quot;: no matches for kind &quot;Deployment&quot; in version &quot;extensions/v1beta1&quot;\n\n我们需要修改如下内容\n# 修改apiVersion: apps/v1# 添加selectorspec:  replicas: 1  selector:    matchLabels:      app: grafana      component: core\n\n修改完成后，我们继续执行上述代码\n# 创建deploymentkubectl create -f grafana-deploy.yaml# 创建svckubectl create -f grafana-svc.yaml# 创建 ingkubectl create -f grafana-ing.yaml\n\n我们能看到，我们的grafana正在\n\n配置数据源下面我们需要开始打开 Grafana，然后配置数据源，导入数据显示模板\nkubectl get svc -n kube-system\n\n\n我们可以通过 ip + 30431 访问我们的 grafana 图形化页面\n\n然后输入账号和密码：admin admin\n进入后，我们就需要配置 prometheus 的数据源\n\n 和 对应的IP【这里IP是我们的ClusterIP】\n\n设置显示数据的模板选择Dashboard，导入我们的模板\n\n然后输入 315 号模板\n\n然后选择 prometheus数据源 mydb，导入即可\n\n导入后的效果如下所示\n\n","tags":["k8s"]}]